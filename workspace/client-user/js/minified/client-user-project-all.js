/* BlobBuilder.js
 * A BlobBuilder implementation.
 * 2012-04-21
 * 
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/BlobBuilder.js/blob/master/BlobBuilder.js */

var BlobBuilder = BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder || (function(view) {
"use strict";
var
	  get_class = function(object) {
		return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
	}
	, FakeBlobBuilder = function(){
		this.data = [];
	}
	, FakeBlob = function(data, type, encoding) {
		this.data = data;
		this.size = data.length;
		this.type = type;
		this.encoding = encoding;
	}
	, FBB_proto = FakeBlobBuilder.prototype
	, FB_proto = FakeBlob.prototype
	, FileReaderSync = view.FileReaderSync
	, FileException = function(type) {
		this.code = this[this.name = type];
	}
	, file_ex_codes = (
		  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
		+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
	).split(" ")
	, file_ex_code = file_ex_codes.length
	, realURL = view.URL || view.webkitURL || view
	, real_create_object_URL = realURL.createObjectURL
	, real_revoke_object_URL = realURL.revokeObjectURL
	, URL = realURL
	, btoa = view.btoa
	, atob = view.atob
	, can_apply_typed_arrays = false
	, can_apply_typed_arrays_test = function(pass) {
		can_apply_typed_arrays = !pass;
	}
	
	, ArrayBuffer = view.ArrayBuffer
	, Uint8Array = view.Uint8Array
;
FakeBlobBuilder.fake = FB_proto.fake = true;
while (file_ex_code--) {
	FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
}
try {
	if (Uint8Array) {
		can_apply_typed_arrays_test.apply(0, new Uint8Array(1));
	}
} catch (ex) {}
if (!realURL.createObjectURL) {
	URL = view.URL = {};
}
URL.createObjectURL = function(blob) {
	var
		  type = blob.type
		, data_URI_header
	;
	if (type === null) {
		type = "application/octet-stream";
	}
	if (blob instanceof FakeBlob) {
		data_URI_header = "data:" + type;
		if (blob.encoding === "base64") {
			return data_URI_header + ";base64," + blob.data;
		} else if (blob.encoding === "URI") {
			return data_URI_header + "," + decodeURIComponent(blob.data);
		} if (btoa) {
			return data_URI_header + ";base64," + btoa(blob.data);
		} else {
			return data_URI_header + "," + encodeURIComponent(blob.data);
		}
	} else if (real_create_object_URL) {
		return real_create_object_URL.call(realURL, blob);
	}
};
URL.revokeObjectURL = function(object_url) {
	if (object_url.substring(0, 5) !== "data:" && real_revoke_object_url) {
		real_revoke_object_url.call(realURL, object_url);
	}
};
FBB_proto.append = function(data/*, endings*/) {
	var bb = this.data;
	// decode data to a binary string
	if (Uint8Array && data instanceof ArrayBuffer) {
		if (can_apply_typed_arrays) {
			bb.push(String.fromCharCode.apply(String, new Uint8Array(data)));
		} else {
			var
				  str = ""
				, buf = new Uint8Array(data)
				, i = 0
				, buf_len = buf.length
			;
			for (; i < buf_len; i++) {
				str += String.fromCharCode(buf[i]);
			}
		}
	} else if (get_class(data) === "Blob" || get_class(data) === "File") {
		if (FileReaderSync) {
			var fr = new FileReaderSync;
			bb.push(fr.readAsBinaryString(data));
		} else {
			// async FileReader won't work as BlobBuilder is sync
			throw new FileException("NOT_READABLE_ERR");
		}
	} else if (data instanceof FakeBlob) {
		if (data.encoding === "base64" && atob) {
			bb.push(atob(data.data));
		} else if (data.encoding === "URI") {
			bb.push(decodeURIComponent(data.data));
		} else if (data.encoding === "raw") {
			bb.push(data.data);
		}
	} else {
		if (typeof data !== "string") {
			data += ""; // convert unsupported types to strings
		}
		// decode UTF-16 to binary string
		bb.push(unescape(encodeURIComponent(data)));
	}
};
FBB_proto.getBlob = function(type) {
	if (!arguments.length) {
		type = null;
	}
	return new FakeBlob(this.data.join(""), type, "raw");
};
FBB_proto.toString = function() {
	return "[object BlobBuilder]";
};
FB_proto.slice = function(start, end, type) {
	var args = arguments.length;
	if (args < 3) {
		type = null;
	}
	return new FakeBlob(
		  this.data.slice(start, args > 1 ? end : this.data.length)
		, type
		, this.encoding
	);
};
FB_proto.toString = function() {
	return "[object Blob]";
};
return FakeBlobBuilder;
}(self));/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2011-08-02
 * 
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

 var saveAs = saveAs  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator)) ||  (function(view) {
	"use strict";
	var
		  doc = view.document
		  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, URL = view.URL || view.webkitURL || view
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			return node.dispatchEvent(event); // false if event was cancelled
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		, deletion_queue = []
		, process_deletion_queue = function() {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, get_object_url = function() {
					var object_url = get_URL().createObjectURL(blob);
					deletion_queue.push(object_url);
					return object_url;
				}
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_object_url(blob);
					}
					target_view.location.href = object_url;
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				save_link.href = object_url;
				save_link.download = name;
				if (click(save_link)) {
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					return;
				}
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			} else {
				target_view = view.open();
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									deletion_queue.push(file);
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;
	
	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;
	
	view.addEventListener("unload", process_deletion_queue, false);
	return saveAs;
}(self));/* canvas-toBlob.js
 * A canvas.toBlob() implementation.
 * 2011-07-13
 * 
 * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

(function(view) {
"use strict";
var
	  Uint8Array = view.Uint8Array
	, HTMLCanvasElement = view.HTMLCanvasElement
	, is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i
	, base64_ranks
	, decode_base64 = function(base64) {
		var
			  len = base64.length
			, buffer = new Uint8Array(len / 4 * 3 | 0)
			, i = 0
			, outptr = 0
			, last = [0, 0]
			, state = 0
			, save = 0
			, rank
			, code
			, undef
		;
		while (len--) {
			code = base64.charCodeAt(i++);
			rank = base64_ranks[code-43];
			if (rank !== 255 && rank !== undef) {
				last[1] = last[0];
				last[0] = code;
				save = (save << 6) | rank;
				state++;
				if (state === 4) {
					buffer[outptr++] = save >>> 16;
					if (last[1] !== 61 /* padding character */) {
						buffer[outptr++] = save >>> 8;
					}
					if (last[0] !== 61 /* padding character */) {
						buffer[outptr++] = save;
					}
					state = 0;
				}
			}
		}
		// 2/3 chance there's going to be some null bytes at the end, but that
		// doesn't really matter with most image formats.
		// If it somehow matters for you, truncate the buffer up outptr.
		return buffer.buffer;
	}
;
if (Uint8Array) {
	base64_ranks = new Uint8Array([
		  62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1
		, -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9
		, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
		, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
		, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
	]);
}
if (HTMLCanvasElement && !HTMLCanvasElement.prototype.toBlob) {
	HTMLCanvasElement.prototype.toBlob = function(callback, type /*, ...args*/) {
		  if (!type) {
			type = "image/png";
		} if (this.mozGetAsFile) {
			callback(this.mozGetAsFile("canvas", type));
			return;
		}
		var
			  args = Array.prototype.slice.call(arguments, 1)
			, dataURI = this.toDataURL.apply(this, args)
			, header_end = dataURI.indexOf(",")
			, data = dataURI.substring(header_end + 1)
			, is_base64 = is_base64_regex.test(dataURI.substring(0, header_end))
			, BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder
			, bb = new BlobBuilder
			, blob
		;
		if (BlobBuilder.fake) {
			// no reason to decode a data: URI that's just going to become a data URI again
			blob = bb.getBlob(type);
			if (is_base64) {
				blob.encoding = "base64";
			} else {
				blob.encoding = "URI";
			}
			blob.data = data;
			blob.size = data.length;
		} else if (Uint8Array) {
			if (is_base64) {
				bb.append(decode_base64(data));
			} else {
				bb.append(decodeURIComponent(data));
			}
			blob = bb.getBlob(type);
		}
		callback(blob);
	};
}
}(self));/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.MidasCommand
 * @extends Ext.util.Observable
 * <p>A base plugin for extending to create standard Midas command buttons.</p>
 * http://msdn.microsoft.com/en-us/library/ms533049%28v=VS.85%29.aspx
 * http://www.mozilla.org/editor/midas-spec.html
 */
Ext.ns('Ext.ux.form.HtmlEditor');

if (!Ext.isObject) {
    Ext.isObject = function(v){
        return v && typeof v == "object";
    };
}

Ext.override(Ext.form.HtmlEditor, {
    getSelectedText: function(clip){
        var doc = this.getDoc(), selDocFrag;
        var txt = '', hasHTML = false, selNodes = [], ret, html = '';
        if (this.win.getSelection || doc.getSelection) {
            // FF, Chrome, Safari
            var sel = this.win.getSelection();
            if (!sel) {
                sel = doc.getSelection();
            }
            if (clip) {
                selDocFrag = sel.getRangeAt(0).extractContents();
            } else {
                selDocFrag = this.win.getSelection().getRangeAt(0).cloneContents();
            }
            Ext.each(selDocFrag.childNodes, function(n){
                if (n.nodeType !== 3) {
                    hasHTML = true;
                }
            });
            if (hasHTML) {
                var div = document.createElement('div');
                div.appendChild(selDocFrag);
                html = div.innerHTML;
                txt = this.win.getSelection() + '';
            } else {
                html = txt = selDocFrag.textContent;
            }
            ret = {
                textContent: txt,
                hasHTML: hasHTML,
                html: html
            };
        } else if (doc.selection) {
            // IE
            this.win.focus();
            txt = doc.selection.createRange();
            if (txt.text !== txt.htmlText) {
                hasHTML = true;
            }
            ret = {
                textContent: txt.text,
                hasHTML: hasHTML,
                html: txt.htmlText
            };
        } else {
            return {
                textContent: ''
            };
        }
        
        return ret;
    }
});

Ext.ux.form.HtmlEditor.MidasCommand = Ext.extend(Ext.util.Observable, {
    // private
    init: function(cmp){
        this.cmp = cmp;
        this.btns = [];
        this.cmp.on('render', this.onRender, this);
        this.cmp.on('initialize', this.onInit, this, {
            delay: 100,
            single: true
        });
    },
    // private
    onInit: function(){
        Ext.EventManager.on(this.cmp.getDoc(), {
            'mousedown': this.onEditorEvent,
            'dblclick': this.onEditorEvent,
            'click': this.onEditorEvent,
            'keyup': this.onEditorEvent,
            buffer: 100,
            scope: this
        });
    },
    // private
    onRender: function(){
        var midasCmdButton, tb = this.cmp.getToolbar(), btn, iconCls;
        Ext.each(this.midasBtns, function(b){
            if (Ext.isObject(b)) {
                iconCls = (b.iconCls) ? b.iconCls : 'x-edit-' + b.cmd;
                if (b.value) { iconCls = iconCls+'-'+b.value.replace(/[<>\/]/g,''); }
                midasCmdButton = {
                    iconCls: iconCls,
                    handler: function(){
                        this.cmp.relayCmd(b.cmd, b.value);
                    },
                    scope: this,
                    tooltip: b.tooltip ||
                    {
                        title: b.title
                    },
                    overflowText: b.overflowText || b.title
                };
            } else {
                midasCmdButton = new Ext.Toolbar.Separator();
            }
            btn = tb.addButton(midasCmdButton);
            if (b.enableOnSelection) {
                btn.disable();
            }
            this.btns.push(btn);
        }, this);
    },
    // private
    onEditorEvent: function(){
        var doc = this.cmp.getDoc();
        Ext.each(this.btns, function(b, i){
            if (this.midasBtns[i].enableOnSelection || this.midasBtns[i].disableOnSelection) {
                if (doc.getSelection) {
                    if ((this.midasBtns[i].enableOnSelection && doc.getSelection() !== '') || (this.midasBtns[i].disableOnSelection && doc.getSelection() === '')) {
                        b.enable();
                    } else {
                        b.disable();
                    }
                } else if (doc.selection) {
                    if ((this.midasBtns[i].enableOnSelection && doc.selection.createRange().text !== '') || (this.midasBtns[i].disableOnSelection && doc.selection.createRange().text === '')) {
                        b.enable();
                    } else {
                        b.disable();
                    }
                }
            }
            if (this.midasBtns[i].monitorCmdState) {
                b.toggle(doc.queryCommandState(this.midasBtns[i].cmd));
            }
        }, this);
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.Divider
 * @extends Ext.util.Observable
 * <p>A plugin that creates a divider on the HtmlEditor. Used for separating additional buttons.</p>
 */
Ext.ux.form.HtmlEditor.Divider = Ext.extend(Ext.util.Observable, {
    // private
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
    },
    // private
    onRender: function(){
        this.cmp.getToolbar().addButton([new Ext.Toolbar.Separator()]);
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.HR
 * @extends Ext.util.Observable
 * <p>A plugin that creates a button on the HtmlEditor for inserting a horizontal rule.</p>
 */
Ext.ux.form.HtmlEditor.HR = Ext.extend(Ext.util.Observable, {
    // HR language text
    langTitle   : 'Horizontal Rule',
    langHelp    : 'Enter the width of the Rule in percentage<br/> followed by the % sign at the end, or to<br/> set a fixed width ommit the % symbol.',
    langInsert  : 'Insert',
    langCancel  : 'Cancel',
    langWidth   : 'Width',
    // defaults
    defaultHRWidth: '100%',
    // private
    cmd: 'hr',
    // private
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
    },
    // private
    onRender: function(){
        var cmp = this.cmp;
        var btn = this.cmp.getToolbar().addButton({
            iconCls: 'x-edit-hr',
            handler: function(){
                if (!this.hrWindow) {
                    this.hrWindow = new Ext.Window({
                        title: this.langTitle,
                        width: 240,
                        closeAction: 'hide',
                        items: [{
                            itemId: 'insert-hr',
                            xtype: 'form',
                            border: false,
                            plain: true,
                            bodyStyle: 'padding: 10px;',
                            labelWidth: 60,
                            labelAlign: 'right',
                            items: [{
                                xtype: 'label',
                                html: this.langHelp + '<br/>&nbsp;'
                            }, {
                                xtype: 'textfield',
                                maskRe: /[0-9]|%/,
                                regex: /^[1-9][0-9%]{1,3}/,
                                fieldLabel: this.langWidth,
                                name: 'hrwidth',
                                width: 60,
                                value: this.defaultHRWidth,
                                listeners: {
                                    specialkey: function(f, e){
                                        if ((e.getKey() == e.ENTER || e.getKey() == e.RETURN) && f.isValid()) {
                                            this.doInsertHR();
                                        }
                                    },
                                    scope: this
                                }
                            }]
                        }],
                        buttons: [{
                            text: this.langInsert,
                            handler: function(){
                                var frm = this.hrWindow.getComponent('insert-hr').getForm();
                                if (frm.isValid()) {
                                    this.doInsertHR();
                                } else {
                                    frm.findField('hrwidth').getEl().frame();
                                }
                            },
                            scope: this
                        }, {
                            text: this.langCancel,
                            handler: function(){
                                this.hrWindow.hide();
                            },
                            scope: this
                        }],
                        listeners: {
                            render: (Ext.isGecko) ? this.focusHRLong : this.focusHR,
                            show: this.focusHR,
                            move: this.focusHR,
                            scope: this
                        }
                    });
                } else {
                    this.hrWindow.getEl().frame();
                }
                this.hrWindow.show();
            },
            scope: this,
            tooltip: {
                title: this.langInsert + ' ' + this.langTitle
            },
            overflowText: this.langTitle
        });
    },
    // private
    focusHRLong: function(w){
        this.focus(w, 600);
    },
    // private
    focusHR: function(w){
        this.focus(w, 100);
    },
    /**
     * This method is just for focusing the text field use for entering the width of the HR.
     * It's extra messy because Firefox seems to take a while longer to render the window than other browsers, 
     * particularly when Firbug is enabled, which is all the time if your like me.
     * Had to crank up the delay for focusing on render to 600ms for Firefox, and 100ms for all other focusing.
     * Other browsers seem to work fine in all cases with as little as 50ms delay. Compromise bleh!
     * @param {Object} win the window to focus
     * @param {Integer} delay the delay in milliseconds before focusing
     */
    focus: function(win, delay){
        win.getComponent('insert-hr').getForm().findField('hrwidth').focus(true, delay);
    },
    // private
    doInsertHR: function(){
        var frm = this.hrWindow.getComponent('insert-hr').getForm();
        if (frm.isValid()) {
            var hrwidth = frm.findField('hrwidth').getValue();
            if (hrwidth) {
                this.insertHR(hrwidth);
            } else {
                this.insertHR(this.defaultHRWidth);
            }
            frm.reset();
            this.hrWindow.hide();
        }
    },
    /**
     * Insert a horizontal rule into the document.
     * @param w String The width of the horizontal rule as the <tt>width</tt> attribute of the HR tag expects. ie: '100%' or '400' (pixels).
     */
    insertHR: function(w){
        this.cmp.insertAtCursor('<hr width="' + w + '">');
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.Image
 * @extends Ext.util.Observable
 * <p>A plugin that creates an image button in the HtmlEditor toolbar for inserting an image. The method to select an image must be defined by overriding the selectImage method. Supports resizing of the image after insertion.</p>
 * <p>The selectImage implementation must call insertImage after the user has selected an image, passing it a simple image object like the one below.</p>
 * <pre>
 *      var img = {
 *         Width: 100,
 *         Height: 100,
 *         ID: 123,
 *         Title: 'My Image'
 *      };
 * </pre>
 */
Ext.ux.form.HtmlEditor.Image = Ext.extend(Ext.util.Observable, {
	// Image language text
	langTitle: 'Insert Image',
    urlSizeVars: ['width','height'],
    basePath: 'image.php',
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
        this.cmp.on('initialize', this.onInit, this, {single: true});
    },
    
    onEditorMouseUp : function(e){
        Ext.get(e.getTarget()).select('img').each(function(el){
            var w = el.getAttribute('width'), h = el.getAttribute('height'), src = el.getAttribute('src')+' ';
            src = src.replace(new RegExp(this.urlSizeVars[0]+'=[0-9]{1,5}([&| ])'), this.urlSizeVars[0]+'='+w+'$1');
            src = src.replace(new RegExp(this.urlSizeVars[1]+'=[0-9]{1,5}([&| ])'), this.urlSizeVars[1]+'='+h+'$1');
            el.set({src:src.replace(/\s+$/,"")});
        }, this);
        
    },
    onInit: function(){
        Ext.EventManager.on(this.cmp.getDoc(), {
			'abort': this.onEditorMouseUp,
			scope: this
		});
    },
    onRender: function() {
    	
        var btn = this.cmp.getToolbar().addButton({
            iconCls: 'x-edit-image',
            scope: this,
            handler: this.selectImage,
            tooltip: {
                title: this.langTitle
            },
            overflowText: this.langTitle
        });
    },
    selectImage: function (){
    	 function validate(data, config) {
             config.fieldUrl.setValue(data.url);
         }
         var chooser = new ImageExplorer({
        	 directoryImageUrl : this.cmp.directoryImageUrl,
             width : 500,
             height : 350,
             htmlEditor : this.cmp
         });
         chooser.show(document);
    },
    
    insertImage: function(img) {
        this.cmp.insertAtCursor('<img src="'+this.basePath+'?'+this.urlSizeVars[0]+'='+img.Width+'&'+this.urlSizeVars[1]+'='+img.Height+'&id='+img.ID+'" title="'+img.Name+'" alt="'+img.Name+'">');
    }
    
});

Image.insertImage = function(data, config) {
	var htmlEditor = config.htmlEditor;
     var url = data.url;
    var indexDatastorageUrl = url.indexOf(config.directoryImageUrl);
    if (indexDatastorageUrl !== -1) {
        url = "./images" + url.substr(indexDatastorageUrl + config.directoryImageUrl.length, url.length);
    }
    
	if (data.width && data.height){
		htmlEditor.insertAtCursor('<img src="'+ url +'" title="'+ data.text +'" width="'+ data.width +'" height="'+ data.height +'" alt="'+ data.text +'">');
	}
	else {
		htmlEditor.insertAtCursor('<img src="'+ url +'" title="'+ data.text +'" alt="'+ data.text +'">');
	}
};
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.RemoveFormat
 * @extends Ext.ux.form.HtmlEditor.MidasCommand
 * <p>A plugin that creates a button on the HtmlEditor that will remove all formatting on selected text.</p>
 */
Ext.ux.form.HtmlEditor.RemoveFormat = Ext.extend(Ext.ux.form.HtmlEditor.MidasCommand, {
    midasBtns: ['|', {
        enableOnSelection: true,
        cmd: 'removeFormat',
        tooltip: {
            title: 'Remove Formatting'
        },
        overflowText: 'Remove Formatting'
    }]
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.IndentOutdent
 * @extends Ext.ux.form.HtmlEditor.MidasCommand
 * <p>A plugin that creates two buttons on the HtmlEditor for indenting and outdenting of selected text.</p>
 */
Ext.ux.form.HtmlEditor.IndentOutdent = Ext.extend(Ext.ux.form.HtmlEditor.MidasCommand, {
    // private
    midasBtns: ['|', {
        cmd: 'indent',
        tooltip: {
            title: 'Indent Text'
        },
        overflowText: 'Indent Text'
    }, {
        cmd: 'outdent',
        tooltip: {
            title: 'Outdent Text'
        },
        overflowText: 'Outdent Text'
    }]
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.SubSuperScript
 * @extends Ext.ux.form.HtmlEditor.MidasCommand
 * <p>A plugin that creates two buttons on the HtmlEditor for superscript and subscripting of selected text.</p>
 */
Ext.ux.form.HtmlEditor.SubSuperScript = Ext.extend(Ext.ux.form.HtmlEditor.MidasCommand, {
    // private
    midasBtns: ['|', {
        enableOnSelection: true,
        cmd: 'subscript',
        tooltip: {
            title: 'Subscript'
        },
        overflowText: 'Subscript'
    }, {
        enableOnSelection: true,
        cmd: 'superscript',
        tooltip: {
            title: 'Superscript'
        },
        overflowText: 'Superscript'
    }]
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.RemoveFormat
 * @extends Ext.ux.form.HtmlEditor.MidasCommand
 * <p>A plugin that creates a button on the HtmlEditor that will remove all formatting on selected text.</p>
 */
Ext.ux.form.HtmlEditor.RemoveFormat = Ext.extend(Ext.ux.form.HtmlEditor.MidasCommand, {
    midasBtns: ['|', {
        enableOnSelection: true,
        cmd: 'removeFormat',
        tooltip: {
            title: 'Remove Formatting'
        },
        overflowText: 'Remove Formatting'
    }]
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @contributor Ronald van Raaphorst - Twensoc
 * @class Ext.ux.form.HtmlEditor.FindReplace
 * @extends Ext.util.Observable
 * <p>A plugin that provides search and replace functionality in source edit mode. Incomplete.</p>
 */
Ext.ux.form.HtmlEditor.FindAndReplace = Ext.extend(Ext.util.Observable, {
	// Find and Replace language text
	langTitle: 'Find/Replace',
	langFind: 'Find',
	langReplace: 'Replace',
	langReplaceWith: 'Replace with',
	langClose: 'Close',
    // private
    cmd: 'findandreplace',
    // private
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on({
            'render': this.onRender,
            'editmodechange': this.editModeChange,
            scope: this
        });
        this.lastSelectionStart=-1;
    },
    editModeChange: function(t, m){
        if (this.btn && m){
            this.btn.setDisabled(false);
        }
    },
    // private
    onRender: function(){
        this.btn = this.cmp.getToolbar().addButton({
            iconCls: 'x-edit-findandreplace',
            sourceEditEnabled:true,
            handler: function(){
                
                if (!this.farWindow){
                
                    this.farWindow = new Ext.Window({
                        title: this.langTitle,
                        closeAction: 'hide',
                        width: 270,
                        items: [{
                            itemId: 'findandreplace',
                            xtype: 'form',
                            border: false,
                            plain: true,
                            bodyStyle: 'padding: 10px;',
                            labelWidth: 80,
                            labelAlign: 'right',
                            items: [{
                                xtype: 'textfield',
                                allowBlank: false,
                                fieldLabel: this.langFind,
                                name: 'find',
                                width: 145
                            }, {
                                xtype: 'textfield',
                                allowBlank: true,
                                fieldLabel: this.langReplaceWith,
                                name: 'replace',
                                width: 145
                            }]
                        }],
                        buttons: [{
                            text: this.langFind,
                            handler: this.doFind,
                            scope: this
                        }, {
                            text: this.langReplace,
                            handler: this.doReplace,
                            scope: this
                        }, {
                            text: this.langClose,
                            handler: function(){
                                this.farWindow.hide();
                            },
                            scope: this
                        }]
                    });
                
                }else{
                    
                    this.farWindow.getEl().frame();
                    
                }
                
                this.farWindow.show();
                
            },
            scope: this,
            tooltip: {
                title: this.langTitle
            },
            overflowText: this.langTitle
        });
        
    },
    doFind: function(){
        
        var frm = this.farWindow.getComponent('findandreplace').getForm();
        if (!frm.isValid()) {
            return '';
        }
        
        var findValue = frm.findField('find').getValue();
        var replaceValue = frm.findField('replace').getValue();
        if(this.cmp.sourceEditMode) {
            // source edit mode
            var textarea = this.cmp.el.dom; 
            var startPos = textarea.selectionStart===this.lastSelectionStart ? textarea.selectionStart+1 : textarea.selectionStart;
            var txt = textarea.value.substring(startPos);
            
            var regexp = new RegExp(findValue);
            var r = txt.search(regexp);
            if(r==-1) {
                return;                                    
            }
            this.lastSelectionStart = startPos + r;
            if(Ext.isGecko) {
                textarea.setSelectionRange(this.lastSelectionStart , this.lastSelectionStart + findValue.length);
                this.cmp.scrollIntoView(startPos);
                this.cmp.focus(false, true);
            }
            return;
        }
        // design mode
        //var doc = this.cmp.getEditorBody();
        //var txt = doc.innerHTML;
        // Should we search/replace in the source, and push the result back to the design?
        
    },
    doReplace: function(){
        
        var frm = this.farWindow.getComponent('findandreplace').getForm();
        if (!frm.isValid()) {
            return '';
        }
        
        var findValue = frm.findField('find').getValue();
        var replaceValue = frm.findField('replace').getValue();
        if(this.cmp.sourceEditMode) {
            var textarea = this.cmp.el.dom;
            var startPos = textarea.selectionStart;
            var endPos = textarea.selectionEnd;
			
			if (startPos == 0 && endPos == 0){
				Ext.Msg.alert("Warning", "No text selection, please select some text");
				return;
			}
			
            var txt = textarea.value;
            
            //cmp.execCmd('delete', null);
            //cmp.focus(false, false);
            //cmp.insertAtCursor(replaceValue);

            //if(Ext.isGecko) {
                // TODO: Scroll into view
                var scrollPosition = textarea.scrollTop;
                textarea.value = txt.substring(0,startPos) + replaceValue + txt.substring(endPos);
                textarea.setSelectionRange(startPos,startPos + replaceValue.length);
                textarea.scrollTop = scrollPosition;
                this.cmp.focus(false, true);
            //}
            return;
        }
		else{
			Ext.Msg.alert("Warning", "Not in Source Edit mode");
		}
        return;
        
    }
});/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.Table
 * @extends Ext.util.Observable
 * <p>A plugin that creates a button on the HtmlEditor for making simple tables.</p>
 */
Ext.ux.form.HtmlEditor.Table = Ext.extend(Ext.util.Observable, {
    // Table language text
    langTitle       : 'Insert Table',
    langInsert      : 'Insert',
    langCancel      : 'Cancel',
    langRows        : 'Rows',
    langColumns     : 'Columns',
    langBorder      : 'Border',
    langCellLabel   : 'Label Cells',
    // private
    cmd: 'table',
    /**
     * @cfg {Boolean} showCellLocationText
     * Set true to display row and column informational text inside of newly created table cells.
     */
    showCellLocationText: true,
    /**
     * @cfg {String} cellLocationText
     * The string to display inside of newly created table cells.
     */
    cellLocationText: '{0}&nbsp;-&nbsp;{1}',
    /**
     * @cfg {Array} tableBorderOptions
     * A nested array of value/display options to present to the user for table border style. Defaults to a simple list of 5 varrying border types.
     */
    tableBorderOptions: [['none', 'None'], ['1px solid #000', 'Sold Thin'], ['2px solid #000', 'Solid Thick'], ['1px dashed #000', 'Dashed'], ['1px dotted #000', 'Dotted']],
    // private
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
    },
    // private
    onRender: function(){
        var btn = this.cmp.getToolbar().addButton({
            iconCls: 'x-edit-table',
            handler: function(){
                if (!this.tableWindow){
                    this.tableWindow = new Ext.Window({
                        title: this.langTitle,
                        closeAction: 'hide',
                        width: 235,
                        items: [{
                            itemId: 'insert-table',
                            xtype: 'form',
                            border: false,
                            plain: true,
                            bodyStyle: 'padding: 10px;',
                            labelWidth: 65,
                            labelAlign: 'right',
                            items: [{
                                xtype: 'numberfield',
                                allowBlank: false,
                                allowDecimals: false,
                                fieldLabel: this.langRows,
                                name: 'row',
                                width: 60
                            }, {
                                xtype: 'numberfield',
                                allowBlank: false,
                                allowDecimals: false,
                                fieldLabel: this.langColumns,
                                name: 'col',
                                width: 60
                            }, {
                                xtype: 'combo',
                                fieldLabel: this.langBorder,
                                name: 'border',
                                forceSelection: true,
                                mode: 'local',
                                store: new Ext.data.ArrayStore({
                                    autoDestroy: true,
                                    fields: ['spec', 'val'],
                                    data: this.tableBorderOptions
                                }),
                                triggerAction: 'all',
                                value: 'none',
                                displayField: 'val',
                                valueField: 'spec',
                                anchor: '-15'
                            }, {
                            	xtype: 'checkbox',
                            	fieldLabel: this.langCellLabel,
                            	checked: this.showCellLocationText,
                            	listeners: {
                            		check: function(){
                            			this.showCellLocationText = !this.showCellLocationText;
                            		},
                            		scope: this
                            	}
                            }]
                        }],
                        buttons: [{
                            text: this.langInsert,
                            handler: function(){
                                var frm = this.tableWindow.getComponent('insert-table').getForm();
                                if (frm.isValid()) {
                                    var border = frm.findField('border').getValue();
                                    var rowcol = [frm.findField('row').getValue(), frm.findField('col').getValue()];
                                    if (rowcol.length == 2 && rowcol[0] > 0 && rowcol[1] > 0) {
                                        var colwidth = Math.floor(100/rowcol[0]);
                                        var html = "<table style='border-collapse: collapse'>";
                                        var cellText = '&nbsp;';
                                        if (this.showCellLocationText){ cellText = this.cellLocationText; }
                                        for (var row = 0; row < rowcol[0]; row++) {
                                            html += "<tr>";
                                            for (var col = 0; col < rowcol[1]; col++) {
                                                html += "<td width='" + colwidth + "%' style='border: " + border + ";'>" + String.format(cellText, (row+1), String.fromCharCode(col+65)) + "</td>";
                                            }
                                            html += "</tr>";
                                        }
                                        html += "</table>";
                                        this.cmp.insertAtCursor(html);
                                    }
                                    this.tableWindow.hide();
                                }else{
                                    if (!frm.findField('row').isValid()){
                                        frm.findField('row').getEl().frame();
                                    }else if (!frm.findField('col').isValid()){
                                        frm.findField('col').getEl().frame();
                                    }
                                }
                            },
                            scope: this
                        }, {
                            text: this.langCancel,
                            handler: function(){
                                this.tableWindow.hide();
                            },
                            scope: this
                        }]
                    });
                
                }else{
                    this.tableWindow.getEl().frame();
                }
                this.tableWindow.show();
            },
            scope: this,
            tooltip: {
                title: this.langTitle
            },
            overflowText: this.langTitle
        });
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.Word
 * @extends Ext.util.Observable
 * <p>A plugin that creates a button on the HtmlEditor for pasting text from Word without all the jibberish html.</p>
 */
Ext.ux.form.HtmlEditor.Word = Ext.extend(Ext.util.Observable, {
    // Word language text
    langTitle: 'Word Paste',
    langToolTip: 'Cleanse text pasted from Word or other Rich Text applications',
    wordPasteEnabled: true,
    // private
	curLength: 0,
	lastLength: 0,
	lastValue: '',
	// private
    init: function(cmp){
        
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
		this.cmp.on('initialize', this.onInit, this, {delay:100, single: true});
        
    },
	// private
	onInit: function(){
		
		Ext.EventManager.on(this.cmp.getDoc(), {
            'keyup': this.checkIfPaste,
            scope: this
        });
		this.lastValue = this.cmp.getValue();
		this.curLength = this.lastValue.length;
		this.lastLength = this.lastValue.length;
		
	},
	// private
	checkIfPaste: function(e){
		
		var diffAt = 0;
		this.curLength = this.cmp.getValue().length;
		
		if (e.V == e.getKey() && e.ctrlKey && this.wordPasteEnabled){
			
			this.cmp.suspendEvents();
			
			diffAt = this.findValueDiffAt(this.cmp.getValue());
			var parts = [
				this.cmp.getValue().substr(0, diffAt),
				this.fixWordPaste(this.cmp.getValue().substr(diffAt, (this.curLength - this.lastLength))),
				this.cmp.getValue().substr((this.curLength - this.lastLength)+diffAt, this.curLength)
			];
			this.cmp.setValue(parts.join(''));
			
			this.cmp.resumeEvents();
		}
		
		this.lastLength = this.cmp.getValue().length;
		this.lastValue = this.cmp.getValue();
		
	},
	// private
	findValueDiffAt: function(val){
		
		for (i=0;i<this.curLength;i++){
			if (this.lastValue[i] != val[i]){
				return i;			
			}
		}
		
	},
    /**
     * Cleans up the jubberish html from Word pasted text.
     * @param wordPaste String The text that needs to be cleansed of Word jibberish html.
     * @return {String} The passed in text with all Word jibberish html removed.
     */
    fixWordPaste: function(wordPaste) {
        
        var removals = [/&nbsp;/ig, /[\r\n]/g, /<(xml|style)[^>]*>.*?<\/\1>/ig, /<\/?(meta|object|span)[^>]*>/ig,
			/<\/?[A-Z0-9]*:[A-Z]*[^>]*>/ig, /(lang|class|type|href|name|title|id|clear)=\"[^\"]*\"/ig, /style=(\'\'|\"\")/ig, /<![\[-].*?-*>/g, 
			/MsoNormal/g, /<\\?\?xml[^>]*>/g, /<\/?o:p[^>]*>/g, /<\/?v:[^>]*>/g, /<\/?o:[^>]*>/g, /<\/?st1:[^>]*>/g, /&nbsp;/g, 
            /<\/?SPAN[^>]*>/g, /<\/?FONT[^>]*>/g, /<\/?STRONG[^>]*>/g, /<\/?H1[^>]*>/g, /<\/?H2[^>]*>/g, /<\/?H3[^>]*>/g, /<\/?H4[^>]*>/g, 
            /<\/?H5[^>]*>/g, /<\/?H6[^>]*>/g, /<\/?P[^>]*><\/P>/g, /<!--(.*)-->/g, /<!--(.*)>/g, /<!(.*)-->/g, /<\\?\?xml[^>]*>/g, 
            /<\/?o:p[^>]*>/g, /<\/?v:[^>]*>/g, /<\/?o:[^>]*>/g, /<\/?st1:[^>]*>/g, /style=\"[^\"]*\"/g, /style=\'[^\"]*\'/g, /lang=\"[^\"]*\"/g, 
            /lang=\'[^\"]*\'/g, /class=\"[^\"]*\"/g, /class=\'[^\"]*\'/g, /type=\"[^\"]*\"/g, /type=\'[^\"]*\'/g, /href=\'#[^\"]*\'/g, 
            /href=\"#[^\"]*\"/g, /name=\"[^\"]*\"/g, /name=\'[^\"]*\'/g, / clear=\"all\"/g, /id=\"[^\"]*\"/g, /title=\"[^\"]*\"/g, 
            /<span[^>]*>/g, /<\/?span[^>]*>/g, /<title>(.*)<\/title>/g, /class=/g, /<meta[^>]*>/g, /<link[^>]*>/g, /<style>(.*)<\/style>/g, 
            /<w:[^>]*>(.*)<\/w:[^>]*>/g];
					
        Ext.each(removals, function(s){
            wordPaste = wordPaste.replace(s, "");
        });
        
        // keep the divs in paragraphs
        wordPaste = wordPaste.replace(/<div[^>]*>/g, "<p>");
        wordPaste = wordPaste.replace(/<\/?div[^>]*>/g, "</p>");
        return wordPaste;
        
    },
	// private
    onRender: function() {
        
        this.cmp.getToolbar().add({
            iconCls: 'x-edit-wordpaste',
            pressed: true,
            handler: function(t){
                t.toggle(!t.pressed);
                this.wordPasteEnabled = !this.wordPasteEnabled;
            },
            scope: this,
            tooltip: {
                text: this.langToolTip
            },
            overflowText: this.langTitle
        });
		
    }
});/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.Link
 * @extends Ext.util.Observable
 * <p>A plugin that creates a button on the HtmlEditor for inserting a link.</p>
 */
Ext.ux.form.HtmlEditor.Link = Ext.extend(Ext.util.Observable, {
    // Link language text
    langTitle   : 'Insert Link',
    langInsert  : 'Insert',
    langCancel  : 'Cancel',
    langTarget  : 'Target',
    langURL     : 'URL',
    langText    : 'Text',
    // private
    linkTargetOptions: [['_self', 'Default'], ['_blank', 'New Window'], ['_parent', 'Parent Window'], ['_top', 'Entire Window']],
    init: function(cmp){
        cmp.enableLinks = false;
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
    },
    onRender: function(){
        var cmp = this.cmp;
        var btn = this.cmp.getToolbar().addButton({
            iconCls: 'x-edit-createlink',
            handler: function(){
                var sel = this.cmp.getSelectedText();
                if (!this.linkWindow) {
                    this.linkWindow = new Ext.Window({
                        title: this.langTitle,
                        closeAction: 'hide',
                        width: 250,
                        height: 160,
                        items: [{
                            xtype: 'form',
                            itemId: 'insert-link',
                            border: false,
                            plain: true,
                            bodyStyle: 'padding: 10px;',
                            labelWidth: 40,
                            labelAlign: 'right',
                            items: [{
                                xtype: 'textfield',
                                fieldLabel: this.langText,
                                name: 'text',
                                anchor: '100%',
                                value: '' 
                            }, {
                                xtype: 'textfield',
                                fieldLabel: this.langURL,
                                vtype: 'url',
                                name: 'url',
                                anchor: '100%',
                                value: 'http://'
                            }, {
                                xtype: 'combo',
                                fieldLabel: this.langTarget,
                                name: 'target',
                                forceSelection: true,
                                mode: 'local',
                                store: new Ext.data.ArrayStore({
                                    autoDestroy: true,
                                    fields: ['spec', 'val'],
                                    data: this.linkTargetOptions
                                }),
                                triggerAction: 'all',
                                value: '_self',
                                displayField: 'val',
                                valueField: 'spec',
                                anchor: '100%'
                            }]
                        }],
                        buttons: [{
                            text: this.langInsert,
                            handler: function(){
                                var frm = this.linkWindow.getComponent('insert-link').getForm();
                                if (frm.isValid()) {
                                    var afterSpace = '', sel = this.cmp.getSelectedText(true), text = frm.findField('text').getValue(), url = frm.findField('url').getValue(), target = frm.findField('target').getValue();
                                    if (text.length && text[text.length - 1] == ' ') {
                                        text = text.substr(0, text.length - 1);
                                        afterSpace = ' ';
                                    }
                                    if (sel.hasHTML) {
                                        text = sel.html;
                                    }
                                    var html = '<a href="' + url + '" target="' + target + '">' + text + '</a>' + afterSpace;
                                    this.cmp.insertAtCursor(html);
                                    this.linkWindow.hide();
                                } else {
                                    if (!frm.findField('url').isValid()) {
                                        frm.findField('url').getEl().frame();
                                    } else if (!frm.findField('target').isValid()) {
                                        frm.findField('target').getEl().frame();
                                    }
                                }
                                
                            },
                            scope: this
                        }, {
                            text: this.langCancel,
                            handler: function(){
                                this.linkWindow.close();
                            },
                            scope: this
                        }],
                        listeners: {
                            show: {
                                fn: function(){
                                    var frm = this.linkWindow.getComponent('insert-link').getForm();
                                    frm.findField('text').setValue(sel.textContent).setDisabled(sel.hasHTML);
                                    frm.findField('url').reset().focus(true, 50);
                                },
                                scope: this,
                                defer: 350
                            }
                        }
                    });
                    this.linkWindow.show();
                } else {
                    this.linkWindow.show();
                    this.linkWindow.getEl().frame();
                }
            },
            scope: this,
            tooltip: this.langTitle
        });
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.SpecialCharacters
 * @extends Ext.util.Observable
 * <p>A plugin that creates a button on the HtmlEditor for inserting special characters.</p>
 */
Ext.ux.form.HtmlEditor.SpecialCharacters = Ext.extend(Ext.util.Observable, {
    // SpecialCharacters language text
    langTitle   : 'Insert Special Character',
    langInsert  : 'Insert',
    langCancel  : 'Cancel',
    /**
     * @cfg {Array} specialChars
     * An array of additional characters to display for user selection.  Uses numeric portion of the ASCII HTML Character Code only. For example, to use the Copyright symbol, which is &#169; we would just specify <tt>169</tt> (ie: <tt>specialChars:[169]</tt>).
     */
    specialChars: [153],
    /**
     * @cfg {Array} charRange
     * Two numbers specifying a range of ASCII HTML Characters to display for user selection. Defaults to <tt>[160, 256]</tt>.
     */
    charRange: [160, 256],
    // private
    chars: [],
    // private
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
    },
    // private
    onRender: function(){
        var cmp = this.cmp;
        var btn = this.cmp.getToolbar().addButton({
            iconCls: 'x-edit-char',
            handler: function(){
                if (!this.chars.length) {
                    if (this.specialChars.length) {
                        Ext.each(this.specialChars, function(c, i){
                            this.chars[i] = ['&#' + c + ';'];
                        }, this);
                    }
                    for (i = this.charRange[0]; i < this.charRange[1]; i++) {
                        this.chars.push(['&#' + i + ';']);
                    }
                }
                var charStore = new Ext.data.ArrayStore({
                    fields: ['char'],
                    data: this.chars
                });
                this.charWindow = new Ext.Window({
                    title: this.langTitle,
                    width: 436,
                    autoHeight: true,
                    layout: 'fit',
                    items: [{
                        xtype: 'dataview',
                        store: charStore,
                        ref: 'charView',
                        autoHeight: true,
                        multiSelect: true,
                        tpl: new Ext.XTemplate('<tpl for="."><div class="char-item">{char}</div></tpl><div class="x-clear"></div>'),
                        overClass: 'char-over',
                        itemSelector: 'div.char-item',
                        listeners: {
                            dblclick: function(t, i, n, e){
                                this.insertChar(t.getStore().getAt(i).get('char'));
                                this.charWindow.close();
                            },
                            scope: this
                        }
                    }],
                    buttons: [{
                        text: this.langInsert,
                        handler: function(){
                            Ext.each(this.charWindow.charView.getSelectedRecords(), function(rec){
                                var c = rec.get('char');
                                this.insertChar(c);
                            }, this);
                            this.charWindow.close();
                        },
                        scope: this
                    }, {
                        text: this.langCancel,
                        handler: function(){
                            this.charWindow.close();
                        },
                        scope: this
                    }]
                });
                this.charWindow.show();
            },
            scope: this,
            tooltip: {
                title: this.langTitle
            },
            overflowText: this.langTitle
        });
    },
    /**
     * Insert a single special character into the document.
     * @param c String The special character to insert (not just the numeric code, but the entire ASCII HTML entity).
     */
    insertChar: function(c){
        if (c) {
            this.cmp.insertAtCursor(c);
        }
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @contributor vizcano - http://www.extjs.com/forum/member.php?u=23512
 * @class Ext.ux.form.HtmlEditor.UndoRedo
 * @extends Ext.ux.form.HtmlEditor.MidasCommand
 * <p>A plugin that creates undo and redo buttons on the HtmlEditor. Incomplete.</p>
 */

Ext.ux.form.HtmlEditor.UndoRedo = Ext.extend(Ext.ux.form.HtmlEditor.MidasCommand, {
    // private
    midasBtns: ['|', {
        cmd: 'undo',
        tooltip: {
            title: 'Undo'
        },
        overflowText: 'Undo'
    }, {
        cmd: 'redo',
        tooltip: {
            title: 'Redo'
        },
        overflowText: 'Redo'
    }]
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @contributor Somani - http://www.sencha.com/forum/member.php?51567-Somani
 * @class Ext.ux.form.HtmlEditor.HeadingButtons
 * @extends Ext.ux.form.HtmlEditor.MidasCommand
 * <p>A plugin that creates a button on the HtmlEditor that will have H1 and H2 options. This is used when you want to restrict users to just a few heading types.</p>
 * NOTE: while 'heading' should be the command used, it is not supported in IE, so 'formatblock' is used instead. Thank you IE.
 */

Ext.ux.form.HtmlEditor.HeadingButtons = Ext.extend(Ext.ux.form.HtmlEditor.MidasCommand, {
    // private
    midasBtns: ['|', {
        enableOnSelection: true,
        cmd: 'formatblock',
        value: '<h1>',
        tooltip: {
            title: '1st Heading'
        },
        overflowText: '1st Heading'
    }, {
        enableOnSelection: true,
        cmd: 'formatblock',
        value: '<h2>',
        tooltip: {
            title: '2nd Heading'
        },
        overflowText: '2nd Heading'
    }]
}); 

/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.HeadingMenu
 * @extends Ext.util.Observable
 * <p>A plugin that creates a menu on the HtmlEditor for selecting a heading size. Takes up less room than the heading buttons if your going to have all six heading sizes available.</p>
 */
Ext.ux.form.HtmlEditor.HeadingMenu = Ext.extend(Ext.util.Observable, {
    init: function(cmp){
        this.cmp = cmp;
        this.cmp.on('render', this.onRender, this);
    },
    // private
    onRender: function(){
        var cmp = this.cmp;
        var btn = this.cmp.getToolbar().addItem({
            xtype: 'combo',
            displayField: 'display',
            valueField: 'value',
            name: 'headingsize',
            forceSelection: true,
            mode: 'local',
            triggerAction: 'all',
            width: 65,
            emptyText: 'Heading',
            store: {
                xtype: 'arraystore',
                autoDestroy: true,
                fields: ['value','display'],
                data: [['H1','1st Heading'],['H2','2nd Heading'],['H3','3rd Heading'],['H4','4th Heading'],['H5','5th Heading'],['H6','6th Heading']]
            },
            listeners: {
                'select': function(combo,rec){
                    this.relayCmd('formatblock', '<'+rec.get('value')+'>');
                    combo.reset();
                },
                scope: cmp
            }
        });
    }
});
/**
 * @author Shea Frederick - http://www.vinylfox.com
 * @class Ext.ux.form.HtmlEditor.plugins
 * <p>A convenience function that returns a standard set of HtmlEditor buttons.</p>
 * <p>Sample usage:</p>
 * <pre><code>
    new Ext.FormPanel({
        ...
        items : [{
            ...
            xtype           : "htmleditor",
            plugins         : Ext.ux.form.HtmlEditor.plugins()
        }]
    });
 * </code></pre>
 */
Ext.ux.form.HtmlEditor.plugins = function(){
    return [
//        new Ext.ux.form.HtmlEditor.Link(),
//        new Ext.ux.form.HtmlEditor.Divider(),
//        new Ext.ux.form.HtmlEditor.Word(),
//        new Ext.ux.form.HtmlEditor.FindAndReplace(),
        new sitools.widget.HtmlEditor.datasetLink(),
        new Ext.ux.form.HtmlEditor.UndoRedo(),
        new Ext.ux.form.HtmlEditor.Divider(),
        new Ext.ux.form.HtmlEditor.Image(),
//        new Ext.ux.form.HtmlEditor.Table(),
        new Ext.ux.form.HtmlEditor.HR(),
        new Ext.ux.form.HtmlEditor.SpecialCharacters(),
        new Ext.ux.form.HtmlEditor.HeadingMenu(),
        new Ext.ux.form.HtmlEditor.IndentOutdent(),
        new Ext.ux.form.HtmlEditor.SubSuperScript(),
        new Ext.ux.form.HtmlEditor.RemoveFormat()
    ];
};/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.3.1
 * Copyright(c) 2006-2010 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
var ImageExplorer = function(config){
	this.config = config;
}

ImageExplorer.prototype = {
    // cache data by image name for easy lookup
    lookup : {},

	show : function(el, callback){
		if(!this.win){
			this.initTemplates();

		 this.store = new Ext.data.JsonStore({
        	proxy : new Ext.data.HttpProxy({
        		method : 'GET',
        		url: this.config.directoryImageUrl,
        		headers : {
    				'Accept' : 'application/json+sitools-directory'
    			}
        	}),
	        idProperty: 'text',
	        fields: [
	                 {name : 'text', mapping: 'text'},
	                 {name : 'lastmod', mapping : 'lastmod', type:'date', dateFormat:'timestamp'},
	                 {name : 'leaf', mapping : 'leaf'}, 
	                 {name : 'url', mapping : 'url'},
	                 {name : 'size', mapping : 'size', type: 'float'},
	                 {name : 'cls', mapping : 'cls'}
	                ],
            listeners: {
		    	'load': {fn:function(){
		    		this.view.select(0); 
		    	}, scope: this, single:true}
		    }
		    });
		 this.store.load();
		 
			var formatSize = function(data){
		        if(data.size < 1024) {
		            return data.size + " bytes";
		        } else {
		            return (Math.round(((data.size*10) / 1024))/10) + " KB";
		        }
		    };

			var formatData = function(data){
		    	data.shortName = data.text.ellipse(15);
		    	data.sizeString = formatSize(data);
		    	data.dateString = new Date(data.lastmod).format("d/m/Y g:i a");
		    	this.lookup[data.text] = data;
		    	return data;
		    };

		    this.view = new Ext.DataView({
				tpl: this.thumbTemplate,
				id : 'imageChooserDataViewId', 
				singleSelect: true,
				overClass:'x-view-over',
				itemSelector: 'div.thumb-wrap',
				emptyText : '<div style="padding:10px;">No images match the specified filter</div>',
				store: this.store,
				listeners: {
					'dblclick'       : {fn: function (dv, ind, node, e){
						this.doCallback(dv, ind, node, e);
					}, scope:this},
					'loadexception'  : {fn:this.onLoadException, scope:this},
					'beforeselect'   : {fn:function(view){
				        return view.store.getRange().length > 0;
				    }}
				},
				prepareData: formatData.createDelegate(this)
			});

		    this.menu = new Ext.menu.Menu({
				id : 'paramMenu',
				items : [{
	                text: 'Initial Size',
	                id : 'initialId',
	                checked: true,
	                checkHandler: function (){
	                	if (this.checked){
	                		this.parentMenu.find('id', 'customId')[0].setChecked(false);
	                	}
	                }
	            }, '-',
	            {
	                text: 'Customisable Size',
	                id : 'customId',
	                checked: false,
	                menu : {
	                	items : [{
	                		xtype: 'spinnerfield',
	                    	emptyText: 'Custom width...',
	                    	name: 'width',
	                    	listeners : {
	                    		scope : this,
	                    		mousedown : function (field, e){
	                    			var ed = ed;
	                    		}
	                    	}
	                	},
	                	{
	                		xtype: 'spinnerfield',
	                		emptyText: 'Custom height...',
	                    	name: 'height',
	                    	listeners : {
	                    		scope : this,
	                    		mousedown : function (field, e){
	                    			var ed = ed;
	                    		}
	                    	}
	                	}]
	                },
	                checkHandler: function (){
	                	if (this.checked){
	                		this.parentMenu.find('id', 'initialId')[0].setChecked(false);
	                	}
	                }
	            }]
			});
		    
		    this.splitButton = new Ext.Toolbar.SplitButton({
		    	id: 'ok-btn',
		    	text: 'OK',
		    	scope : this,
	            handler: function (){
	            	var node = this.view.getSelectedNodes()[0];
	            	var rec = this.view.getStore().getById(node.id);
	            	
	            	if(this.menu.find('id', 'initialId')[0].checked){
	                	this.doCallback2(this.view, rec);
                	}
	            	else {
	            		var subMenu = this.menu.find('id', 'customId')[0];
	            		var width = subMenu.menu.find('name', 'width')[0].getValue();
	            		var height = subMenu.menu.find('name', 'height')[0].getValue();
	            		
	            		this.doCallback2(this.view, rec, width, height);
	            	}
                },
	            menu : this.menu
		    });
		    
		    var cfg = {
		    	title: i18n.get('label.chooseImage'),
		    	id: 'img-chooser-dlg',
		    	layout: 'border',
				minWidth: 500,
				minHeight: 450,
				modal: true,
//				closeAction: 'hide',
				border: false,
				tbar : [ '->', {
                		xtype : 'label',
                		text : i18n.get('label.uploadFile') + ' :'
            		}, 
            		{
                		xtype : 'button',
                		iconAlign : 'right',
                		iconCls : 'upload-icon',
              			tooltip : i18n.get('label.uploadFile'),
                		scope : this,
                		handler : function () {
			        		var callbackUpload = function (createdNode) {
			        			var rec = new Ext.data.Record(createdNode);
					        	this.add(rec);
					        	this.reload();
				        	}
				        
					        var uploadWin = new sitools.user.modules.datastorageUploadFile({
					        	urlUpload : this.config.directoryImageUrl + "/",
					        	callback : callbackUpload,
					        	scope : this.store
					        }).show();
                		}
            		}
            	],
				items:[{
					id: 'img-chooser-view',
					region: 'center',
					autoScroll: true,
					items: this.view,
                    tbar:[{
                    	text: i18n.get ('label.filter')
                    },{
                    	xtype: 'textfield',
                    	id: 'filter',
                    	selectOnFocus: true,
                    	width: 100,
                    	listeners: {
                    		'render': {fn:function(){
						    	Ext.getCmp('filter').getEl().on('keyup', function(){
						    		this.filter();
						    	}, this, {buffer:500});
                    		}, scope:this}
                    	}
                    }, ' ', '-', {
                    	text: i18n.get ('label.sortBy')
                    }, {
                    	id: 'sortSelect',
                    	xtype: 'combo',
				        typeAhead: true,
				        triggerAction: 'all',
				        width: 100,
				        editable: false,
				        mode: 'local',
				        displayField: 'desc',
				        valueField: 'text',
				        lazyInit: false,
				        value: 'text',
				        store: new Ext.data.ArrayStore({
					        fields: ['text', 'desc'],
					        data : [['text', 'Name'],['size', 'File Size'],['lastmod', 'Last Modified']]
					    }),
					    listeners: {
							'select': {fn:this.sortImages, scope:this}
					    }
				    }]
				}],
				buttons: [this.splitButton
				,{
					text: 'Cancel',
					handler: function(){ this.win.close(); },
					scope: this
				}],
				keys: {
					key: 27, // Esc key
					handler: function(){ this.win.close(); },
					scope: this
				}
			};
			Ext.apply(cfg, this.config);
		    this.win = new Ext.Window(cfg);
		}

		this.reset();
	    this.win.show(el);
		this.callback = callback;
		this.animateTarget = el;
	},

	initTemplates : function(){
		this.thumbTemplate = new Ext.XTemplate(
			'<tpl for=".">',
				'<tpl if="this.isImage(url)">',
					'<div class="thumb-wrap" id="{text}">',
					'<div class="thumb"><img src="{url}" height="96" width="96" title="{shortName}"></div>',
					'<span>{shortName}</span></div>',
				'</tpl>',
			'</tpl>',
			{
    			compiled : true,
    			isLeaf : function (leaf){
    				return leaf;
    			},
    			isImage : function (text){
    				var imageRegex = /\.(png|jpg|jpeg|gif|bmp)$/;
    				if (text.match(imageRegex))
    					return true;
    				else{
    					return false;
    				}
    			}
            }
		);
		this.thumbTemplate.compile();
	},

	filter : function(){
		var filter = Ext.getCmp('filter');
		this.view.store.filter('text', filter.getValue());
		this.view.select(0);
	},

	sortImages : function(){
		var v = Ext.getCmp('sortSelect').getValue();
    	this.view.store.sort(v, v == 'text' ? 'asc' : 'desc');
    	this.view.select(0);
    },

	reset : function(){
		if(this.win.rendered){
			Ext.getCmp('filter').reset();
			this.view.getEl().dom.scrollTop = 0;
		}
	    this.view.store.clearFilter();
		this.view.select(0);
	},

	doCallback : function(dv, ind, node, e){
		
		var rec = dv.getStore().getById(node.id);
		//Insert Selected Image in HtmlEditor
		Image.insertImage(rec.data, this.config);
		
		this.win.close();
    },
    
    doCallback2 : function (dv, rec, width, height){
    	//Insert Selected Image in HtmlEditor
    	
    	if (width && height){
    		rec.data.width = width;
    		rec.data.height = height;
    	}
    	Image.insertImage(rec.data, this.config);
    	
		this.win.close();
    },

	onLoadException : function(v,o){
	    this.view.getEl().update('<div style="padding:10px;">Error loading images.</div>');
	},
	
	isImage : function (text){
		var imageRegex = /\.(png|jpg|jpeg|gif|bmp)$/;
		if (text.match(imageRegex))
			return true;
		else{
			var ind = this.store.find('text', text);
			this.store.remove(this.store.getAt(ind));
			return false;
		}
	}
};

String.prototype.ellipse = function(maxLength){
    if(this.length > maxLength){
        return this.substr(0, maxLength-3) + '...';
    }
    return this;
};
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, i18n, loadUrl */

Ext.namespace('sitools.widget.HtmlEditor');
/**
 * datasetLink widget
 * 
 * @class sitools.widget.HtmlEditor.datasetLink
 * @extends Ext.util.Observable
 */
sitools.widget.HtmlEditor.datasetLink = Ext.extend(Ext.util.Observable, {

	init : function(cmp) {
//        this.cmp = cmp;
//        this.cmp.on('render', this.onRender, this);
		
		this.browseField = new Ext.form.TriggerField({
            name : 'datasetLink',
            fieldLabel : i18n.get('label.selectDatasetLink'),
            allowBlank : false,
            labelWidth : 100,
            editable : false,
            emptyText : i18n.get('label.openDatasetBrowser'),
            anchor : '100%',
            forceSelection: true,
            onTriggerClick : function () {
		        if (!this.disabled) {
		            var browser = new sitools.widget.HtmlEditor.datasetBrowser({
                        field : this
		            });
		            new Ext.Window({
		            	title : i18n.get('label.selectDatasetLink'),
		            	iconCls : 'x-edit-datasetLink',
		            	layout : 'fit',
		            	height : 300,
		            	width : 300,
		            	autoScroll : true,
		            	items : [browser]
		            }).show();
		        }
		    }
        });
        
        var sel;
		this.datasetLinkWindow = new Ext.Window({
			title : i18n.get('label.insertDatasetLink'),
			closeAction : 'hide',
			resizable : false,
			width : 400,
			height : 175,
			items : [{
				xtype : 'form',
				itemId : 'insert-datasetLink',
				border : false,
				plain : true,
				bodyStyle : 'padding: 10px;',
				labelWidth : 100,
				labelAlign : 'right',
				bbar : new Ext.ux.StatusBar({
		            text : i18n.get('label.ready'),
		            id : 'sbWinEditProfile',
		            iconCls : 'x-status-valid',
		            hidden : true
		        }),
				items : [{
							xtype : 'textfield',
							allowBlank : false,
							fieldLabel : i18n.get('label.text'),
							name : 'text',
							anchor : '100%',
							value : ''
						}, this.browseField ]
			}],
			buttons : [{
				text : i18n.get('label.insertDatasetLink'),
				handler : function() {
					var frm = this.datasetLinkWindow
							.getComponent('insert-datasetLink').getForm();
					if (frm.isValid()) {
						text = frm.findField('text').getValue(); 
						browseField = frm.findField('datasetLink');
						
						var html = String.format(browseField.dataLinkComponent + "{0}</a>", text);
						this.cmp.insertAtCursor(html);
						this.datasetLinkWindow.close();
					} else {
						var sb = Ext.getCmp('sbWinEditProfile');
						 sb.setStatus({
			                text : i18n.get('warning.checkForm'),
			                iconCls : 'x-status-error',
			                hidden : false
			            });
			            sb.setVisible(true);
			            return;
					}

				},
				scope : this
			}, {
				text : i18n.get('label.cancel'),
				handler : function() {
					this.datasetLinkWindow.close();
				},
				scope : this
			}]
		});
	},

	onRender : function() {
		this.btnToolbar = this.cmp.getToolbar().addButton({
			iconCls : 'x-edit-datasetLink',
			scope : this,
			handler : this.showDatasetLinkWindow,
			tooltip : i18n.get('label.insertDatasetLink')
		});
	},
	
	showDatasetLinkWindow : function () {
		if (!this.datasetLinkWindow.isDestroyed) {
			this.datasetLinkWindow.show();
		} 
		else {
			this.datasetLinkWindow.destroy();
			this.init(this.cmp);
			this.datasetLinkWindow.show();
		}
	}
	
});

Ext.reg('sitools.widget.HtmlEditor.datasetLink',
		sitools.widget.HtmlEditor.datasetLink);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, i18n, loadUrl */

Ext.namespace('sitools.widget.sitoolsEditorPlugins');
/**
 * datasetLink widget
 * 
 * @class sitools.widget.sitoolsEditorPlugins.datasetBrowser
 * @extends Ext.util.Observable
 */
sitools.widget.sitoolsEditorPlugins.datasetBrowser = function(config) {
	this.datasets = [];
	this.browseField = config.field;
	this.textField = config.textField;
	
	/**
	 * INDEX JPB var projectId = Ext.util.Cookies.get('projectId'); if
	 * (Ext.isEmpty(projectId)){ Ext.Msg.alert(i18n.get ('warning.noProject'));
	 * return; }
	 */

	// var projectId = projectGlobal.getProjectId();
	var projectAttachment = projectGlobal.sitoolsAttachementForUsers;
	var treeUtils = commonTreeUtils;

	var conn = Ext.Ajax;
	conn.request({
		url : projectAttachment + '/datasets?media=json',
		method : 'GET',
		scriptTag : true,
		scope : this,
		success : function(response) {
			if (!showResponse(response, false)) {
				return;
			}
			var config = Ext.decode(response.responseText);
			var i = 0;
			Ext.each(config.data, function(dataset) {
				if (dataset.authorized !== "false") {
					this.datasets.push({
						text : dataset.name,
						listeners : {
							scope : this,
							beforeexpand : function(node) {
								node.removeAll(true);
								if (dataset.status != "ACTIVE") {
									var notify = new Ext.ux.Notification({
												iconCls : 'x-icon-information',
												title : i18n
														.get('label.information'),
												html : i18n
														.get('warning.wrongStatus'),
												autoDestroy : true,
												hideDelay : 1000
											});
									notify.show(document);
									return true;
								}
								conn.request({
									// url : '/sitools/datasets/' + dataset.id +
									// '?media=json',
									url : dataset.url + '?media=json',
									scope : this,
									success : function(response) {
										var dataset = Ext.decode(response.responseText).dataset;
										commonTreeUtils.addShowData(node,dataset);
										SitoolsDesk.navProfile.manageDatasetExplorerShowDefinitionAndForms(commonTreeUtils, node, dataset);

										conn.request({
											url : dataset.sitoolsAttachementForUsers
													+ "/opensearch.xml",
											scope : this,
											success : function(response) {
												var xml = response.responseXML;
												var dq = Ext.DomQuery;
												// check if there is a success
												// node
												// in the xml
												var success = dq
														.selectNode(
																'OpenSearchDescription ',
																xml);

												if (success !== undefined) {
//													commonTreeUtils.addOpensearch(node, dataset);
												}
												return true;
											}
										});
//										commonTreeUtils.addFeeds(node, dataset);
									}
								});
								return true;
							}
						},
						children : [{
									text : ""
								}]
					});
				} else {
					this.datasets.push({
								text : dataset.name,
								leaf : false,
								icon : loadUrl.get('APP_URL')
										+ "/common/res/images/icons/cadenas.png",
								authorized : false
							});
				}
				i++;
			}, this);
			this.fireEvent('datasetLoaded');
		},
		failure : function() {
			Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.noProject'));
		}
	});
	this.rootNode = new Ext.tree.AsyncTreeNode({
				nodeType : 'async',
				text : 'dataSets',
				leaf : false,
				draggable : false,
				children : this.datasets,
				expanded : false,
				listeners : {
					scope : this,
					beforeexpand : function() {
						this.rootNode.removeAll(true);
						this.rootNode.appendChild(this.datasets);
						return true;
					}
				}
			});
			
	sitools.widget.sitoolsEditorPlugins.datasetBrowser.superclass.constructor.call(this,
			Ext.apply({
						expanded : true,
						useArrows : true,
						autoScroll : true,
						animate : true,
						loader : new Ext.tree.TreeLoader(),
						root : this.rootNode,
						rootVisible : true,
						layout : 'fit',
						listeners : {
							beforeload : function(node) {
								return node.isRoot || Ext.isDefined(node.attributes.children);
							},
							datasetLoaded : function() {
								this.getRootNode().expand();
							}
						},
						bbar : ['->', {
							xtype : 'button',
							text : i18n.get('label.select'),
							scope : this,
			                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/valid.png',
							handler : this.onValidate
						}]
					}));

};

Ext.extend(sitools.widget.sitoolsEditorPlugins.datasetBrowser, Ext.tree.TreePanel, {
			_getSettings : function() {
				return {
					preferencesPath : "/modules",
					preferencesFileName : this.id
				};
			},

			onValidate : function() {
				var selNode = this.selModel.getSelectedNode();
				if (Ext.isEmpty(selNode)) {
				    return Ext.Msg.alert(i18n.get('label.info'), i18n.get('label.noDatasetSelected'));
				}
				
				if (selNode.isLeaf() && selNode.attributes.type != "defi") {
					    var urlLink, displayValue;
						urlLink = selNode.attributes.dataUrl;
						displayValue = selNode.attributes.winTitle;
//						this.browseField.setValue(displayValue);
						
						this.browseField.datasetName = selNode.attributes.datasetName;
						
					if (selNode.attributes.type == "data") {
					    this.browseField.setValue('Data : ' + selNode.attributes.datasetName);
					    this.textField.setValue(selNode.attributes.datasetName);
					    
						this.browseField.dataLinkComponent = String.format("parent.sitools.user.clickDatasetIcone(\"{0}\", 'data'); return false;", urlLink);
					}
					else if (selNode.attributes.type == "form"){
					    this.browseField.setValue('Form : ' + selNode.attributes.datasetName);
					    this.textField.setValue(selNode.attributes.datasetName);
						this.browseField.dataLinkComponent = String.format('parent.SitoolsDesk.showFormFromEditor(\'{0}/forms\'); return false;', urlLink);
					}
					this.ownerCt.close();
				}
			}

		});

Ext.reg('sitools.widget.sitoolsEditorPlugins.datasetBrowser', sitools.widget.sitoolsEditorPlugins.datasetBrowser);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, i18n, loadUrl */

Ext.namespace('sitools.widget.sitoolsEditorPlugins');
/**
 * datasetLink widget
 * 
 * @class sitools.widget.sitoolsEditorPlugins.moduleBrowser
 * @extends Ext.util.Observable
 */
sitools.widget.sitoolsEditorPlugins.moduleBrowser = Ext.extend(Ext.grid.GridPanel, {
    layout : 'fit',
    initComponent : function () {
        
        this.urlModule = projectGlobal.sitoolsAttachementForUsers + loadUrl.get('APP_PROJECTS_MODULES_URL');
        
        this.store = new Ext.data.JsonStore({
            root : 'data',
            url : this.urlModule,
            autoLoad : true,
            fields : [{
                name : 'id'
            }, {
                name : 'name'
            },{
                name : 'title'
            }, {
                name : 'description'
            }, {
                name : 'imagePath'
            },{
                name : 'icon'
            }, {
                name : 'xtype'
            }]
        });
        
        this.viewConfig = {
            forceFit: true,
            autoFill : true
        };
        
        this.sm = new Ext.grid.RowSelectionModel({
            singleSelect:true,
            listeners : {
                scope : this,
                rowselect : function (grid, rowInd, rec) {
                    var btn = this.getBottomToolbar().find('name', 'selectButton')[0];
                    btn.setDisabled(false);
                },
                rowdeselect : function (grid, rowInd, rec) {
                    var btn = this.getBottomToolbar().find('name', 'selectButton')[0];
                    btn.setDisabled(true);
                }
            }
                
        });
        
        this.cm = new Ext.grid.ColumnModel({
            columns : [{
                width : 35,
                sortable : true,
                dataIndex : 'icon',
                renderer : function(value, metaData, record, rowIndex, colIndex, store) {
                    if (Ext.isEmpty(value)) {
                        return "";
                    }
//                    var imageReference = new Reference(value);
                    metaData.css += " " + value;
                    return "";
//                    return "<img src=" + imageReference.getFile() + " height=16 width=16 />";
                }
            }, {
                header : i18n.get('headers.name'),
                width : 170,
                sortable : true,
                dataIndex : 'name'
            }, {
                header : i18n.get('header.title'),
                width : 170,
                sortable : true,
                dataIndex : 'title'
            }]
        });
        
        this.bbar = ['->', {
            xtype : 'button',
            name : 'selectButton',
            text : i18n.get('label.select'),
            icon : loadUrl.get('APP_URL') + '/common/res/images/icons/valid.png',
            scope : this,
            disabled : true,
            handler : this.onValidate
        }];
        
        sitools.widget.sitoolsEditorPlugins.moduleBrowser.superclass.initComponent.call(this);
    },
    
    /**
     * method called when trying to save preference
     * 
     * @returns
     */
    _getSettings : function() {
        return {
            preferencesPath : "/modules",
            preferencesFileName : this.id
        };
    },

    onValidate : function() {
        var module = this.getSelectionModel().getSelected();
        if (Ext.isEmpty(module)) {
            return Ext.Msg.alert(i18n.get('label.info'), i18n.get('label.selectModule'));
        }
        
        this.browseField.moduleTitle = module.data.title;
        this.browseField.moduleComponent = String.format("parent.sitools.user.component.module.moduleUtils.openModule(\"{0}\"); return false;", module.data.id);
        
        
        this.browseField.setValue('Module : ' + module.data.title);
        this.textField.setValue(module.data.title);
        
        this.ownerCt.close();
    }
});
Ext.reg('sitools.widget.sitoolsEditorPlugins.moduleBrowser', sitools.widget.sitoolsEditorPlugins.moduleBrowser);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, i18n, loadUrl */

Ext.namespace('sitools.widget.sitoolsEditorPlugins');
/**
 * datasetLink widget
 * 
 * @class sitools.widget.sitoolsEditorPlugins.documentBrowser
 * @extends Ext.util.Observable
 */
sitools.widget.sitoolsEditorPlugins.documentBrowser = Ext.extend(Ext.Window, {
    width : 500,
    height : 500,
    layout : 'fit',
    initComponent : function () {
        
        this.title = i18n.get('label.importDocTitle');
        
        this.documentUrl = this.datastorageUrl + '/documents/';
        
        this.store = new Ext.data.JsonStore({
            url: this.documentUrl,
            root: 'items',
            fields: [
                'name', 'url',
                {name:'size', type: 'float'},
                {name:'lastmod', type:'date', dateFormat:'timestamp'}
            ],
            listeners: {
                scope : this,
                load : function (store, records, options) {
                    Ext.each(records, function(record){
                        var url = new Reference(record.get('url'));
                        var recordUrl = url.getFile();
                        record.set("url", recordUrl);
                    });
                },
                exception : function (misc) { // s'il y a une exception, on essaye de créer le dossier /documents
                    Ext.Ajax.request({
                        url : this.documentUrl,
                        method : 'PUT',
                        success : function (ret) {
                        },
                        failure : alertFailure
                    });
                }
            }
        });
        this.store.load();
        
        this.grid = new Ext.grid.GridPanel({
            region : 'center',
            padding:'5',
            store: this.store,
            title: i18n.get('label.selectDocToImport'),
            sm: new Ext.grid.RowSelectionModel({singleSelect:true}),
            colModel: new Ext.grid.ColumnModel({
                columns: [{
                        width: 30, 
                        sortable: true,
                        scope : this,
                        renderer : function (value) {
                            var lastDot = value.lastIndexOf(".");
                            var icon = this.getIcon(value.slice(lastDot + 1, value.length));
                            if (icon == null) {
                                return "";
                            }
                            return "<img src=" + icon + " />";
                        }
                    }, {
                        header: i18n.get('headers.name'),
                        dataIndex: 'name',
                        width: 150, 
                        sortable: true
                    }, {
                        header: i18n.get('label.size'),
                        dataIndex: 'size',
                        width: 120, 
                        renderer : function (value) {
                            if(value < 1024) {
                                return value + " bytes";
                            } else {
                                return (Math.round(((value*10) / 1024))/10) + " KB";
                            }
                        }
                    }, {
                        header: i18n.get('label.lastmod'),
                        xtype: 'datecolumn',
                        dataIndex: 'lastmod',
                        width: 120, 
                        renderer : function (value) {
                            return new Date(value).format("d/m/Y g:i a");
                        }
                    }]
            }),
            viewConfig: {
                forceFit: true,
                autoFill : true
            }
        });
        
        this.formPanel = new Ext.FormPanel({
            fileUpload : true,
            collapsible : true,
            formId : 'formUploadId',
            autoHeight : true,
            bodyStyle : 'padding: 10px 10px 0 10px;',
            height : 100,
            region : 'north',
            labelWidth : 100,
            defaults : {
                anchor : '100%',
                allowBlank : true,
                msgTarget : 'side'
            },
            items : [{
                xtype : 'fileuploadfield',
                fieldLabel: i18n.get('label.file'),
                id : 'form-file',
                emptyText : i18n.get('label.selectFile'),
                name : 'image',
                buttonText : '',
                buttonCfg : {
                    iconCls : 'upload-icon'
                }
            }],
            buttons : [{
                text : i18n.get('label.uploadFile'),
                scope : this,
                handler : function () {
                    if (this.formPanel.getForm().isValid()) {
                        var f = this.formPanel.getForm();
                        var fileName = f.findField('form-file').getValue();
                        fileName = fileName.substring(fileName.lastIndexOf("\\") + 1, fileName.lenght);

                        Ext.Ajax.request({
                            url : this.documentUrl,
                            form : 'formUploadId',
                            isUpload : true,
                            waitMsg : "wait...",
                            method : 'POST',
                            scope : this,
                            success : function (response) {
                            },
                            failure : function (response) {
                                Ext.Msg.alert(i18n.get('label.error'));
                            },
                            callback : function () {
                                this.grid.getStore().reload();
                            }
                        });
                    }
                }
            }]
        });

        this.container = new Ext.Panel({
            padding:'5',
            layout: 'border',
            defaults: {margins:'0 0 5 0'},
            items:[this.grid, this.formPanel],
            bbar : ['->' ,{
                text : i18n.get('label.insert'),
                scope : this,
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/valid.png',
                handler : this.setDocumentToInsert
            }]
        });
        
        this.listeners = {
            scope : this,
            activate : function (win) {
                this.bringToFront(win);
            },
            show : function (win) {
                this.bringToFront(win);
            }
        };
        
        this.items = [this.container];
        
        sitools.widget.sitoolsEditorPlugins.documentBrowser.superclass.initComponent.call(this);
    },
    
    setDocumentToInsert : function () {
        var document = this.grid.getSelectionModel().getSelected();
        
        if (Ext.isEmpty(document)) {
            return;
        }
        
        var textfield = this.dialog.getContentElement('mainFrameDocument', 'textDocUrlID');
        var docUrl = this.documentUrl + document.data.name;
        
        
        textfield.documentName = document.data.name;
        textfield.documentUrl = docUrl;
        textfield.setValue("Document : " + document.data.name);
        textfield.documentComponent = String.format("parent.sitools.user.component.bottom.Bottom.showFooterLink(\"{0}\", \"{1}\"); return false;", docUrl, document.data.name);
        
        this.close();
    },
    
    bringToFront : function (win){
        if (win && !Ext.isEmpty(win.zindex) && win.isVisible()) {
            win.focus();
            win.setZIndex(win.zindex);
        }
    },
    
    getIcon : function (ext) {
        if (ext == "doc" || ext == "docx") {
            return loadUrl.get('APP_URL') + '/common/res/images/icons/word.png';
        } else if (ext == "xls" || ext == "xlsx") {
            return loadUrl.get('APP_URL') + '/common/res/images/icons/excel.png';
        } else if (ext == "ppt" || ext == "pptx") {
            return loadUrl.get('APP_URL') + '/common/res/images/icons/powerpoint.png';
        } else if (ext == "pdf" || ext == "PDF") {
            return loadUrl.get('APP_URL') + '/common/res/images/icons/icon-pdf-small.png';
        } else if (ext == "py") {
            return loadUrl.get('APP_URL') + '/common/res/images/icons/python.png';
        } else {
            return null;
        }
    }
    
});
Ext.reg('sitools.widget.sitoolsEditorPlugins.documentBrowser', sitools.widget.sitoolsEditorPlugins.documentBrowser);
Ext.override (GeoExt.data.FeatureStore, {
    /**
	 * Sort by multiple fields in the specified order.
	 * 
	 * @param {Array}
	 *            An Array of field sort specifications, or, if ascending sort
	 *            is required on all columns, an Array of field names. A field
	 *            specification looks like:
	 * 
	 * <pre><code>
	 * {
	 *     ordersList : [ {
	 *         field : firstname,
	 *         direction : ASC
	 *     }, {
	 *         field : name
	 *         direction : DESC
	 *     } ]
	 * }
	 * 
	 * </code>
	 * 
	 */
    multiSort : function (sorters, direction) {
        this.hasMultiSort = true;
        direction = direction || "ASC";

        if (this.multiSortInfo && direction == this.multiSortInfo.direction) {
            direction = direction.toggle("ASC", "DESC");
        }

        this.multiSortInfo = {
            sorters : sorters,
            direction : direction
        };

        if (this.remoteSort) {
            // this.singleSort(sorters[0].field, sorters[0].direction);
            this.load(this.lastOptions);

        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
    },
    getSortState : function () {
        return this.hasMultiSort ? this.multiSortInfo : this.sortInfo;
    },

    // application du tri multiple sur le store
    load : function (options) {
        options = Ext.apply({}, options);
        this.storeOptions(options);
        if ((this.sortInfo || this.multiSortInfo) && this.remoteSort) {
            var pn = this.paramNames;
            options.params = Ext.apply({}, options.params);
            this.isInSort = true;
            var root = pn.sort;
            if (this.hasMultiSort) {
                options.params[pn.sort] = Ext.encode({
                    "ordersList" : this.multiSortInfo.sorters
                });
            } else {
                options.params[pn.sort] = Ext.encode({
                    "ordersList" : [ this.sortInfo ]
                });
            }

        }

        try {
            return this.execute('read', null, options);
        } catch (e) {
            this.handleException(e);
            return false;
        }
    }
	
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, ann, alert, document, alertFailure, getDesktop, SitoolsDesk, locale, portal */
/*global DEFAULT_WIN_HEIGHT, DEFAULT_WIN_WIDTH, sitools, loadUrl, includeJs, DEFAULT_PREFERENCES_FOLDER */

/*
 * @include "desktop/desktop.js"
 * @include "components/columnsDefinition/dependencies/columnsDefinition.js"
 * @include "components/forms/forms.js"
 */

Ext.namespace('sitools.env');
var userPreferences = null;
var userLogin = null;
var sql2ext = {

    map : [],
    load : function (url) {

        var i18nRef = this;
        Ext.Ajax.request({
            method : 'GET',
            url : url,
            // params:'formLogin', using autorization instead
            success : function (response, opts) {
                ann(response.responseText, "no response is sent");
                i18nRef.map = i18nRef.transformsPropertiesToMap(response.responseText);
            },
            failure : function (response, opts) {
                alert("Error! Can't read i18n file with url :" + url);
            }
        });

    },
    /**
     * Transforms a properties Text to a map
     * 
     * @param text
     *            raw properties file
     * @returns a map (associative array) TODO check when the raw properties
     */
    transformsPropertiesToMap : function (text) {
        var array = text.split('\n');
        var localMap = [];
        var i;
        for (i = 0; i < array.length; i++) {
            var string = array[i];
            var indexOfEqualsSign = string.indexOf('=');
            if (indexOfEqualsSign >= 1) {
                var key = string.substring(0, indexOfEqualsSign).replace('\r', '');
                var value = string.substring(indexOfEqualsSign + 1).replace('\r', '');
                localMap[key] = value;
            }
        }
        return localMap;
    },
    /**
     * return the i18n value
     * 
     * @param name
     * @returns
     */
    get : function (entry) {
        return !Ext.isEmpty(this.map[entry]) ? this.map[entry] : 'auto';
    }
};
var i18n = {

    map : [],
    /**
     * Load a properties file and and the name/values in a associative array ;
     * Executing this function on multiple properties file increase the size of
     * the array Results can be displayed in the help panel with the display()
     * function
     * 
     * @param url
     *            URL of the i18n file
     * @param callback
     *            No args function that will be executed
     * @returns void
     */
    load : function (url, callback, loopOnFailure) {
        var i18nRef = this;
        Ext.Ajax.request({
            method : 'GET',
            url : url,
            loopOnFailure : (Ext.isEmpty(loopOnFailure)) ? true : loopOnFailure,
            // params:'formLogin', using autorization instead
            success : function (response, opts) {
                ann(response.responseText, "no response is sent");
                i18nRef.map = i18nRef.transformsPropertiesToMap(response.responseText);
                if (Ext.isFunction(callback)) {
                    callback();
                }
            },
            failure : function (response, opts) {
                if (!opts.loopOnFailure) {
                    Ext.Msg.alert("Error! Can't read i18n file with url :" + url);
                } else {
                    locale.restoreDefault();
                    url = '/sitools/res/i18n/' + locale.getLocale() + '/gui.properties';
                    i18n.load(url, callback, false);
                }
            }
        });

    },
    /**
     * Transforms a properties Text to a map
     * 
     * @param text
     *            raw properties file
     * @returns a map (associative array) TODO check when the raw properties
     *          file is rotten
     */
    transformsPropertiesToMap : function (text) {
        var array = text.split('\n');
        var localMap = [];
        var i;
        for (i = 0; i < array.length; i++) {
            var string = array[i];
            var indexOfEqualsSign = string.indexOf('=');
            if (indexOfEqualsSign >= 1) {
                var key = string.substring(0, indexOfEqualsSign).replace('\r', '');
                var value = string.substring(indexOfEqualsSign + 1).replace('\r', '');
                localMap[key] = value;
            }
        }
        return localMap;
    },
    /**
     * return the i18n value
     * 
     * @param name
     * @returns
     */
    get : function (entry) {
        return !Ext.isEmpty(this.map[entry]) ? this.map[entry] : entry;
    }
};

/**
 * To be defined
 */
var componentManager = {
    loadedComponents : [],
    load : function (name) {

    }
};

var data = {
    ret : null,
    /**
     * Fetch a html file in the url, and display its content into the helpPanel. *
     * 
     * @param url
     * @returns
     */
    get : function (url, cbk) {
        Ext.Ajax.request({
            method : 'GET',
            url : url,
            success : function (response, opts) {
                cbk(Ext.decode(response.responseText));
            },
            failure : function (response, opts) {
                Ext.Msg.alert("Warning", "Error! Can't get data with url :" + url);
            }
        });
        return this.ret;
    }

};
userLogin = Ext.util.Cookies.get('userLogin');
var userStorage = {
	set : function (filename, filepath, content, callback, scope) {
	    userStorage.setData(filename, filepath, content, callback, scope, "json");
    },
    setXML : function (filename, filepath, content, callback, scope) {
        userStorage.setData(filename, filepath, content, callback, scope, "xml");
    },
    //private
    setData : function (filename, filepath, content, callback, scope, type) {
        var config = {
                url : loadUrl.get('APP_URL') + loadUrl.get('APP_USERSTORAGE_USER_URL').replace('{identifier}', userLogin) + "/files",
                method : 'POST',
                scope : scope,
                params : {
                    filepath : filepath,
                    filename : filename
                },
                jsonData : content,
                success : function (ret) {
                    var Json = Ext.decode(ret.responseText);
                    if (!Json.success) {
                        Ext.Msg.alert(i18n.get('label.warning'), Json.message);
                        return;
                    } else {
                        var notify = new Ext.ux.Notification({
                            iconCls : 'x-icon-information',
                            title : i18n.get('label.information'),
                            html : Json.message,
                            autoDestroy : true,
                            hideDelay : 1000
                        });
                        notify.show(document);
                    }
                },
                failure : function () {
                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('label.warning.savepreference.error'));
                    return;
                },
                callback : callback
            };
        

        if (type === "xml") {
            config.xmlData = content;
        } else {
            config.jsonData = content;
        }
        
        Ext.Ajax.request(config);
    },
    get : function (fileName, filePath, scope, success, failure, callback) {
        Ext.Ajax.request({
            url : loadUrl.get('APP_URL') + loadUrl.get('APP_USERSTORAGE_USER_URL').replace('{identifier}', userLogin) + "/files" + filePath + "/" + fileName,
            method : 'GET',
            scope : scope,
            success : success,
            failure : failure, 
            callback : callback
        });
    }
};

/**
 * Global project variable Used to get the projectId from the url
 */
var projectGlobal = {
    /**
     * Get the current projectId from the url url is like :
     * /sitools/client-user/{projectName}/indexproject.html /sitools/client-user/
     * can be changed
     * 
     * @return the projectId
     */
    projectId : null,
    projectName : null,
    preferences : null,
    userRoles : null, 
    isAdmin : false,
    sitoolsAttachementForUsers : null,
    modules : null,
    links : null,
    callback : Ext.emptyFn,

    initProject : function (callback) {
        this.callback = callback;
        this.projectName = this.getProjectName();
        this.getProjectInfo();
    },

    // only load datasetView used by datasets in the current project
    getDataViewsDependencies : function () {
		Ext.Ajax.request({
            url : this.sitoolsAttachementForUsers + "/datasetViews",
            method : "GET",
            scope : this,
            success : function (ret) {
                var json = Ext.decode(ret.responseText);
                if (!json.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.errorloadingdataviews'));
                    return false;
                } else {
                    var data = json.data;                    
                    Ext.each(data, function (datasetViewComponent) {
                    	if (!Ext.isEmpty(datasetViewComponent.dependencies) && !Ext.isEmpty(datasetViewComponent.dependencies.js)) {
                            Ext.each(datasetViewComponent.dependencies.js, function (dependencies) {
                                includeJs(dependencies.url);
                            }, this);
                        }
                        if (!Ext.isEmpty(datasetViewComponent.dependencies) && !Ext.isEmpty(datasetViewComponent.dependencies.css)) {
							Ext.each(datasetViewComponent.dependencies.css, function (dependencies) {
								includeCss(dependencies.url);
							}, this);
						}
                    });
                    
                }
            },
            callback : function () {
                this.getFormDependencies();
            }
        });   
    }, 
    getFormDependencies : function () {
		Ext.Ajax.request({
            url : loadUrl.get('APP_URL') + loadUrl.get('APP_FORMCOMPONENTS_URL'),
            method : "GET",
            scope : this,
            success : function (ret) {
                var json = Ext.decode(ret.responseText);
                if (!json.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.errorLoadingFormDependencies'));
                    return false;
                } else {
                    var data = json.data;                    
                    Ext.each(data, function (formComponent) {
						includeJs(formComponent.fileUrlUser);
                    });
                }
            },
            callback : function () {
                this.getGUIServicesDependencies();
            }
        });   
    },
    getGUIServicesDependencies : function () {
        Ext.Ajax.request({
            url : this.sitoolsAttachementForUsers + "/guiServices",
            method : "GET",
            scope : this,
            success : function (ret) {
                var json = Ext.decode(ret.responseText);
                if (!json.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.errorLoadingGuiServicesDependencies'));
                    return false;
                } else {
                    var data = json.data;
                    var javascriptDependencies = []
                        Ext.each(data, function (service) {
                            if (!Ext.isEmpty(service.dependencies.js)) {
                                javascriptDependencies = javascriptDependencies.concat(service.dependencies.js);
                            }
                            if (!Ext.isEmpty(service.dependencies.css)) {
                                Ext.each(service.dependencies.css, function (dependencies) {
                                    includeCss(dependencies.url);
                                }, this);
                            }
                        }, this);
                    includeJsForceOrder(javascriptDependencies, 0, this.initLanguages, this);
                }
            }
        });   
    },
    initLanguages : function () {
        Ext.Ajax.request({
            scope : this,
            method : "GET",
            /* /sitools/client-user */
//            url : loadUrl.get('APP_URL') + loadUrl.get('APP_CLIENT_USER_URL') + '/tmp/langues.json',
            url : loadUrl.get('APP_URL') + '/client-user/tmp/langues.json',
            success : function (response) {
                var json = Ext.decode(response.responseText);
	            this.languages = json.data;
            },
            failure : function (response) {
                Ext.Msg.alert('Status', i18n.get('warning.serverError'));
            }, 
            callback : function () {
                this.getPreferences(this.callback);
            }
        });
    },
    getUserRoles : function (cb) {
		if (Ext.isEmpty(userLogin)) {
			cb.call();
		} 
		else {
			Ext.Ajax.request({
	            url : loadUrl.get('APP_URL') + loadUrl.get("APP_USER_ROLE_URL"),
	            method : "GET",
	            scope : this,
	            success : function (ret) {
	                var json = Ext.decode(ret.responseText);
	                if (!json.success) {
	                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.errorGettingUserRoles'));
	                    return false;
	                } else {
						this.user = json.user;        
						if (Ext.isEmpty(this.user.roles)) {
							return;
						}
						for (var index = 0; index < this.user.roles.length; index++) {
							var role = this.user.roles[index];
							if (role.name === "Administrator") {
								this.isAdmin = true;
							}
	                    }
	                }
	            },
	            callback : cb
	        });   
		}
    }, 
    getProjectName : function () {
        if (this.projectName === null) {
            // get the relative url
            var url = document.location.pathname;
            // split the url to get each part of the url in a tab cell
            var tabUrl = url.split("/");

            var i = 0, index;
            var found = false;
            // search for index.html, the projectName is right before
            // '/index.html'
            while (i < tabUrl.length && !found) {
                if (tabUrl[i] === "project-index.html") {
                    found = true;
                    index = i;
                }
                i++;
            }
            // get the projectName from the tabUrl
            this.projectName = tabUrl[index - 1];

            if (this.projectName === undefined || this.projectName === "") {
                Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.noProject'));
            }
        }
        return this.projectName;
    },
    /**
     * Get the name of a project from the server
     */
    getProjectInfo : function () {
        Ext.Ajax.request({
            url : loadUrl.get('APP_URL') + loadUrl.get('APP_PORTAL_URL') + '/projects/' + this.projectName,
            method : "GET",
            scope : this,
            success : function (ret) {
                var data = Ext.decode(ret.responseText);
                if (!data.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.noProjectFound'));
                    return false;
                } else {
                    this.sitoolsAttachementForUsers = data.project.sitoolsAttachementForUsers;
                    this.projectId = data.project.id;
                    this.projectName = data.project.name;
                    this.htmlHeader = data.project.htmlHeader;
                    this.links = data.project.links;
                    this.navigationMode = data.project.navigationMode;
                }
//                var topEl = Ext.get('toppanel');
//                topEl.update(Ext.util.Format.htmlDecode(data.project.htmlHeader));
            },
            callback : function (options, success, response) {
                if (success) {
                    this.getDataViewsDependencies();
                }
            },
            failure : function (response, opts) {
                if (response.status === 403) {
                    Ext.getBody().unmask();
                    Ext.MessageBox.buttonText.ok = i18n.get('label.login');
                    Ext.Msg.show({
                        title : i18n.get('label.information'),
                        msg : i18n.get('label.projectNeedToBeLogged'),
                        width : 350,
                        buttons : Ext.MessageBox.OK,
                        icon : Ext.MessageBox.INFO,
                        fn : function (response) {
                            if (response === 'ok') {
                                sitools.userProfile.LoginUtils.connect({
                                    url : loadUrl.get('APP_URL') + '/login',
                                    register : loadUrl.get('APP_URL') + '/inscriptions/user',
                                    reset : loadUrl.get('APP_URL') + '/resetPassword',
                                    handler : function () {
                                        portal.initAppliPortal({
                                            siteMapRes : loadUrl.get('APP_URL') + loadUrl.get('APP_CLIENT_USER_URL')
                                        });
                                    }
                                });
                            }
                        }
                    });
                }
                else {
                    Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.noProjectError'));
                }
            }
        });
    },    
    getPreferences : function (callback) {
        if (!Ext.isEmpty(userLogin)) {
            var filePath = "/" + DEFAULT_PREFERENCES_FOLDER + "/" + projectGlobal.projectName;
			var fileName = "desktop";
			var success = function (ret) {
                try {
                    this.preferences = Ext.decode(ret.responseText);
	                callback.call();
                } catch (err) {
	                callback.call();
                }
            };
            
            var failure = function (ret) {
                this.getPublicPreferences(callback);
            };
            
            userStorage.get(fileName, filePath, this, success, failure);
        } else {
            this.getPublicPreferences(callback);
        }
    }, 
    getPublicPreferences : function (callback) {
        var AppPublicStorage = loadUrl.get('APP_PUBLIC_STORAGE_URL') + "/files";
        Ext.Ajax.request({
//                url : "/sitools/userstorage/" + userLogin + "/" + DEFAULT_PREFERENCES_FOLDER + "/" + this.projectName + "/desktop?media=json",
            url : loadUrl.get('APP_URL') + AppPublicStorage + "/" + DEFAULT_PREFERENCES_FOLDER + "/" + this.projectName + "/desktop?media=json",
            method : 'GET',
            scope : this,
            success : function (ret) {
                try {
                    this.preferences = Ext.decode(ret.responseText);
                } catch (err) {
                    this.preferences = null;
                }
            }, 
            callback : callback
        });
    }
};

var publicStorage = {
    set : function (filename, filepath, content, callback) {
        this.url = loadUrl.get('APP_URL') + loadUrl.get('APP_PUBLIC_STORAGE_URL') + "/files";
        Ext.Ajax.request({
            url : this.url,
            method : 'POST',
            scope : this,
            params : {
                filepath : filepath,
                filename : filename
            },
            jsonData : content,
            success : function (ret) {
                var Json = Ext.decode(ret.responseText);
                if (!Json.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), Json.message);
                    return;
                } else {
                    var notify = new Ext.ux.Notification({
                        iconCls : 'x-icon-information',
                        title : i18n.get('label.information'),
                        html : Json.message,
                        autoDestroy : true,
                        hideDelay : 1000
                    });
                    notify.show(document);
                }
            },
            failure : function () {
                Ext.Msg.alert(i18n.get('label.warning'), i18n.get('label.warning.savepreference.error'));
                return;
            },
            callback : function () {
                if (!Ext.isEmpty(callback)) {
                    callback.call();
                }
            }
        });

    },
    get : function (fileName, filePath, scope, success, failure) {
        Ext.Ajax.request({
            url : loadUrl.get('APP_URL') + loadUrl.get('APP_PUBLIC_STORAGE_URL') + "/files" + filePath + "/" + fileName,
            method : 'GET',
            scope : scope,
            success : success,
            failure : failure
        });
    }, 
    remove : function () {
        this.url = loadUrl.get('APP_URL') + loadUrl.get('APP_PUBLIC_STORAGE_URL') + "/files" + "?recursive=true";
        Ext.Ajax.request({
            url : this.url,
            method : 'DELETE',
            scope : this,
            success : function (ret) {
                var notify = new Ext.ux.Notification({
                    iconCls : 'x-icon-information',
                    title : i18n.get('label.information'),
                    html : i18n.get("label.publicUserPrefDeleted"),
                    autoDestroy : true,
                    hideDelay : 1000
                });
                notify.show(document);
            },
            failure : function (ret) {
                //cas normal... 
				if (ret.status === 404) {
					var notify = new Ext.ux.Notification({
				        iconCls : 'x-icon-information',
				        title : i18n.get('label.information'),
				        html : i18n.get("label.publicUserPrefDeleted"),
				        autoDestroy : true,
				        hideDelay : 1000
				    });
				    notify.show(document);
				}
				else {
					var notifye = new Ext.ux.Notification({
				        iconCls : 'x-icon-error',
				        title : i18n.get('label.error'),
				        html : ret.responseText,
				        autoDestroy : true,
				        hideDelay : 1000
				    });
				    notifye.show(document);
				}
                
            }
        });
    }
};

function showResponse(ret, notification) {
    try {
        var Json = Ext.decode(ret.responseText);
        if (!Json.success) {
            Ext.Msg.alert(i18n.get('label.warning'), Json.message);
            return false;
        }
        if (notification) {
            var notify = new Ext.ux.Notification({
                iconCls : 'x-icon-information',
                title : i18n.get('label.information'),
                html : Json.message,
                autoDestroy : true,
                hideDelay : 1000
            });
            notify.show(document);
        }
        return true;
    } catch (err) {
        Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.javascriptError') + " : " + err);
        return false;
    }
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.0+
 * Copyright(c) 2006-2009 Ext JS, LLC
 * licensing@extjs.com
 * http://www.extjs.com/license
 */

/*global Ext, i18n, date, Digest, sql2ext, SitoolsDesk, loadUrl, sitools, showResponse, ColumnRendererEnum, document*/

// GLOBAL BEHAVIOUR
var DEFAULT_NATIVEJSON = false; //must be set to false to constrain Ext.doEncode (if true, doesn't work with prototype library)
var DEFAULT_TIMEOUT = 30000; // server request timeout (msec)
var DEFAULT_TIMEBUF = 10; // time to wait before sending request (msec)
var DEFAULT_NBRETRY = 0;// 3; // nb of request retries (if failure)
var SERVER_OK = 200;
var DEFAULT_WIN_HEIGHT = 400;
var DEFAULT_WIN_WIDTH = 600;
var DEFAULT_WINORDER_WIDTH = 400;
var DEFAULT_ORDER_FOLDER = "dataSelection";
var DEFAULT_PREFERENCES_FOLDER = "preferences";
var DEFAULT_LIVEGRID_BUFFER_SIZE = 300; 
var URL_CGU = "/sitools/res/licences/cgu.html";
var COOKIE_DURATION = 20;
var MULTIDS_TIME_DELAY = 2000;
var SITOOLS_DEFAULT_PROJECT_IMAGE_URL = "/sitools/res/images/sitools2_logo.png";
/**
 * The nearLimit is a
     * parameter for the predictive fetch algorithm within the view. If your
     * bufferSize is small, set this to a value around a third or a quarter of
     * the store's bufferSize (e.g. a value of 25 for a bufferSize of 100;
 */
var DEFAULT_NEAR_LIMIT_SIZE = 100;

Ext.BLANK_IMAGE_URL = '/sitools/cots/extjs/resources/images/default/s.gif';
Ext.USE_NATIVE_JSON  = DEFAULT_NATIVEJSON;
Ext.Ajax.timeout = DEFAULT_TIMEOUT;
var onBeforeRequest = function (conn, options) {
    var date = new Date();
    if (!Ext.isEmpty(Ext.util.Cookies.get('scheme'))) {
		if (Ext.util.Cookies.get('scheme') == "HTTP_Digest") {
			var tmp = null;
			var method = "GET";
			if (!Ext.isEmpty(options.method)) {
				method = options.method;
			}
			var url = options.url;
            if (Ext.isEmpty(options.url) && !Ext.isEmpty(options.scope)) {
                if (!Ext.isEmpty(options.scope.url)) {
                    url = options.scope.url;
                }
            }
			
			var A1 = Ext.util.Cookies.get("A1");
			var auth = new Digest({
				usr : Ext.util.Cookies.get("userLogin"),
				algorithm : Ext.util.Cookies.get("algorithm"),
				realm : Ext.util.Cookies.get("realm"),
				url : url,
				nonce : Ext.util.Cookies.get('nonce'), 
				method : method, 
				mode : "digest", 
				A1 : A1
			});
			Ext.apply(Ext.Ajax.defaultHeaders, {
				Authorization : auth.getDigestAuth()
		    });

		}
		else {
		    if (!Ext.isEmpty(Ext.util.Cookies.get('hashCode'))) {
		        Ext.util.Cookies.set('hashCode', Ext.util.Cookies.get('hashCode'), date.add(Date.MINUTE, COOKIE_DURATION));
		        Ext.apply(Ext.Ajax.defaultHeaders, {
					Authorization : Ext.util.Cookies.get('hashCode')
		        });
		    } else {
		        Ext.apply(Ext.Ajax.defaultHeaders, {
                    Authorization : ''
                });
		    }
		}
    }
    if (!Ext.isEmpty(Ext.util.Cookies.get('userLogin'))) {
        Ext.util.Cookies.set('userLogin', Ext.util.Cookies.get('userLogin'), date.add(Date.MINUTE, COOKIE_DURATION));
    }
};

Ext.Ajax.on('beforerequest', onBeforeRequest, this);

var DEFAULT_LOCALE = "en";
var SITOOLS_DATE_FORMAT = 'Y-m-d\\TH:i:s.u';
var SITOOLS_DEFAULT_IHM_DATE_FORMAT = 'Y-m-d H:i:s.u';

var locale = {
    locale : DEFAULT_LOCALE,
    isInit : false,
    getLocale : function () {
        if (!this.isInit) {
            if (Ext.isEmpty(Ext.util.Cookies.get('language'))) {
                var navigator = window.navigator;
                this.locale = navigator.language || navigator.browserLanguage || navigator.userLanguage;
            }
            else {
                this.locale = Ext.util.Cookies.get('language');
            }
            this.isInit = true;
        }
        return this.locale;                
        
    },
    setLocale : function (locale) {
        this.locale = locale;
    },
    restoreDefault : function () {
        this.setLocale(DEFAULT_LOCALE);
    }
};

var onRequestFeedException = function (proxy, type, action, options, response, args) {
    // si on a un cookie de session et une erreur 403
    if ((response.status == 403) && !Ext.isEmpty(Ext.util.Cookies.get('hashCode'))) {
        Ext.MessageBox.minWidth = 360;
        Ext.MessageBox.alert(i18n.get('label.session.expired'), response.responseText);
    } else {
        Ext.MessageBox.minWidth = 360;
        Ext.MessageBox.alert(i18n.get('label.error'), response.responseText);
    }
    return false;
};

// GLOBAL VARIABLES
var desktop;
var projectGlobal;
var projectId;

// Application d'exception sur tous les JsonStores :
// Ext.override (Ext.data.JsonStore, {
// listeners : {
// exception : function (dataProxy, type, action, options, response){
// Ext.Msg.alert (i18n.get('label.warning'), response.responseText);
// }
// }
// });

// GLOBAL FUNCTIONS
function alertFailure(response, opts) {
	var txt;
	if (response.status == SERVER_OK) {
		var ret = Ext.decode(response.responseText).message;
		txt = i18n.get('msg.error') + ': ' + ret;
	} else {
		txt = i18n.get('warning.serverError') + ': ' + response.statusText;
	}
	Ext.Msg.alert(i18n.get('label.warning'), txt);
// Ext.WindowMgr.bringToFront(alert);
}

function extColModelToJsonColModel(ExtColModel) {
	var colModel = [];
	var columns;
	if (!Ext.isEmpty(ExtColModel.columns)) {
		columns = ExtColModel.columns;
	}
	else {
		columns = ExtColModel;
	}
	Ext.each(columns, function (column) {
	    if (!column.isSelectionModel) {
            colModel.push({
                columnAlias : column.columnAlias,
                dataIndex : column.dataIndexSitools,
                dataIndexSitools : column.dataIndexSitools,
                header : column.header,
                filter : column.filter,
                hidden : column.hidden,
                id : column.id,
                previewColumn : column.previewColumn,
                primaryKey : column.primaryKey,
                schema : column.schema,
                sortable : column.sortable,
                sqlColumnType : column.sqlColumnType,
                tableAlias : column.tableAlias,
                tableName : column.tableName,
                toolTip : column.tooltip,
                urlColumn : column.urlColumn,
                width : column.width,
                // columnAliasDetail : column.columnAliasDetail,
                columnRenderer : column.columnRenderer,
                // datasetDetailId : column.datasetDetailId,
                specificColumnType : column.specificColumnType,
                javaSqlColumnType : column.javaSqlColumnType,
                format : column.format
            //			image : column.image,
            //			datasetDetailUrl : column.datasetDetailUrl

            });
        }
	});
	return colModel;
}

function extColModelToSrv(ExtColModel) {
	var colModel = [];
	var columns;
	if (!Ext.isEmpty(ExtColModel.columns)) {
		columns = ExtColModel.columns;
	}
	else {
		columns = ExtColModel;
	}
	Ext.each(columns, function (column) {
		if (!column.hidden && !column.isSelectionModel) {
			colModel.push(column.columnAlias);
		}
	});
	return colModel.join(", ");
}

function extColModelToStorage(ExtColModel) {
    var colModel = [];
    var columns;
    if (!Ext.isEmpty(ExtColModel.columns)) {
        columns = ExtColModel.columns;
    }
    else {
        columns = ExtColModel;
    }
    Ext.each(columns, function (column) {
        if (!column.hidden && !column.isSelectionModel) {
            colModel.push({
                columnAlias : column.columnAlias, 
                dataIndex : column.dataIndex, 
                dataIndexSitools : column.dataIndexSitools, 
                editor : column.editor, 
                filter : column.filter, 
                header : column.header, 
                hidden : column.hidden, 
                id : column.id, 
                isColumn : column.isColumn, 
                previewColumn : column.previewColumn, 
                primaryKey : column.primaryKey, 
                schema : column.schema, 
                sortable : column.sortable, 
                sqlColumnType : column.sqlColumnType, 
                tableAlias : column.tableAlias, 
                tableName : column.tableName, 
                toolTip : column.tooltip, 
                urlColumn : column.urlColumn, 
                width : column.width, 
//				columnAliasDetail : column.columnAliasDetail,
				columnRenderer : column.columnRenderer, 
//				datasetDetailId : column.datasetDetailId, 
				specificColumnType : column.specificColumnType, 
				javaSqlColumnType : column.javaSqlColumnType,
                unit : column.unit,
                format : column.format
//                image : column.image,
//                datasetDetailUrl : column.datasetDetailUrl
            });
        }
    });
    return colModel;
}
/**
 * Get the Sitools Desktop
 * @returns the sitools Desktop
 */
function getDesktop() {
	if (Ext.isEmpty(this.SitoolsDesk)) {
		return null;
	}
	else {
		return this.SitoolsDesk.app.desktop;
	}
}

/**
 * Get the Sitools Application
 * @returns the sitools Desktop
 */
function getApp() {
	if (Ext.isEmpty(SitoolsDesk)) {
		return null;
	}
	else {
		return SitoolsDesk.app;
	}
}

// Ext.WindowMgr = getDesktop().getManager();
// Override de la méthode initEvents pour que le windowManager utilisé soit
// toujours le même
Ext.override(Ext.Window, {
    initEvents : function () {
	    Ext.Window.superclass.initEvents.call(this);
	    if (this.animateTarget) {
	        this.setAnimateTarget(this.animateTarget);
	    }
	
	    if (this.resizable) {
	        this.resizer = new Ext.Resizable(this.el, {
	            minWidth: this.minWidth,
	            minHeight: this.minHeight,
	            handles: this.resizeHandles || 'all',
	            pinned: true,
	            resizeElement : this.resizerAction,
	            handleCls: 'x-window-handle'
	        });
	        this.resizer.window = this;
	        this.mon(this.resizer, 'beforeresize', this.beforeResize, this);
	    }
	
	    if (this.draggable) {
	        this.header.addClass('x-window-draggable');
	    }
	    this.mon(this.el, 'mousedown', this.toFront, this);
// this.manager = this.manager || Ext.WindowMgr;
	    var tmp = getDesktop();
	    if (Ext.isEmpty(tmp)) {
	        this.manager = Ext.WindowMgr;
	    }
	    else {
		    this.manager = getDesktop().getManager() || Ext.WindowMgr;
	    }
	    this.manager.register(this);
	    if (this.maximized) {
	        this.maximized = false;
	        this.maximize();
	    }
	    if (this.closable) {
	        var km = this.getKeyMap();
	        km.on(27, this.onEsc, this);
	        km.disable();
	    }
	}
});

Ext.override(Ext.grid.GridPanel, {
    stripeRows : true
});

Ext.data.Types.DATEASSTRING = {
	convert : function (v, data) {
		return v;
	}, 
	sortType : function (v) {
		return v;
	}, 
	type : "dateAsString"
	
};


function includeJs(url) {
	if (Ext.isEmpty(url)) {
		return;
	}
	var head = document.getElementsByTagName('head')[0];
	var script = document.createElement('script');
	script.setAttribute('src',	url);
	script.setAttribute('type', 'text/javascript');
	head.appendChild(script);
}

/**
 * Include JS scripts in the given order and trigger callback when all scripts are loaded  
 * @param ConfUrls {Array} the list of scripts to load
 * @param indexAInclure {int} the index during the iteration
 * @param callback {function} the callback
 * @param scope {Object} the scope of the callback
 */
function includeJsForceOrder(ConfUrls, indexAInclure, callback, scope) {
    //Test if all inclusions are done for this list of urls
    if (indexAInclure < ConfUrls.length) {
        var url = ConfUrls[indexAInclure].url;
        
        var trouve = false;
        var targetEl = "script";
        var targetAttr = "src";
        var scripts = document.getElementsByTagName(targetEl);
        var script;
        for (var i = scripts.length; i > 0; i--) {
            script = scripts[i - 1];
            if (script && script.getAttribute(targetAttr) !== null && script.getAttribute(targetAttr).indexOf(url) != -1) {
                trouve = true;
            }
        }
        if (!trouve) {
            // if not : include the Js Script
            var DSLScript = document.createElement("script");
            DSLScript.type = "text/javascript";
            DSLScript.onload = includeJsForceOrder.createDelegate(this, [ ConfUrls, indexAInclure + 1, callback, scope ]);
            DSLScript.onreadystatechange = includeJsForceOrder.createDelegate(this, [ ConfUrls, indexAInclure + 1, callback, scope ]);
            DSLScript.onerror = includeJsForceOrder.createDelegate(this, [ ConfUrls, indexAInclure + 1, callback, scope ]);
            DSLScript.src = url;

            var headID = document.getElementsByTagName('head')[0];
           headID.appendChild(DSLScript);           
        } else {
            includeJsForceOrder(ConfUrls, indexAInclure + 1, callback, scope);
        }
    } else {
        if (!Ext.isEmpty(callback)) {
            if (Ext.isEmpty(scope)) {
                callback.call();
            } else {
                callback.call(scope);
            }
        }
    }
}

function includeCss(url) {
	var headID = document.getElementsByTagName("head")[0];
	var newCss = document.createElement('link');
	newCss.type = 'text/css';
	newCss.rel = 'stylesheet';
	newCss.href = url;
	newCss.media = 'screen';
	// pas possible de monitorer l'evenement onload sur une balise link
	headID.appendChild(newCss);
}


Ext.override(Ext.PagingToolbar, {
    initComponent : function () {
        var T = Ext.Toolbar;
        var pagingItems = [this.first = new T.Button({
            tooltip: this.firstText,
            overflowText: this.firstText,
            iconCls: 'x-tbar-page-first',
            disabled: true,
            handler: this.moveFirst,
            scope: this
        }), this.prev = new T.Button({
            tooltip: this.prevText,
            overflowText: this.prevText,
            iconCls: 'x-tbar-page-prev',
            disabled: true,
            handler: this.movePrevious,
            scope: this
        }), '-', this.beforePageText,
        this.inputItem = new Ext.form.NumberField({
            cls: 'x-tbar-page-number',
            allowDecimals: false,
            allowNegative: false,
            enableKeyEvents: true,
            selectOnFocus: true,
            submitValue: false,
            listeners: {
                scope: this,
                keydown: this.onPagingKeyDown,
                blur: this.onPagingBlur
            }
        }), this.afterTextItem = new T.TextItem({
            text: String.format(this.afterPageText, 1)
        }), '-', this.next = new T.Button({
            tooltip: this.nextText,
            overflowText: this.nextText,
            iconCls: 'x-tbar-page-next',
            disabled: true,
            handler: this.moveNext,
            scope: this
        }), this.last = new T.Button({
            tooltip: this.lastText,
            overflowText: this.lastText,
            iconCls: 'x-tbar-page-last',
            disabled: true,
            handler: this.moveLast,
            scope: this
        }), '-'];


        var userItems = this.items || this.buttons || [];
        if (this.prependButtons) {
            this.items = userItems.concat(pagingItems);
        } else {
            this.items = pagingItems.concat(userItems);
        }
        delete this.buttons;
        if (this.displayInfo) {
            this.items.push('->');
            this.items.push(this.displayItem = new T.TextItem({}));
        }
        Ext.PagingToolbar.superclass.initComponent.call(this);
        this.addEvents(
            /**
             * @event change
             * Fires after the active page has been changed.
             * @param {Ext.PagingToolbar} this
             * @param {Object} pageData An object that has these properties:<ul>
             * <li><code>total</code> : Number <div class="sub-desc">The total number of records in the dataset as
             * returned by the server</div></li>
             * <li><code>activePage</code> : Number <div class="sub-desc">The current page number</div></li>
             * <li><code>pages</code> : Number <div class="sub-desc">The total number of pages (calculated from
             * the total number of records in the dataset as returned by the server and the current {@link #pageSize})</div></li>
             * </ul>
             */
            'change',
            /**
             * @event beforechange
             * Fires just before the active page is changed.
             * Return false to prevent the active page from being changed.
             * @param {Ext.PagingToolbar} this
             * @param {Object} params An object hash of the parameters which the PagingToolbar will send when
             * loading the required page. This will contain:<ul>
             * <li><code>start</code> : Number <div class="sub-desc">The starting row number for the next page of records to
             * be retrieved from the server</div></li>
             * <li><code>limit</code> : Number <div class="sub-desc">The number of records to be retrieved from the server</div></li>
             * </ul>
             * <p>(note: the names of the <b>start</b> and <b>limit</b> properties are determined
             * by the store's {@link Ext.data.Store#paramNames paramNames} property.)</p>
             * <p>Parameters may be added as required in the event handler.</p>
             */
            'beforechange'
        );
        this.on('afterlayout', this.onFirstLayout, this, {single: true});
        this.cursor = 0;
        this.bindStore(this.store, true);
    }, 
    onFirstLayout : function () {
        this.refresh = new Ext.Toolbar.Button({
            tooltip: i18n.get('label.refreshText'),
            overflowText: i18n.get('label.refreshText'),
            iconCls: 'x-tbar-loading',
            handler: this.doRefresh,
            scope: this
        });
        this.insert(10, this.refresh);
        if (this.dsLoaded) {
            this.onLoad.apply(this, this.dsLoaded);
        }
    }
});






/**
 * Build a {Ext.grid.ColumnModel} columnModel with a dataset informations
 * @param {Array} listeColonnes Array of dataset Columns
 * @param {Array} dictionnaryMappings Array of Dataset dictionnary mappings 
 * @param {Object} dataviewConfig the specific dataview Configuration.
 * @return {Ext.grid.ColumnModel} the builded columnModel
 */
function getColumnModel(listeColonnes, dictionnaryMappings, dataviewConfig, dataviewId) {
    var columns = [];
    if (!Ext.isEmpty(listeColonnes)) {
        Ext.each(listeColonnes, function (item, index, totalItems) {
            
            var tooltip = "";
            if (item.toolTip) {
                tooltip = item.toolTip;
            } else {
                if (Ext.isArray(dictionnaryMappings) && !Ext.isEmpty(dictionnaryMappings)) {
                    var dico = dictionnaryMappings[0];
                    var dicoMapping = dico.mapping || [];
                    dicoMapping.each(function (mapping) {
                        if (item.columnAlias == mapping.columnAlias) {
                            var concept = mapping.concept || {};
                            if (!Ext.isEmpty(concept.description)) {
                                tooltip += concept.description.replace('"', "''") + "<br>";
                            }
                        }
                    });
                }
            }
           
            var renderer = sitools.user.component.dataviews.dataviewUtils.getRendererLiveGrid(item, dataviewConfig, dataviewId);
            var hidden;
            if (Ext.isEmpty(item.visible)) {
                hidden = item.hidden;
            } else {
                hidden = !item.visible;
            }
            if (Ext.isEmpty(item.columnRenderer) ||  ColumnRendererEnum.NO_CLIENT_ACCESS != item.columnRenderer.behavior) {
	            columns.push(new Ext.grid.Column({
	                columnAlias : item.columnAlias,
	                dataIndexSitools : item.dataIndex,
	                dataIndex : item.columnAlias,
	                header : item.header,
	                width : item.width,
	                sortable : item.sortable,
	                hidden : hidden,
	                tooltip : tooltip,
	                renderer : renderer,
	                schema : item.schema,
	                tableName : item.tableName,
	                tableAlias : item.tableAlias,
	                id : item.id,
	                // urlColumn : item.urlColumn,
	                primaryKey : item.primaryKey,
	                previewColumn : item.previewColumn,
	                filter : item.filter,
	                sqlColumnType : item.sqlColumnType, 
//	                columnAliasDetail : item.columnAliasDetail,
					columnRenderer : item.columnRenderer, 
//					datasetDetailId : item.datasetDetailId, 
					specificColumnType : item.specificColumnType,
//	                image : item.image,
//	                datasetDetailUrl : item.datasetDetailUrl,
					menuDisabled : true,
	                format : item.format
	            }));
            }
            
        }, this);
    }

    var cm = new Ext.grid.ColumnModel({
        columns : columns
    });
    return cm;
}


//Date.formatFunctions['sitoolsGrid Y-m-d H:i:s'] = function () {
//	if (this.getHours() === 0 && this.getMinutes() === 0 && this.getSeconds() === 0) {
//		return this.format(BDD_DATE_FORMAT);
//	}
//	else {
//		return this.format(BDD_DATE_FORMAT_WITH_TIME);
//	}
//};


Ext.override(Ext.menu.DateMenu, {
    initComponent : function () {
        this.on('beforeshow', this.onBeforeShow, this);
        if (this.strict == (Ext.isIE7 && Ext.isStrict)) {
            this.on('show', this.onShow, this, {single: true, delay: 20});
        }
        Ext.apply(this, {
            plain: true,
            showSeparator: false,
            items: this.picker = new Ext.SitoolsDatePicker(Ext.applyIf({
                internalRender: this.strict || !Ext.isIE,
                ctCls: 'x-menu-date-item',
                id: this.pickerId
            }, this.initialConfig))
        });
        this.picker.purgeListeners();
        Ext.menu.DateMenu.superclass.initComponent.call(this);
        
        this.relayEvents(this.picker, ['select']);
        this.on('show', this.picker.focus, this.picker);
        this.on('select', this.menuHide, this);
        if (this.handler) {
            this.on('select', this.handler, this.scope || this);
        }
    }
});

Ext.override(Ext.form.DateField,  {
    
    showTime : false,
    
    onTriggerClick : function () {
        if (this.disabled) {
            return;
        }
        if (Ext.isEmpty(this.menu)) {
            this.menu = new Ext.menu.DateMenu({
                hideOnClick: false,
                showTime : this.showTime, 
                focusOnSelect: false
            });
        }
        this.onFocus();
        Ext.apply(this.menu.picker,  {
            minDate : this.minValue,
            maxDate : this.maxValue,
            disabledDatesRE : this.disabledDatesRE,
            disabledDatesText : this.disabledDatesText,
            disabledDays : this.disabledDays,
            disabledDaysText : this.disabledDaysText,
            format : this.format,
            showToday : this.showToday,
            minText : String.format(this.minText, this.formatDate(this.minValue)),
            maxText : String.format(this.maxText, this.formatDate(this.maxValue))
        });
        this.menu.picker.setValue(this.getValue() || new Date());
        this.menu.show(this.el, "tl-bl?");
        this.menuEvents('on');
    }
    
    
    
});
/**
 * Display the content of the file located at the given Url depending on its
 * content type
 * 
 * @param url
 *            the url of the file
 * @param title
 *            the title of the window to open
 */
function viewFileContent(url, title) {
  // build first request to get the headers
    Ext.Ajax.request({
        url : url,
        method : 'HEAD',
        scope : this,
        success : function (ret) {            
            try {
                var headerFile = ret.getResponseHeader("Content-Type").split(";")[0].split("/")[0];
                if (headerFile == "text" || ret.getResponseHeader("Content-Type").indexOf("application/json") >= 0) {
                    Ext.Ajax.request({
                        url : url,
                        method : 'GET',
                        scope : this,
                        success : function (ret) {
                            var windowConfig = {
                                id : "winPreferenceDetailId", 
                                title : title, 
                                iconCls : "version"
                            };
                            var jsObj = sitools.user.component.entete.userProfile.viewTextPanel;
                            var componentCfg = {
                                url : url,
                                text : ret.responseText,
                                formatJson : (ret.getResponseHeader("Content-Type").indexOf("application/json") >= 0)
						    };
                            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
                        }
                    });
                }
                else if (headerFile == "image") {
                    sitools.user.component.dataviews.dataviewUtils.showPreview(url, title);

                }
                else {
                    sitools.user.component.dataviews.dataviewUtils.downloadFile(url);
                }
            } catch (err) {
                Ext.Msg.alert(i18n.get('label.error'), err);
            }
        },
        failure : function (ret) {
            return null;
        }
    });
}

Ext.override(Ext.data.XmlReader, {
    buildExtractors : function () {
        if (this.ef) {
            return;
        }
        var s       = this.meta,
            Record  = this.recordType,
            f       = Record.prototype.fields,
            fi      = f.items,
            fl      = f.length;

        if (s.totalProperty) {
            this.getTotal = this.createAccessor(s.totalProperty);
        }
        if (s.successProperty) {
            this.getSuccess = this.createAccessor(s.successProperty);
        }
        if (s.messageProperty) {
            this.getMessage = this.createAccessor(s.messageProperty);
        }
        this.getRoot = function (res) {
            return (!Ext.isEmpty(res[this.meta.record])) ? res[this.meta.record] : res[this.meta.root];
        };
        if (s.idPath || s.idProperty) {
            var g = this.createAccessor(s.idPath || s.idProperty);
            this.getId = function (rec) {
                var id = g(rec) || rec.id;
                return (id === undefined || id === '') ? null : id;
            };
        } else {
            this.getId = function () {
                return null;
            };
        }
        var ef = [];
        for (var i = 0; i < fl; i++) {
            f = fi[i];
            var map = (f.mapping !== undefined && f.mapping !== null) ? f.mapping : f.name;
            if (f.createAccessor !== undefined && f.createAccessor !== null) {
				ef.push(f.createAccessor);
			}
			else {
				ef.push(this.createAccessor(map));
			}
        }
        this.ef = ef;
    }
});

Ext.override(Ext.layout.BorderLayout.Region, {
    getCollapsedEl : function () {
        if (!this.collapsedEl) {
            if (!this.toolTemplate) {
                var tt = new Ext.Template(
                     '<span class="x-panel-collapsed-text">{title}</span>', 
					 '<div class="x-tool x-tool-{id}">&#160;</div>'
                );
				
                tt.disableFormats = true;
                tt.compile();
                Ext.layout.BorderLayout.Region.prototype.toolTemplate = tt;
            }
            this.collapsedEl = this.targetEl.createChild({
                cls: "x-layout-collapsed x-layout-collapsed-" + this.position,
                id: this.panel.id + '-xcollapsed'
            });
			
            this.collapsedEl.enableDisplayMode('block');

            if (this.collapseMode == 'mini') {
                this.collapsedEl.addClass('x-layout-cmini-' + this.position);
                this.miniCollapsedEl = this.collapsedEl.createChild({
					cls : "x-layout-mini x-layout-mini-" + this.position, 
					html : "&#160;"
                });
                this.miniCollapsedEl.addClassOnOver('x-layout-mini-over');
                this.collapsedEl.addClassOnOver("x-layout-collapsed-over");
                this.collapsedEl.on('click', this.onExpandClick, this, {stopEvent : true});
            }
            else {
                if (this.collapsible !== false && !this.hideCollapseTool) {
                    var t = this.expandToolEl = this.toolTemplate.append(
                        this.collapsedEl.dom,
                        {
							id: 'expand-' + this.position, 
							title : this.panel.collapsedTitle
						}, true);
                    t.addClassOnOver('x-tool-expand-' + this.position + '-over');
                    t.on('click', this.onExpandClick, this, {
						stopEvent: true
                    });
                }
                if (this.floatable !== false || this.titleCollapse) {
					this.collapsedEl.addClassOnOver("x-layout-collapsed-over");
					this.collapsedEl.on("click", this[this.floatable ? 'collapseClick' : 'onExpandClick'], this);
                }
            }
        }
        return this.collapsedEl;
    }

});

Ext.ns("sitools.user");

/**
 * A méthod call when click on dataset Icon. Request the dataset, and open a window depending on type
 * 
 * @static
 * @param {string} url the url to request the dataset
 * @param {string} type the type of the component.
 * @param {} extraCmpConfig an extra config to apply to the component.
 */
sitools.user.clickDatasetIcone = function (url, type, extraCmpConfig) {
	Ext.Ajax.request({
		method : "GET", 
		url : url, 
		success : function (ret) {
            var Json = Ext.decode(ret.responseText);
            if (showResponse(ret)) {
                var dataset = Json.dataset;
	            var componentCfg, javascriptObject;
	            var windowConfig = {
	                datasetName : dataset.name, 
	                type : type, 
	                saveToolbar : true, 
	                toolbarItems : []
	            };
                switch (type) {
				case "desc" : 
					Ext.apply(windowConfig, {
						title : i18n.get('label.description') + " : " + dataset.name, 
						id : "desc" + dataset.id, 
						saveToolbar : false, 
						iconCls : "version"
					});
					
					componentCfg = {
						autoScroll : true,
						html : dataset.descriptionHTML
					};
					Ext.applyIf(componentCfg, extraCmpConfig);
					javascriptObject = Ext.Panel;
					SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);
					
					break;
				case "data" : 
                    javascriptObject = eval(SitoolsDesk.navProfile.getDatasetOpenMode(dataset));
                
	                Ext.apply(windowConfig, {
	                    winWidth : 900, 
	                    winHeight : 400,
                        title : i18n.get('label.dataTitle') + " : " + dataset.name, 
                        id : type + dataset.id, 
                        iconCls : "dataviews"
	                });
                    
	                componentCfg = {
	                    dataUrl : dataset.sitoolsAttachementForUsers,
	                    datasetId : dataset.Id,
	                    datasetCm : dataset.columnModel, 
	                    datasetName : dataset.name,
	                    dictionaryMappings : dataset.dictionaryMappings,
	                    datasetViewConfig : dataset.datasetViewConfig, 
	                    preferencesPath : "/" + dataset.datasetName, 
	                    preferencesFileName : "datasetOverview", 
	                    sitoolsAttachementForUsers : dataset.sitoolsAttachementForUsers
	                };
                
                
	                Ext.applyIf(componentCfg, extraCmpConfig);
					SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);

					break;
				case "forms" : 
		            var menuForms = new Ext.menu.Menu();
		            Ext.Ajax.request({
						method : "GET", 
						url : dataset.sitoolsAttachementForUsers + "/forms", 
						success : function (ret) {
							try {
								var Json = Ext.decode(ret.responseText);
								if (! Json.success) {
									throw Json.message;
								}
								if (Json.total === 0) {
									throw i18n.get('label.noForms');
								}
				                javascriptObject = sitools.user.component.forms.mainContainer;
								if (Json.total == 1) {
						            var form = Json.data[0];
						            Ext.apply(windowConfig, {
						                title : i18n.get('label.forms') + " : " + dataset.name + "." + form.name, 
						                iconCls : "forms"
						            });
						            
						
					                Ext.apply(windowConfig, {
					                    id : type + dataset.id + form.id
					                });
					                componentCfg = {
					                    dataUrl : dataset.sitoolsAttachementForUsers,
					                    dataset : dataset, 
					                    formId : form.id,
					                    formName : form.name,
					                    formParameters : form.parameters,
					                    formZones : form.zones,
					                    formWidth : form.width,
					                    formHeight : form.height, 
					                    formCss : form.css, 
				                        preferencesPath : "/" + dataset.name + "/forms", 
				                        preferencesFileName : form.name
					                };
					                Ext.applyIf(componentCfg, extraCmpConfig);
									SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);

				                }
								else {
									
									var handler = null;
									Ext.each(Json.data, function (form) {
										handler = function (form, dataset) {
											Ext.apply(windowConfig, {
												title : i18n.get('label.forms') + " : " + dataset.name + "." + form.name, 
												iconCls : "forms"
								            });
								
							                Ext.apply(windowConfig, {
							                    id : type + dataset.id + form.id
							                });
							                componentCfg = {
							                    dataUrl : dataset.sitoolsAttachementForUsers,
							                    formId : form.id,
							                    formName : form.name,
							                    formParameters : form.parameters,
							                    formWidth : form.width,
							                    formHeight : form.height, 
							                    formCss : form.css, 
							                    dataset : dataset
							                };
							                Ext.applyIf(componentCfg, extraCmpConfig);
											SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);
										};
										menuForms.addItem({
											text : form.name, 
											handler : function () {
												handler(form, dataset);
											}, 
											icon : loadUrl.get('APP_URL') + "/common/res/images/icons/tree_forms.png"
										});
						                
									}, this);
									menuForms.showAt(Ext.EventObject.xy);
								}
					            
				
								
							}
							catch (err) {
								var tmp = new Ext.ux.Notification({
						            iconCls : 'x-icon-information',
						            title : i18n.get('label.information'),
						            html : i18n.get(err),
						            autoDestroy : true,
						            hideDelay : 1000
						        }).show(document);
							}
						}
		            });

					break;
				case "feeds" : 
		            var menuFeeds = new Ext.menu.Menu();
		            Ext.Ajax.request({
						method : "GET", 
						url : dataset.sitoolsAttachementForUsers + "/feeds", 
						success : function (ret) {
							try {
								var Json = Ext.decode(ret.responseText);
								if (! Json.success) {
									throw Json.message;
								}
								if (Json.total === 0) {
									throw i18n.get('label.noFeeds');
								}
				                javascriptObject = sitools.widget.FeedGridFlux;
								if (Json.total == 1) {
						            var feed = Json.data[0];
						            Ext.apply(windowConfig, {
						                title : i18n.get('label.feeds') + " : (" + dataset.name + ") " + feed.title, 
						                id : type + dataset.id + feed.id, 
						                iconCls : "feedsModule"
						            });
						
					                componentCfg = {
					                    datasetId : dataset.id,
					                    urlFeed : dataset.sitoolsAttachementForUsers + "/clientFeeds/" + feed.name,
					                    feedType : feed.feedType, 
					                    datasetName : dataset.name,
					                    feedSource : feed.feedSource,
					                    autoLoad : true
					                };
						            Ext.applyIf(componentCfg, extraCmpConfig);
									SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);

				                }
								else {
									var handler = null;
									Ext.each(Json.data, function (feed) {
										handler = function (feed, dataset) {
											Ext.apply(windowConfig, {
												title : i18n.get('label.feeds') + " : (" + dataset.name + ") " + feed.title, 
												id : type + dataset.id + feed.id, 
												iconCls : "feedsModule"
								            });
								
							                
							                componentCfg = {
							                    datasetId : dataset.id,
							                    urlFeed : dataset.sitoolsAttachementForUsers + "/clientFeeds/" + feed.name,
							                    feedType : feed.feedType, 
							                    datasetName : dataset.name,
							                    feedSource : feed.feedSource,
							                    autoLoad : true
							                };
							                Ext.applyIf(componentCfg, extraCmpConfig);
											SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);
										};
										menuFeeds.addItem({
											text : feed.name, 
											handler : function () {
												handler(feed, dataset);
											}, 
											icon : loadUrl.get('APP_URL') + "/common/res/images/icons/rss.png"
										});
						                
									}, this);
									menuFeeds.showAt(Ext.EventObject.xy);
								}
					            
				
								
							}
							catch (err) {
								var tmp = new Ext.ux.Notification({
						            iconCls : 'x-icon-information',
						            title : i18n.get('label.information'),
						            html : i18n.get(err),
						            autoDestroy : true,
						            hideDelay : 1000
						        }).show(document);
							}
						}
		            });

					break;
				case "defi" : 
		            Ext.apply(windowConfig, {
		                title : i18n.get('label.definitionTitle') + " : " + dataset.name, 
		                id : type + dataset.id, 
		                iconCls : "semantic"
		            });
		
	                javascriptObject = sitools.user.component.columnsDefinition;
	                
	                componentCfg = {
	                    datasetId : dataset.id,
	                    datasetCm : dataset.columnModel, 
	                    datasetName : dataset.name,
                        dictionaryMappings : dataset.dictionaryMappings, 
                        preferencesPath : "/" + dataset.name, 
                        preferencesFileName : "semantic"
	                };
	                Ext.applyIf(componentCfg, extraCmpConfig);
					SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);

					break;
				case "openSearch" : 
		            Ext.Ajax.request({
						method : "GET", 
						url : dataset.sitoolsAttachementForUsers + "/opensearch.xml", 
						success : function (ret) {
                            var xml = ret.responseXML;
                            var dq = Ext.DomQuery;
                            // check if there is a success node
                            // in the xml
                            var success = dq.selectNode('OpenSearchDescription ', xml);
							if (!success) {
								var tmp = new Ext.ux.Notification({
						            iconCls : 'x-icon-information',
						            title : i18n.get('label.information'),
						            html : i18n.get("label.noOpenSearch"),
						            autoDestroy : true,
						            hideDelay : 1000
						        }).show(document);
								return;
							}
							
							Ext.apply(windowConfig, {
				                title : i18n.get('label.opensearch') + " : " + dataset.name, 
				                id : type + dataset.id, 
				                iconCls : "openSearch"
				            });
				
			                javascriptObject = sitools.user.component.datasetOpensearch;
			                
			                componentCfg = {
			                    datasetId : dataset.id,
			                    dataUrl : dataset.sitoolsAttachementForUsers, 
			                    datasetName : dataset.name, 
		                        preferencesPath : "/" + dataset.name, 
		                        preferencesFileName : "openSearch"
			                };
			                Ext.applyIf(componentCfg, extraCmpConfig);
							SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);
                            
                        }
		            });

					break;
				}
            }
		}, 
		failure : alertFailure
	});
};

/**
 * Add a tooltip on every form field: tooltip could be an object like tooltip : {
 * text : string width : number }, or a simple string
 */
Ext.override(Ext.form.Field, {
	tooltip : null, 
	listeners : {
		render: function () {
			Ext.form.Field.superclass.render.apply(this, arguments);
			
			if (!Ext.isEmpty(this.tooltip)) {
				var ttConfig = {};
				if (Ext.isString(this.tooltip)) {
					ttConfig = {
						html : this.tooltip, 
						width : 200, 
						dismissDelay : 5000
					};
				} 
				else if (Ext.isObject(this.tooltip)) {
                    ttConfig = this.tooltip;
                } else {
                    return;
                }
                Ext.apply(ttConfig, {
                    target : this.el
                });
				this.tTip = new Ext.ToolTip(ttConfig);
			}
		}
	}
});

/**
 * Add a tooltip on every boxcomponent : tooltip could be an object like tooltip : {
 * text : string width : number }, or a simple string
 */
Ext.override(Ext.BoxComponent, {
    tooltip : null, 
    listeners : {
        render: function () {
            Ext.BoxComponent.superclass.render.apply(this, arguments);
            
            if (!Ext.isEmpty(this.tooltip)) {
                var ttConfig = {};
                if (Ext.isString(this.tooltip)) {
                    ttConfig = {
                        html : this.tooltip, 
                        width : 200, 
                        dismissDelay : 5000
                    };
                } 
                else if (Ext.isObject(this.tooltip)) {
                    ttConfig = this.tooltip;
                } else {
                    return;
                }
                Ext.apply(ttConfig, {
                    target : this.el
                });
                this.tTip = new Ext.ToolTip(ttConfig);
            }
        }
    }
});

/**
 * Add a tooltip on every boxcomponent : tooltip could be an object like tooltip : {
 * text : string width : number }, or a simple string
 */
Ext.override(Ext.Button, {
    setTooltip : function() {
		return;
	}
});

/**
 * Get the folder name to store the cart file name depending on the project name
 * @param projectName the project name
 * @returns {String} the folder name to store the cart file
 */
function getCartFolder (projectName) {
    return "/" + DEFAULT_ORDER_FOLDER + "/cart/" + projectName;
}

Ext.override(Ext.Window, {
    /**
     * Fit a window to its container (desktop)
     * Resizing and repositionning
     */
    fitToDesktop : function () {
        //resize windows to fit desktop
        var vs = this.container.getViewSize(false);
        var winSize = this.getSize();
        var winPos = this.getPosition()
        
        var outputWinSize = winSize;
        var outputWinPos = winPos;
        
        
        if(winSize.width > vs.width) {
            outputWinSize.width = vs.width - 5;
        }

        if(winSize.height > vs.height) {
            outputWinSize.height = vs.height - 5;
        }
        this.setSize(outputWinSize.width, outputWinSize.height);
        
        
        if(winPos[0] + outputWinSize.width > vs.width) {
            outputWinPos.x = 0;
        }

        if(winPos[1] + outputWinSize.height > vs.height) {
            outputWinPos.y = 0;
        }
        this.setPosition(outputWinPos.x, outputWinPos.y);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */

/*global Ext, i18n, locale:true, sitools, loadUrl, userLogin, DEFAULT_PREFERENCES_FOLDER*/
/*
 * @include "../../client-public/js/siteMap.js"
 * @include "portal/portal.js"
 */

// Sample desktop configuration
function initAppliDesktop() {
    return;
}

var portal;

var portalApp = {
    projects : null,
    languages : null,
    preferences : null,
	//callbacks : [this.callSiteMapResource, this.initProjects, this.initLanguages, this.initPreferences]
    autoChainAjaxRequest : true,
    initProjects : function (callback) {
        Ext.Ajax.request({
            scope : this,
            /* sitools/portal/projects...*/
            url : loadUrl.get('APP_URL') + loadUrl.get('APP_PORTAL_URL') + '/projects?media=json', 
//            url : '/sitools/portal/projects?media=json', 
            method : 'GET',
            success : function (response) {
                try {
                    this.projects = Ext.decode(response.responseText).data;
                    if (this.autoChainAjaxRequest) {
						this.initLanguages();
                    }
                } catch (err) {
                    Ext.Msg.alert(i18n.get('label.error'), err);
                }

                // portal = new sitools.Portal(response.responseJSON.data);
            },
            failure : function (response) {
                Ext.Msg.alert('Status', i18n.get('warning.serverError'));
            }
        });
    },
    initLanguages : function () {
        Ext.Ajax.request({
            scope : this,
            method : "GET",
            /* /sitools/client-user */
//            url : loadUrl.get('APP_URL') + loadUrl.get('APP_CLIENT_USER_URL') + '/tmp/langues.json',
            url : loadUrl.get('APP_URL') + '/client-user/tmp/langues.json',
            success : function (response) {
                this.languages = Ext.decode(response.responseText).data;
                if (this.autoChainAjaxRequest) {
					this.initPreferences();
                }
            },
            failure : function (response) {
                Ext.Msg.alert('Status', i18n.get('warfning.serverError'));
            }
        });
    },
    initPreferences : function (cb) {
        if (Ext.isEmpty(userLogin)) {
            var projects = this.projects;
            var languages = this.languages;
            var preferences = this.preferences;
            var callback;
            if (this.autoChainAjaxRequest) {
				callback = function () {
	                // loadUrl.load('/sitools/client-user/siteMap', function (){
	                portal = new sitools.Portal(projects, languages, preferences);
	                // });
	            };
            }
            else {
				callback = cb;
            }
            i18n.load(loadUrl.get('APP_URL') + '/res/i18n/' + locale.getLocale() + '/gui.properties', callback);
            return;
        }
        var filePath = "/" + DEFAULT_PREFERENCES_FOLDER + '/portal';
        var success = function (response) {
            this.preferences = Ext.decode(response.responseText);
            if (!Ext.isEmpty(this.preferences.language)) {
                locale.setLocale(this.preferences.language);
            }

        };
        var failure = function () {
        	return;
        };
        var callback = function () {
            var projects = this.projects;
            var languages = this.languages;
            var preferences = this.preferences;
            i18n.load(loadUrl.get('APP_URL') + '/res/i18n/' + locale.getLocale() + '/gui.properties', function () {
                // loadUrl.load('/sitools/client-user/siteMap', function (){
                portal = new sitools.Portal(projects, languages, preferences);
                // });
            });
        };
        
        userStorage.get("portal", filePath, this, success, failure, callback);
        
    },
    initAppliPortal : function (opts, callback) {
        if (!Ext.isEmpty(Ext.util.Cookies.get('userLogin'))) {
            var auth = Ext.util.Cookies.get('hashCode');
            Ext.Ajax.defaultHeaders = {
                "Authorization" : auth,
                "Accept" : "application/json",
                "X-User-Agent" : "Sitools"
            };
        } else {
            Ext.Ajax.defaultHeaders = {
                "Accept" : "application/json",
                "X-User-Agent" : "Sitools"
            };
        }
        Ext.QuickTips.init();
//        this.callbacks[0](opts.siteMapRes, callback);
        this.callSiteMapResource(opts.siteMapRes, callback);
        //this.initProjects();
    },
    
    callSiteMapResource : function (res, cb) {
        var callback;
        if (this.autoChainAjaxRequest) {
			callback = this.initProjects;
        } else {
			callback = cb;
        } 
        loadUrl.load(res + '/siteMap', callback, this);
    }
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
var ID = {
    PANEL : {
        MENU : 'menuPanelId',
        TREE : 'treePanelId',
        MAIN : 'mainPanelId',
        HELP : 'helpPanelId'
    },
    CMP : {
        TOOLBAR : 'toolbarId',
        MENU : 'menuId'
    },
    WIN : {
        LOGIN : 'loginWinId',
        ORDER : 'orderWinId'
    },
    BOX : {
        REG : 'regBoxId',
        USER : 'userBoxId',
        GROUP : 'groupBoxId',
        FIREWALL : 'firewallBoxId'
    },
    PORTLET : {
        PROJET : 'portletProjectId',
        RECHERCHE : 'portletRecherceID',
        FEEDS : 'portletFeedsId'
    },
    PORTALTREENAV : {
        PROJET : 'navProjectId',
        RECHERCHE : 'navRechercheId',
        FEEDS : 'navFeedsId'

    }
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/

/**
 * Object to expose common tree Utils Methods
 * @requires sitools.user.component.datasetOpensearch
 * @requires sitools.user.component.forms.mainContainer
 */
/*global Ext, i18n, loadUrl, getDesktop, sitools, SitoolsDesk */
var commonTreeUtils = {
    addShowData : function (node, dataset) {
        node.appendChild({
            id : "nodedata" + dataset.id,
            text : i18n.get('label.dataTitle'),
            winTitle : i18n.get('label.dataTitle') + " : " + dataset.name,
            leaf : true,
            type : "data",
            datasetId : dataset.id,
            columnModel : dataset.columnModel,
            datasetName : dataset.name,
            datasetDescription : dataset.description,
            dataUrl : dataset.sitoolsAttachementForUsers, 
            dictionaryMappings : dataset.dictionaryMappings,
            icon : loadUrl.get('APP_URL') + "/common/res/images/icons/tree_datasets.png", 
            datasetView : dataset.datasetView, 
            datasetViewConfig : dataset.datasetViewConfig, 
            sitoolsAttachementForUsers : dataset.sitoolsAttachementForUsers
        });
        
    },

    addShowDefinition : function (node, dataset) {
        node.appendChild({
            text : i18n.get('label.definitionTitle'),
            winTitle : i18n.get('label.definitionTitle') + " : " + dataset.name,
            leaf : true,
            type : "defi",
            datasetId : dataset.id,
            columnModel : dataset.columnModel,
            datasetName : dataset.name, 
            dictionaryMappings : dataset.dictionaryMappings,
            icon : loadUrl.get('APP_URL') + "/common/res/images/icons/tree_dictionary.png"
        });
    },

    addOpensearch : function (node, dataset) {
        node.appendChild({
            text : i18n.get('label.opensearch'),
            winTitle : i18n.get('label.opensearch') + " : " + dataset.name,
            leaf : true,
            type : "openSearch",
            datasetId : dataset.id,
            columnModel : dataset.columnModel,
            datasetName : dataset.name,
            dataUrl : dataset.sitoolsAttachementForUsers, 
            icon : loadUrl.get('APP_URL') + "/common/res/images/icons/toolbar_open_search.png"
        });
    },

    addForm : function (node, dataset) {
        node.appendChild({
            text : i18n.get('label.forms'),
            leaf : false,
            children : [ {
                leaf : true
            } ],
            datasetId : dataset.id,
            columnModel : dataset.columnModel,
            datasetName : dataset.name,
            listeners : {
                scope : this,
                beforeexpand : function (node) {
                    var conn = new Ext.data.Connection();
                    conn.request({
                        url : dataset.sitoolsAttachementForUsers + '/forms?media=json',
                        success : function (response) {
                            node.removeAll(true);
                            var forms = Ext.decode(response.responseText);
                            if (!forms.success) {
                                Ext.msg.alert(i18n.get('label.warning'), forms.message);
                                return;
                            }
                            Ext.each(forms.data, function (form) {
                                node.appendChild({
                                    leaf : true,
                                    winTitle : i18n.get('label.forms') + " : " + dataset.name + "." + form.name,
                                    dataset : dataset, 
                                    datasetId : dataset.id,
                                    columnModel : dataset.columnModel,
                                    datasetName : dataset.name,
                                    dataUrl : dataset.sitoolsAttachementForUsers,
                                    type : "form",
                                    text : form.name,
                                    formId : form.id,
                                    formName : form.name,
                                    formParameters : form.parameters,
                                    formZones : form.zones,
                                    formWidth : form.width,
                                    formHeight : form.height,
                                    formCss : form.css, 
                                    node : this, 
                                    icon : loadUrl.get('APP_URL') + "/common/res/images/icons/tree_forms.png", 
                                    datasetView : dataset.datasetView

                                });
                            });

                        }
                    });
                }
            }
        });
    },

    addFeeds : function (node, dataset) {
        node.appendChild({
            text : i18n.get('label.feeds'),
            leaf : false,
            children : [ {
                leaf : true
            } ],
            datasetId : dataset.id,
            datasetName : dataset.name,
            listeners : {
                scope : this,
                beforeexpand : function (node) {
                    var conn = new Ext.data.Connection();
                    conn.request({
                        url : dataset.sitoolsAttachementForUsers + '/feeds?media=json',
                        success : function (response) {
                            node.removeAll(true);
                            var feeds = Ext.decode(response.responseText);
                            if (!feeds.success) {
                                Ext.msg.alert(i18n.get('label.warning'), feeds.message);
                                return;
                            }
                            Ext.each(feeds.data, function (feed) {
                                node.appendChild({
                                    leaf : true,
                                    winTitle : i18n.get('label.feeds') + " : (" + dataset.name + ") " + feed.title,
                                    type : "feeds",
                                    text : feed.name,
                                    datasetId : dataset.id,
                                    feedId : feed.name,
                                    dataUrl : dataset.sitoolsAttachementForUsers,
                                    feedType : feed.feedType,
                                    feedSource : feed.feedSource,
                                    datasetName : dataset.name, 
                                    icon : loadUrl.get('APP_URL') + "/common/res/images/icons/rss.png"
                                    
                                });
                            });

                        }
                    });
                }
            }
        });
    },

    /**
     * Build the component regarding to the node, 
     * Load a window with this component into the SitoolsDesk
     * @param node
     */
    treeAction : function (node) {
        var desktop = getDesktop();
        var win = desktop.getWindow("wind" + node.id);

        if (!win) {
            var componentCfg, javascriptObject;
            var windowConfig = {
				datasetId : node.attributes.datasetId,
				title : node.attributes.winTitle, 
                datasetName : node.attributes.datasetName, 
                datasetDescription : node.attributes.datasetDescription,
                type : node.attributes.type, 
                saveToolbar : true, 
                toolbarItems : []
            };

            if (node.attributes.type === "data") {
                //open the dataView according to the dataset Configuration.
//                javascriptObject = eval(node.attributes.datasetView.jsObject);
				javascriptObject = eval(SitoolsDesk.navProfile.getDatasetOpenMode(node.attributes));
				
				Ext.apply(windowConfig, {
					winWidth : 900, 
					winHeight : 400, 
					iconCls : "dataviews"
				});
                componentCfg = {
                    dataUrl : node.attributes.dataUrl,
                    datasetId : node.attributes.datasetId,
                    datasetCm : node.attributes.columnModel, 
                    datasetName : node.attributes.datasetName,
                    dictionaryMappings : node.attributes.dictionaryMappings,
                    datasetViewConfig : node.attributes.datasetViewConfig, 
                    preferencesPath : "/" + node.attributes.datasetName, 
                    preferencesFileName : "datasetOverview", 
                    sitoolsAttachementForUsers : node.attributes.sitoolsAttachementForUsers
                };
                
            }
            if (node.attributes.type === "defi") {
                javascriptObject = sitools.user.component.columnsDefinition;
                Ext.apply(windowConfig, {
                    id : node.attributes.type + node.attributes.datasetId, 
					iconCls : "semantic"
                });
                componentCfg = {
                    datasetId : node.attributes.datasetId,
                    datasetCm : node.attributes.columnModel, 
                    datasetName : node.attributes.datasetName,
                    dictionaryMappings : node.attributes.dictionaryMappings, 
                    preferencesPath : "/" + node.attributes.datasetName, 
                    preferencesFileName : "semantic"
                };
            }
            if (node.attributes.type === "openSearch") {
                javascriptObject = sitools.user.component.datasetOpensearch;
                Ext.apply(windowConfig, {
                    id : node.attributes.type + node.attributes.datasetId, 
					iconCls : "openSearch"
                });
                componentCfg = {
                    datasetId : node.attributes.datasetId,
                    dataUrl : node.attributes.dataUrl, 
                    datasetName : node.attributes.datasetName, 
                    preferencesPath : "/" + node.attributes.datasetName, 
                    preferencesFileName : "openSearch"
                };
            }
            if (node.attributes.type === "form") {
                javascriptObject = sitools.user.component.forms.mainContainer;
                Ext.apply(windowConfig, {
                    id : node.attributes.type + node.attributes.datasetId + node.attributes.formId, 
					iconCls : "forms"
                });
                componentCfg = {
                    dataUrl : node.attributes.dataUrl,
                    dataset : node.attributes.dataset, 
                    formId : node.attributes.formId,
                    formName : node.attributes.formName,
                    formParameters : node.attributes.formParameters,
                    formZones : node.attributes.formZones,
                    formWidth : node.attributes.formWidth,
                    formHeight : node.attributes.formHeight, 
                    formCss : node.attributes.formCss, 
                    preferencesPath : "/" + node.attributes.datasetName + "/forms", 
                    preferencesFileName : node.attributes.formName
                };
            }
            if (node.attributes.type === "feeds") {
                javascriptObject = sitools.widget.FeedGridFlux;
                var url = node.attributes.dataUrl + "/clientFeeds/" + node.attributes.feedId;
                Ext.apply(windowConfig, {
                    id : node.attributes.type + node.attributes.datasetId + node.attributes.feedId, 
                    iconCls : "feedsModule"
                });
                componentCfg = {
                    datasetId : node.attributes.datasetId,
                    urlFeed : url,
                    feedType : node.attributes.feedType, 
                    datasetName : node.attributes.datasetName,
                    feedSource : node.attributes.feedSource,
                    autoLoad : true
                };

            }
            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);

        } else {
            win.toFront();
        }
    }
};/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document*/
/*!
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/**
 * <p>SAMPLE USAGE:</p>
 * 
 * <pre><code>
this.startMenu = new Ext.ux.StartMenu({ iconCls: 'user', height: 300, shadow: true, title: get_cookie('memberName'), width: 300 });

this.startMenu.add({ text: 'Grid Window', iconCls:'icon-grid', handler :
this.createWindow, scope: this });
 
this.startMenu.addTool({ 
	text:'Logout', 
	iconCls:'logout', 
	handler:function(){
		window.location = "logout.php"; 
	}, 
	scope:this 
});
 * </code></pre>
 * @class Ext.ux.StartMenu
 * @extends Ext.menu.Menu A start menu object.
 * @constructor Creates a new StartMenu
 * @cfg {Object}
 *            config Configuration options
 * 
 * 
 */

Ext.namespace("Ext.ux");

Ext.ux.StartMenu = Ext.extend(Ext.menu.Menu, {
    initComponent : function (config) {
	    Ext.ux.StartMenu.superclass.initComponent.call(this, config);

	    var tools = this.toolItems;
	    this.toolItems = new Ext.util.MixedCollection();
	    if (tools) {
		    this.addTool.apply(this, tools);
	    }
    },

    // private
    onRender : function (ct, position) {
	    Ext.ux.StartMenu.superclass.onRender.call(this, ct, position);
	    var el = this.el.addClass('ux-start-menu');

	    var header = el.createChild({
	        tag : "div",
	        cls : "x-window-header x-unselectable x-panel-icon " + this.iconCls
	    });

	    this.header = header;

	    var headerText = header.createChild({
	        tag : "span",
	        cls : "x-window-header-text"
	    });
	    var tl = header.wrap({
		    cls : "ux-start-menu-tl"
	    });
	    var tr = header.wrap({
		    cls : "ux-start-menu-tr"
	    });
	    var tc = header.wrap({
		    cls : "ux-start-menu-tc"
	    });

	    this.menuBWrap = el.createChild({
	        tag : "div",
	        cls : "x-window-body x-border-layout-ct ux-start-menu-body"
	    });
	    var ml = this.menuBWrap.wrap({
		    cls : "ux-start-menu-ml"
	    });
	    var mc = this.menuBWrap.wrap({
		    cls : "x-window-mc ux-start-menu-bwrap"
	    });

	    this.menuPanel = this.menuBWrap.createChild({
	        tag : "div",
	        cls : "x-panel x-border-panel ux-start-menu-apps-panel"
	    });
	    this.toolsPanel = this.menuBWrap.createChild({
	        tag : "div",
	        cls : "x-panel x-border-panel ux-start-menu-tools-panel"
	    });

	    var bwrap = ml.wrap({
		    cls : "x-window-bwrap"
	    });
	    var bc = bwrap.createChild({
	        tag : "div",
	        cls : "ux-start-menu-bc"
	    });
	    var bl = bc.wrap({
		    cls : "ux-start-menu-bl x-panel-nofooter"
	    });
	    var br = bc.wrap({
		    cls : "ux-start-menu-br"
	    });

	    this.ul.appendTo(this.menuPanel);

	    var toolsUl = this.toolsPanel.createChild({
	        tag : "ul",
	        cls : "x-menu-list"
	    });

	    this.mon(toolsUl, 'click', this.onClick, this);
	    this.mon(toolsUl, 'mouseover', this.onMouseOver, this);
	    this.mon(toolsUl, 'mouseout', this.onMouseOut, this);

	    if (this.item) {
		    this.items.each(function (item) {
			    item.parentMenu = this;
		    }, this);
	    }
	    this.toolItems.each(function (item) {
		    if (!Ext.isEmpty(item.text)) {
			    item.text = i18n.get(item.text);
		    }
		    var li = document.createElement("li");
		    li.className = "x-menu-list-item";
		    toolsUl.dom.appendChild(li);
		    item.render(li);
		    item.parentMenu = this;
	    }, this);

	    this.toolsUl = toolsUl;

	    this.menuBWrap.setStyle('position', 'relative');
	    this.menuBWrap.setHeight(this.height - 28);

	    this.menuPanel.setStyle({
	        padding : '2px',
	        position : 'absolute',
	        overflow : 'auto'
	    });

	    this.toolsPanel.setStyle({
	        padding : '2px 4px 2px 2px',
	        position : 'absolute',
	        overflow : 'auto'
	    });

	    this.setTitle(this.title);
    },

    // private
    findTargetItem : function (e) {
	    var t = e.getTarget(".x-menu-list-item", this.ul, true);
	    if (t && t.menuItemId) {
		    if (this.items.get(t.menuItemId)) {
			    return this.items.get(t.menuItemId);
		    } else {
			    return this.toolItems.get(t.menuItemId);
		    }
	    }
    },

    /**
	 * Displays this menu relative to another element
	 * 
	 * @param {Mixed}
	 *            element The element to align to
	 * @param {String}
	 *            position (optional) The {@link Ext.Element#alignTo} anchor
	 *            position to use in aligning to the element (defaults to
	 *            this.defaultAlign)
	 * @param {Ext.ux.StartMenu}
	 *            parentMenu (optional) This menu's parent menu, if applicable
	 *            (defaults to undefined)
	 */
    show : function (el, pos, parentMenu) {
	    this.parentMenu = parentMenu;
	    if (!this.el) {
		    this.render();
	    }

	    this.fireEvent("beforeshow", this);
	    this.showAt(this.el.getAlignToXY(el, pos || this.defaultAlign), parentMenu, false);
	    var tPanelWidth = 100;
	    var box = this.menuBWrap.getBox();
	    this.menuPanel.setWidth(box.width - tPanelWidth);
	    this.menuPanel.setHeight(box.height);

	    this.toolsPanel.setWidth(tPanelWidth);
	    this.toolsPanel.setX(box.x + box.width - tPanelWidth);
	    this.toolsPanel.setHeight(box.height);
    },

    addTool : function () {
	    var a = arguments, l = a.length, item;
	    for (var i = 0; i < l; i++) {
		    var el = a[i];
		    if (el.render) { // some kind of Item
			    item = this.addToolItem(el);
		    } else if (typeof el == "string") { // string
			    if (el == "separator" || el == "-") {
				    item = this.addToolSeparator();
			    } else {
				    item = this.addText(el);
			    }
		    } else if (el.tagName || el.el) { // element
			    item = this.addElement(el);
		    } else if (typeof el == "object") { // must be menu item config?
			    item = this.addToolMenuItem(el);
		    }
	    }
	    return item;
    },

    /**
	 * Adds a separator bar to the Tools
	 * 
	 * @return {Ext.menu.Item} The menu item that was added
	 */
    addToolSeparator : function () {
	    return this.addToolItem(new Ext.menu.Separator({
		    itemCls : 'ux-toolmenu-sep'
	    }));
    },

    addToolItem : function (item) {
	    item.text = i18n.get(item.text);
	    this.toolItems.add(item);
	    if (this.ul) {
		    var li = document.createElement("li");
		    li.className = "x-menu-list-item";
		    this.ul.dom.appendChild(li);
		    item.render(li, this);
		    this.delayAutoWidth();
	    }
	    return item;
    },

    addToolMenuItem : function (config) {
	    if (!(config instanceof Ext.menu.Item)) {
		    if (typeof config.checked == "boolean") { // must be check menu
			    // item config?
			    config = new Ext.menu.CheckItem(config);
		    } else {
			    config = new Ext.menu.Item(config);
		    }
	    }
	    return this.addToolItem(config);
    },

    setTitle : function (title, iconCls) {
	    this.title = title;
	    this.header.child('span').update(title);
	    return this;
    }
});
Ext.ns("sitools.common");

sitools.common._PreviewBox = Ext.extend(Ext.BoxComponent, {
	inited : false,
	defaultZIndex : 13000,
	defaultLeft : 0,
	defaultTop : 35,
	hideTop : 25,
	boxWidth : 250,
	cloneWinMaxWidth : 220,
	cloneWinMaxHeight : 116,
	hideDelay : 500,
	showDelay : 500,
	constructor : function() {
		sitools.common._PreviewBox.superclass.constructor.call(this, {
			renderTo : document.body,
			cls : "taskbar-previewbox",
			hidden : true
		});
		this.inited = false;
		this.hoverCount = 0
	},
	createBoxElements : function() {
		var el = this.getEl(), box;
		this.boxMl = el.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-ml"
		});
		this.boxMr = this.boxMl.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-mr"
		});
		this.boxMc = this.boxMr.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-mc"
		});
		this.arrow = el.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-arrow"
		});
		box = this.boxMc;
		this.desc = box.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-desc"
		});
		box.createChild( {
			tag : "hr"
		});
		this.win = box.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-win"
		});
		this.inited = true;
	},
//	onTaskbarClick : function() {
//		this.hideBox(true)
//	},
	showBox : function(boxConfig) {
		if (!this.isEnabled()) {
			return
		}
		this.needShowBox = true;
		this.hoverCount += 1;
		this.doShowBox.defer(300, this, [ boxConfig, this.hoverCount ]);
	},
	doShowBox : function(boxConfig, hoverCount) {
		var win, winEl, previewBox, center;
		if (!boxConfig || !boxConfig.win || !boxConfig.centerX) {
			return;
		}
		if (this.hoverCount !== hoverCount) {
			return;
		}
		if (!this.needShowBox) {
			return;
		}
		if (!this.inited) {
			this.createBoxElements()
		}
		center = Ext.isNumber(boxConfig.centerX) ? boxConfig.centerX : this.defaultLeft;
		win = boxConfig.win;
		winEl = win.getEl();

		this.desc.update(boxConfig.win.title);
		if (this.clonedEl) {
			this.clonedEl.remove()
		}
		this.clonedEl = this.getClonedEl(win);
		
		this.clonedEl.show();
		
		this.win.appendChild(this.clonedEl);
		previewBox = this.getEl();
		var top = Ext.get("ux-taskbar").getTop() - previewBox.getHeight() - 10;
		if (this.isVisible()) {
			previewBox.setTop(top);
			this.show();
			previewBox.shift( {
				left : center - (this.boxWidth / 2),
				opacity : 1,
				duration : 0.3
			})
		} else {
			previewBox.setLeftTop(center - (this.boxWidth / 2), top - 200);
			previewBox.setOpacity(0);
			this.show();
			top = Ext.get("ux-taskbar").getTop() - previewBox.getHeight() - 10;
			previewBox.shift( {
				top : top,
				opacity : 1,
				duration : 0.8
			});
		}
		this.hoverCount = 0;
	},
	hideBox : function(a) {
		if (!this.isEnabled()) {
			return
		}
		this.needShowBox = false;
		(function() {
			if (this.needShowBox) {
				return
			}
			this.doHideBox(a)
		}).defer((a === true) ? 0 : 300, this);
	},
	doHideBox : function(b) {
		var c;
		var a = function() {
			if (this.needShowBox) {
				return
			}
			this.hide();
		};
		if (this.clonedEl) {
			this.clonedEl.remove()
		}
		this.hoverCount = 0;
		if (b === true) {
			a.call(this);
			return
		}
		c = this.getEl();
		var top = Ext.get("ux-taskbar").getTop() - c.getHeight() - 20;
		
		c.shift( {
			top : top,
			opacity : 0,
			duration : 0.2,
			scope : this,
			callback : a
		});
	},
	getClonedEl : function(win) {
		var c = 0;
		var h = 0;
		var el = win.getEl();
		var newHtmlEl = el.dom.cloneNode(true);
		newHtmlEl.removeAttribute("id");
		var newEl = Ext.get(newHtmlEl);
		newEl.visibilityCls = "x-hide-display";
		newEl._previewMask = newEl.createChild( {
			tag : "div",
			cls : "taskbar-previewbox-win-mask"
		});

		var size = el.getSize();
		if (size.height === 0 && size.width === 0) {
			size = SitoolsDesk.getDesktop().getDesktopEl().getSize();
		}
		var d = this.cloneWinMaxWidth / size.width;
		c = (this.cloneWinMaxHeight - size.height * d) / 2;
		if ((size.height * d) > this.cloneWinMaxHeight) {
			d = this.cloneWinMaxHeight / size.height;
			c = 0;
			h = (this.cloneWinMaxWidth - size.width * d) / 2
		}
		d = Math.min(d, 1);
		newEl.addClass("taskbar-previewbox-win-transform");
		newEl.setStyle("-webkit-transform", String.format("scale({0})", d));
		newEl.setStyle("-moz-transform", String.format("scale({0})", d));
		newEl.setStyle("-o-transform", String.format("scale({0})", d));
		newEl.setStyle("transform", String.format("scale({0})", d));
		newEl.setLeftTop(h, c);
		return newEl;
	},
	isEnabled : function() {
		return true;
	}
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document*/
/*!
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/**
 * @class Ext.ux.TaskBar
 * @extends Ext.util.Observable
 */
Ext.ux.TaskBar = function (app, enableWarning) {
	this.app = app;
	this.init(enableWarning);
};

Ext.extend(Ext.ux.TaskBar, Ext.util.Observable, {
    init : function (enableWarning) {
//	    this.startMenu = new Ext.ux.StartMenu(Ext.apply({
//	        iconCls : 'user',
//	        height : 300,
//	        shadow : true,
//	        title : 'Jack Slocum',
//	        width : 300
//	    }, this.app.startConfig));

//	    this.startBtn = new Ext.Button({
//	        text : i18n.get('label.start'),
//	        id : 'ux-startbutton',
//	        iconCls : 'start',
//	        menu : this.startMenu,
//	        menuAlign : 'bl-tl',
//	        renderTo : 'ux-taskbar-start',
//	        clickEvent : 'mousedown',
//	        template : new Ext.Template('<table cellspacing="0" class="x-btn"><tbody class="{1}"><tr>',
//	                '<td class="ux-startbutton-left"><i>&#160;</i></td>',
//	                '<td class="ux-startbutton-center"><em class="{2} unselectable="on">',
//	                '<button class="x-btn-text" type="{0}" style="height:30px;"></button>', '</em></td>',
//	                '<td class="ux-startbutton-right"><i>&#160;</i></td>', '</tr></tbody></table>')
//	    });

//	    var width = this.startBtn.getEl().getWidth() + 10;

//	    var sbBox = new Ext.BoxComponent({
//	        el : 'ux-taskbar-start',
//	        id : 'TaskBarStart',
//	        minWidth : width,
//	        region : 'west',
//	        split : true,
//	        width : width
//	    });

        this.staticButtonPanel = new Ext.ux.TaskButtonsPanel({
            el : 'ux-staticbuttons-panel',
            id : 'TaskBarStaticButtons',
            region : 'center',
            style : 'overflow:hidden !important; height: 30px; width: 100% !important;', 
            listeners : {
        		addNewWindow : function () {
        			this.items[0].action = "minimize";
        		}
        	}
        });
        
	    this.tbPanel = new Ext.ux.TaskButtonsPanel({
	        el : 'ux-taskbuttons-panel',
	        id : 'TaskBarButtons',
	        region : 'center',
            style : 'overflow:hidden !important', 
            enableWarning : enableWarning
	    });

	    var container = new Ext.ux.TaskBarContainer({
	        el : 'ux-taskbar',
	        layout : 'border',
	        items : [ this.staticButtonPanel, this.tbPanel ]
	    });
	    
	    return this;
    },

    addTaskButton : function (win) {
	    var btn = this.tbPanel.addButton(win, 'ux-taskbuttons-panel');
	    this.setActiveButton(btn);
	    return btn;
	    this.staticButtonPanel.fireEvent("addNewWindow");
    },

    removeTaskButton : function (btn) {
	    this.tbPanel.removeButton(btn);
    },

    setActiveButton : function (btn) {
	    this.tbPanel.setActiveButton(btn);
    }, 
    getActiveButton : function () {
	    return this.tbPanel.getActiveButton();
    }, 

    getPreviousBtn : function (btn) {
    	return this.tbPanel.getPreviousBtn(btn);
    }, 
    getNextBtn : function (btn) {
    	return this.tbPanel.getNextBtn(btn);
    }, 
    getAllTaskButtons : function () {
    	return this.tbPanel.items;
    }, 
    setEnableWarning : function (enableWarning) {
    	this.tbPanel.enableWarning = enableWarning;
    }
});

/**
 * @class Ext.ux.TaskBarContainer
 * @extends Ext.Container
 */
Ext.ux.TaskBarContainer = Ext.extend(Ext.Container, {
    initComponent : function () {
	    Ext.ux.TaskBarContainer.superclass.initComponent.call(this);

	    this.el = Ext.get(this.el) || Ext.getBody();
	    this.el.setHeight = Ext.emptyFn;
	    this.el.setWidth = Ext.emptyFn;
	    this.el.setSize = Ext.emptyFn;
	    this.el.setStyle({
	        overflow : 'hidden',
	        margin : '0',
	        border : '0 none'
	    });
	    this.el.dom.scroll = 'no';
	    this.allowDomMove = false;
	    this.autoWidth = true;
	    this.autoHeight = true;
	    Ext.EventManager.onWindowResize(this.fireResize, this);
	    this.renderTo = this.el;
	    this.listeners = {
    		maximizeDesktop : this.onMaximizeDesktop
    	}
    },

    fireResize : function (w, h) {
	    this.onResize(w, h, w, h);
	    this.fireEvent('resize', this, w, h, w, h);
    }, 
    onMaximizeDesktop : function () {
    }
});

/**
 * @class Ext.ux.TaskButtonsPanel
 * @extends Ext.BoxComponent
 */
Ext.ux.TaskButtonsPanel = Ext.extend(Ext.BoxComponent, {
    activeButton : null,
    enableScroll : true,
    scrollIncrement : 0,
    scrollRepeatInterval : 400,
    scrollDuration : .35,
    animScroll : true,
    resizeButtons : false,
    buttonWidth : 168,
    minButtonWidth : 118,
    buttonMargin : 2,
    buttonWidthSet : false,

    initComponent : function () {
	    Ext.ux.TaskButtonsPanel.superclass.initComponent.call(this);
	    this.on('resize', this.delegateUpdates);
	    this.items = [];

	    this.stripWrap = Ext.get(this.el).createChild({
	        cls : 'ux-taskbuttons-strip-wrap',
	        cn : {
	            tag : 'ul',
	            cls : 'ux-taskbuttons-strip'
	        }
	    });
	    this.stripSpacer = Ext.get(this.el).createChild({
		    cls : 'ux-taskbuttons-strip-spacer'
	    });
	    this.strip = new Ext.Element(this.stripWrap.dom.firstChild);

	    this.edge = this.strip.createChild({
	        tag : 'li',
	        cls : 'ux-taskbuttons-edge'
	    });
	    this.strip.createChild({
		    cls : 'x-clear'
	    });
	    if (this.enableWarning) {
		    this.warningCt = this.edge.createChild({
		        tag : 'div', 
		        cls : "ux-taskbar-warningCt"
		    });
	    }
    },

    addButton : function (win) {
	    var li = this.strip.createChild({
		    tag : 'li'
	    }, this.edge); // insert before the edge
	    var btn = new Ext.ux.TaskBar.TaskButton(win, li);

	    this.items.push(btn);

	    if (!this.buttonWidthSet) {
		    this.lastButtonWidth = btn.container.getWidth();
	    }

	    this.setActiveButton(btn);
	    return btn;
    },
    
    addStaticButton : function (button) {
        var li = this.strip.createChild({
            tag : 'li'
        }, this.edge); // insert before the edge
        button.render(li);
        this.items.push(button);

    },
    
    removeButton : function (btn) {
	    var li = document.getElementById(btn.container.id);
	    Ext.fly(li).ghost('b', {
	    	duration : .5,
	    	remove : true, 
	    	callback : function () {
	    		btn.destroy();
	    	}
	    });
	    

	    var s = [];
	    for (var i = 0, len = this.items.length; i < len; i++) {
		    if (this.items[i] != btn) {
			    s.push(this.items[i]);
		    }
	    }
	    this.items = s;

	    this.delegateUpdates();
    },

    setActiveButton : function (btn) {
    	if (this.activeButton) {
    		Ext.fly(this.activeButton.el).removeClass('active-win');
        }
    	Ext.fly(btn.el).addClass('active-win');
		
    	this.activeButton = btn;
	    this.delegateUpdates();
    },
    getActiveButton : function() {
    	return this.activeButton;
    },
    getNextBtn : function (btn) {
    	var result;
    	try {
        	for (var i = 0, len = this.items.length; i < len; i++) {
    		    if (this.items[i] == btn) {
    			    result = this.items[i+1];
    		    }
    	    }
        	return result;
    	}
    	catch (err) {
    		return null;
    	}
    }, 
    
    getPreviousBtn : function (btn) {
    	var result;
    	try {
        	for (var i = 0, len = this.items.length; i < len; i++) {
    		    if (this.items[i] == btn) {
    			    result = this.items[i-1];
    		    }
    	    }
        	return result;
    	}
    	catch (err) {
    		return null;
    	}
    }, 
    
    delegateUpdates : function () {
	    /*
		 * if(this.suspendUpdates){ return; }
		 */
	    if (this.resizeButtons && this.rendered) {
		    this.autoSize();
	    }
	    if (this.enableScroll && this.rendered) {
		    this.autoScroll();
	    }
	    if (this.enableWarning) {
		    if (this.items.length > 10) {
		    	this.removeButton(this.items[0]);
		    }
		    if (this.items.length == 10) {
		    	this.warningCt.addClass('x-warning');
		        this.warningTT = new Ext.ToolTip({
		            target: this.warningCt,
		            width: 200,
		            anchor : "bottom", 
		            cls : "x-form-invalid-tip", 
		            html : i18n.get('label.tooManyPanelsOpened'), 
		            dismissDelay: 5000 // auto hide after 15 seconds
		        });

		    }
		    else {
		    	if (this.warningTT) {
		    		this.warningTT.destroy();
		    	}
		    	this.warningCt.removeClass("x-warning");
		    }
	    }
    },

    autoSize : function () {
	    var count = this.items.length;
	    var ow = this.el.dom.offsetWidth;
	    var aw = this.el.dom.clientWidth;

	    if (!this.resizeButtons || count < 1 || !aw) { // !aw for display:none
		    return;
	    }

	    var each = Math.max(Math.min(Math.floor((aw - 4) / count) - this.buttonMargin, this.buttonWidth),
	            this.minButtonWidth); // -4 for float errors in IE
	    var btns = this.stripWrap.dom.getElementsByTagName('button');

	    this.lastButtonWidth = Ext.get(btns[0].id).findParent('li').offsetWidth;

	    for (var i = 0, len = btns.length; i < len; i++) {
		    var btn = btns[i];

		    var tw = Ext.get(btns[i].id).findParent('li').offsetWidth;
		    var iw = btn.offsetWidth;

		    btn.style.width = (each - (tw - iw)) + 'px';
	    }
    },

    autoScroll : function () {
	    var count = this.items.length;
	    var ow = this.el.dom.offsetWidth;
	    var tw = this.el.dom.clientWidth;

	    var wrap = this.stripWrap;
	    var cw = wrap.dom.offsetWidth;
	    var pos = this.getScrollPos();
	    var l = this.edge.getOffsetsTo(this.stripWrap)[0] + pos;

	    if (!this.enableScroll || count < 1 || cw < 20) { // 20 to prevent
															// display:none
															// issues
		    return;
	    }

	    wrap.setWidth(tw); // moved to here because of problem in Safari

	    if (l <= tw) {
		    wrap.dom.scrollLeft = 0;
		    // wrap.setWidth(tw); moved from here because of problem in Safari
		    if (this.scrolling) {
			    this.scrolling = false;
			    this.el.removeClass('x-taskbuttons-scrolling');
			    this.scrollLeft.hide();
			    this.scrollRight.hide();
		    }
	    } else {
		    if (!this.scrolling) {
			    this.el.addClass('x-taskbuttons-scrolling');
		    }
		    tw -= wrap.getMargins('lr');
		    wrap.setWidth(tw > 20 ? tw : 20);
		    if (!this.scrolling) {
			    if (!this.scrollLeft) {
				    this.createScrollers();
			    } else {
				    this.scrollLeft.show();
				    this.scrollRight.show();
			    }
		    }
		    this.scrolling = true;
		    if (pos > (l - tw)) { // ensure it stays within bounds
			    wrap.dom.scrollLeft = l - tw;
		    } else { // otherwise, make sure the active button is still
						// visible
			    this.scrollToButton(this.activeButton, true); // true to
																// animate
		    }
		    this.updateScrollButtons();
	    }
    },

    createScrollers : function () {
	    var h = this.el.dom.offsetHeight; // var h =
											// this.stripWrap.dom.offsetHeight;

	    // left
	    var sl = this.el.insertFirst({
		    cls : 'ux-taskbuttons-scroller-left'
	    });
	    sl.setHeight(h);
	    sl.addClassOnOver('ux-taskbuttons-scroller-left-over');
	    this.leftRepeater = new Ext.util.ClickRepeater(sl, {
	        interval : this.scrollRepeatInterval,
	        handler : this.onScrollLeft,
	        scope : this
	    });
	    this.scrollLeft = sl;

	    // right
	    var sr = this.el.insertFirst({
		    cls : 'ux-taskbuttons-scroller-right'
	    });
	    sr.setHeight(h);
	    sr.addClassOnOver('ux-taskbuttons-scroller-right-over');
	    this.rightRepeater = new Ext.util.ClickRepeater(sr, {
	        interval : this.scrollRepeatInterval,
	        handler : this.onScrollRight,
	        scope : this
	    });
	    this.scrollRight = sr;
    },

    getScrollWidth : function () {
	    return this.edge.getOffsetsTo(this.stripWrap)[0] + this.getScrollPos();
    },

    getScrollPos : function () {
	    return parseInt(this.stripWrap.dom.scrollLeft, 10) || 0;
    },

    getScrollArea : function () {
	    return parseInt(this.stripWrap.dom.clientWidth, 10) || 0;
    },

    getScrollAnim : function () {
	    return {
	        duration : this.scrollDuration,
	        callback : this.updateScrollButtons,
	        scope : this
	    };
    },

    getScrollIncrement : function () {
	    return (this.scrollIncrement || this.lastButtonWidth + 2);
    },

    /*
	 * getBtnEl : function(item){ return document.getElementById(item.id); },
	 */

    scrollToButton : function (item, animate) {
	    item = item.el.dom.parentNode; // li
	    if (!item) {
		    return;
	    }
	    var el = item; // this.getBtnEl(item);
	    var pos = this.getScrollPos(), area = this.getScrollArea();
	    var left = Ext.fly(el).getOffsetsTo(this.stripWrap)[0] + pos;
	    var right = left + el.offsetWidth;
	    if (left < pos) {
		    this.scrollTo(left, animate);
	    } else if (right > (pos + area)) {
		    this.scrollTo(right - area, animate);
	    }
    },

    scrollTo : function (pos, animate) {
	    this.stripWrap.scrollTo('left', pos, animate ? this.getScrollAnim() : false);
	    if (!animate) {
		    this.updateScrollButtons();
	    }
    },

    onScrollRight : function () {
	    var sw = this.getScrollWidth() - this.getScrollArea();
	    var pos = this.getScrollPos();
	    var s = Math.min(sw, pos + this.getScrollIncrement());
	    if (s != pos) {
		    this.scrollTo(s, this.animScroll);
	    }
    },

    onScrollLeft : function () {
	    var pos = this.getScrollPos();
	    var s = Math.max(0, pos - this.getScrollIncrement());
	    if (s != pos) {
		    this.scrollTo(s, this.animScroll);
	    }
    },

    updateScrollButtons : function () {
	    var pos = this.getScrollPos();
	    this.scrollLeft[pos === 0 ? 'addClass' : 'removeClass']('ux-taskbuttons-scroller-left-disabled');
	    this.scrollRight[pos >= (this.getScrollWidth() - this.getScrollArea()) ? 'addClass' : 'removeClass']
	            ('ux-taskbuttons-scroller-right-disabled');
    }
});

/**
 * @class Ext.ux.TaskBar.TaskButton
 * @extends Ext.Button
 */
Ext.ux.TaskBar.TaskButton = function (win, el) {
	this.win = win;
	var iconCls = win.iconCls;
	if(Ext.isEmpty(iconCls)){
		iconCls = 'smallLogo';
	}
	
	
	Ext.ux.TaskBar.TaskButton.superclass.constructor.call(this, {
	    iconCls : iconCls,
//	    text : Ext.util.Format.ellipsis(win.title, 12),
	    renderTo : el,
	    handler : function (btn) {
			SitoolsDesk.navProfile.taskbar.handleTaskButton.call(this, btn);
		},
//	    clickEvent : 'mousedown',
	    template : new Ext.Template('<table cellspacing="0" class="x-btn {3}"><tbody><tr>',
	            '<td class="ux-taskbutton-center"><em class="{5} unselectable="on">',
	            '<button class="x-btn-text {2}" type="{1}" style="height:28px;">{0}</button>', '</em></td>',
	            "</tr></tbody></table>")
	});
};

Ext.extend(Ext.ux.TaskBar.TaskButton, Ext.Button, {
	scale : "medium", 
	width : 50, 
	initButtonEl : function() {
		Ext.ux.TaskBar.TaskButton.superclass.initButtonEl.apply(this, arguments);
//		this.mon(this.el, "contextmenu", this.onContextMenu, this);
		this.mon(this.el, "mouseover", this.onMouseOverHandler, this);
		this.mon(this.el, "mouseout", this.onMouseOutHandler, this);
		
	},
    onRender : function () {
	    Ext.ux.TaskBar.TaskButton.superclass.onRender.apply(this, arguments);

	    this.cmenu = new Ext.menu.Menu({
		    items : SitoolsDesk.navProfile.taskbar.getContextMenuItems.call(this)
	    });

	    this.cmenu.on('beforeshow', function () {
	    	SitoolsDesk.navProfile.taskbar.beforeShowCtxMenu.call(this);
	    }, this);

	    this.el.on('contextmenu', function (e) {
		    e.stopEvent();
		    if (!this.cmenu.el) {
			    this.cmenu.render();
		    }
		    var xy = e.getXY();
		    xy[1] -= this.cmenu.el.getHeight();
		    this.cmenu.showAt(xy);
	    }, this);
    },
	
    onMouseOverHandler : function(d) {
		if (this.state === "normal") {
			return;
		}

		var ca = this.container.getAlignToXY(this.container, "?");
		var cw = this.container.getWidth();
		var boxConfig = {
			win : this.win,
			centerX : ca[0] + (cw / 2)
		};
		sitools.PreviewBox.showBox(boxConfig);
	},
	onMouseOutHandler : function(a) {
		sitools.PreviewBox.hideBox();
	}, 

    closeWin : function (cMenu, e, win) {
		SitoolsDesk.navProfile.taskbar.closeWin.call(this, cMenu, e, win);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/*global Ext, sitools*/
/**
 * The object that builds main desktop off the application.
 * @param {Ext.app.App} app
 */
Ext.Desktop = function (app) {
	/**
	 * The taskBar object
	 * @type Ext.ux.TaskBar
	 */
	this.taskbar = new Ext.ux.TaskBar(app, true);
	this.xTickSize = this.yTickSize = 1;
	var taskbar = this.taskbar;

	var desktopEl = Ext.get('x-desktop');
	var bureauEl = Ext.get('bureau');
	var topEl = Ext.get('toppanel');
	var taskbarEl = Ext.get('ux-taskbar');
	var shortcuts = Ext.get('x-shortcuts');

	var windowsGroup = new Ext.WindowGroup({
		nbWin : function () {
			return this.accessList.length;
		}
	});
	var activeWindow;

	/**
	 * Minimize a window in the desktop.
	 * @private 
	 * @param {Ext.Window} win the window to minimize
	 */
	function minimizeWin(win) {
	    win.minimized = true;
	    win.hide(win.taskButton.getEl());
	}


	/**
	 * Render the window at the top of the desktop.
	 * @private 
	 * @param {Ext.Window} win the window to minimize
	 */
	function markActive(win) {
		if (activeWindow && activeWindow != win) {
			markInactive(activeWindow);
		}
		taskbar.setActiveButton(win.taskButton);
		activeWindow = win;
		Ext.fly(win.taskButton.el).addClass('active-win');
		win.minimized = false;
	}

	/**
	 * @private 
	 * @param {Ext.Window} win the window to minimize
	 */
	function markInactive(win) {
		if (win == activeWindow) {
			activeWindow = null;
			Ext.fly(win.taskButton.el).removeClass('active-win');
		}
	}

	
	/**
	 * Set the height of the different elements of the desktop, according to the screen height.
	 * @private 
	 */
	function layout() {
		var el = Ext.get("x-main");
		var enteteEl = SitoolsDesk.getEnteteEl();
		var bottom = SitoolsDesk.getBottomEl();
		try {
			el.setHeight(Ext.getBody().getHeight() - enteteEl.getHeight() - bottom.getHeight())
			desktopEl.setHeight(Ext.get("x-desktop-taskbar").getHeight()- taskbarEl.getHeight());
		}
		catch (err) {
			return;
		}
		
		windowsGroup.each(function (win) {
            if (win.maximized) {
                win.fitContainer();
            }
            else {
                win.fitToDesktop();               
            }
        });
		
//		bureauEl.setHeight(Ext.lib.Dom.getViewHeight() - taskbarEl.getHeight() - topEl.getHeight())
	}
	
	/**
	 * Remove a window from the desktop.
	 * @private 
	 * @param {Ext.Window} win the window to minimize
	 */
	function removeWin(win) {
		taskbar.removeTaskButton(win.taskButton);
		layout();
	}
	
	Ext.EventManager.onWindowResize(layout);

	this.layout = layout;

	/**
	 * Creates a window. 
	 * @method
	 * @returns {Ext.ux.stateFullWindow} the builded window.
	 */
	this.createWindow = function (config, cls) {
		var win = new (cls || Ext.ux.stateFullWindow)(Ext.applyIf(config || {}, {
		    renderTo : desktopEl,
		    constrain : true, 
		    constrainHeader : true, 
		    draggable : true, 
		    manager : windowsGroup,
		    minimizable : true,
		    maximizable : true, 
	        //DA : forcer le doLayout apres l'affichage 
		    listeners : {
		        show : function (win) {
                    var size = win.getSize();
                    size.width = size.width - 1;
                    
                    win.setSize(size);
		            win.doLayout();
		        }
		    }, 
		    cfgWindow : config.cfgWindow
		}));
		win.dd.xTickSize = this.xTickSize;
		win.dd.yTickSize = this.yTickSize;
		win.resizer.widthIncrement = this.xTickSize;
		win.resizer.heightIncrement = this.yTickSize;
		win.resizer.constrainTo = desktopEl;
		win.show();
		
		win.setPagePosition(config.xPos, config.yPos);
		win.taskButton = taskbar.addTaskButton(win);
		
		win.cmenu = new Ext.menu.Menu({
			items : [

			]
		});

		win.on({
		    'activate' : {
			    fn : markActive
		    },
		    'beforeshow' : {
			    fn : markActive
		    },
		    'deactivate' : {
			    fn : markInactive
		    },
		    'minimize' : {
			    fn : minimizeWin
		    },
		    'close' : {
			    fn : removeWin
		    }
		});

		layout();
		return win;
	};
	/**
	 * Creates a window. 
	 * @method
	 * @returns {Ext.ux.stateFullWindow} the builded window.
	 */
	this.createPanel = function (config, cls) {
		var panel = new (cls || Ext.Panel)(Ext.applyIf(config || {}, {
		    renderTo : desktopEl
		}));
		
		panel.taskButton = taskbar.addTaskButton(panel);
		panel.on({
		    'activate' : {
			    fn : markActive
		    },
		    'beforeshow' : {
			    fn : markActive
		    },
		    'deactivate' : {
			    fn : markInactive
		    },
		    'destroy' : {
		        fn : removeWin
		    }
		});
		layout();
		return panel;
	};
	
	
	/**
	 * @method 
	 * @returns {Ext.WindowGroup} the windowGroup object of this desktop.
	 */
	this.getManager = function () {
		return windowsGroup;
	};

	/**
	 * Returns the window with the id . 
	 * @param {string} id the id to look for
	 * @returns {Ext.Window} win the window
	 */
	this.getWindow = function (id) {
		return windowsGroup.get(id);
	};

	this.getWinWidth = function () {
		var width = Ext.lib.Dom.getViewWidth();
		return width < 200 ? 200 : width;
	};

	this.getWinHeight = function () {
		var height = (Ext.lib.Dom.getViewHeight() - taskbarEl.getHeight());
		return height < 100 ? 100 : height;
	};

	this.getWinX = function (width) {
		return (Ext.lib.Dom.getViewWidth() - width) / 2;
	};

	this.getWinY = function (height) {
		return (Ext.lib.Dom.getViewHeight() - taskbarEl.getHeight() - height) / 2;
	};

	this.setTickSize = function (xTickSize, yTickSize) {
		this.xTickSize = xTickSize;
		if (arguments.length == 1) {
			this.yTickSize = xTickSize;
		} else {
			this.yTickSize = yTickSize;
		}
		windowsGroup.each(function (win) {
			win.dd.xTickSize = this.xTickSize;
			win.dd.yTickSize = this.yTickSize;
			win.resizer.widthIncrement = this.xTickSize;
			win.resizer.heightIncrement = this.yTickSize;
		}, this);
	};

	this.maximize = function () {
		SitoolsDesk.getEnteteComp().fireEvent("maximizeDesktop");
		SitoolsDesk.getBottomComp().fireEvent("maximizeDesktop");
		Ext.DomQuery.select("div[stype=freeDiv]").each(function (freeDiv) {
			freeDiv.style.height = "0px";
			freeDiv.style.width = "0px";
		});
		SitoolsDesk.app.getModulesInDiv().each(function (moduleInDiv) {
			moduleInDiv.fireEvent("maximizeDesktop", moduleInDiv);
		});
		
		//Agrandir la zone desktopAndTaskbar
		this.getDesktopAndTaskBarEl().setHeight(Ext.getBody().getHeight() - SitoolsDesk.getEnteteEl().getHeight());
		this.getDesktopAndTaskBarEl().setWidth(Ext.getBody().getWidth());
		this.getDesktopEl().setHeight(Ext.getBody().getHeight() - SitoolsDesk.getEnteteEl().getHeight() - taskbarEl.getHeight());
		this.getDesktopEl().setWidth(Ext.getBody().getWidth());
		
		if (SitoolsDesk.getDesktop().activePanel) {
			SitoolsDesk.getDesktop().activePanel.fireEvent("resizeDesktop", SitoolsDesk.getDesktop().activePanel);
		}
		
		this.getManager().each(function (win) {
			if (win.maximized) {
				win.fitContainer();
			}
		});

		SitoolsDesk.getDesktop().taskbar.tbPanel.ownerCt.doLayout()
		
	}
	
	this.minimize = function () {
		SitoolsDesk.getEnteteComp().fireEvent("minimizeDesktop");
		SitoolsDesk.getBottomComp().fireEvent("minimizeDesktop");
		
		Ext.DomQuery.select("div[stype=freeDiv]").each(function (freeDiv) {
			freeDiv.style.height = "";
			freeDiv.style.width = "";
		});
		
		//Revenir à la taille initiale de la zone desktopAndTaskbar
		this.getDesktopAndTaskBarEl().dom.style.height="";
		this.getDesktopAndTaskBarEl().dom.style.width="";
		
		this.getDesktopEl().setWidth("");
		
		layout();
		if (SitoolsDesk.getDesktop().activePanel) {
			SitoolsDesk.getDesktop().activePanel.fireEvent("resizeDesktop", SitoolsDesk.getDesktop().activePanel);
		}
		
		SitoolsDesk.getDesktop().taskbar.tbPanel.ownerCt.doLayout()
		
		SitoolsDesk.app.getModulesInDiv().each(function (moduleInDiv) {
			moduleInDiv.fireEvent("minimizeDesktop", moduleInDiv);
		});
		
	}
	/**
	 * called when contextMenu cascade option is pressed.
	 * @method 
	 */
	this.cascade = function () {
		var x = 0, y = 0;
		windowsGroup.each(function (win) {
			if (win.isVisible() && !win.maximized) {
				win.setPosition(x, y);
				x += 20;
				y += 20;
			}
		}, this);
	};

	/**
	 * called when contextMenu tile option is pressed.
	 * @method 
	 */
	this.tile = function () {
		var availWidth = desktopEl.getWidth(true);
		var x = this.xTickSize;
		var y = this.yTickSize;
		var nextY = y;
		windowsGroup.each(function (win) {
			if (win.isVisible() && !win.maximized) {
				var w = win.el.getWidth();

				// Wrap to next row if we are not at the line start and this
				// Window will go off the end
				if ((x > this.xTickSize) && (x + w > availWidth)) {
					x = this.xTickSize;
					y = nextY;
				}

				win.setPosition(x, y);
				x += w + this.xTickSize;
				nextY = Math.max(nextY, y + win.el.getHeight() + this.yTickSize);
			}
		}, this);
	};

	this.contextMenu = new Ext.menu.Menu({
		items : [ {
		    text : 'Tile',
		    handler : this.tile,
		    scope : this, 
		    icon : loadUrl.get('APP_URL') + "/res/images/icons/presentation2.png"
		}, {
		    text : 'Cascade',
		    handler : this.cascade,
		    scope : this, 
		    icon : loadUrl.get('APP_URL') + "/res/images/icons/presentation1.png"
		} ]
	});
	desktopEl.on('contextmenu', function (e) {
		if (e.target.id == "x-desktop"){
			e.stopEvent();
			this.contextMenu.showAt(e.getXY());
		}
	}, this);

	layout();

	if (shortcuts) {
		shortcuts.on('click', function (e, t) {
			if (t = e.getTarget('dt', shortcuts)) {
				e.stopEvent();
				var module = app.getModule(t.id.replace('-shortcut', ''));
				if (module) {
					module.openModule();
				}
			}
		});
	}
	
	this.getDesktopEl = function () {
		return Ext.get('x-desktop');
	}
	this.getDesktopAndTaskBarEl = function () {
		return Ext.get('x-desktop-taskbar');
	}
	
	
	
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/*global Ext, sitools, ID, i18n, showResponse,locale,window*/
/*
 * @include "Desktop.js"
 */
/**
 * The Main Application 
 * @cfg {} cfg The initial config 
 * @class Ext.app.App
 * @extends Ext.util.Observable
 */
Ext.app.App = function (cfg) {
	Ext.apply(this, cfg);

	this.addEvents({
	    'ready' : true,
	    'beforeunload' : true
	});
	
};

Ext.extend(Ext.app.App, Ext.util.Observable, {
    /**
     * True when application is ready
     * @type Boolean
     */
    isReady : false,
    /**
     * The list of modules
     * @type [Ext.app.Module]  
     */
    modules : [], 
	/**
	 * The list of modules to be displayed in a Div
	 * @type [Ext.Panel]  
	 */
	modulesInDiv : [],
	/**
     * The fishEyeMenu
     * @type Ext.ux.FisheyeMenuExtention 
     */
    fisheye : null,
	
	/**
	 * BasicMethod to override.
	 */
	getStartConfig : function () {

    },
    
    /**
     * Initialize application.
     * Call the method init which must have been override on instanciation.
     */
    initApp : function () {
//		this.startConfig = this.startConfig || this.getStartConfig();

	    this.desktop = new Ext.Desktop(this);
	    sitools.PreviewBox = new sitools.common._PreviewBox();
		
//	    this.tabMenu = [];
//
//	    this.launcher = this.desktop.taskbar.startMenu;
//
//	    this.modules = this.getModules();
//	    if (this.modules) {
//		    this.initModules(this.modules);
//	    }

	    this.init();
	    
	    Ext.EventManager.on(window, 'beforeunload', this.onUnload, this);
	    this.isReady = true;
    },

	/**
	 * @method
	 * BasicMethod to override.
	 */
    getModules : Ext.emptyFn,
	/**
	 * @method
	 * BasicMethod to override.
	 */
    getModulesInDiv : Ext.emptyFn,
	/**
	 * @method
	 * BasicMethod to override.
	 */
    init : Ext.emptyFn,

	/**
	 * Add all modules to fisheye menu and launcher.
	 */
    initModules : function (ms) {
	    this.modules = ms;

	    for (var i = 0, len = ms.length; i < len; i++) {
		    var m = ms[i];

		    this.launcher.add(m.launcher);
//		    this.tabMenu.push(m.fisheye);
		    m.app = this;
	    }

//	    this.fisheye = new Ext.ux.FisheyeMenuExtention({
//	        renderTo : 'fisheye-menu-bottom',
//	        hAlign : 'center', // left|center|right
//	        vAlign : 'bottom', // top|bottom
//	        itemWidth : 60,
//	        items : this.tabMenu
//	    });

	    // quand tous les modules sont prets,
	    // l'application est prete a etre utilisee
	    this.isReady = true;
    },

    /**
     * Add a single Module
     * @param {Ext.app.Module} module
     */
    addModule : function (module) {
	    this.launcher.add(module.launcher);
	    this.fisheye.addItem(module.fisheye);
	    module.app = this;
    },
    /**
     * Remove a single Module
     * @param {Ext.app.Module} moduleToRemove
     */
    removeModule : function (moduleToRemove) {
	    this.launcher.remove(moduleToRemove.id);
	    this.fisheye.removeItem(moduleToRemove.fisheye.id);
	    this.modules.remove(moduleToRemove);

    },

    /**
     * Return a {Ext.app.Module} module from his name
     * @param {string} name
     * @return {Ext.app.Module} if founded, "" else
     */
    getModule : function (name) {
	    var ms = this.modules;
	    if (!Ext.isEmpty(ms)) {
		    for (var i = 0, len = ms.length; i < len; i++) {
			    if (ms[i].id == name || ms[i].appType == name) {
				    return ms[i];
			    }
		    }
	    }
	    return '';
    },

    /**
     * 
     * @return {Ext.Desktop} the Desktop object
     */
    getDesktop : function () {
	    return this.desktop;
    },

    /**
     * @return {Ext.ux.FisheyeMenuExtention} return the Fisheye menu object
     */
    getFisheyeMenu : function () {
	    return this.fisheye;
    },

    /**
     * Called by the event beforeunload on the window object
     * @param {} e
     */
    onUnload : function (e) {
	    if (this.fireEvent('beforeunload', this) === false) {
		    e.stopEvent();
	    }
    }, 
    /**
     * @deprecated (it is not masking taskBar)
     */
    showSpinner : function () {
    	Ext.getBody().mask("loading...", "x-mask-loading");
    }, 
    /**
     * @deprecated (it is not masking taskBar)
     */
    hideSpinner : function () {
    	if (Ext.getBody().isMasked()){
    		Ext.getBody().unmask();
    	}
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/*global Ext, sitools*/

/**
 * A simple Observable class to instanciate module App
 * @class Ext.app.Module
 * @extends Ext.util.Observable
 */
Ext.app.Module = function (config) {
	Ext.apply(this, config);
	Ext.app.Module.superclass.constructor.call(this);
	this.init();
};

Ext.extend(Ext.app.Module, Ext.util.Observable, {
	init : Ext.emptyFn
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/*global Ext, sitools, ID, i18n, showResponse, alertFailure,clog*/
Ext.ns('Ext.ux.grid');

/**
 * @class Ext.ux.grid.CheckColumn
 * @extends Object GridPanel plugin to add a column with check boxes to a grid.
 *          <p>
 *          Example usage:
 *          </p>
 * 
 * <pre><code>
 *  // create the column
 *  var checkColumn = new Ext.grid.CheckColumn({
 *  header: 'Indoor?',
 *  dataIndex: 'indoor',
 *  id: 'check',
 *  width: 55
 *  });
 * 
 *  // add the column to the column model
 *  var cm = new Ext.grid.ColumnModel([{
 *  header: 'Foo',
 *  ...
 *  },
 *  checkColumn
 *  ]);
 * 
 *  // create the grid
 *  var grid = new Ext.grid.EditorGridPanel({
 *  ...
 *  cm: cm,
 *  plugins: [checkColumn], // include plugin
 *  ...
 *  });
 * </code></pre>
 * 
 * In addition to storing a Boolean value within the record data, this class
 * toggles a css class between <tt>'x-grid3-check-col'</tt> and
 * <tt>'x-grid3-check-col-on'</tt> to alter the background image used for a
 * column.
 */
Ext.ux.grid.CheckColumn = function(config){
    
	Ext.apply(this, config);
    if(!this.id){
        this.id = Ext.id();
    }
    this.renderer = this.renderer.createDelegate(this);
};

Ext.ux.grid.CheckColumn = Ext.extend(Ext.Component, {
    enabled : true, 
    init : function(grid){
        this.grid = grid;
        this.grid.on('render', function(){
            var view = this.grid.getView();
            view.mainBody.on('mousedown', this.onMouseDown, this);
        }, this);
        
    },

    onMouseDown : function(e, t){
        
        if(Ext.fly(t).hasClass(this.createId()) && Ext.fly(t).hasClass("x-grid3-check-col-enabled")){
            e.stopEvent();
            var index = this.grid.getView().findRowIndex(t);
            var record = this.grid.store.getAt(index);
            
            var newValue;
            newValue = !record.data[this.dataIndex];
            
            record.set(this.dataIndex, !record.data[this.dataIndex]);
            this.fireEvent('change', this, newValue);
        }
    },

    renderer : function(v, p, record){
        p.css += ' x-grid3-check-col-td'; 
        var cmp = Ext.getCmp(this.id); 
        if (cmp.enabled) {
        	return String.format('<div id="{2}" class="x-grid3-check-col{0} x-grid3-check-col-enabled {1}">&#160;</div>', v ? '-on' : '', cmp.createId(), this.id);
        }
        else {
        	return String.format('<div id="{2}" class="x-grid3-check-disabled-col{0} {1}">&#160;</div>', v ? '-on' : '', cmp.createId(), this.id);
        }
    },
    
    createId : function(){
        return 'x-grid3-cc-' + this.id;
    } , 
    getEnabled : function () {
    	return this.enabled;
    }, 
    setEnabled : function (value) {
    	this.enabled = value;
    }
    
});

// register ptype
Ext.preg('checkcolumn', Ext.ux.grid.CheckColumn);

// backwards compat
Ext.grid.CheckColumn = Ext.ux.grid.CheckColumn;
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, ann */
Ext.namespace('sitools.siteMap');

var loadUrl = {

    map : [],
    /**
     * Load a properties file and and the name/values in a associative array ;
     * Executing this function on multiple properties file increase the size of
     * the array Results can be displayed in the help panel with the display()
     * function
     * 
     * @param url
     *            URL of the i18n file
     * @param callback
     *            No args function that will be executed
     * @returns void
     */
    load : function (url, callback, scope) {

        var siteMapRef = this;
        siteMapRef.transformsPropertiesToMap(url, callback, scope);

    },
    /**
     * Transforms a xml Text to a map
     * 
     * @param text
     *            raw properties file
     * @returns a map (associative array) TODO check when the raw properties
     *          file is rotten
     */
    transformsPropertiesToMap : function (url, callback, scope) {

        var store = new Ext.data.Store({
            proxy : new Ext.data.HttpProxy({
                url : url,
                restful : true
            }),
            reader : new Ext.data.XmlReader({
                record : 'url'
            }, [ {
                name : 'name',
                mapping : 'name'
            }, {
                name : 'loc',
                mapping : 'loc'
            } ])
        });
        var localMap = this.map;

        store.load({
            scope : scope,
            callback : function (r, options, success) {
                var i = 0;
                while (i != undefined) {
                    var rec = r[i];
                    if (rec != undefined) {
                        var url = rec.data.loc;
                        var name = rec.data.name;
                        localMap[name] = url;
                        i++;
                    } else {
                        i = undefined;
                    }
                }
                callback.call(this);
            }
        });
    },
    /**
     * return the url value
     * 
     * @param name
     * @returns
     */
    get : function (entry) {
        return !Ext.isEmpty(this.map[entry]) ? this.map[entry] : entry;
    }
};

/**
 * To be defined
 */
var componentManager = {

    loadedComponents : [],

    load : function (name) {

    }

};

var data = {
    ret : null,
    /**
     * Fetch a html file in the url, and display its content into the helpPanel. *
     * 
     * @param url
     * @returns
     */
    get : function (url, cbk) {
        Ext.Ajax.request({
            method : 'GET',
            url : url,
            success : function (response, opts) {
                cbk(Ext.decode(response.responseText));
            },
            failure : function (response, opts) {
                Ext.Msg.alert("Warning", "Error! Can't get data with url :" + url);
            }
        });
        return this.ret;
    }

};

Ext.applyIf(Array.prototype, {
    clone : function () {
        return [].concat(this);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, showResponse, alertFailure, extColModelToSrv*/
/**
 * Redefine the method beforeColMenuShow to request the store when adding a column
 * @class Ext.ux.sitoolsGridView
 * @extends Ext.grid.GridView
 */
Ext.ux.sitoolsGridView = Ext.extend(Ext.grid.GridView, {
	// surcharge de la méthode pour que l'ajout d'une colonne relance une
	// interrogation du store
	// avec comme parametre le nouveau columnModel
//	beforeColMenuShow : function () {
//		var cm = this.cm, colCount = cm.getColumnCount();
//		this.colMenu.removeAll();
//		for (var i = 0; i < colCount; i++) {
//			if (cm.config[i].hideable !== false) {
//				this.colMenu.add(new Ext.menu.CheckItem({
//				    itemId : 'col-' + cm.getColumnId(i),
//				    text : cm.getColumnHeader(i),
//				    checked : !cm.isHidden(i),
//				    hideOnClick : false,
//				    disabled : cm.config[i].hideable === false,
//				    listeners : {
//				        scope : this,
//				        checkchange : function (ci, checked) {
//					        if (checked) {
//						        var colModel = extColModelToSrv(this.cm);
//						        this.grid.getStore().load({
//							        params : {
//								        colModel : Ext.util.JSON.encode(colModel)
//							        }
//						        });
//					        }
//				        }
//				    }
//				}));
//			}
//		}
//	}, 
	
    doRender : function(columns, records, store, startRow, colCount, stripe) {
        var templates    = this.templates,
            cellTemplate = templates.cell,
            rowTemplate  = templates.row,
            last         = colCount - 1;

        var tstyle = 'width:' + this.getTotalWidth() + ';';

        
        var rowBuffer = [],
            colBuffer = [],
            rowParams = {tstyle: tstyle},
            meta      = {},
            column,
            record;

        
        for (var j = 0, len = records.length; j < len; j++) {
            record    = records[j];
            colBuffer = [];

            var rowIndex = j + startRow;

            
            for (var i = 0; i < colCount; i++) {
                column = columns[i];

                meta.id    = column.id;
                meta.css   = i === 0 ? 'x-grid3-cell-first ' : (i == last ? 'x-grid3-cell-last ' : '');
                meta.attr  = meta.cellAttr = '';
                meta.style = column.style;
                meta.value = column.renderer.call(column.scope, record.data[column.name], meta, record, rowIndex, i, store);

                if (Ext.isEmpty(meta.value)) {
                    meta.value = '&#160;';
                }

                if (this.markDirty && record.dirty && Ext.isDefined(record.modified[column.name])) {
                    meta.css += ' x-grid3-dirty-cell';
                }

                colBuffer[colBuffer.length] = cellTemplate.apply(meta);
            }

            
            var alt = [];

            if (stripe && ((rowIndex + 1) % 2 === 0)) {
                alt[0] = 'x-grid3-row-alt';
            }

            if (record.dirty) {
                alt[1] = ' x-grid3-dirty-row';
            }

            rowParams.cols = colCount;

            if (this.getRowClass) {
                alt[2] = this.getRowClass(record, rowIndex, rowParams, store);
            }

            rowParams.alt   = alt.join(' ');
            rowParams.cells = colBuffer.join('');

            rowBuffer[rowBuffer.length] = rowTemplate.apply(rowParams);
        }
		//Ajout du cas où il n'y a pas de records.
		if (records.length == 0) {
			var alt = [];

            rowParams.cols = colCount;

            rowParams.cells = " ";

            rowBuffer[0] = rowTemplate.apply(rowParams);
		}
        return rowBuffer.join('');
    }, 
    renderRows : function(startRow, endRow){
        
        var g = this.grid, cm = g.colModel, ds = g.store, stripe = g.stripeRows;
        var colCount = cm.getColumnCount();

        //if(ds.getCount() < 1){
          //  return '';
        //}

        var cs = this.getColumnData();

        startRow = startRow || 0;
        endRow = !Ext.isDefined(endRow) ? ds.getCount()-1 : endRow;

        
        var rs = ds.getRange(startRow, endRow);

        return this.doRender(cs, rs, ds, startRow, colCount, stripe);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/**
*
*  Base64 encode / decode
*  http://www.webtoolkit.info/
*
**/
 
var Base64 = {
 
	// private property
	_keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
 
	// public method for encoding
	encode : function (input) {
		var output = "";
		var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
		var i = 0;
 
		input = Base64._utf8_encode(input);
 
		while (i < input.length) {
 
			chr1 = input.charCodeAt(i++);
			chr2 = input.charCodeAt(i++);
			chr3 = input.charCodeAt(i++);
 
			enc1 = chr1 >> 2;
			enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
			enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
			enc4 = chr3 & 63;
 
			if (isNaN(chr2)) {
				enc3 = enc4 = 64;
			} else if (isNaN(chr3)) {
				enc4 = 64;
			}
 
			output = output +
			this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
			this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
 
		}
 
		return output;
	},
 
	// public method for decoding
	decode : function (input) {
		var output = "";
		var chr1, chr2, chr3;
		var enc1, enc2, enc3, enc4;
		var i = 0;
 
		input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 
		while (i < input.length) {
 
			enc1 = this._keyStr.indexOf(input.charAt(i++));
			enc2 = this._keyStr.indexOf(input.charAt(i++));
			enc3 = this._keyStr.indexOf(input.charAt(i++));
			enc4 = this._keyStr.indexOf(input.charAt(i++));
 
			chr1 = (enc1 << 2) | (enc2 >> 4);
			chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
			chr3 = ((enc3 & 3) << 6) | enc4;
 
			output = output + String.fromCharCode(chr1);
 
			if (enc3 != 64) {
				output = output + String.fromCharCode(chr2);
			}
			if (enc4 != 64) {
				output = output + String.fromCharCode(chr3);
			}
 
		}
 
		output = Base64._utf8_decode(output);
 
		return output;
 
	},
 
	// private method for UTF-8 encoding
	_utf8_encode : function (string) {
		string = string.replace(/\r\n/g,"\n");
		var utftext = "";
 
		for (var n = 0; n < string.length; n++) {
 
			var c = string.charCodeAt(n);
 
			if (c < 128) {
				utftext += String.fromCharCode(c);
			}
			else if((c > 127) && (c < 2048)) {
				utftext += String.fromCharCode((c >> 6) | 192);
				utftext += String.fromCharCode((c & 63) | 128);
			}
			else {
				utftext += String.fromCharCode((c >> 12) | 224);
				utftext += String.fromCharCode(((c >> 6) & 63) | 128);
				utftext += String.fromCharCode((c & 63) | 128);
			}
 
		}
 
		return utftext;
	},
 
	// private method for UTF-8 decoding
	_utf8_decode : function (utftext) {
		var string = "";
		var i = 0;
		var c = c1 = c2 = 0;
 
		while ( i < utftext.length ) {
 
			c = utftext.charCodeAt(i);
 
			if (c < 128) {
				string += String.fromCharCode(c);
				i++;
			}
			else if((c > 191) && (c < 224)) {
				c2 = utftext.charCodeAt(i+1);
				string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
				i += 2;
			}
			else {
				c2 = utftext.charCodeAt(i+1);
				c3 = utftext.charCodeAt(i+2);
				string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
				i += 3;
			}
 
		}
 
		return string;
	}
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 *  md5.js 1.0b 27/06/96
 *
 * Javascript implementation of the RSA Data Security, Inc. MD5
 * Message-Digest Algorithm.
 *
 * Copyright (c) 1996 Henri Torgemane. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for any purposes and without
 * fee is hereby granted provided that this copyright notice
 * appears in all copies.
 *
 * Of course, this soft is provided "as is" without express or implied
 * warranty of any kind.
 *
 *
 * Modified with german comments and some information about collisions.
 * (Ralf Mieke, ralf@miekenet.de, http://mieke.home.pages.de)
 * French translation: Serge François, serge@selfhtml.org, http://fr.selfhtml.org
 */



function array(n) {
  for(i=0;i<n;i++) this[i]=0;
  this.length=n;
}



/* Quelques fonctions fondamentales doivent être transformées à cause
 * d'erreurs Javascript.
 * Essayez par exemple de calculer 0xffffffff >> 4 ...
 * Les fonctions utilisées maintenant sont il est vrai plus lentes que les
 * fonctions originales mais elles fonctionnent.
 */

function integer(n) { return n%(0xffffffff+1); }

function shr(a,b) {
  a=integer(a);
  b=integer(b);
  if (a-0x80000000>=0) {
    a=a%0x80000000;
    a>>=b;
    a+=0x40000000>>(b-1);
  } else
    a>>=b;
  return a;
}

function shl1(a) {
  a=a%0x80000000;
  if (a&0x40000000==0x40000000)
  {
    a-=0x40000000;
    a*=2;
    a+=0x80000000;
  } else
    a*=2;
  return a;
}

function shl(a,b) {
  a=integer(a);
  b=integer(b);
  for (var i=0;i<b;i++) a=shl1(a);
  return a;
}

function and(a,b) {
  a=integer(a);
  b=integer(b);
  var t1=(a-0x80000000);
  var t2=(b-0x80000000);
  if (t1>=0)
    if (t2>=0)
      return ((t1&t2)+0x80000000);
    else
      return (t1&b);
  else
    if (t2>=0)
      return (a&t2);
    else
      return (a&b);
}

function or(a,b) {
  a=integer(a);
  b=integer(b);
  var t1=(a-0x80000000);
  var t2=(b-0x80000000);
  if (t1>=0)
    if (t2>=0)
      return ((t1|t2)+0x80000000);
    else
      return ((t1|b)+0x80000000);
  else
    if (t2>=0)
      return ((a|t2)+0x80000000);
    else
      return (a|b);
}

function xor(a,b) {
  a=integer(a);
  b=integer(b);
  var t1=(a-0x80000000);
  var t2=(b-0x80000000);
  if (t1>=0)
    if (t2>=0)
      return (t1^t2);
    else
      return ((t1^b)+0x80000000);
  else
    if (t2>=0)
      return ((a^t2)+0x80000000);
    else
      return (a^b);
}

function not(a) {
  a=integer(a);
  return (0xffffffff-a);
}

/* Début de l'algorithme */

    var state = new array(4);
    var count = new array(2);
        count[0] = 0;
        count[1] = 0;
    var buffer = new array(64);
    var transformBuffer = new array(16);
    var digestBits = new array(16);

    var S11 = 7;
    var S12 = 12;
    var S13 = 17;
    var S14 = 22;
    var S21 = 5;
    var S22 = 9;
    var S23 = 14;
    var S24 = 20;
    var S31 = 4;
    var S32 = 11;
    var S33 = 16;
    var S34 = 23;
    var S41 = 6;
    var S42 = 10;
    var S43 = 15;
    var S44 = 21;

    function F(x,y,z) {
        return or(and(x,y),and(not(x),z));
    }

    function G(x,y,z) {
        return or(and(x,z),and(y,not(z)));
    }

    function H(x,y,z) {
        return xor(xor(x,y),z);
    }

    function I(x,y,z) {
        return xor(y ,or(x , not(z)));
    }

    function rotateLeft(a,n) {
        return or(shl(a, n),(shr(a,(32 - n))));
    }

    function FF(a,b,c,d,x,s,ac) {
        a = a+F(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a = a+b;
        return a;
    }

    function GG(a,b,c,d,x,s,ac) {
        a = a+G(b, c, d) +x + ac;
        a = rotateLeft(a, s);
        a = a+b;
        return a;
    }

    function HH(a,b,c,d,x,s,ac) {
        a = a+H(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a = a+b;
        return a;
    }

    function II(a,b,c,d,x,s,ac) {
        a = a+I(b, c, d) + x + ac;
        a = rotateLeft(a, s);
        a = a+b;
        return a;
    }

    function transform(buf,offset) {
        var a=0, b=0, c=0, d=0;
        var x = transformBuffer;

        a = state[0];
        b = state[1];
        c = state[2];
        d = state[3];

        for (i = 0; i < 16; i++) {
            x[i] = and(buf[i*4+offset],0xff);
            for (j = 1; j < 4; j++) {
                x[i]+=shl(and(buf[i*4+j+offset] ,0xff), j * 8);
            }
        }

        /* tour 1 */
        a = FF ( a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
        d = FF ( d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
        c = FF ( c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
        b = FF ( b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
        a = FF ( a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
        d = FF ( d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
        c = FF ( c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
        b = FF ( b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
        a = FF ( a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
        d = FF ( d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
        c = FF ( c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
        b = FF ( b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
        a = FF ( a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
        d = FF ( d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
        c = FF ( c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
        b = FF ( b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

        /* tour 2 */
        a = GG ( a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
        d = GG ( d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
        c = GG ( c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
        b = GG ( b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
        a = GG ( a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
        d = GG ( d, a, b, c, x[10], S22,  0x2441453); /* 22 */
        c = GG ( c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
        b = GG ( b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
        a = GG ( a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
        d = GG ( d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
        c = GG ( c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
        b = GG ( b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
        a = GG ( a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
        d = GG ( d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
        c = GG ( c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
        b = GG ( b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

        /* tour 3 */
        a = HH ( a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
        d = HH ( d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
        c = HH ( c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
        b = HH ( b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
        a = HH ( a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
        d = HH ( d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
        c = HH ( c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
        b = HH ( b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
        a = HH ( a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
        d = HH ( d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
        c = HH ( c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
        b = HH ( b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
        a = HH ( a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
        d = HH ( d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
        c = HH ( c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
        b = HH ( b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

        /* tour 4 */
        a = II ( a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
        d = II ( d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
        c = II ( c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
        b = II ( b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
        a = II ( a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
        d = II ( d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
        c = II ( c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
        b = II ( b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
        a = II ( a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
        d = II ( d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
        c = II ( c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
        b = II ( b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
        a = II ( a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
        d = II ( d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
        c = II ( c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
        b = II ( b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

        state[0] +=a;
        state[1] +=b;
        state[2] +=c;
        state[3] +=d;

    }
    /* Avec l'initialisation de  Dobbertin:
       state[0] = 0x12ac2375;
       state[1] = 0x3b341042;
       state[2] = 0x5f62b97c;
       state[3] = 0x4ba763ed;
       s'il y a une collision:

       begin 644 Message1
       M7MH=JO6_>MG!X?!51$)W,CXV!A"=(!AR71,<X`Y-IIT9^Z&8L$2N'Y*Y:R.;
       39GIK9>TF$W()/MEHR%C4:G1R:Q"=
       `
       end

       begin 644 Message2
       M7MH=JO6_>MG!X?!51$)W,CXV!A"=(!AR71,<X`Y-IIT9^Z&8L$2N'Y*Y:R.;
       39GIK9>TF$W()/MEHREC4:G1R:Q"=
       `
       end
    */
    function init() {
        count[0]=count[1] = 0;
        state[0] = 0x67452301;
        state[1] = 0xefcdab89;
        state[2] = 0x98badcfe;
        state[3] = 0x10325476;
        for (i = 0; i < digestBits.length; i++)
            digestBits[i] = 0;
    }

    function update(b) {
        var index,i;

        index = and(shr(count[0],3) , 0x3f);
        if (count[0]<0xffffffff-7)
          count[0] += 8;
        else {
          count[1]++;
          count[0]-=0xffffffff+1;
          count[0]+=8;
        }
        buffer[index] = and(b,0xff);
        if (index  >= 63) {
            transform(buffer, 0);
        }
    }

    function finish() {
        var bits = new array(8);
        var        padding;
        var        i=0, index=0, padLen=0;

        for (i = 0; i < 4; i++) {
            bits[i] = and(shr(count[0],(i * 8)), 0xff);
        }
        for (i = 0; i < 4; i++) {
            bits[i+4]=and(shr(count[1],(i * 8)), 0xff);
        }
        index = and(shr(count[0], 3) ,0x3f);
        padLen = (index < 56) ? (56 - index) : (120 - index);
        padding = new array(64);
        padding[0] = 0x80;
        for (i=0;i<padLen;i++)
          update(padding[i]);
        for (i=0;i<8;i++)
          update(bits[i]);

        for (i = 0; i < 4; i++) {
            for (j = 0; j < 4; j++) {
                digestBits[i*4+j] = and(shr(state[i], (j * 8)) , 0xff);
            }
        }
    }

/* Fin de l'algorithme MD5 */

function hexa(n) {
 var hexa_h = "0123456789abcdef";
 var hexa_c="";
 var hexa_m=n;
 for (hexa_i=0;hexa_i<8;hexa_i++) {
   hexa_c=hexa_h.charAt(Math.abs(hexa_m)%16)+hexa_c;
   hexa_m=Math.floor(hexa_m/16);
 }
 return hexa_c;
}


var ascii="01234567890123456789012345678901" +
          " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"+
          "[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

function MD5(message)
{
 var l,s,k,ka,kb,kc,kd;

 init();
 for (k=0;k<message.length;k++) {
   l=message.charAt(k);
   update(ascii.lastIndexOf(l));
 }
 finish();
 ka=kb=kc=kd=0;
 for (i=0;i<4;i++) ka+=shl(digestBits[15-i], (i*8));
 for (i=4;i<8;i++) kb+=shl(digestBits[15-i], ((i-4)*8));
 for (i=8;i<12;i++) kc+=shl(digestBits[15-i], ((i-8)*8));
 for (i=12;i<16;i++) kd+=shl(digestBits[15-i], ((i-12)*8));
 s=hexa(kd)+hexa(kc)+hexa(kb)+hexa(ka);
 return s;
}
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
function Digest (config) {
	this.url = config.url;
	this.usr = config.usr;
	this.pwd = config.pwd;
	this.realm = config.realm;
	this.algorithm = config.algorithm;
	this.nonce = config.nonce;
	this.method = config.method;
	this.mode = config.mode;
	this.A1 = config.A1;
	
 	this.getDigestAuth = function () {
		this.resetHeaders();
		return this.buildAuthenticationRequest();
	};
	this.getA1 = function () {
		this.resetHeaders();
		return this.digest(this.usr + ':' + this.realm + ':' + this.pwd);
	};

	this.resetHeaders = function () {
		if ( typeof( this.headers) != "undefined" ) {
		  delete this.headers;
		}
		this.headers = {
		  'uri' : this.url,
		  'username' : this.usr,
		  'algorithm' : this.algorithm,
		  'realm' : this.realm, 
		  'nonce' : this.nonce
		};
	}; 

	this.digest = function (s) {
// Fallback to MD5 if requested algorithm is unavilable.
		if (typeof ( window[this.headers.algorithm] ) != 'function') {
		    if (typeof ( window['MD5'] ) != 'function') {
		      	alert('Votre navigateur ne supporte pas l\'authentification HTTP Digest !');
		      	return false;
		    } else {
		      	return MD5(s);
		    }
  		}
  		return window[this.headers.algorithm](s);
	};  

	this.buildResponseHash = function () {
		if (this.headers.salt) {
			auth.secret = auth.secret + ':' + auth.headers.salt;
		    delete auth.headers.salt;
		}
		if (this.headers.migrate) {
			auth.secret = this.digest(auth.secret);
		}
		
		var A1;
		if (Ext.isEmpty(this.A1)){
			A1 = this.getA1();
		}
		else {
			A1 = this.A1;
		}
		//delete this.secret;
		var A2 = this.digest(this.method + ':' + this.headers.uri);
		
		if (this.mode == 'digest') {
			return this.digest(A1 + ":" + this.headers.nonce + ":" + A2);
		}
		//TODO : voir s'il y a d'autres encodages possibles
		return null;
	};  

	this.buildAuthenticationRequest = function () {
	    var request = "Digest";
	    
	    var comma = ' ';
	    for (name in this.headers) {
	      request += comma + name + '="' + this.headers[name] + '"';
	      comma = ',';
	    }
	//    request += ' username="'+ auth.headers.username+ '"';
	    
	    // don't continue further if there is no algorithm yet.
	    if (typeof( this.headers.algorithm ) == 'undefined') {
	      return request;
	    }
	    
	    var r = this.buildResponseHash();
	    
	    if (r) {
	      request += ", response=\"" + r + "\"";
	      return request;
	    }
	
	    return false;
	};
  
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/**
 * shortcut for console.assert(object is not null neither undefined neither
 * empty string)
 */
/*global cerr,ctrace,isFirebugConsoleIsActive,console */
function ann(obj, message) {

    if (obj === true || obj === false) {
    	return; 
    }
    if (obj === undefined) {
        cerr('Object is undefined - ' + message);
        ctrace();
        return;
    }
    if (obj === null) {
        cerr('Object is null - ' + message);
        ctrace();
        return;
    }
    if (obj === "") {
        cerr('String seems empty - ' + message);
        ctrace();
        return;   
    }

    if (obj == NaN) {
        cerr('Object equals NaN - ' + message);
        ctrace();
        return;
    }

}


/**
 * shortcut for console.assert(object is not null neither undefined neither
 * empty string)
 */
function assert(condition, message) {

    if (!condition) {
    	cerr('Condition is not valid : ' + message);
    	ctrace();
    	return;
    }
}

/**
 * Log on the console
 */
function clog(message) {
	if (isFirebugConsoleIsActive()) {
		console.log(message);
	}	
}

/**
 * Display an error on the console
 */
function cerr(message) {
	if (isFirebugConsoleIsActive()) {
		console.trace();
	}	
}

/**
 * Trace the Javascript stack to this point
 */
function ctrace() {
	if (isFirebugConsoleIsActive()) {
		console.trace();
	}
}

/**
 * Trace the Javascript stack to this point
 */
function cdir(obj) {
	if (isFirebugConsoleIsActive()) {
		console.dir(obj);
	}
}

/**
 * Return true if the firebug console is active, false elsewhere
 */
function isFirebugConsoleIsActive() {
	try {
		if (console !== null && console !== undefined)
		{
			return true;
		} else {
			return false;
		}
	}
	catch (e) {
		return false;
	}
}




/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
Ext.ns("sitools.common.utils");

/**
 * An utility class to use for specific sitools dates.
 */
sitools.common.utils.Date = {
	/**
	 * The regExp to test if a string can be transformed to a date 
	 */
	regToday : new RegExp("^\{\\$TODAY\} *(\\+ *[0-9]*|\\- *[0-9]*)?$"),
	/**
	 * in the template {$TODAY} + x, determine the x unit (currently it is a Day)
	 * @type 
	 */
	timeInterval : Date.DAY, 
	/**
	 * Transform a String value containing {$TODAY} into a valid date.
	 * @param {String} val the string value
	 * @return {Date} the date Value.
	 */
	stringWithTodayToDate : function(val) {
		if (Ext.isDate(val)) {
			return val;
		}
		if (!this.regToday.test(val)) {
			return null;
		}
		
		var regNbJour = new RegExp("[0-9]+", "g");
		var regOp = new RegExp("[+]|[-]");
		var nbJour = parseFloat(regNbJour.exec(val));
		var op = regOp.exec(val);
		
		var result = new Date();
		if (Ext.isEmpty(nbJour) && !Ext.isEmpty(op)) {
			return null;
		}
		if (!Ext.isEmpty(nbJour) && !Ext.isEmpty(op)) {
			if (op == "-") {
				nbJour = nbJour * -1;
			}
			result = result.add(this.timeInterval, nbJour); 
		}
		return result;

	}, 
	/**
	 * Test if a date object is valid or not.
	 * @param {Date} d date value
	 * @return {Boolean} valid or not valid
	 */
	isValidDate : function (d) {
		if ( Object.prototype.toString.call(d) !== "[object Date]" )
			return false;
		return !isNaN(d.getTime());
	}
}/* URL class for JavaScript
 * Copyright (C) 2003 Johan Känngård, <johan AT kanngard DOT net>
 * http://dev.kanngard.net/
 *	
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * The GPL is located at: http://www.gnu.org/licenses/gpl.txt
 */
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/* Creates a new URL object with the specified url String. */
function Reference(url){
	if(url.length==0) eval('throw "Invalid URL ['+url+'];');
	this.url=url;
	this.port=-1;
	this.query=(this.url.indexOf('?')>=0)?this.url.substring(this.url.indexOf('?')+1):'';
	if(this.query.indexOf('#')>=0) this.query=this.query.substring(0,this.query.indexOf('#'));
	this.protocol='';
	this.host='';
	var protocolSepIndex=this.url.indexOf('://');
	if(protocolSepIndex>=0){
		this.protocol=this.url.substring(0,protocolSepIndex).toLowerCase();
		this.host=this.url.substring(protocolSepIndex+3);
		if(this.host.indexOf('/')>=0) this.host=this.host.substring(0,this.host.indexOf('/'));
		var atIndex=this.host.indexOf('@');
		if(atIndex>=0){
			var credentials=this.host.substring(0,atIndex);
			var colonIndex=credentials.indexOf(':');
			if(colonIndex>=0){
				this.username=credentials.substring(0,colonIndex);
				this.password=credentials.substring(colonIndex);
			}else{
				this.username=credentials;
			}
			this.host=this.host.substring(atIndex+1);
		}
		var portColonIndex=this.host.indexOf(':');
		if(portColonIndex>=0){
			this.port=this.host.substring(portColonIndex+1);
			this.host=this.host.substring(0,portColonIndex);
		}
		this.file=this.url.substring(protocolSepIndex+3);
		this.file=this.file.substring(this.file.indexOf('/'));
	}else{
		this.file=this.url;
	}
	if(this.file.indexOf('?')>=0) this.file=this.file.substring(0, this.file.indexOf('?'));
	var refSepIndex=url.indexOf('#');
	if(refSepIndex>=0){
		this.file=this.file.substring(0,refSepIndex);
		this.reference=this.url.substring(this.url.indexOf('#'));
	}else{
		this.reference='';
	}
	this.path=this.file;
	if(this.query.length>0) this.file+='?'+this.query;
	if(this.reference.length>0) this.file+='#'+this.reference;

	this.getPort=getPort;
	this.getQuery=getQuery;
	this.getProtocol=getProtocol;
	this.getHost=getHost;
	this.getUserName=getUserName;
	this.getPassword=getPassword;
	this.getFile=getFile;
	this.getReference=getReference;
	this.getPath=getPath;
	this.getArgumentValue=getArgumentValue;
	this.getArgumentValues=getArgumentValues;
	this.toString=toString;

	/* Returns the port part of this URL, i.e. '8080' in the url 'http://server:8080/' */
	function getPort(){
		return this.port;
	}

	/* Returns the query part of this URL, i.e. 'Open' in the url 'http://server/?Open' */
	function getQuery(){
		return this.query;
	}

	/* Returns the protocol of this URL, i.e. 'http' in the url 'http://server/' */
	function getProtocol(){
		return this.protocol;
	}

	/* Returns the host name of this URL, i.e. 'server.com' in the url 'http://server.com/' */
	function getHost(){
		return this.host;
	}

	/* Returns the user name part of this URL, i.e. 'joe' in the url 'http://joe@server.com/' */
	function getUserName(){
		return this.username;
	}

	/* Returns the password part of this url, i.e. 'secret' in the url 'http://joe:secret@server.com/' */
	function getPassword(){
		return this.password;
	}

	/* Returns the file part of this url, i.e. everything after the host name. */
	function getFile(){
		return this.file;
	}

	/* Returns the reference of this url, i.e. 'bookmark' in the url 'http://server/file.html#bookmark' */
	function getReference(){
		return this.reference;
	}

	/* Returns the file path of this url, i.e. '/dir/file.html' in the url 'http://server/dir/file.html' */
	function getPath(){
		return this.path;
	}

	/* Returns the FIRST matching value to the specified key in the query.
	   If the url has a non-value argument, like 'Open' in '?Open&bla=12', this method
	   returns the same as the key: 'Open'...
	   The url must be correctly encoded, ampersands must encoded as &amp;
	   I.e. returns 'value' if the key is 'key' in the url 'http://server/?Open&amp;key=value' */
	function getArgumentValue(key){
		var a=this.getArgumentValues();
		if(a.length<1) return '';
		for(var i=0;i<a.length;i++){
			if(a[i][0]==key) return a[i][1];
		}
		return '';
	}

	/* Returns all key / value pairs in the query as a two dimensional array */
	function getArgumentValues(){
		var a=new Array();
		var b=this.query.split('&amp;');
		var c='';
		if(b.length<1) return a;
		for(var i=0;i<b.length;i++){
			c=b[i].split('=');
			a[i]=new Array(c[0],((c.length==1)?c[0]:c[1]));
		}
		return a;
	}

	/* Returns a String representation of this url */
	function toString(){
		return this.url;
	}
}/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
Ext.ns("sitools.common.utils");

/**
 * An utility class to use in sitools.
 */
sitools.common.utils.Utils = {
	/**
	 * Transform an Array of Sitools properties (with field name, value) into an object.
	 * @param {Array} array the array to transform
	 * @return {Object} An object containing all properties as attributes.
	 */
	arrayProperties2Object : function (array) {
		var result = {};
		Ext.each(array, function(item){
			if (!Ext.isEmpty(item.name) && !Ext.isEmpty(item.value)) {
				result[item.name] = item.value;
			}
		});
		return result;
	}, 
	/**
	 * Highlight a json string inside a <pre> html tag 
	 */
	syntaxHighlight : function (json) {
        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
            var cls = 'number';
            if (/^"/.test(match)) {
                if (/:$/.test(match)) {
                    cls = 'key';
                } else {
                    cls = 'string';
                }
            } else if (/true|false/.test(match)) {
                cls = 'boolean';
            } else if (/null/.test(match)) {
                cls = 'null';
            }
            return '<span class="' + cls + '">' + match + '</span>';
        });
    }
}

sitoolsUtils = sitools.common.utils.Utils;
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/**
 * @class Ext.ux.StatusBar
 * <p>Basic status bar component that can be used as the bottom toolbar of any {@link Ext.Panel}.  In addition to
 * supporting the standard {@link Ext.Toolbar} interface for adding buttons, menus and other items, the StatusBar
 * provides a greedy status element that can be aligned to either side and has convenient methods for setting the
 * status text and icon.  You can also indicate that something is processing using the {@link #showBusy} method.</p>
 * <pre><code>
new Ext.Panel({
    title: 'StatusBar',
    // etc.
    bbar: new Ext.ux.StatusBar({
        id: 'my-status',

        // defaults to use when the status is cleared:
        defaultText: 'Default status text',
        defaultIconCls: 'default-icon',

        // values to set initially:
        text: 'Ready',
        iconCls: 'ready-icon',

        // any standard Toolbar items:
        items: [{
            text: 'A Button'
        }, '-', 'Plain Text']
    })
});

// Update the status bar later in code:
var sb = Ext.getCmp('my-status');
sb.setStatus({
    text: 'OK',
    iconCls: 'ok-icon',
    clear: true // auto-clear after a set interval
});

// Set the status bar to show that something is processing:
sb.showBusy();

// processing....

sb.clearStatus(); // once completeed
</code></pre>
 * @extends Ext.Toolbar
 * @constructor
 * Creates a new StatusBar
 * @param {Object/Array} config A config object
 */
Ext.ux.StatusBar = Ext.extend(Ext.Toolbar, {
    /**
     * @cfg {String} statusAlign
     * The alignment of the status element within the overall StatusBar layout.  When the StatusBar is rendered,
     * it creates an internal div containing the status text and icon.  Any additional Toolbar items added in the
     * StatusBar's {@link #items} config, or added via {@link #add} or any of the supported add* methods, will be
     * rendered, in added order, to the opposite side.  The status element is greedy, so it will automatically
     * expand to take up all sapce left over by any other items.  Example usage:
     * <pre><code>
// Create a left-aligned status bar containing a button,
// separator and text item that will be right-aligned (default):
new Ext.Panel({
    title: 'StatusBar',
    // etc.
    bbar: new Ext.ux.StatusBar({
        defaultText: 'Default status text',
        id: 'status-id',
        items: [{
            text: 'A Button'
        }, '-', 'Plain Text']
    })
});

// By adding the statusAlign config, this will create the
// exact same toolbar, except the status and toolbar item
// layout will be reversed from the previous example:
new Ext.Panel({
    title: 'StatusBar',
    // etc.
    bbar: new Ext.ux.StatusBar({
        defaultText: 'Default status text',
        id: 'status-id',
        statusAlign: 'right',
        items: [{
            text: 'A Button'
        }, '-', 'Plain Text']
    })
});
</code></pre>
     */
    /**
     * @cfg {String} defaultText
     * The default {@link #text} value.  This will be used anytime the status bar is cleared with the
     * <tt>useDefaults:true</tt> option (defaults to '').
     */
    /**
     * @cfg {String} defaultIconCls
     * The default {@link #iconCls} value (see the iconCls docs for additional details about customizing the icon).
     * This will be used anytime the status bar is cleared with the <tt>useDefaults:true</tt> option (defaults to '').
     */
    /**
     * @cfg {String} text
     * A string that will be <b>initially</b> set as the status message.  This string
     * will be set as innerHTML (html tags are accepted) for the toolbar item.
     * If not specified, the value set for <code>{@link #defaultText}</code>
     * will be used.
     */
    /**
     * @cfg {String} iconCls
     * A CSS class that will be <b>initially</b> set as the status bar icon and is
     * expected to provide a background image (defaults to '').
     * Example usage:<pre><code>
// Example CSS rule:
.x-statusbar .x-status-custom {
    padding-left: 25px;
    background: transparent url(images/custom-icon.gif) no-repeat 3px 2px;
}

// Setting a default icon:
var sb = new Ext.ux.StatusBar({
    defaultIconCls: 'x-status-custom'
});

// Changing the icon:
sb.setStatus({
    text: 'New status',
    iconCls: 'x-status-custom'
});
</code></pre>
     */

    /**
     * @cfg {String} cls
     * The base class applied to the containing element for this component on render (defaults to 'x-statusbar')
     */
    cls : 'x-statusbar',
    /**
     * @cfg {String} busyIconCls
     * The default <code>{@link #iconCls}</code> applied when calling
     * <code>{@link #showBusy}</code> (defaults to <tt>'x-status-busy'</tt>).
     * It can be overridden at any time by passing the <code>iconCls</code>
     * argument into <code>{@link #showBusy}</code>.
     */
    busyIconCls : 'x-status-busy',
    /**
     * @cfg {String} busyText
     * The default <code>{@link #text}</code> applied when calling
     * <code>{@link #showBusy}</code> (defaults to <tt>'Loading...'</tt>).
     * It can be overridden at any time by passing the <code>text</code>
     * argument into <code>{@link #showBusy}</code>.
     */
    busyText : 'Loading...',
    /**
     * @cfg {Number} autoClear
     * The number of milliseconds to wait after setting the status via
     * <code>{@link #setStatus}</code> before automatically clearing the status
     * text and icon (defaults to <tt>5000</tt>).  Note that this only applies
     * when passing the <tt>clear</tt> argument to <code>{@link #setStatus}</code>
     * since that is the only way to defer clearing the status.  This can
     * be overridden by specifying a different <tt>wait</tt> value in
     * <code>{@link #setStatus}</code>. Calls to <code>{@link #clearStatus}</code>
     * always clear the status bar immediately and ignore this value.
     */
    autoClear : 5000,

    /**
     * @cfg {String} emptyText
     * The text string to use if no text has been set.  Defaults to
     * <tt>'&nbsp;'</tt>).  If there are no other items in the toolbar using
     * an empty string (<tt>''</tt>) for this value would end up in the toolbar
     * height collapsing since the empty string will not maintain the toolbar
     * height.  Use <tt>''</tt> if the toolbar should collapse in height
     * vertically when no text is specified and there are no other items in
     * the toolbar.
     */
    emptyText : '&nbsp;',

    // private
    activeThreadId : 0,

    // private
    initComponent : function(){
        if(this.statusAlign=='right'){
            this.cls += ' x-status-right';
        }
        Ext.ux.StatusBar.superclass.initComponent.call(this);
    },

    // private
    afterRender : function(){
        Ext.ux.StatusBar.superclass.afterRender.call(this);

        var right = this.statusAlign == 'right';
        this.currIconCls = this.iconCls || this.defaultIconCls;
        this.statusEl = new Ext.Toolbar.TextItem({
            cls: 'x-status-text ' + (this.currIconCls || ''),
            text: this.text || this.defaultText || ''
        });

        if(right){
            this.add('->');
            this.add(this.statusEl);
        }else{
            this.insert(0, this.statusEl);
            this.insert(1, '->');
        }
        this.doLayout();
    },

    /**
     * Sets the status {@link #text} and/or {@link #iconCls}. Also supports automatically clearing the
     * status that was set after a specified interval.
     * @param {Object/String} config A config object specifying what status to set, or a string assumed
     * to be the status text (and all other options are defaulted as explained below). A config
     * object containing any or all of the following properties can be passed:<ul>
     * <li><tt>text</tt> {String} : (optional) The status text to display.  If not specified, any current
     * status text will remain unchanged.</li>
     * <li><tt>iconCls</tt> {String} : (optional) The CSS class used to customize the status icon (see
     * {@link #iconCls} for details). If not specified, any current iconCls will remain unchanged.</li>
     * <li><tt>clear</tt> {Boolean/Number/Object} : (optional) Allows you to set an internal callback that will
     * automatically clear the status text and iconCls after a specified amount of time has passed. If clear is not
     * specified, the new status will not be auto-cleared and will stay until updated again or cleared using
     * {@link #clearStatus}. If <tt>true</tt> is passed, the status will be cleared using {@link #autoClear},
     * {@link #defaultText} and {@link #defaultIconCls} via a fade out animation. If a numeric value is passed,
     * it will be used as the callback interval (in milliseconds), overriding the {@link #autoClear} value.
     * All other options will be defaulted as with the boolean option.  To customize any other options,
     * you can pass an object in the format:<ul>
     *    <li><tt>wait</tt> {Number} : (optional) The number of milliseconds to wait before clearing
     *    (defaults to {@link #autoClear}).</li>
     *    <li><tt>anim</tt> {Number} : (optional) False to clear the status immediately once the callback
     *    executes (defaults to true which fades the status out).</li>
     *    <li><tt>useDefaults</tt> {Number} : (optional) False to completely clear the status text and iconCls
     *    (defaults to true which uses {@link #defaultText} and {@link #defaultIconCls}).</li>
     * </ul></li></ul>
     * Example usage:<pre><code>
// Simple call to update the text
statusBar.setStatus('New status');

// Set the status and icon, auto-clearing with default options:
statusBar.setStatus({
    text: 'New status',
    iconCls: 'x-status-custom',
    clear: true
});

// Auto-clear with custom options:
statusBar.setStatus({
    text: 'New status',
    iconCls: 'x-status-custom',
    clear: {
        wait: 8000,
        anim: false,
        useDefaults: false
    }
});
</code></pre>
     * @return {Ext.ux.StatusBar} this
     */
    setStatus : function(o){
        o = o || {};

        if(typeof o == 'string'){
            o = {text:o};
        }
        if(o.text !== undefined){
            this.setText(o.text);
        }
        if(o.iconCls !== undefined){
            this.setIcon(o.iconCls);
        }

        if(o.clear){
            var c = o.clear,
                wait = this.autoClear,
                defaults = {useDefaults: true, anim: true};

            if(typeof c == 'object'){
                c = Ext.applyIf(c, defaults);
                if(c.wait){
                    wait = c.wait;
                }
            }else if(typeof c == 'number'){
                wait = c;
                c = defaults;
            }else if(typeof c == 'boolean'){
                c = defaults;
            }

            c.threadId = this.activeThreadId;
            this.clearStatus.defer(wait, this, [c]);
        }
        return this;
    },

    /**
     * Clears the status {@link #text} and {@link #iconCls}. Also supports clearing via an optional fade out animation.
     * @param {Object} config (optional) A config object containing any or all of the following properties.  If this
     * object is not specified the status will be cleared using the defaults below:<ul>
     * <li><tt>anim</tt> {Boolean} : (optional) True to clear the status by fading out the status element (defaults
     * to false which clears immediately).</li>
     * <li><tt>useDefaults</tt> {Boolean} : (optional) True to reset the text and icon using {@link #defaultText} and
     * {@link #defaultIconCls} (defaults to false which sets the text to '' and removes any existing icon class).</li>
     * </ul>
     * @return {Ext.ux.StatusBar} this
     */
    clearStatus : function(o){
        o = o || {};

        if(o.threadId && o.threadId !== this.activeThreadId){
            // this means the current call was made internally, but a newer
            // thread has set a message since this call was deferred.  Since
            // we don't want to overwrite a newer message just ignore.
            return this;
        }

        var text = o.useDefaults ? this.defaultText : this.emptyText,
            iconCls = o.useDefaults ? (this.defaultIconCls ? this.defaultIconCls : '') : '';

        if(o.anim){
            // animate the statusEl Ext.Element
            this.statusEl.el.fadeOut({
                remove: false,
                useDisplay: true,
                scope: this,
                callback: function(){
                    this.setStatus({
	                    text: text,
	                    iconCls: iconCls
	                });

                    this.statusEl.el.show();
                }
            });
        }else{
            // hide/show the el to avoid jumpy text or icon
            this.statusEl.hide();
	        this.setStatus({
	            text: text,
	            iconCls: iconCls
	        });
            this.statusEl.show();
        }
        return this;
    },

    /**
     * Convenience method for setting the status text directly.  For more flexible options see {@link #setStatus}.
     * @param {String} text (optional) The text to set (defaults to '')
     * @return {Ext.ux.StatusBar} this
     */
    setText : function(text){
        this.activeThreadId++;
        this.text = text || '';
        if(this.rendered){
            this.statusEl.setText(this.text);
        }
        return this;
    },

    /**
     * Returns the current status text.
     * @return {String} The status text
     */
    getText : function(){
        return this.text;
    },

    /**
     * Convenience method for setting the status icon directly.  For more flexible options see {@link #setStatus}.
     * See {@link #iconCls} for complete details about customizing the icon.
     * @param {String} iconCls (optional) The icon class to set (defaults to '', and any current icon class is removed)
     * @return {Ext.ux.StatusBar} this
     */
    setIcon : function(cls){
        this.activeThreadId++;
        cls = cls || '';

        if(this.rendered){
	        if(this.currIconCls){
	            this.statusEl.removeClass(this.currIconCls);
	            this.currIconCls = null;
	        }
	        if(cls.length > 0){
	            this.statusEl.addClass(cls);
	            this.currIconCls = cls;
	        }
        }else{
            this.currIconCls = cls;
        }
        return this;
    },

    /**
     * Convenience method for setting the status text and icon to special values that are pre-configured to indicate
     * a "busy" state, usually for loading or processing activities.
     * @param {Object/String} config (optional) A config object in the same format supported by {@link #setStatus}, or a
     * string to use as the status text (in which case all other options for setStatus will be defaulted).  Use the
     * <tt>text</tt> and/or <tt>iconCls</tt> properties on the config to override the default {@link #busyText}
     * and {@link #busyIconCls} settings. If the config argument is not specified, {@link #busyText} and
     * {@link #busyIconCls} will be used in conjunction with all of the default options for {@link #setStatus}.
     * @return {Ext.ux.StatusBar} this
     */
    showBusy : function(o){
        if(typeof o == 'string'){
            o = {text:o};
        }
        o = Ext.applyIf(o || {}, {
            text: this.busyText,
            iconCls: this.busyIconCls
        });
        return this.setStatus(o);
    }
});
Ext.reg('statusbar', Ext.ux.StatusBar);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, ID, i18n, showResponse, alertFailure,clog,window,Base64 */
Ext.namespace('sitools.userProfile');

/*
 * defurl: default page url to load if click on Cancel button url: url to
 * request if click on Login button handler: if request is OK then is called
 * register: url to set to Register button reset: url to set to Reset Password
 * button
 */

sitools.userProfile.LoginUtils = {

    connect : function (config) {
        var url = loadUrl.get('APP_URL') + "/login-details";
        Ext.Ajax.request({
            method : "GET",
            url : url,
            success : function (ret) {
                var Json = Ext.decode(ret.responseText);
                if (Json.success) {
                    var data = Json.data;
                    var delegateLogin = false;
                    var delegateLoginUrl = null;

                    Ext.each(data, function (property) {
                        if (property.name === "Starter.SECURITY.DELEGATE_LOGIN") {
                            delegateLogin = (property.value === "true");
                        }
                        if (property.name === "Starter.SECURITY.DELEGATE_LOGIN_URL") {
                            delegateLoginUrl = property.value;
                        }
                    });

                    if (delegateLogin) {
                        if (Ext.isEmpty(delegateLoginUrl)) {
                            Ext.Msg.alert(i18n.get("label.warning"), "No Logout url defined");
                            return;
                        }
                        sitools.userProfile.LoginUtils.delegateLoginLogout(delegateLoginUrl);
                    } else {
                        sitools.userProfile.LoginUtils.sitoolsLogin(config);
                    }

                } else {
                    // if the parameters are not available perform classic login
                    sitools.userProfile.LoginUtils.sitoolsLogin(config);
                }
            },
            failure : function () {
                // if the parameters are not available perform classic login
                sitools.userProfile.LoginUtils.sitoolsLogin(config);
            }

        });
    },

    logout : function () {
        var url = loadUrl.get('APP_URL') + "/login-details";
        Ext.Ajax.request({
            method : "GET",
            url : url,
            success : function (ret) {
                var Json = Ext.decode(ret.responseText);
                if (Json.success) {
                    var data = Json.data;
                    var delegateLogout = false;
                    var delegateLogoutUrl = null;

                    Ext.each(data, function (property) {
                        if (property.name === "Starter.SECURITY.DELEGATE_LOGOUT") {
                            delegateLogout = (property.value === "true");
                        }
                        if (property.name === "Starter.SECURITY.DELEGATE_LOGOUT_URL") {
                            delegateLogoutUrl = property.value;
                        }
                    });
                        
                    utils_logout(!delegateLogout);
                    if (delegateLogout) {
                        if (Ext.isEmpty(delegateLogoutUrl)) {
                            Ext.Msg.alert(i18n.get("label.warning"), "No Logout url defined");
                            return;
                        }
                        sitools.userProfile.LoginUtils.delegateLoginLogout(delegateLogoutUrl);
                    }

                } else {
                    // if the parameters are not available perform classic
                    // logout
                    utils_logout(true);
                }
            },
            failure : function () {
                // if the parameters are not available perform classic logout
                utils_logout(true);
            }

        });

    },
    /**
     * 
     * @param config
     */
    editProfile : function (callback) {
        var url = loadUrl.get('APP_URL') + "/login-details";
        Ext.Ajax.request({
            method : "GET",
            url : url,
            success : function (ret) {
                var Json = Ext.decode(ret.responseText);
                if (Json.success) {
                    var data = Json.data;
                    var delegateUserManagment = false;
                    var delegateUserManagmentUrl = null;

                    Ext.each(data, function (property) {
                        if (property.name === "Starter.SECURITY.DELEGATE_USER_MANAGMENT") {
                            delegateUserManagment = (property.value === "true");
                        }
                        if (property.name === "Starter.SECURITY.DELEGATE_USER_MANAGMENT_URL") {
                            delegateUserManagmentUrl = property.value;
                        }
                    });
                    
                    if (delegateUserManagment) {
                        if (Ext.isEmpty(delegateUserManagmentUrl)) {
                            Ext.Msg.alert(i18n.get("label.warning"), "No user managment url defined");
                            return;
                        }
                        sitools.userProfile.LoginUtils.delegateLoginLogout(delegateUserManagmentUrl);
                    } else {
                        // if the parameters are not available perform classic
                        // user managment
                        callback.call();
                    }

                } else {
                    // if the parameters are not available perform classic
                    // user managment
                    callback.call();
                }
            },
            failure : function () {
                // if the parameters are not available perform classic logout
                callback.call();
            }

        });

    },

    sitoolsLogin : function (config) {
        new sitools.userProfile.Login(config).show();
    },

    delegateLoginLogout : function (urlTemplate) {
        var url = urlTemplate.replace("{goto}", document.URL);
        window.open(url, "_self");
    },
    
    

};
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, ID, i18n, showResponse, alertFailure,clog,window,Base64 */
Ext.namespace('sitools.userProfile');

/*
 * defurl: default page url to load if click on Cancel button url: url to
 * request if click on Login button handler: if request is OK then is called
 * register: url to set to Register button reset: url to set to Reset Password
 * button
 */

sitools.userProfile.Login = Ext.extend(Ext.Window, {
    id : 'winLogin',
    layout : 'hbox',
    width : 392,
    height : 220,
    resizable : false,
    closable : false,
    modal : true,
    initComponent : function () {
        this.title = i18n.get('label.login');
        this.bbar = new Ext.ux.StatusBar({
            text : i18n.get('label.ready'),
            id : 'sbWinLogin',
            iconCls : 'x-status-valid',
            items : [ {
                text : i18n.get('label.passwordLost'),
                hidden : !this.reset,
                scope : this,
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/wadl.gif',
                iconAlign : 'right',
                handler : function () {
                    Ext.getCmp('winLogin').close();
                    var reset = new sitools.userProfile.resetPassword({
                        closable : this.closable,
                        url : this.reset,
                        handler : this.handler
                    });
                    reset.show();
                }

            } ]
        });
        this.combo = new Ext.form.ComboBox({
            typeAhead : true,
            triggerAction : 'all',
            forceSelection : true,
            allowBlank : false,
            lazyRender : true,
            mode : 'local',
            store : new Ext.data.ArrayStore({
                id : 0,
                fields : [ 'myId', 'displayText' ],
                data : [ [ 1, i18n.get('label.userPortal') ], [ 2, i18n.get('label.administration') ] ]
            }),
            valueField : 'myId',
            displayField : 'displayText',
            anchor : '80%',
            value : 1,
            fieldLabel : i18n.get('label.target'),
            hideLabel : true
        });
        if (this.chooseLocation) {
            this.combo.setVisible(true);
            this.combo.hideLabel = false;
        } else {
            this.combo.setVisible(false);
//            this.setSize(392, 160);
            this.setSize(392, 175);
        }
        this.items = [ {
            xtype : 'form',
            frame : true,
            border : false,
            buttonAlign : 'center',
            id : 'frmLogin',
            width : 392,
            labelWidth : 100,
            padding : "10px 10px 0px 60px",
            bodyStyle : "background-image: url("+loadUrl.get('APP_URL')+"/common/res/images/ux/login-big.gif);" +
			"background-position: top left;" +
			"background-repeat: no-repeat;",
            items : [ {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.login'),
                name : 'login',
                id : 'logId',
                allowBlank : false,
                anchor : '80%',
                listeners : {
                    afterrender : function (login) {
                        login.focus(false, 100);
                    }
                }
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.password'),
                name : 'password',
                id : 'pwdId',
                allowBlank : false,
                inputType : 'password',
                anchor : '80%',
                listeners : {
                    scope : this,
                    specialkey : function (field, e) {
                        if (e.getKey() == e.ENTER) {
                            this.getAuth();
                        }
                    }
                }
            }, this.combo ],
            buttons : [ {
                text : i18n.get('label.login'),
                handler : this.getAuth,
                scope : this
            }, {
                text : i18n.get('label.reset'),
                handler : function () {
                    Ext.getCmp('frmLogin').getForm().reset();
                    Ext.getCmp('sbWinLogin').setStatus({
                        text : i18n.get('label.ready'),
                        iconCls : 'x-status-valid'
                    });
                }
            }, {
                text : i18n.get('label.cancel'),
                hidden : !this.defurl,
                scope : this,
                handler : function () {
                    window.location.href = this.defurl;
                }
            }, {
                text : i18n.get('label.register'),
                hidden : !this.register,
                scope : this,
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/refresh.png',
                handler : function () {
                    Ext.getCmp('winLogin').close();
                    var register = new sitools.userProfile.Register({
                        closable : this.closable,
                        url : this.register,
                        login : this.url,
                        handler : this.handler
                    });
                    register.show();
                }
            } ]
        } ];

        sitools.userProfile.Login.superclass.initComponent.call(this);
    },

    getAuth : function () {
        /*
         * var usr = Ext.getCmp('logId').getValue(); var pwd =
         * Ext.getCmp('pwdId').getValue(); var tok = usr + ':' + pwd; var hash =
         * Base64.encode(tok); var auth = 'Basic ' + hash;
         * Ext.util.Cookies.set('hashCode', auth);
         * Ext.apply(Ext.Ajax.defaultHeaders, { "Authorization" : auth });
         * this.login();
         */

        Ext.util.Cookies.set('A1', "");
        Ext.util.Cookies.set('userLogin', "");
        Ext.util.Cookies.set('scheme', "");
        Ext.util.Cookies.set('algorithm', "");
        Ext.util.Cookies.set('realm', "");
        Ext.util.Cookies.set('nonce', "");
        Ext.util.Cookies.set('hashCode', "");
        Ext.apply(Ext.Ajax.defaultHeaders, {
            "Authorization" : ""
        });

        Ext.Ajax.request({
            url : this.url,
            method : 'GET',
            scope : this,
            success : function (response, opts) {
                var Json = Ext.decode(response.responseText);
                var date = new Date();
                if (!Ext.isEmpty(Json.data)) {
                    if (Json.data.scheme == 'HTTP_Digest') {
                        var auth = new Digest({
                            usr : Ext.getCmp('logId').getValue(),
                            pwd : Ext.getCmp('pwdId').getValue(),
                            realm : Json.data.realm
                        });
                        var A1 = auth.getA1();

                        // stockage en cookie du mode d'authorization
                        Ext.util.Cookies.set('A1', A1);
                        Ext.util.Cookies.set('userLogin', auth.usr, date.add(Date.MINUTE, 1));
                        Ext.util.Cookies.set('scheme', Json.data.scheme);
                        Ext.util.Cookies.set('algorithm', Json.data.algorithm);
                        Ext.util.Cookies.set('realm', auth.realm);
                        Ext.util.Cookies.set('nonce', Json.data.nonce);

                    } else if (Json.data.scheme == "HTTP_Basic") {
                        var usr = Ext.getCmp('logId').getValue();
                        var pwd = Ext.getCmp('pwdId').getValue();
                        var tok = usr + ':' + pwd;
                        var hash = Base64.encode(tok);
                        var auth = 'Basic ' + hash;

                        // stockage en cookie du mode d'authorization
                        Ext.util.Cookies.set('userLogin', usr, date.add(Date.MINUTE, 1));
                        Ext.util.Cookies.set('scheme', Json.data.scheme);
                        Ext.util.Cookies.set('hashCode', auth, date.add(Date.MINUTE, 1));
                    }
                }

                this.login();
            },
            failure : alertFailure
        });

    },
    login : function () {
        if (!Ext.getCmp('frmLogin').getForm().isValid()) {
            Ext.getCmp('sbWinLogin').setStatus({
                text : i18n.get('warning.checkForm'),
                iconCls : 'x-status-error'
            });
            return;
        }

        Ext.getCmp('winLogin').body.mask();
        Ext.getCmp('sbWinLogin').showBusy();
        Ext.Ajax.request({
            url : this.url,
            method : 'GET',
            scope : this,
            success : function (response, opts) {
                try {
                    var Json = Ext.decode(response.responseText);
                    if (Json.success) {
                        // var date = new Date();
                        Ext.apply(Ext.Ajax.defaultHeaders, {
                            "Authorization" : Ext.util.Cookies.get('hashCode')
                        });

                        Ext.getCmp('winLogin').close();
                        // this.handler.call(this.scope || this);
                        if (this.chooseLocation) {
                            if (this.combo.getValue() == 1) {
                                window.location.href = loadUrl.get('APP_URL') + '/login-redirect?kwd=/client-user/index.html';
                                // window.location.href =
                                // "/sitools/client-user/index.html?authorization="
                                // + hash;
                            } else {
                                Ext.Ajax.request({
                                    url : loadUrl.get('APP_URL') + '/login-redirect?kwd=/client-admin',
                                    method : "GET",
                                    success : function (response) {
                                        Ext.Msg.alert('error login.js redirect with authorization');
                                    }
                                });
                                // window.location.href =
                                // "/sitools/client-admin";
                            }
                        } else {
                            window.location.reload();
                        }

                    } else {
                        Ext.util.Cookies.set('userLogin', "", new Date().add(Date.MINUTE, COOKIE_DURATION * -1));
                        Ext.util.Cookies.set('scheme', "", new Date().add(Date.MINUTE, COOKIE_DURATION * -1));
                        Ext.util.Cookies.set('hashCode', "", new Date().add(Date.MINUTE, COOKIE_DURATION * -1));

                        var txt = i18n.get('warning.serverError') + ': ' + Json.message;
                        Ext.getCmp('winLogin').body.unmask();
                        Ext.getCmp('sbWinLogin').setStatus({
                            // text: ret.error ? ret.error :
                            // i18n.get('warning.serverUnreachable'),
                            text : txt,
                            iconCls : 'x-status-error'
                        });

                    }
                } catch (err) {
                    Ext.Msg.alert(i18n.get('label.error'), err);
                }
            },
            failure : function (response, opts) {
                Ext.util.Cookies.set('userLogin', "", new Date().add(Date.MINUTE, COOKIE_DURATION * -1));
                Ext.util.Cookies.set('scheme', "", new Date().add(Date.MINUTE, COOKIE_DURATION * -1));
                Ext.util.Cookies.set('hashCode', "", new Date().add(Date.MINUTE, COOKIE_DURATION * -1));

                var txt;
                if (response.status == 200) {
                    var ret = Ext.decode(response.responseText).error;
                    txt = i18n.get('msg.error') + ': ' + ret;
                } else {
                    txt = i18n.get('warning.serverError') + ': ' + response.statusText;
                }
                Ext.getCmp('winLogin').body.unmask();
                Ext.getCmp('sbWinLogin').setStatus({
                    // text: ret.error ? ret.error :
                    // i18n.get('warning.serverUnreachable'),
                    text : txt,
                    iconCls : 'x-status-error'
                });
            }
        });
    }

});

Ext.reg('s-login', sitools.userProfile.Login);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document*/
Ext.namespace('sitools.userProfile');	
/*
 * config { url + handler }
 */
/**
 * @cfg {string} url the url to request when register
 * @cfg {string} login the url to login  
 * @class sitools.userProfile.Register
 * @extends Ext.Window
 */
sitools.userProfile.Register = Ext.extend(Ext.Window, {
    id: 'winRegister',
	layout: 'hbox',
	width: 420,
	height: 480,
	resizable: false,
	closable: false,
	modal: true,
  
	initComponent: function () {
		this.title = i18n.get('label.register');
		this.captchaUrl = loadUrl.get('APP_URL') + loadUrl.get('APP_INSCRIPTIONS_USER_URL') + '/captcha?width=300&height=50';
		
	    this.bbar = new Ext.ux.StatusBar({
			text: i18n.get('label.ready'),
			id: 'sbWinRegister',
			iconCls: 'x-status-valid'
		});
	    
	    this.captcha = new Ext.BoxComponent({
	        id : 'captchaBox',
	        autoEl: {
	            tag: 'img',
	            src: this.captchaUrl + '&_dc=' + new Date().getTime()
	        },
	        fieldLabel : i18n.get('label.captcha'),
	        height : 50,
	        width : 300,
	        anchor: '100%'
	    });
	    
	    this.items = [{
	    	xtype: 'form',
//			frame: false,
			border: false,
			buttonAlign: 'center',
			id: 'frmRegister',
			bodyStyle: 'padding:10px 10px 0px 60px; background:url("'+loadUrl.get('APP_URL')+'/common/res/images/ux/register-big.gif") no-repeat;',
			width: 400,
			height : 430,
			labelWidth: 120,
			items: [{
				xtype: 'textfield',
				fieldLabel: i18n.get('label.login'),
				name: 'identifier',
				id: 'regLogin',
				allowBlank: false,
	            vtype: 'uniquelogin',
	            anchor: '100%'
			}, {
				xtype: 'textfield',
				fieldLabel: i18n.get('label.firstName'),
				name: 'firstName',
				id: 'regFirstName',
				allowBlank: false,
	            anchor: '100%'
			}, {
				xtype: 'textfield',
				fieldLabel: i18n.get('label.lastName'),
				name: 'lastName',
				id: 'regLastName',
				allowBlank: false,
	            anchor: '100%'
			}, {
				xtype: 'textfield',
				fieldLabel: i18n.get('label.password'),
				name: 'password',
				allowBlank: false,
				inputType: 'password',
	            vtype: 'passwordlength',
	            id: 'pass1',
	            anchor: '100%'
			}, {
				xtype: 'textfield',
				fieldLabel: i18n.get('label.confirmPassword'),
				name: 'cpassword',
				submitValue: false,
				allowBlank: false,
				inputType: 'password',
	            id: 'pass2',
	            initialPassField: 'pass1',
	            vtype: 'password',
	            anchor: '100%'
			}, {
				xtype: 'textfield',
				fieldLabel: i18n.get('label.email'),
	            id: 'regEmail',
				name: 'email',
				vtype: 'uniqueemail',
				allowBlank: false,
	            validationEvent: '',
	            anchor: '100%'
			}, {
                xtype : 'textfield',
                name : 'organisation',
                fieldLabel : i18n.get('label.organisation'),
                anchor : '100%'
            }, {
				xtype: 'textarea',
				fieldLabel: i18n.get('label.comment'),
	            id: 'regComment',
				name: 'comment',
	            validationEvent: '',
	            height: 40,
	            anchor: '100%'
			}, 
			    this.captcha,
			{
			    xtype: 'button',
			    text: i18n.get('label.captchaReload'),
			    icon : loadUrl.get('APP_URL') + '/common/res/images/icons/refresh.png',
			    x : 150,
			    arrowAlign : 'right',
			    reloadUrl : this.captchaUrl,
                handler : function () {
                    Ext.util.Cookies.clear('captcha');
                    var box = Ext.get('captchaBox');
                    box.dom.src = this.reloadUrl + '&_dc=' + new Date().getTime();
                    box.slideIn('l');
                }
			},
			{
                xtype: 'textfield',
                fieldLabel: i18n.get('label.fieldCaptcha'),
                name: 'captcha',
                id: 'captcha',
                allowBlank: false,
                anchor: '100%'
            },
            {
				xtype: 'checkbox',
				fieldLabel: String.format(i18n.get('label.acceptCGU'), URL_CGU),
	            id: 'acceptCGU',
				name: 'acceptCGU',
	            height: 40,
	            anchor: '100%', 
	            submitValue : false
			}],
			buttons: [
				{ text: i18n.get('label.register'), handler: this.register, scope: this },
				{ text: i18n.get('label.reset'), reloadUrl : this.captchaUrl, handler: function () {
						Ext.getCmp('frmRegister').getForm().reset();
						Ext.getCmp('sbWinRegister').setStatus({
							text: i18n.get('label.ready'),
				        	iconCls: 'x-status-valid'
						});
						Ext.util.Cookies.clear('captcha');
	                    var box = Ext.get('captchaBox');
	                    box.dom.src = this.reloadUrl + '&_dc=' + new Date().getTime();
	                    box.slideIn('l');
					}
				},
					{ text: i18n.get('label.login'), hidden: !this.register, scope: this,
					icon: loadUrl.get('APP_URL') + '/common/res/images/icons/refresh.png',
					handler: function () {
		        		Ext.getCmp('winRegister').close();
		        		var login = new sitools.userProfile.Login({
		        			closable: this.closable,
		        			url: this.login,
		        			register: this.url,
		        			handler: this.handler
		        		});
		        		login.show();
					}
				}
				]
	    	}];
        sitools.userProfile.Register.superclass.initComponent.call(this);
	},
	
    register : function () {
        var f = Ext.getCmp('frmRegister').getForm();
        if (!f.findField('acceptCGU').getValue()) {
        	Ext.getCmp('sbWinRegister').setStatus({
                text: i18n.get('label.mustAcceptCGU'),
                iconCls: 'x-status-error'
            });;
        	return;
        }
        if (! f.isValid()) {
            Ext.getCmp('sbWinRegister').setStatus({
                text: i18n.get('warning.checkForm'),
                iconCls: 'x-status-error'
            });
            this.reloadCaptcha();
            return;
        }
        var putObject = new Object();
		putObject.properties = [];
        
        Ext.iterate(f.getValues(), function (key, value) {
            if (key == 'organisation') {
                putObject.properties.push({
                	name : "organisation", 
                	value : value,
                	scope : "Editable"
            	});
            } else {
                if (key != 'captcha') {
                    putObject[key] = value;
                }
            }
        }, this);
		
        var cook = Ext.util.Cookies.get('captcha');
        var capt = f.findField('captcha').getValue();
        
        Ext.getCmp('winRegister').body.mask();
        Ext.getCmp('sbWinRegister').showBusy();
		Ext.Ajax.request({
			url: this.url,
			method: 'POST',
			jsonData: putObject,
			params : {
                "captcha.id" : cook,
                "captcha.key" : capt
            },
			scope: this,
        	success: function (response, opts) {
	    		var json = Ext.decode(response.responseText);
	    		if (json.success){
	    		    new Ext.ux.Notification({
                        iconCls : 'x-icon-information',
                        title : i18n.get('label.information'),
                        html : i18n.get('label.registerSent'),
                        autoDestroy : true,
                        hideDelay : 1000
                    }).show(document);
	    			Ext.getCmp('winRegister').close();
	    		}
	    		else {
					Ext.getCmp('winRegister').body.unmask();
		            Ext.getCmp('sbWinRegister').setStatus({
		            	text : json.message,
		                iconCls: 'x-status-error'
		            });	    			
	    			
	    		}
	    		if (this.handler !== null && this.handler !== undefined) {
	    			this.handler.call(this.scope || this);
	    		}
            },
            failure: function (response, opts) {
        		var txt;
        		if (response.status == 200) {
            		var ret = Ext.decode(response.responseText).message;
            		txt = i18n.get('msg.error') + ': ' + ret;
        		} else if (response.status == 403){
        		    txt = i18n.get('msg.wrongCaptcha');        			
        		} else {
        		    txt = i18n.get('warning.serverError') + ': ' + response.statusText;
        		}
        		Ext.getCmp('winRegister').body.unmask();
	            Ext.getCmp('sbWinRegister').setStatus({
	            	text : txt,
	                iconCls: 'x-status-error'
	            });
	            this.reloadCaptcha();
	    	}
        });
    },
    
    reloadCaptcha : function () {
        Ext.util.Cookies.clear('captcha');
        var box = Ext.get('captchaBox');
        box.dom.src = this.captchaUrl + '&_dc=' + new Date().getTime();
        box.slideIn('l');
        
        var f = Ext.getCmp('frmRegister').getForm();
        var capt = f.findField('captcha').setValue("");

        
    }
   
});

Ext.reg('s-register', sitools.userProfile.Register);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
Ext.namespace('sitools.userProfile');

/**
 * A specific window to reset user password 
 * @cfg {boolean} closable Window config
 * @cfg {string} url The url to send reset request
 * @cfg {} handler A method to call after success 
 * @class sitools.userProfile.resetPassword
 * @extends Ext.Window
 */
sitools.userProfile.resetPassword = Ext.extend(Ext.Window, {
    id : 'winPassword',
    layout : 'hbox',
    width : 420,
    height : 183,
    resizable : false,
    // closable: true,
    modal : true,

    initComponent : function () {
        this.title = i18n.get('label.resetPassword');
        this.bbar = new Ext.ux.StatusBar({
            text : i18n.get('label.ready'),
            id : 'sbWinPassword',
            iconCls : 'x-status-valid'
        });
        this.items = [ {
            xtype : 'form',
//            frame : false,
            border : false,
            buttonAlign : 'center',
            id : 'frmResetPassword',
            bodyStyle : 'padding:10px 10px 0px 60px; background:url("'+loadUrl.get('APP_URL')+'/common/res/images/ux/login-big.gif") no-repeat;',
            width : 400,
            labelWidth : 120,
            items : [ {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.login'),
                name : 'identifier',
                id : 'regLogin',
                allowBlank : false,
                anchor : '100%'
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.email'),
                id : 'regEmail',
                name : 'email',
                vtype : 'uniqueemail',
                allowBlank : false,
                validationEvent : '',
                anchor : '100%'
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.emailConfirm'),
                id : 'regEmailConfirm',
                name : 'emailConfirm',
                vtype : 'uniqueemail',
                allowBlank : false,
                validationEvent : '',
                anchor : '100%'
            } ],
            buttons : [ {
                text : i18n.get('label.resetPassword'),
                handler : this.reset,
                scope : this
            }, {
                text : i18n.get('label.reset'),
                handler : function () {
                    Ext.getCmp('frmResetPassword').getForm().reset();
                    Ext.getCmp('sbWinPassword').setStatus({
                        text : i18n.get('label.ready'),
                        iconCls : 'x-status-valid'
                    });
                }
            } ]
        } ];
        sitools.userProfile.resetPassword.superclass.initComponent.call(this);
    },
    reset : function () {
        var f = Ext.getCmp('frmResetPassword').getForm();
        if (f.findField('email').getValue() != f.findField('emailConfirm').getValue()) {
            Ext.getCmp('sbWinPassword').setStatus({
                text : i18n.get('warning.checkForm'),
                iconCls : 'x-status-error'
            });
            return;
        }

        if (!f.isValid()) {
            Ext.getCmp('sbWinPassword').setStatus({
                text : i18n.get('warning.checkForm'),
                iconCls : 'x-status-error'
            });
            return;
        }
        var putObject = new Object();
        Ext.iterate(f.getValues(), function (key, value) {
            if (key != 'emailConfirm') {
                putObject[key] = value;
            }
        }, this);

        Ext.getCmp('winPassword').body.mask();
        Ext.getCmp('sbWinPassword').showBusy();
        Ext.Ajax.request({
            url : this.url,
            method : 'PUT',
            jsonData : putObject,
            scope : this,
            success : function (response, opts) {
                var json = Ext.decode(response.responseText);
                if (json.success) {
                    Ext.getCmp('winPassword').body.unmask();
                    Ext.getCmp('sbWinPassword').setStatus({
                        text : json.message,
                        iconCls : 'x-status-valid'
                    });
                    Ext.getCmp('winPassword').close();
                    
                    var notify = new Ext.ux.Notification({
                        iconCls : 'x-icon-information',
                        title : i18n.get('label.information'),
                        html : i18n.get('label.passwordSent') + json.message,
                        autoDestroy : true,
                        hideDelay : 1300
                    });
                    notify.show(document);
                } else {
                    Ext.getCmp('winPassword').body.unmask();
                    Ext.getCmp('sbWinPassword').setStatus({
                        text : json.message,
                        iconCls : 'x-status-error'
                    });

                }
                if (this.handler !== null && this.handler !== undefined) {
                    this.handler.call(this.scope || this);
                }
            },
            failure : function (response, opts) {
                var txt;
                if (response.status == 200) {
                    var ret = Ext.decode(response.responseText).message;
                    txt = i18n.get('msg.error') + ': ' + ret;
                } else {
                    txt = i18n.get('warning.serverError') + ': ' + response.statusText;
                }
                Ext.getCmp('winPassword').body.unmask();
                Ext.getCmp('sbWinPassword').setStatus({
                    text : txt,
                    iconCls : 'x-status-error'
                });
            }
        });
    }
});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, i18n,document */
Ext.namespace('sitools.userProfile');
/*
 * config { url + handler }
 */
sitools.userProfile.editProfile = Ext.extend(Ext.Panel, {
//    id : 'winEditProfile',
//    layout : 'hbox',
//    width : 420,
//    height : 410,
//    resizable : false,
//    closable : true,
//    modal : true,
	padding : "10px 10px 0px 60px",
	frame : true,
	layout : "fit", 

    initComponent : function () {
    	this.bodyStyle = "background-image: url("+loadUrl.get('APP_URL')+"/common/res/images/ux/login-big.gif);" +
    			"background-position: top left;" +
    			"background-repeat: no-repeat;";

//        this.title = i18n.get('label.editProfile');
        this.bbar = new Ext.ux.StatusBar({
            text : i18n.get('label.ready'),
            id : 'sbWinEditProfile',
            iconCls : 'x-status-valid'
        });

        var storeProperties = new Ext.data.JsonStore({
            fields : [ {
                name : 'name',
                type : 'string'
            }, {
                name : 'value',
                type : 'string'
            }, {
                name : 'scope',
                type : 'string'
            } ],
            autoLoad : false
        });
        var smProperties = new Ext.grid.RowSelectionModel({
            singleSelect : true
        });

        var cmProperties = new Ext.grid.ColumnModel({
            columns : [ {
                header : i18n.get('headers.name'),
                dataIndex : 'name',
                editor : new Ext.form.TextField({
                    readOnly : true
                })
            }, {
                header : i18n.get('headers.value'),
                dataIndex : 'value',
                editor : new Ext.form.TextField({
                    allowBlank : false
                })
            }],
            defaults : {
                sortable : false,
                width : 100
            }
        });

        this.gridProperties = new Ext.grid.EditorGridPanel({
            title : i18n.get('title.properties'),
            id : 'userGridProperties',
            height : 130,
            autoScroll : true,
            clicksToEdit : 1,
            store : storeProperties,
            cm : cmProperties,
            sm : smProperties,
            viewConfig : {
                forceFit : true,
                getRowClass : function (row, col) { 
                    var data = row.data;
                    if (data.scope == 'ReadOnly') {
                        return "row-grid-readOnly"; 
                    }
                } 
            },
            listeners : {
                beforeedit : function (e) {
                    var scope = e.record.data.scope;
                    var name = e.field;
                    if (scope == 'ReadOnly' || name == 'name') {
                        return false;
                    }
                }
            }
        });
        
        this.items = [ {
            xtype : 'form',
            flex : 1, 
            border : false,
            buttonAlign : 'center',
            id : 'frmEditProfile',
            labelWidth : 120,
            items : [ {
                xtype : 'textfield',
                name : 'identifier',
                fieldLabel : i18n.get('label.login'),
                anchor : '100%',
                allowBlank : false,
                readOnly : true,
                style : {
                    color : '#C0C0C0'
                },
                id : "nameField"
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.firstName'),
                name : 'firstName',
                id : 'regFirstName',
                allowBlank : false,
                anchor : '100%'
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.lastName'),
                name : 'lastName',
                id : 'regLastName',
                allowBlank : false,
                anchor : '100%'
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.password'),
                anchor : '100%',
                inputType : 'password',
                name : 'secret',
                value : '',
                id : "passwordField",
                vtype : 'passwordlength'
            }, {
                id : "confirmSecret",
                xtype : 'textfield',
                fieldLabel : i18n.get('label.confirmPassword'),
                anchor : '100%',
                inputType : 'password',
                initialPassField : 'passwordField',
                vtype : 'password',
                name : 'confirmSecret',
                submitValue : false,
                value : ''
            }, {
                xtype : 'textfield',
                fieldLabel : i18n.get('label.email'),
                id : 'regEmail',
                name : 'email',
                vtype : 'uniqueemail',
                allowBlank : false,
                validationEvent : '',
                anchor : '100%'
            }, this.gridProperties ],
            buttons : [ {
                text : i18n.get('label.saveEdit'),
                x : 30,
                handler : this.saveEdit,
                scope : this
            }]
        } ];
        
        sitools.userProfile.editProfile.superclass.initComponent.call(this);
        
    },

    saveEdit : function () {
        var f = Ext.getCmp('frmEditProfile').getForm();

        if (!f.isValid()) {
            Ext.getCmp('sbWinEditProfile').setStatus({
                text : i18n.get('warning.checkForm'),
                iconCls : 'x-status-error'
            });
            return;
        }

        var putObject = f.getValues();
        putObject.properties = [];
        this.gridProperties.getStore().each(function (item) {
            putObject.properties.push({
                name : item.data.name,
                value : item.data.value,
                scope : item.data.scope
            });
        });

        this.body.mask();
        Ext.getCmp('sbWinEditProfile').showBusy();

        Ext.Ajax.request({
            url : this.url,
            method : 'PUT',
            jsonData : putObject,
            scope : this,
            success : function (response, opts) {
                var json = Ext.decode(response.responseText);
                if (json.success) {
                    this.ownerCt.close();
                    
                    var notify = new Ext.ux.Notification({
                        iconCls : 'x-icon-information',
                        title : i18n.get('label.information'),
                        html : json.message,
                        autoDestroy : true,
                        hideDelay : 1000
                    });
                    notify.show(document);
                } else {
                    Ext.getCmp('winEditProfile').body.unmask();
                    Ext.getCmp('sbWinEditProfile').setStatus({
                        text : json.message,
                        iconCls : 'x-status-error'
                    });

                }
                if (this.handler !== null && this.handler !== undefined) {
                    this.handler.call(this.scope || this, putObject);
                }
            },
            failure : function (response, opts) {
                var txt;
                if (response.status == 200) {
                    var ret = Ext.decode(response.responseText).message;
                    txt = i18n.get('msg.error') + ': ' + ret;
                } else {
                    txt = i18n.get('warning.serverError') + ': ' + response.statusText;
                }
                Ext.getCmp('winEditProfile').body.unmask();
                Ext.getCmp('sbWinEditProfile').setStatus({
                    text : txt,
                    iconCls : 'x-status-error'
                });
            }
        });
    },

    onRender : function () {
        sitools.userProfile.editProfile.superclass.onRender.apply(this, arguments);
        if (this.url) {
            Ext.Ajax.request({
                url : this.url,
                method : 'GET',
                scope : this,
                success : function (ret) {
                    var f = this.findByType('form')[0].getForm();
                    var data = Ext.decode(ret.responseText);
                    if (data.user !== undefined) {
                        f.setValues(data.user);
                        f.findField('secret').setValue('');
                        if (!Ext.isEmpty(data.user.properties)) {
                            Ext.each(data.user.properties, function (property) {
                                var rec = new Ext.data.Record({
                                    name : property.name,
                                    value : property.value,
                                    scope : property.scope
                                });
                                this.gridProperties.getStore().add(rec);
                            }, this);
                        }
                    }
                },
                failure : alertFailure
            });
        }
    },
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }

});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
var loginErrLength = 'Login minimum 4 character !';
var loginErrUnique = 'Login already in use !';
var loginSuccess = 'Login avaliable';
var emailErrFormat = 'Email not valid !';
var emailErrUnique = 'Email already in use !';
var emailSuccess = 'Email valid & avaliable';

Ext.apply(Ext.form.VTypes, {
    uniqueloginMask : /[a-z0-9_\.\-@\+]/i,
	uniquelogin : function(val) {
        if (val.length < 4) {
            Ext.apply(Ext.form.VTypes, {
                uniqueloginText: loginErrLength
            });
            return false;
        } else {
            /*Ext.Ajax.request({
                url: 'user/ext_is_unique_login',
                method: 'POST',
                params: 'login=' + val,
                success: function(o) {
                    if (o.responseText == 0) {
                        resetLoginValidator(false);
                        Ext.apply(Ext.form.VTypes, {
                            uniqueloginText: loginErrUnique
                        });
                        return false;
                    } else {
                        resetLoginValidator(true);
                    }
                }
            });*/
            return true;
        }
	},
	uniqueloginText : loginErrUnique,

    uniqueemailMask : /[a-z0-9_\.\-@\+]/i,
    uniqueemail : function(val) {
        var uniqueemail = /^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/;
        if (uniqueemail.test(val)) {
        	/*
            Ext.Ajax.request({
                url: BASE_URL + 'user/ext_is_unique_email',
                method: 'POST',
                params: 'email=' + val,
                success: function(o) {
                    if (o.responseText == 0) {
                        resetEmailValidator(false);
                        Ext.apply(Ext.form.VTypes, {
                            uniqueemailText: emailErrUnique
                        });
                    } else {
                        resetEmailValidator(true);
                    }
                }
            });*/
            return true;
        } else {
            return false;
        }

    },
    uniqueemailText : emailErrFormat,

    password : function(val, field) {
        if (field.initialPassField) {
            var pwd = Ext.getCmp(field.initialPassField);
            return (val == pwd.getValue());
        }
        return true;
    },
    passwordText : 'Passwords do not match',

    passwordlength : function(val) {
        if (val.length < 6 || val.length > 40) {
            return false;
        } else {
            return true;
        }
    },
    passwordlengthText : 'Invalid Password Length. It must be between 6 and 40'
});

function resetLoginValidator(is_error) {
	Ext.apply(Ext.form.VTypes, {
		uniquelogin : function(val) {
            if (val.length < 4) {
                Ext.apply(Ext.form.VTypes, {
                    uniqueloginText: loginErrLength
                });
                return false;
            } else {
            	/*
                Ext.Ajax.request({
                    url: 'user/ext_is_unique_login',
                    method: 'POST',
                    params: 'login=' + val,
                    success: function(o) {
                        if (o.responseText == 0) {
                            resetLoginValidator(false);
                        } else {
                            resetLoginValidator(true);
                        }
                    }
                });
                return is_error;
                */return true;
            }
		}
	});
}

function resetEmailValidator(value) {
    Ext.apply(Ext.form.VTypes, {
        uniqueemail : function(val) {
            var uniqueemail = /^(\w+)([\-+.][\w]+)*@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/;
            if (uniqueemail.test(val)) {
                /*Ext.Ajax.request({
                    url: BASE_URL + 'user/ext_is_unique_email',
                    method: 'POST',
                    params: 'email=' + val,
                    success: function(o) {
                        if (o.responseText == 0) {
                            resetEmailValidator(false);
                            Ext.apply(Ext.form.VTypes, {
                                uniqueemailText: emailErrUnique
                            });
                        } else {
                            resetEmailValidator(true);
                        }
                    }
                });*/return true;
            } else {
                return false;
            }
            return (value);
        }
    });
}
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/

/**  (c) 2007-2008 Timo Michna / www.matikom.de
*  All rights reserved
*
*  This script is free software; you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation; either version 3 of the License, or
*  (at your option) any later version.
*
*  The GNU General Public License can be found at
*  http://www.gnu.org/copyleft/gpl.html.
*
*
*  This script is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  This copyright notice MUST APPEAR in all copies of the script!
***************************************************************/

/***************************************************************
*  For commercial use, ask the author for permission and different license
***************************************************************/


Ext.namespace('Ext.ux');
Ext.namespace('Ext.ux.Plugin');

Ext.ux.Plugin.LiteRemoteComponent = function (config){
	var defaultType = config.xtype || 'panel';
    var callback = function(res){ 
		this.container.add(Ext.ComponentMgr.create(Ext.decode(res.responseText), defaultType)).show();
		this.container.doLayout() ;
	};
    return{
		init : function (container){
			this.container = container;
			Ext.Ajax.request(Ext.apply(config, {success: callback, scope: this}));
    	}
	}
};

/**
 * @author Timo Michna / matikom
 * @class Ext.ux.Plugin.RemoteComponent
 * @extends Ext.util.Observable
 * @constructor
 * @param {Object} config
 * @version 0.3.0
 * Plugin for Ext.Container/Ext.Toolbar Elements to dynamically 
 * add Components from a remote source to the Element�s body.  
 * Loads configuration as JSON-String from a remote source. 
 * Creates the Components from configuration.
 * Adds the Components to the Container body.
 * Additionally to its own config options the class accepts all the 
 * configuration options required to configure its internal Ext.Ajax.request().
 */
Ext.ux.Plugin.RemoteComponent = function (config){

   /**
    * @cfg {String} breakOn 
	* set to one of the plugins events, to stop any 
    * further processing of the plugin, when the event fires.
    */
   /**
    * @cfg {mixed} loadOn 
	* Set to one of the Containers events {String}, to defer 
    * further processing of the plugin to when the event fires.
	* Set as an object literal {event: 'event', scope: 'scope'}
    * to listen for a different components (not the container) event.
    * Set to an numeric Array to listen to different events or components.
    * Use String or Literal style in numeric Array. Plugin will load by
	* the first occurence of any of the events. 
    */
   /**
	* @cfg {String} xtype 
	* Default xtype for loaded toplevel component.
	* Overwritten by config.xtype or xtype declaration 
	* Defaults to 'panel'
	* in loaded toplevel component.
	*/
   /**
	* @cfg {Boolean} purgeSubscribers 
	* set to 'true' to avoid unsubstribing all listeners after successfull process chain 
	* Defaults to false
	*/
   /**
	* @cfg {Mixed el} mask 
	* The element or DOM node, or its id to mask with loading indicator  
	*/
   /**
	* @cfg {Object} maskConfig 
	* Configuration for LoadMask.
	* only effective if config option 'mask' is set.    
	*/
	var defaultType = config.xtype || 'panel';
	Ext.applyIf(config, {
		purgeSubscribers:true
	});
	this.initialConfig = config;
    Ext.apply(this, config);
    //this.purgeSubscribers = config.purgeSubscribers || true;
    this.addEvents({
	    /**
	     * @event beforeload
	     * Fires before AJAX request. Return false to stop further processing.
	     * @param {Object} config
	     * @param {Ext.ux.Plugin.RemoteComponent} this
	     */
        'beforeload' : true,
	    /**
	     * @event beforecreate
	     * Fires before creation of new Components from AJAX response. 
		 * Return false to stop further processing.
	     * @param {Object} JSON-Object decoded from AJAX response
	     * @param {Ext.ux.Plugin.RemoteComponent} this
	     */
        'beforecreate' : true,
	    /**
	     * @event beforeadd
	     * Fires before adding the new Components to the Container. 
		 * Return false to stop further processing.
	     * @param {Object} new Components created from AJAX response.
	     * @param {Ext.ux.Plugin.RemoteComponent} this
	     */
        'beforeadd' : true,
	    /**
	     * @event beforecomponshow
	     * Fires before show() is called on the new Components. 
		 * Return false to stop further processing.
	     * @param {Object} new Components created from AJAX response.
	     * @param {Ext.ux.Plugin.RemoteComponent} this
	     */
        'beforecomponshow': true,
	    /**
	     * @event beforecontainshow
	     * Fires before show() is called on the Container. 
		 * Return false to stop further processing.
	     * @param {Object} new Components created from AJAX response.
	     * @param {Ext.ux.Plugin.RemoteComponent} this
	     */
        'beforecontainshow': true,
	    /**
	     * @event success
	     * Fires after full process chain. 
		 * Return false to stop further processing.
	     * @param {Object} new Components created from AJAX response.
	     * @param {Ext.ux.Plugin.RemoteComponent} this
	     */
        'success': true
    });
	Ext.ux.Plugin.RemoteComponent.superclass.constructor.call(this, config);
	// set breakpoint 
	if(config.breakOn){
	 	this.on(config.breakOn, function(){return false;});
	}
   /**
    * private
    * method adds component to container.
    * Creates Components from responseText and  
    * and populates Components in Container.
    * @param {Object} JSON Config for new component.
    */
	var renderComponent = function(JSON){
		if(this.fireEvent('beforeadd', JSON, this)){
			//this.container.initComponent();
			var component = this.container.add(JSON);
			
			component.fireEvent ('bodyResize', this);
			//alert (this.container.ownerCt.height());
			if(this.fireEvent('beforecomponshow', component, this)){
				return component;	
			} 				
		} 
	}.createDelegate(this);
   /**
    * private
    * Callback method for successful Ajax request.
    * Creates Components from responseText and  
    * and populates Components in Container.
    * @param {Object} response object from successful AJAX request.
    */
    var callback = function(res){ 
        var JSON = Ext.decode(res.responseText);
		if(this.fireEvent('beforecreate', JSON, this)){
			var component = null;
			//JSON = JSON instanceof Array ? JSON[0] : JSON;
			if(JSON instanceof Array){
				Ext.each(JSON, function(j, i){
						component = renderComponent(j).show();;
				});			
			}else{
				component = renderComponent(JSON).show();
			}
			if(this.fireEvent('beforecontainshow', component, this)){
				this.container.ownerCt.doLayout();
				this.fireEvent('success', component, this);
			} 				
		}   
		if(this.purgeSubscribers){
			this.purgeListeners();				
		}
	}.createDelegate(this);
   /**
    * public
    * Processes the AJAX request.
    * Generally only called internal. Can be called external,
    * when processing has been stopped or defered by config
    * options breakOn or loadOn.
    */
	this.load = function(){
		if(this.fireEvent('beforeload', config, this)){
			if(config.mask){
				var mask = new Ext.LoadMask(Ext.getDom(config.mask), Ext.apply({msg:'loading components...'}, config.maskConfig || {}));	
				mask.show();
				this.on('success', mask.hide, mask);
			}
			Ext.Ajax.request(Ext.apply(config, {success: callback, scope: this}));				
		} 
	};
   /**
    * public
    * Initialization method called by the Container.
    */
    this.init = function (container){
		container.on('beforedestroy', function(){this.purgeListeners();}, this);
		this.container = container;
		if(config.loadOn){		 	
			if(config.loadOn instanceof Array){
				Ext.each(config.loadOn, function(l, i, a){
					var evt = l.event || l.loadOn;
					var defer = function (){
						this.load();
						Ext.each(a, function(lo){
							(lo.scope || container).un(evt, defer, this);	
						}.createDelegate(this));
					}.createDelegate(this);
					(l.scope || container).on(evt, defer, this);					
				}.createDelegate(this));
			}else{
				(config.loadOn.scope || container).on((config.loadOn.event || config.loadOn), this.load, this, {single:true});							
			}
		}else{
			this.load();	
		}           
    };
};
Ext.extend(Ext.ux.Plugin.RemoteComponent, Ext.util.Observable);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.3.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
Ext.ns('Ext.ux.form');

/**
 * @class Ext.ux.form.MultiSelect
 * @extends Ext.form.Field
 * A control that allows selection and form submission of multiple list items.
 *
 *  @history
 *    2008-06-19 bpm Original code contributed by Toby Stuart (with contributions from Robert Williams)
 *    2008-06-19 bpm Docs and demo code clean up
 *
 * @constructor
 * Create a new MultiSelect
 * @param {Object} config Configuration options
 * @xtype multiselect
 */
Ext.ux.form.MultiSelect = Ext.extend(Ext.form.Field,  {
    /**
     * @cfg {String} legend Wraps the object with a fieldset and specified legend.
     */
    /**
     * @cfg {Ext.ListView} view The {@link Ext.ListView} used to render the multiselect list.
     */
    /**
     * @cfg {String/Array} dragGroup The ddgroup name(s) for the MultiSelect DragZone (defaults to undefined).
     */
    /**
     * @cfg {String/Array} dropGroup The ddgroup name(s) for the MultiSelect DropZone (defaults to undefined).
     */
    /**
     * @cfg {Boolean} ddReorder Whether the items in the MultiSelect list are drag/drop reorderable (defaults to false).
     */
    ddReorder:false,
    /**
     * @cfg {Object/Array} tbar The top toolbar of the control. This can be a {@link Ext.Toolbar} object, a
     * toolbar config, or an array of buttons/button configs to be added to the toolbar.
     */
    /**
     * @cfg {String} appendOnly True if the list should only allow append drops when drag/drop is enabled
     * (use for lists which are sorted, defaults to false).
     */
    appendOnly:false,
    /**
     * @cfg {Number} width Width in pixels of the control (defaults to 100).
     */
    width:100,
    /**
     * @cfg {Number} height Height in pixels of the control (defaults to 100).
     */
    height:100,
    /**
     * @cfg {String/Number} displayField Name/Index of the desired display field in the dataset (defaults to 0).
     */
    displayField:0,
    /**
     * @cfg {String/Number} valueField Name/Index of the desired value field in the dataset (defaults to 1).
     */
    valueField:1,
    /**
     * @cfg {Boolean} allowBlank False to require at least one item in the list to be selected, true to allow no
     * selection (defaults to true).
     */
    allowBlank:true,
    /**
     * @cfg {Number} minSelections Minimum number of selections allowed (defaults to 0).
     */
    minSelections:0,
    /**
     * @cfg {Number} maxSelections Maximum number of selections allowed (defaults to Number.MAX_VALUE).
     */
    maxSelections:Number.MAX_VALUE,
    /**
     * @cfg {String} blankText Default text displayed when the control contains no items (defaults to the same value as
     * {@link Ext.form.TextField#blankText}.
     */
    blankText:Ext.form.TextField.prototype.blankText,
    /**
     * @cfg {String} minSelectionsText Validation message displayed when {@link #minSelections} is not met (defaults to 'Minimum {0}
     * item(s) required').  The {0} token will be replaced by the value of {@link #minSelections}.
     */
    minSelectionsText:'Minimum {0} item(s) required',
    /**
     * @cfg {String} maxSelectionsText Validation message displayed when {@link #maxSelections} is not met (defaults to 'Maximum {0}
     * item(s) allowed').  The {0} token will be replaced by the value of {@link #maxSelections}.
     */
    maxSelectionsText:'Maximum {0} item(s) allowed',
    /**
     * @cfg {String} delimiter The string used to delimit between items when set or returned as a string of values
     * (defaults to ',').
     */
    delimiter:',',
    /**
     * @cfg {Ext.data.Store/Array} store The data source to which this MultiSelect is bound (defaults to <tt>undefined</tt>).
     * Acceptable values for this property are:
     * <div class="mdetail-params"><ul>
     * <li><b>any {@link Ext.data.Store Store} subclass</b></li>
     * <li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally.
     * <div class="mdetail-params"><ul>
     * <li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">
     * A 1-dimensional array will automatically be expanded (each array item will be the combo
     * {@link #valueField value} and {@link #displayField text})</div></li>
     * <li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">
     * For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo
     * {@link #valueField value}, while the value at index 1 is assumed to be the combo {@link #displayField text}.
     * </div></li></ul></div></li></ul></div>
     */

    // private
    defaultAutoCreate : {tag: "div"},

    // private
    initComponent: function(){
    	Ext.ux.form.MultiSelect.superclass.initComponent.call(this);

        if(Ext.isArray(this.store)){
            if (Ext.isArray(this.store[0])){
                this.store = new Ext.data.ArrayStore({
                    fields: ['value','text'],
                    data: this.store
                });
                this.valueField = 'value';
            }else{
                this.store = new Ext.data.ArrayStore({
                    fields: ['text'],
                    data: this.store,
                    expandData: true
                });
                this.valueField = 'text';
            }
            this.displayField = 'text';
        } else {
            this.store = Ext.StoreMgr.lookup(this.store);
            this.displayField = this.store.displayField;
            this.valueField = this.store.valueField;
        }

        this.addEvents({
            'dblclick' : true,
            'click' : true,
            'change' : true,
            'drop' : true
        });
    },

    // private
    onRender: function(ct, position){
        Ext.ux.form.MultiSelect.superclass.onRender.call(this, ct, position);

        var fs = this.fs = new Ext.form.FieldSet({
            renderTo: this.el,
            title: this.legend,
            height: this.height - 20,
            width: this.width,
            style: "padding:0;",
            tbar: this.tbar
        });
        fs.body.addClass('ux-mselect');

        this.view = new Ext.ListView({
            multiSelect: true,
            store: this.store,
            columns: [{ header: 'Value', width: 1, dataIndex: this.displayField }],
            hideHeaders: true
        });

        fs.add(this.view);

        this.view.on('click', this.onViewClick, this);
        this.view.on('beforeclick', this.onViewBeforeClick, this);
        this.view.on('dblclick', this.onViewDblClick, this);

        this.hiddenName = this.name || Ext.id();
        var hiddenTag = { tag: "input", type: "hidden", value: "", name: this.hiddenName };
        this.hiddenField = this.el.createChild(hiddenTag);
        this.hiddenField.dom.disabled = this.hiddenName != this.name;
        fs.doLayout();
    },

    // private
    afterRender: function(){
        Ext.ux.form.MultiSelect.superclass.afterRender.call(this);

        if (this.ddReorder && !this.dragGroup && !this.dropGroup){
            this.dragGroup = this.dropGroup = 'MultiselectDD-' + Ext.id();
        }

        if (this.draggable || this.dragGroup){
            this.dragZone = new Ext.ux.form.MultiSelect.DragZone(this, {
                ddGroup: this.dragGroup
            });
        }
        if (this.droppable || this.dropGroup){
            this.dropZone = new Ext.ux.form.MultiSelect.DropZone(this, {
                ddGroup: this.dropGroup
            });
        }
        
        if (this.values) {
        	this.setValue(this.values);
        }
    },

    // private
    onViewClick: function(vw, index, node, e) {
        this.fireEvent('change', this, this.getValue(), this.hiddenField.dom.value);
        this.hiddenField.dom.value = this.getValue();
        this.fireEvent('click', this, e);
        this.validate();
    },

    // private
    onViewBeforeClick: function(vw, index, node, e) {
        if (this.disabled || this.readOnly) {
            return false;
        }
    },

    // private
    onViewDblClick : function(vw, index, node, e) {
        return this.fireEvent('dblclick', vw, index, node, e);
    },

    /**
     * Returns an array of data values for the selected items in the list. The values will be separated
     * by {@link #delimiter}.
     * @return {Array} value An array of string data values
     */
    getValue: function(valueField){
        var returnArray = [];
        var selectionsArray = this.view.getSelectedIndexes();
        if (selectionsArray.length == 0) {return '';}
        for (var i=0; i<selectionsArray.length; i++) {
            var returnValue = this.store.getAt(selectionsArray[i]).get((valueField != null) ? valueField : this.valueField);
            if (Ext.isString(returnValue)){
                returnValue = returnValue;
            }

            returnArray.push(returnValue);
        }        return returnArray.join(this.delimiter);
    },

    /**
     * Sets a delimited string (using {@link #delimiter}) or array of data values into the list.
     * @param {String/Array} values The values to set
     */
    setValue: function(values) {
        var index;
        var selections = [];
        this.view.clearSelections();
        this.hiddenField.dom.value = '';

        if (!values || (values == '')) { return; }

        if (!Ext.isArray(values)) { values = values.split(this.delimiter); }
        for (var i=0; i<values.length; i++) {
            index = this.view.store.indexOf(this.view.store.query(this.valueField,
                new RegExp('^' + values[i] + '$', "i")).itemAt(0));
            selections.push(index);
        }
        this.view.select(selections);
        this.hiddenField.dom.value = this.getValue();
        this.validate();
    },

    // inherit docs
    reset : function() {
        this.setValue('');
    },

    // inherit docs
    getRawValue: function(valueField) {
        var tmp = this.getValue(valueField);
        if (tmp.length) {
            tmp = tmp.split(this.delimiter);
        }
        else {
            tmp = [];
        }
        return tmp;
    },

    // inherit docs
    setRawValue: function(values){
        setValue(values);
    },

    // inherit docs
    validateValue : function(value){
        if (value.length < 1) { // if it has no value
             if (this.allowBlank) {
                 this.clearInvalid();
                 return true;
             } else {
                 this.markInvalid(this.blankText);
                 return false;
             }
        }
        if (value.length < this.minSelections) {
            this.markInvalid(String.format(this.minSelectionsText, this.minSelections));
            return false;
        }
        if (value.length > this.maxSelections) {
            this.markInvalid(String.format(this.maxSelectionsText, this.maxSelections));
            return false;
        }
        return true;
    },

    // inherit docs
    disable: function(){
        this.disabled = true;
        if (!Ext.isEmpty(this.hiddenField)){
            this.hiddenField.dom.disabled = true;
        }
        if (!Ext.isEmpty(this.fs)){
        	this.fs.disable();
        }
    },

    // inherit docs
    enable: function(){
        this.disabled = false;
        this.hiddenField.dom.disabled = false;
        this.fs.enable();
    },

    // inherit docs
    destroy: function(){
        Ext.destroy(this.fs, this.dragZone, this.dropZone);
        Ext.ux.form.MultiSelect.superclass.destroy.call(this);
    }
});


Ext.reg('multiselect', Ext.ux.form.MultiSelect);

//backwards compat
Ext.ux.Multiselect = Ext.ux.form.MultiSelect;


Ext.ux.form.MultiSelect.DragZone = function(ms, config){
    this.ms = ms;
    this.view = ms.view;
    var ddGroup = config.ddGroup || 'MultiselectDD';
    var dd;
    if (Ext.isArray(ddGroup)){
        dd = ddGroup.shift();
    } else {
        dd = ddGroup;
        ddGroup = null;
    }
    Ext.ux.form.MultiSelect.DragZone.superclass.constructor.call(this, this.ms.fs.body, { containerScroll: true, ddGroup: dd });
    this.setDraggable(ddGroup);
};

Ext.extend(Ext.ux.form.MultiSelect.DragZone, Ext.dd.DragZone, {
    onInitDrag : function(x, y){
        var el = Ext.get(this.dragData.ddel.cloneNode(true));
        this.proxy.update(el.dom);
        el.setWidth(el.child('em').getWidth());
        this.onStartDrag(x, y);
        return true;
    },

    // private
    collectSelection: function(data) {
        data.repairXY = Ext.fly(this.view.getSelectedNodes()[0]).getXY();
        var i = 0;
        this.view.store.each(function(rec){
            if (this.view.isSelected(i)) {
                var n = this.view.getNode(i);
                var dragNode = n.cloneNode(true);
                dragNode.id = Ext.id();
                data.ddel.appendChild(dragNode);
                data.records.push(this.view.store.getAt(i));
                data.viewNodes.push(n);
            }
            i++;
        }, this);
    },

    // override
    onEndDrag: function(data, e) {
        var d = Ext.get(this.dragData.ddel);
        if (d && d.hasClass("multi-proxy")) {
            d.remove();
        }
    },

    // override
    getDragData: function(e){
        var target = this.view.findItemFromChild(e.getTarget());
        if(target) {
            if (!this.view.isSelected(target) && !e.ctrlKey && !e.shiftKey) {
                this.view.select(target);
                this.ms.setValue(this.ms.getValue());
            }
            if (this.view.getSelectionCount() == 0 || e.ctrlKey || e.shiftKey) return false;
            var dragData = {
                sourceView: this.view,
                viewNodes: [],
                records: []
            };
            if (this.view.getSelectionCount() == 1) {
                var i = this.view.getSelectedIndexes()[0];
                var n = this.view.getNode(i);
                dragData.viewNodes.push(dragData.ddel = n);
                dragData.records.push(this.view.store.getAt(i));
                dragData.repairXY = Ext.fly(n).getXY();
            } else {
                dragData.ddel = document.createElement('div');
                dragData.ddel.className = 'multi-proxy';
                this.collectSelection(dragData);
            }
            return dragData;
        }
        return false;
    },

    // override the default repairXY.
    getRepairXY : function(e){
        return this.dragData.repairXY;
    },

    // private
    setDraggable: function(ddGroup){
        if (!ddGroup) return;
        if (Ext.isArray(ddGroup)) {
            Ext.each(ddGroup, this.setDraggable, this);
            return;
        }
        this.addToGroup(ddGroup);
    }
});

Ext.ux.form.MultiSelect.DropZone = function(ms, config){
    this.ms = ms;
    this.view = ms.view;
    var ddGroup = config.ddGroup || 'MultiselectDD';
    var dd;
    if (Ext.isArray(ddGroup)){
        dd = ddGroup.shift();
    } else {
        dd = ddGroup;
        ddGroup = null;
    }
    Ext.ux.form.MultiSelect.DropZone.superclass.constructor.call(this, this.ms.fs.body, { containerScroll: true, ddGroup: dd });
    this.setDroppable(ddGroup);
};

Ext.extend(Ext.ux.form.MultiSelect.DropZone, Ext.dd.DropZone, {
    /**
     * Part of the Ext.dd.DropZone interface. If no target node is found, the
     * whole Element becomes the target, and this causes the drop gesture to append.
     */
    getTargetFromEvent : function(e) {
        var target = e.getTarget();
        return target;
    },

    // private
    getDropPoint : function(e, n, dd){
        if (n == this.ms.fs.body.dom) { return "below"; }
        var t = Ext.lib.Dom.getY(n), b = t + n.offsetHeight;
        var c = t + (b - t) / 2;
        var y = Ext.lib.Event.getPageY(e);
        if(y <= c) {
            return "above";
        }else{
            return "below";
        }
    },

    // private
    isValidDropPoint: function(pt, n, data) {
        if (!data.viewNodes || (data.viewNodes.length != 1)) {
            return true;
        }
        var d = data.viewNodes[0];
        if (d == n) {
            return false;
        }
        if ((pt == "below") && (n.nextSibling == d)) {
            return false;
        }
        if ((pt == "above") && (n.previousSibling == d)) {
            return false;
        }
        return true;
    },

    // override
    onNodeEnter : function(n, dd, e, data){
        return false;
    },

    // override
    onNodeOver : function(n, dd, e, data){
        var dragElClass = this.dropNotAllowed;
        var pt = this.getDropPoint(e, n, dd);
        if (this.isValidDropPoint(pt, n, data)) {
            if (this.ms.appendOnly) {
                return "x-tree-drop-ok-below";
            }

            // set the insert point style on the target node
            if (pt) {
                var targetElClass;
                if (pt == "above"){
                    dragElClass = n.previousSibling ? "x-tree-drop-ok-between" : "x-tree-drop-ok-above";
                    targetElClass = "x-view-drag-insert-above";
                } else {
                    dragElClass = n.nextSibling ? "x-tree-drop-ok-between" : "x-tree-drop-ok-below";
                    targetElClass = "x-view-drag-insert-below";
                }
                if (this.lastInsertClass != targetElClass){
                    Ext.fly(n).replaceClass(this.lastInsertClass, targetElClass);
                    this.lastInsertClass = targetElClass;
                }
            }
        }
        return dragElClass;
    },

    // private
    onNodeOut : function(n, dd, e, data){
        this.removeDropIndicators(n);
    },

    // private
    onNodeDrop : function(n, dd, e, data){
        if (this.ms.fireEvent("drop", this, n, dd, e, data) === false) {
            return false;
        }
        var pt = this.getDropPoint(e, n, dd);
        if (n != this.ms.fs.body.dom)
            n = this.view.findItemFromChild(n);

        if(this.ms.appendOnly) {
            insertAt = this.view.store.getCount();
        } else {
            insertAt = n == this.ms.fs.body.dom ? this.view.store.getCount() - 1 : this.view.indexOf(n);
            if (pt == "below") {
                insertAt++;
            }
        }

        var dir = false;

        // Validate if dragging within the same MultiSelect
        if (data.sourceView == this.view) {
            // If the first element to be inserted below is the target node, remove it
            if (pt == "below") {
                if (data.viewNodes[0] == n) {
                    data.viewNodes.shift();
                }
            } else {  // If the last element to be inserted above is the target node, remove it
                if (data.viewNodes[data.viewNodes.length - 1] == n) {
                    data.viewNodes.pop();
                }
            }

            // Nothing to drop...
            if (!data.viewNodes.length) {
                return false;
            }

            // If we are moving DOWN, then because a store.remove() takes place first,
            // the insertAt must be decremented.
            if (insertAt > this.view.store.indexOf(data.records[0])) {
                dir = 'down';
                insertAt--;
            }
        }

        for (var i = 0; i < data.records.length; i++) {
            var r = data.records[i];
            if (data.sourceView) {
                data.sourceView.store.remove(r);
            }
            this.view.store.insert(dir == 'down' ? insertAt : insertAt++, r);
            var si = this.view.store.sortInfo;
            if(si){
                this.view.store.sort(si.field, si.direction);
            }
        }
        return true;
    },

    // private
    removeDropIndicators : function(n){
        if(n){
            Ext.fly(n).removeClass([
                "x-view-drag-insert-above",
                "x-view-drag-insert-left",
                "x-view-drag-insert-right",
                "x-view-drag-insert-below"]);
            this.lastInsertClass = "_noclass";
        }
    },

    // private
    setDroppable: function(ddGroup){
        if (!ddGroup) return;
        if (Ext.isArray(ddGroup)) {
            Ext.each(ddGroup, this.setDroppable, this);
            return;
        }
        this.addToGroup(ddGroup);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document,projectGlobal,userStorage*/
Ext.ns('Ext.ux');
Ext.ux.stateFullWindow = Ext.extend(Ext.Window, {
    saveSettings : function (componentSettings, forPublicUser) {
	    if (Ext.isEmpty(userLogin)) {
		    Ext.Msg.alert(i18n.get('label.warning', 'label.needLogin'));
		    return;
	    }
	    var position = Ext.encode(this.getPosition(true));
	    var size = Ext.encode(this.getSize());

	    var putObject = {};

	    // putObject['datasetId'] = datasetId;
	    // putObject['componentType'] = componentType;
	    putObject.componentSettings = componentSettings;

	    putObject.windowSettings = {};
	    putObject.windowSettings.size = size;
	    putObject.windowSettings.position = position;
	    putObject.windowSettings.specificType = this.specificType;
	    putObject.windowSettings.moduleId = this.getId();
	    putObject.windowSettings.typeWindow = this.typeWindow;
	    putObject.windowSettings.maximized = this.maximized;
	    
	    var baseFilePath = "/" + DEFAULT_PREFERENCES_FOLDER + "/" + projectGlobal.projectName;
	    
	    var filePath = componentSettings.preferencesPath;
	    var fileName = componentSettings.preferencesFileName;
	    if (Ext.isEmpty(filePath) || Ext.isEmpty(fileName)) {
	    	return;
	    }
	    
	    filePath = baseFilePath + filePath;
	    
	    if (forPublicUser) {
	    	publicStorage.set(fileName, filePath, putObject);
	    }
	    else {
	    	userStorage.set(fileName, filePath, putObject);
	    }
	    return putObject;
    }, 
    //Change the posistion when maximizing the window (according to the desktop position
    maximize : function(){
        if(!this.maximized){
            this.expand(false);
            this.restoreSize = this.getSize();
            this.restorePos = this.getPosition(true);
            if (this.maximizable){
                this.tools.maximize.hide();
                this.tools.restore.show();
            }
            this.maximized = true;
            this.el.disableShadow();

            if(this.dd){
                this.dd.lock();
            }
            if(this.collapsible){
                this.tools.toggle.hide();
            }
            this.el.addClass('x-window-maximized');
            this.container.addClass('x-window-maximized-ct');

            this.setPosition(0,0);
            this.fitContainer();
            this.fireEvent('maximize', this);
        }
        return this;
    }
    
});
Ext.reg('statewindow', Ext.ux.stateFullWindow);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
Ext.namespace("Ext.ux");
Ext.ux.NotificationMgr = {
positions: []
};
Ext.ux.Notification = Ext.extend(Ext.Window, {
    initComponent: function(){
        Ext.apply(this, {
            iconCls: this.iconCls || 'x-icon-information',
            cls: 'x-notification',
            width: 200,
            autoHeight: true,
            plain: false,
            draggable: false,
            shadow:false,
            bodyStyle: 'text-align:center'
        });
        if(this.autoDestroy) {
            this.task = new Ext.util.DelayedTask(this.hide, this);
        } else {
            this.closable = true;
        }
        Ext.ux.Notification.superclass.initComponent.apply(this);
    },
    setMessage: function(msg){
        this.body.update(msg);
    },
    setTitle: function(title, iconCls){
        Ext.ux.Notification.superclass.setTitle.call(this, title, iconCls||this.iconCls);
    },
    onDestroy: function(){
        Ext.ux.NotificationMgr.positions.remove(this.pos);
        Ext.ux.Notification.superclass.onDestroy.call(this);   
    },
    cancelHiding: function(){
        this.addClass('fixed');
        if(this.autoDestroy) {
            this.task.cancel();
        }
    },
    afterShow: function(){
        Ext.ux.Notification.superclass.afterShow.call(this);
        Ext.fly(this.body.dom).on('click', this.cancelHiding, this);
        if(this.autoDestroy) {
            this.task.delay(this.hideDelay || 5000);
       }
    },
    animShow: function(){
        this.pos = 0;
        while(Ext.ux.NotificationMgr.positions.indexOf(this.pos)>-1)
            this.pos++;
        Ext.ux.NotificationMgr.positions.push(this.pos);
        this.setSize(200,100);
        this.el.alignTo(document, "br-br", [ -20, -140-((this.getSize().height+10)*this.pos) ]);
        this.el.slideIn('b', {
            duration: 1,
            callback: this.afterShow,
            scope: this
        });
    },
    animHide: function(){
        this.el.ghost("b", {
            duration: 1,
            remove: false,
            callback : function () {
                Ext.ux.NotificationMgr.positions.remove(this.pos);
                this.destroy();
            }.createDelegate(this)

        });
    },
    focus: Ext.emptyFn
});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, i18n, projectGlobal, alertFailure, showResponse, loadUrl, userLogin*/

Ext.ux.PersistantSelectionGridPanel = Ext.extend(Ext.grid.GridPanel, {
    selectedRecords: [],
    initComponent : function () {
        
        this.getStore().on('beforeload', this.rememberSelection, this);
        this.getView().on('refresh', this.refreshSelection, this);
        
        Ext.ux.PersistantSelectionGridPanel.superclass.initComponent.call(this);
    }, 
    
    rememberSelection: function(selModel, selectedRecords) {
        if (!this.rendered || Ext.isEmpty(this.el)) {
            return;
        }

        this.selectedRecords = this.getSelectionModel().getSelections();
    },
    
    refreshSelection: function() {
        if (0 >= this.selectedRecords.length) {
            return;
        }

        var newRecordsToSelect = [];
        for (var i = 0; i < this.selectedRecords.length; i++) {
            record = this.getStore().getById(this.selectedRecords[i].id);
            if (!Ext.isEmpty(record)) {
                newRecordsToSelect.push(record);
            }
        }

        this.getSelectionModel().selectRecords(newRecordsToSelect);
//        Ext.defer(this.setScrollTop, 30, this, [this.getView().scrollState.top]);
    }
});

Ext.reg('Ext.ux.PersistantSelectionGridPanel',Ext.ux.PersistantSelectionGridPanel);
/** 
 * @class Ext.ux.grid.filter.Filter
 * @extends Ext.util.Observable
 * Abstract base class for filter implementations.
 */

Ext.ns("sitools.widget");

sitools.widget.Filter = Ext.extend(Ext.Container, {
    /**
     * @cfg {String} columnAlias 
     * The {@link Ext.data.Store} columnAlias of the field this filter represents.
     */
    columnAlias : null,
    
	layout : "vbox",
	layoutConfig : {
		align : "left", 
		pack : "center"
	},
	specificType : "filter",
	
    constructor : function (config) {
        Ext.apply(this, config);
        this.layout = 'hbox';    
		this.columnAlias = config.columnAlias;
		this.specificType = "filter";
        sitools.widget.Filter.superclass.constructor.call(this);

        this.init(config);
        if(config && config.value){
            this.setValue(config.value);
            delete config.value;
        }
    },

    /**
     * Template method to be implemented by all subclasses that is to
     * initialize the filter and install required menu items.
     * Defaults to Ext.emptyFn.
     */
    init : Ext.emptyFn,
    
    /**
     * Template method to be implemented by all subclasses that is to
     * get and return the value of the filter.
     * Defaults to Ext.emptyFn.
     * @return {Object} The 'serialized' form of this filter
     * @methodOf Ext.ux.grid.filter.Filter
     */
    getValue : Ext.emptyFn,
    
    /**
     * Template method to be implemented by all subclasses that is to
     * set the value of the filter and fire the 'update' event.
     * Defaults to Ext.emptyFn.
     * @param {Object} data The value to set the filter
     * @methodOf Ext.ux.grid.filter.Filter
     */	
    setValue : Ext.emptyFn,
    
    /**
     * Template method to be implemented by all subclasses that is to
     * validates the provided Ext.data.Record against the filters configuration.
     * Defaults to <tt>return true</tt>.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function(){
        return true;
    }, 
    
    _getHeight : Ext.emptyFn,
    
    getFilterData : function (){
        return this.getValue();
    }


});

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
Ext.ns("sitools.widget");
sitools.widget.DateFilter = Ext.extend(sitools.widget.Filter, {
	
    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * @cfg {String} format
     * The date format to use
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',

    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    flex : 0.9, 
    style: {
        "padding-left" : '10px'
    },
    height : 60,
    
    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        config = config || {};
        this.dateFormat = Ext.isEmpty(config.format)?SITOOLS_DEFAULT_IHM_DATE_FORMAT:config.format; 
        this.inputFrom = new Ext.form.DateField({
        	anchor : "100%", 
        	fieldLabel : "ux-rangemenu-gte", 
        	format : this.dateFormat, 
        	labelStyle : "height: 10px", 
        	width : 150
        }); 
        this.inputTo = new Ext.form.DateField({
        	anchor : "100%", 
        	fieldLabel : "ux-rangemenu-lte", 
        	format : this.dateFormat, 
        	labelStyle : "height: 10px", 
        	width : 150
            
        }); 
        var formPanel = new Ext.form.FormPanel({
        	items : [this.inputFrom, this.inputTo], 
        	labelWidth : 21, 
        	bodyBorder : false, 
        	border : false,
        	layout : 'form',
        	layoutConfig : {
        		fieldTpl : new Ext.Template(
        	
				    '<div class="x-form-item {itemCls}" tabIndex="-1">',
				        '<label for="{id}" style="{labelStyle}" class="x-form-item-label {label}"></label>',
				        '<div class="x-form-element" id="x-form-el-{id}" style="{elementStyle}">',
				        '</div><div class="{clearCls}"></div>',
				    '</div>'
				)
        	}
        })
        
        
        this.add(formPanel);
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var result = [];
        if (!Ext.isEmpty(this.inputFrom.getValue())) {
        	result.push({
	        	"columnAlias" : this.columnAlias, 
	        	"data" : {
	        		"comparison" : "gte", 
	        		"value" : this.inputFrom.getValue().format(SITOOLS_DATE_FORMAT), 
	        		"type" : "date"
	        	}
	        });
        }
        if (!Ext.isEmpty(this.inputTo.getValue())) {
        	result.push({
	        	"columnAlias" : this.columnAlias, 
	        	"data" : {
	        		"comparison" : "lte", 
	        		"value" : this.inputTo.getValue().format(SITOOLS_DATE_FORMAT), 
	        		"type" : "date"
	        	}
        	});
        }
        return result;
    },
    
    getConfig : function () {
    	if (!Ext.isEmpty(this.inputFrom.getValue()) || !Ext.isEmpty(this.inputTo.getValue())) {
	 		return {
	    		"columnAlias" : this.columnAlias, 
	    		"value" : {
	    			"from" : this.inputFrom.getValue(), 
	    			"to" : this.inputTo.getValue() 
	    		}, 
	    		"type" : "date"
	    	};
    	}
    	else {
    		return null;
    	}
    	
    }, 
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
    setValue : function (value) {
        this.inputFrom.setValue(value.from);
        this.inputTo.setValue(value.to);
        
    } , 
    _getHeight : function () {
    	return this.height;
    }
});
Ext.ns("sitools.widget");
sitools.widget.StringFilter = Ext.extend(sitools.widget.Filter, {
	
    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',

    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    flex : 0.9, 
    style: {
        "padding-left" : '10px'
    },
    
    height : 30, 
    
    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        config = config || {};
        
        this.inputItem = new Ext.form.TextField({
        	anchor : "100%", 
        	fieldLabel : "ux-gridfilter-text-icon", 
        	labelStyle : "height: 10px", 
        	width : 150
        }); 
        var formPanel = new Ext.form.FormPanel({
        	items : [this.inputItem], 
        	labelWidth : 21, 
        	bodyBorder : false, 
        	border : false, 
        	layout : 'form',
        	layoutConfig : {
        		fieldTpl : new Ext.Template(
        	
				    '<div class="x-form-item {itemCls}" tabIndex="-1">',
				        '<label for="{id}" style="{labelStyle}" class="x-form-item-label {label}"></label>',
				        '<div class="x-form-element" id="x-form-el-{id}" style="{elementStyle}">',
				        '</div><div class="{clearCls}"></div>',
				    '</div>'
				)
        	}
        });
        
        
        
        this.add(formPanel);
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        if (!Ext.isEmpty(this.inputItem.getValue())) {
	        return [{
	        	"columnAlias" : this.columnAlias, 
	        	"data" : {
	        		"comparison" : "LIKE", 
	        		"value" : this.inputItem.getValue(), 
	        		"type" : "string"
	        	}
	        }];
        }
        else {
        	return [];
        }
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getConfig : function () {
     	if (!Ext.isEmpty(this.inputItem.getValue())) {
	 		return {
	    		"columnAlias" : this.columnAlias, 
	    		"value" : this.inputItem.getValue(), 
	    		"type" : "string"
	    	};
    	}
    	else {
    		return null;
    	}       
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
    setValue : function (value) {
        this.inputItem.setValue(value);
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex);

        if(typeof val != 'string') {
            return (this.getValue().length === 0);
        }

        return val.toLowerCase().indexOf(this.getValue().toLowerCase()) > -1;
    }, 
    _getHeight : function () {
    	return this.height;
    }
    
});
Ext.ns("sitools.widget");
sitools.widget.NumericFilter = Ext.extend(sitools.widget.Filter, {
	
    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',

    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    flex : 0.9, 
    style: {
        "padding-left" : '10px'
    },
    height : 60,
    
    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        config = config || {};
        
        this.inputFrom = new Ext.form.NumberField({
        	anchor : "100%", 
        	fieldLabel : "ux-rangemenu-gte", 
        	labelStyle : "height: 10px", 
        	width : 150
        }); 
        this.inputTo = new Ext.form.NumberField({
        	anchor : "100%", 
        	fieldLabel : "ux-rangemenu-lte", 
        	labelStyle : "height: 10px", 
        	width : 150
        });        
         
        var formPanel = new Ext.form.FormPanel({
        	items : [this.inputTo, this.inputFrom], 
        	labelWidth : 21, 
        	bodyBorder : false, 
        	border : false,
        	layoutConfig : {
        		fieldTpl : new Ext.Template(
        	
				    '<div class="x-form-item {itemCls}" tabIndex="-1">',
				        '<label for="{id}" style="{labelStyle}" class="x-form-item-label {label}"></label>',
				        '<div class="x-form-element" id="x-form-el-{id}" style="{elementStyle}">',
				        '</div><div class="{clearCls}"></div>',
				    '</div>'
				)
        	}
        })
        
        
        this.add(formPanel);
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var result = [];
        if (!Ext.isEmpty(this.inputFrom.getValue())) {
        	result.push({
	        	"columnAlias" : this.columnAlias, 
	        	"data" : {
	        		"comparison" : "gte", 
	        		"value" : this.inputFrom.getValue(), 
	        		"type" : "numeric"
	        	}
	        });
        }
        if (!Ext.isEmpty(this.inputTo.getValue())) {
        	result.push({
	        	"columnAlias" : this.columnAlias, 
	        	"data" : {
	        		"comparison" : "lte", 
	        		"value" : this.inputTo.getValue(), 
	        		"type" : "numeric"
	        	}
        	});
        }
        return result;
    },    
    getConfig : function () {
    	if (!Ext.isEmpty(this.inputFrom.getValue()) || !Ext.isEmpty(this.inputTo.getValue())) {
	 		return {
	    		"columnAlias" : this.columnAlias, 
	    		"value" : {
	    			"from" : this.inputFrom.getValue(), 
	    			"to" : this.inputTo.getValue() 
	    		}, 
	    		"type" : "numeric"
	    	};
    	}
    	else {
    		return null;
    	}
    }, 
    
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
    setValue : function (value) {
        this.inputFrom.setValue(value.from);
        this.inputTo.setValue(value.to);
        
    } , 
    _getHeight : function () {
    	return this.height;
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/** 
 * @class sitools.widget.FiltersCollection
 * @extends Ext.util.MixedCollection
 * Class for sitoolsFilter.getValue() collections.
 */

Ext.ns("sitools.widget");

sitools.widget.FiltersCollection = Ext.extend(Ext.util.MixedCollection, {
    
    constructor : function (config) {
        sitools.widget.FiltersCollection.superclass.constructor.call(this);
        if (!Ext.isEmpty(config)) {
            this.addAll(config.filters);
        }
    },

    
    getFilterData : function(){
        var filters = [];
        this.each(function (filter, index, length) {
            filters.push(filter);            
        });
        return filters;
    }
    
});/*
 * Ext JS Library 3.3.1
 * Copyright(c) 2006-2010 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
Ext.ns('Ext.ux.grid');

/**
 * @class Ext.ux.grid.RowExpander
 * @extends Ext.util.Observable
 * Plugin (ptype = 'rowexpander') that adds the ability to have a Column in a grid which enables
 * a second row body which expands/contracts.  The expand/contract behavior is configurable to react
 * on clicking of the column, double click of the row, and/or hitting enter while a row is selected.
 *
 * @ptype rowexpander
 */
Ext.ux.grid.RowExpander = Ext.extend(Ext.util.Observable, {
    /**
     * @cfg {Boolean} expandOnEnter
     * <tt>true</tt> to toggle selected row(s) between expanded/collapsed when the enter
     * key is pressed (defaults to <tt>true</tt>).
     */
    expandOnEnter : true,
    /**
     * @cfg {Boolean} expandOnDblClick
     * <tt>true</tt> to toggle a row between expanded/collapsed when double clicked
     * (defaults to <tt>true</tt>).
     */
    expandOnDblClick : true,

    header : '',
    width : 20,
    sortable : false,
    fixed : true,
    hideable: false,
    menuDisabled : true,
    dataIndex : '',
    id : 'expander',
    lazyRender : true,
    enableCaching : true,

    constructor: function (config) {
        Ext.apply(this, config);

        this.addEvents({
            /**
             * @event beforeexpand
             * Fires before the row expands. Have the listener return false to prevent the row from expanding.
             * @param {Object} this RowExpander object.
             * @param {Object} Ext.data.Record Record for the selected row.
             * @param {Object} body body element for the secondary row.
             * @param {Number} rowIndex The current row index.
             */
            beforeexpand: true,
            /**
             * @event expand
             * Fires after the row expands.
             * @param {Object} this RowExpander object.
             * @param {Object} Ext.data.Record Record for the selected row.
             * @param {Object} body body element for the secondary row.
             * @param {Number} rowIndex The current row index.
             */
            expand: true,
            /**
             * @event beforecollapse
             * Fires before the row collapses. Have the listener return false to prevent the row from collapsing.
             * @param {Object} this RowExpander object.
             * @param {Object} Ext.data.Record Record for the selected row.
             * @param {Object} body body element for the secondary row.
             * @param {Number} rowIndex The current row index.
             */
            beforecollapse: true,
            /**
             * @event collapse
             * Fires after the row collapses.
             * @param {Object} this RowExpander object.
             * @param {Object} Ext.data.Record Record for the selected row.
             * @param {Object} body body element for the secondary row.
             * @param {Number} rowIndex The current row index.
             */
            collapse: true
        });

        Ext.ux.grid.RowExpander.superclass.constructor.call(this);

        if (this.tpl) {
            if (typeof this.tpl == 'string') {
                this.tpl = new Ext.Template(this.tpl);
            }
            this.tpl.compile();
        }

        this.state = {};
        this.bodyContent = {};
    },

    getRowClass : function (record, rowIndex, p, ds) {
        p.cols = p.cols - 1;
        var content = this.bodyContent[record.id];
        if (!content && !this.lazyRender) {
            content = this.getBodyContent(record, rowIndex);
        }
        if (content) {
            p.body = content;
        }
        return this.state[record.id] ? 'x-grid3-row-expanded' : 'x-grid3-row-collapsed';
    },

    init : function (grid) {
        this.grid = grid;

        var view = grid.getView();
        view.getRowClass = this.getRowClass.createDelegate(this);

        view.enableRowBody = true;


        grid.on('render', this.onRender, this);
        grid.on('destroy', this.onDestroy, this);
    },

    // @private
    onRender : function () {
        var grid = this.grid;
        var mainBody = grid.getView().mainBody;
        mainBody.on('mousedown', this.onMouseDown, this, {delegate: '.x-grid3-row-expander'});
        if (this.expandOnEnter) {
            this.keyNav = new Ext.KeyNav(this.grid.getGridEl(), {
                'enter' : this.onEnter,
                scope: this
            });
        }
        if (this.expandOnDblClick) {
            grid.on('rowdblclick', this.onRowDblClick, this);
        }
    },
    
    // @private    
    onDestroy : function () {
        if (this.keyNav) {
            this.keyNav.disable();
            delete this.keyNav;
        }
        /*
         * A majority of the time, the plugin will be destroyed along with the grid,
         * which means the mainBody won't be available. On the off chance that the plugin
         * isn't destroyed with the grid, take care of removing the listener.
         */
        var mainBody = this.grid.getView().mainBody;
        if (mainBody) {
            mainBody.un('mousedown', this.onMouseDown, this);
        }
    },
    // @private
    onRowDblClick : function (grid, rowIdx, e) {
        this.toggleRow(rowIdx);
    },

    onEnter : function (e) {
        var g = this.grid;
        var sm = g.getSelectionModel();
        var sels = sm.getSelections();
        for (var i = 0, len = sels.length; i < len; i++) {
            var rowIdx = g.getStore().indexOf(sels[i]);
            this.toggleRow(rowIdx);
        }
    },

    getBodyContent : function (record, index) {
        if (!this.enableCaching) {
            return this.tpl.apply(record.data);
        }
        var content = this.bodyContent[record.id];
        if (!content) {
            content = this.tpl.apply(record.data);
            this.bodyContent[record.id] = content;
        }
        return content;
    },

    onMouseDown : function (e, t) {
		e.stopEvent();
		var row = e.getTarget('.x-grid3-row');
		this.toggleRow(row);
	},

	renderer : function (v, p, record) {
        p.cellAttr = 'rowspan="2"';
        return '<div class="x-grid3-row-expander">&#160;</div>';
    },

    beforeExpand : function (record, body, rowIndex) {
		if (this.fireEvent('beforeexpand', this, record, body, rowIndex) !== false) {
			if (this.tpl && this.lazyRender) {
				body.innerHTML = this.getBodyContent(record, rowIndex);
			}
			return true;
		} else {
			return false;
		}
    },

    toggleRow : function (row) {
		if (typeof row == 'number') {
			row = this.grid.view.getRow(row);
		}
		this[Ext.fly(row).hasClass('x-grid3-row-collapsed')
				? 'expandRow'
				: 'collapseRow'](row);
	},

	expandRow : function (row) {
		if (typeof row == 'number') {
			row = this.grid.view.getRow(row);
		}
		var record = this.grid.store.getAt(row.rowIndex);
		var body = Ext.DomQuery.selectNode('tr:nth(2) div.x-grid3-row-body',
				row);
		if (this.beforeExpand(record, body, row.rowIndex)) {
			this.state[record.id] = true;
			Ext.fly(row).replaceClass('x-grid3-row-collapsed',
					'x-grid3-row-expanded');
			this.fireEvent('expand', this, record, body, row.rowIndex);
		}
	},

	collapseRow : function (row) {
		if (typeof row == 'number') {
			row = this.grid.view.getRow(row);
		}
		var record = this.grid.store.getAt(row.rowIndex);
		var body = Ext.fly(row).child('tr:nth(1) div.x-grid3-row-body', true);
		if (this.fireEvent('beforecollapse', this, record, body, row.rowIndex) !== false) {
			this.state[record.id] = false;
			Ext.fly(row).replaceClass('x-grid3-row-expanded',
					'x-grid3-row-collapsed');
			this.fireEvent('collapse', this, record, body, row.rowIndex);
		}
	}
});

Ext.preg('rowexpander', Ext.ux.grid.RowExpander);

//backwards compat
Ext.grid.RowExpander = Ext.ux.grid.RowExpander;
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, showResponse, alertFailure*/
Ext.namespace('sitools.widget');

/**
 * Basic Box for all admin panels.
 * @class sitools.widget.Box
 * @extends Ext.Panel
 */
sitools.widget.Box = Ext.extend(Ext.Panel, {
    width : '98%',
    frame : true,
    baseCls : 'x-box',
    cls : 'x-box-blue module-root centering',
    _title : '',

    constructor : function (cfg) {

	    sitools.widget.Box.superclass.constructor.call(this, Ext.apply({
	        _title : cfg.label,
	        _idItem : cfg.idItem
	    }, cfg));
    },

    initComponent : function () {
	    this.items.unshift({
	        xtype : 'component',
	        html : this._title,
	        cls : 'subtitle icon-' + this.idItem
	    });
	    sitools.widget.Box.superclass.initComponent.call(this);
    } 
    
});
// register type
Ext.reg('s-box', sitools.widget.Box);

/**
 * A simple json store with new methods
 * @class sitools.widget.JsonStore
 * @extends Ext.data.JsonStore
 */
sitools.widget.JsonStore = Ext.extend(Ext.data.JsonStore, {
    /**
     * dirty : true if one record have been added
     * @type Boolean
     */
    dirty : false,

    /**
     * Setter for dirty
     * @param {Boolean} value
     */
    _setDirty : function (value) {
	    this.dirty = value;
    },
    /**
     * Get the dirty value
     * @return {Boolean}
     */
    _getDirty : function () {
	    return this.dirty;
    },
    /**
     * Set dirty to true
     * @param {Array} records the list of records added
     */
    add : function (records) {
	    this.dirty = true;
	    sitools.widget.JsonStore.superclass.add.call(this, records);
    },
    /**
     * Set dirty to true
     * @param {Ext.data.Record} record the record removed
     */
    remove : function (record) {
	    this.dirty = true;
	    sitools.widget.JsonStore.superclass.remove.call(this, record);
    }
});

/**
 * A simple Ext.Button with a specific iconCls
 * @class sitools.widget.menuButton
 * @extends Ext.Button
 */
sitools.widget.menuButton = Ext.extend(Ext.Button, {

	constructor : function (config) {

		config = Ext.apply({
			iconCls : 'menu-button'
		}, config);

		sitools.widget.menuButton.superclass.constructor.call(this, config);
	}
});
Ext.reg('s-menuButton', sitools.widget.menuButton);

/**
 * @class TemplateTreeNode
 * @extends Ext.tree.AsyncTreeNode
 * 
 */
sitools.widget.templateTreeNode = function (attributes) {
	var tpl;
	if (attributes.tpl === undefined) {
		tpl = new Ext.Template(
		        "<div >{text}<b>{nbRecords} records</b><img src='{urlImage}'></img><a style='text-align:right' href='{urlReadme}'>readme</a></div>");
	} else {
		tpl = attributes.tpl;
	}
	attributes.text = tpl.apply(attributes);
	attributes.leaf = false;
	var config = Ext.apply({
		children : []
	}, attributes);

	sitools.widget.templateTreeNode.superclass.constructor.call(this, config);

};

Ext.extend(sitools.widget.templateTreeNode, Ext.tree.AsyncTreeNode, {

});
// add this new node to the list of nodes
Ext.tree.TreePanel.nodeTypes.templateTreeNode = sitools.widget.templateTreeNode;

/**
 * A toolbar with buttons to move rows up or down
 * 
 * @cfg {string} gridId :
 *            the id of the grid. This is not mandatory if the grid is
 *            not the scope of the buttons
 * @class sitools.widget.GridSorterToolbar
 * @extends Ext.Toolbar
 */
sitools.widget.GridSorterToolbar = Ext.extend(Ext.Toolbar, {
    initComponent : function () {
        sitools.widget.GridSorterToolbar.superclass.initComponent.call(this);
        this.add('->', new sitools.widget.GridTop({
							gridId : this.gridId
						}), new sitools.widget.GridUp({
							gridId : this.gridId
						}), new sitools.widget.GridDown({
							gridId : this.gridId
						}), new sitools.widget.GridBottom({
							gridId : this.gridId
						}));
    }
});
Ext.reg('sitools.widget.GridSorterToolbar', sitools.widget.GridSorterToolbar);

/**
 * A RowExpander used for plugin grids to add violation informations 
 * The parameters are the same as the class Ext.ux.grid.RowExpander
 * 
 * @class sitools.admin.resourcesPlugins.violationRowExpander
 * @extends Ext.ux.grid.RowExpander
 */
sitools.widget.ViolationRowExpander = Ext.extend(
   Ext.ux.grid.RowExpander, {
        getRowClass : function (record, index, rowParams, store) {
            //call the method from the superclass
            var cls = sitools.widget.ViolationRowExpander.superclass.getRowClass.call(this,
                    record, index, rowParams, store);
            //add a class depending on the violation type
            var violation = record.get("violation");
            if (!Ext.isEmpty(violation)) {
                if (violation.level == "CRITICAL") {
                    cls += " red-row";
                } else if (violation.level == "WARNING") {
                    cls += " orange-row";
                }
            }
            return cls;
        }
});

Ext.reg('sitools.widget.ViolationRowExpander', sitools.widget.ViolationRowExpander);

/**
 * Color picker on a triggerField * 
 * @event select when a new color is selected
 * @class sitools.widget.colorField
 * @extends Ext.form.TriggerField
 */
sitools.widget.colorField = Ext.extend(
	Ext.form.TriggerField, {
		onTriggerClick : function (e) {
			var cp = new Ext.menu.ColorMenu({
		        scope : this, 
		        handler: function (cm, color) {
		            this.setValue("#" + color);
		            this.setFontColor("#" + color);
                    this.fireEvent("select", this, color);
		        }
		    });
		    cp.showAt(e.getXY());

		},
		setFontColor : function (color) {
	        var h2d = function (d) {
				return parseInt(d, 16);
			};
			var value = [
                h2d(color.slice(1, 3)),
                h2d(color.slice(3, 5)),
                h2d(color.slice(5))
            ];
	        var avg = (value[0] + value[1] + value[2]) / 3;
		    this.el.setStyle({
				'color' : (avg > 128) ? '#000' : '#FFF', 
				'background-color' : color, 
				'background-image' : "none"
		    });
            
		}, 
		listeners : {
			afterrender : function (tf) {
				tf.setFontColor(tf.getValue());
			}
		}
	}
)

sitools.widget.DateFieldWithToday = Ext.extend(Ext.form.DateField, {
	regToday : new RegExp("^\{\\$TODAY\}"), 
    invalidTextWithToday : "Impossible to make a date with {0}. A valid example is {$TODAY} + 1", 
    parseDate : function (value) {
        if(!value || Ext.isDate(value)){
            return value;
        }
		//Ajout d'un test sur la valeur pour sortir s'il y a la valeur {$TODAY}
		if (this.regToday.test(value)) {
        	return value;
        }
        var v = this.safeParse(value, this.format),
            af = this.altFormats,
            afa = this.altFormatsArray;

        if (!v && af) {
            afa = afa || af.split("|");

            for (var i = 0, len = afa.length; i < len && !v; i++) {
                v = this.safeParse(value, afa[i]);
            }
        }
        return v;
    },
    getErrors : function (value) {
        var errors = Ext.form.DateField.superclass.getErrors.apply(this, arguments);

        value = this.formatDate(value || this.processValue(this.getRawValue()));

        if (value.length < 1) { // if it's blank and textfield didn't flag it then it's valid
             return errors;
        }

        var svalue = value;
        // Ne pas parser la date en objet Date si {$TODAY} est présent
        var time = false;
        if (this.regToday.test(value)) {
        	try {
				value = sitools.common.utils.Date.stringWithTodayToDate(value);
				if (!sitools.common.utils.Date.isValidDate(value)) {
					throw "";
				}
			}
        	catch (err) {
        		errors.push(String.format(this.invalidTextWithToday, svalue));
        		return errors;	
        	}
        	
        }
        else {
        	value = this.parseDate(value);
        }
        
        if (!value) {
            errors.push(String.format(this.invalidText, svalue, this.format));
            return errors;
        }

        time = value.getTime();
        
        if (this.minValue && time < this.minValue.clearTime().getTime()) {
            errors.push(String.format(this.minText, this.formatDate(this.minValue)));
        }

        if (this.maxValue && time > this.maxValue.clearTime().getTime()) {
            errors.push(String.format(this.maxText, this.formatDate(this.maxValue)));
        }

        if (this.disabledDays) {
            var day = value.getDay();

            for(var i = 0; i < this.disabledDays.length; i++) {
                if (day === this.disabledDays[i]) {
                    errors.push(this.disabledDaysText);
                    break;
                }
            }
        }

        var fvalue = this.formatDate(value);
        if (this.disabledDatesRE && this.disabledDatesRE.test(fvalue)) {
            errors.push(String.format(this.disabledDatesText, fvalue));
        }

        return errors;
    	
    }, 
    setValue : function (date) {
    	if (this.regToday.test(date)) {
    		return Ext.form.DateField.superclass.setValue.call(this, date);
    	}
    	else {
			return Ext.form.DateField.superclass.setValue.call(this, this.formatDate(this.parseDate(date)));
    	
    	}
    	
    }
});

sitools.widget.rootTreeLoader = Ext.extend(Ext.tree.TreeLoader, {
	createNode : function (attr) {
		if (Ext.isEmpty(attr.children)) {
			attr.leaf = true;
		}
		return Ext.tree.TreeLoader.prototype.createNode.call(this, attr);
	}, 
	processResponse : function (response, node, callback, scope) {
	    var json = response.responseText, children, newNode, i = 0, len;
	    try {
	
	        if (!(children = response.responseData)) {
	            children = Ext.decode(json);
	            if (this.root) {
	                if (!this.getRoot) {
	                    this.getRoot = Ext.data.JsonReader.prototype.createAccessor(this.root);
	                }
	                children = this.getRoot(children);
	            }
	        }
	        node.beginUpdate();
	        for (len = children.length; i < len; i++) {
	            newNode = this.createNode(children[i]);
	            if (newNode) {
	                node.appendChild(newNode);
	            }
	        }
	        node.endUpdate();
	        this.runCallback(callback, scope || node, [ node ]);
	    } catch (e) {
	        this.handleFailure(response);
	    }
	}, 
	setUrl : function (url) {
		this.url = url;
	}
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document */
Ext.ns("sitools.common.forms");

/**
 * A static method to transform a parameter to a sitools component.
 * @static
 * @param {} parameter the parameter as stored in the formParameter Model
 * @param {string} dataUrl the Url to request eventual data 
 * @param {string} formId the main formId
 * @param {} datasetCm the dataset Column model 
 * @param {string} context should be dataset or project. 
 *  @param {formComponentsPanel} the parent form
 * @return {Ext.Container} the container to include into form
 */
sitools.common.forms.formParameterToComponent = function (parameter, dataUrl, formId, datasetCm, context, form) {

	var valuesToSelect = null;
	this.component = null;
	var value, values, items, i, component, defaultValues, existsWidgetForParameterCode, selectedValue, minValue, maxValue, disabledDates;

	//The name of the constructor
	var constructor = eval(parameter.jsUserObject);
	component = new constructor ({
        parameterId : parameter.id, 
        values : Ext.isArray(parameter.values) ? parameter.values : [],
	    code : parameter.code,
	    type : parameter.type,
	    label : parameter.label,
	    height : parameter.height,
	    widthBox : parameter.width, 
	    valueSelection : parameter.valueSelection, 
        parentParam : parameter.parentParam, 
        dataUrl : dataUrl, 
        autoComplete : parameter.autoComplete, 
        formId : formId, 
        dimensionId : parameter.dimensionId, 
        unit : parameter.unit, 
        css : parameter.css, 
        defaultValues : parameter.defaultValues, 
        extraParams : parameter.extraParams, 
        datasetCm : datasetCm, 
        context : context,
        form : form,
	});
	
	return {
	    parameter : parameter,
	    component : component
	};

};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, locale, ImageChooser, 
 showHelp, loadUrl*/
Ext.namespace('sitools.common.forms');

/**
 * Object to expose methods to build form Components user objects in dataset Context
 * @class sitools.common.forms.DatasetContex
 * 
 */
sitools.common.forms.DatasetContext = function () {
//sitools.user.forms.components.DatasetContext = function () {
	this.context = "dataset";
	
    /**
     * Return the unit corresponding to a given column Alias
     * @param {} scope the initial config
     * @return {} the unit founded
     */
	this.getRefUnit = function (scope) {
    	var columnAlias = scope.code[0];
    	if (Ext.isEmpty(scope.datasetCm)) {
    		return;
    	}
    	var result;
    	Ext.each(scope.datasetCm, function(column){
    		if (column.columnAlias == columnAlias) {
    			result = column.unit;
    		}
    	});
    	return result;
    };

};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, locale, ImageChooser, 
 showHelp, loadUrl*/
Ext.namespace('sitools.common.forms');

/**
 * Object to expose methods to build form Components user objects in project Context
 * @class sitools.common.forms.ProjectContext
 * 
 */
sitools.common.forms.ProjectContext = function () {
//sitools.user.forms.components.ProjectContext = function () {
	this.context = "project";
	/**
     * Return the unit corresponding to a given scope
     * @param {} scope the initial config
     * @return {} the unit founded
     */
	this.getRefUnit = function (scope) {
    	return scope.unit;
    };


};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, locale, ImageChooser, 
 showHelp, loadUrl*/
/*
 * @include "DatasetContext.js"
 * @include "ProjectContext.js" 
 */
Ext.namespace('sitools.common.forms');

/**
 * Basic factory to return DatasetFactory or ProjectFactory according with context. 
 * @param {String} context must be "dataset" or project"
 * @class sitools.common.forms.ComponentFactory
 * @return {}
 */
sitools.common.forms.ComponentFactory = function (context) {
//sitools.user.forms.components.ComponentFactory = function (context) {
	if (context == "dataset") {
		return new sitools.common.forms.DatasetContext(); 
	}
	if (context == "project") {
		return new sitools.common.forms.ProjectContext(); 
	}
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools*/
Ext.ns('sitools.common.forms');

/**
 * Abstract class to build Sitools form components with units.
 * @class sitools.common.forms.AbstractWithUnit
 * @extends Ext.Container
 */
sitools.common.forms.AbstractWithUnit = Ext.extend(Ext.Container, {
//sitools.component.users.SubSelectionParameters.AbstractComponentsWithUnit = Ext.extend(Ext.Container, {
   dimensionId : null,
   userUnit : null, 
   userDimension : null,
   
   initComponent : function () {
		this.userDimension = this.dimensionId;
		this.userUnit = this.unit;
		
		this.storeUnits = new Ext.data.JsonStore({
            id : 'storeUnitSelect',
            root : 'dimension.units',
            idProperty : 'id',
            fields : [ {
                name : 'unitName',
                type : 'string'
            }, {
                name : 'label',
                type : 'string'
            }]
        });
                    
        sitools.common.forms.AbstractWithUnit.superclass.initComponent.call(this);
   },
   /**
    * Load all units available with a given dimension.
    * On Callback : show a {Ext.Window} with the result in a gridPanel
    * @param {} event The click event (to get coordinates) 
    */
   loadUnits : function (event) {
        if (!this.unitsLoaded) {
            this.storeUnits.removeAll();
            Ext.Ajax.request({
                method : "GET",
                url : loadUrl.get('APP_URL') + loadUrl.get('APP_DIMENSIONS_ADMIN_URL') + '/dimension/' + this.dimensionId,
                scope : this, 
                success : function (ret) {
                    var Json = Ext.decode(ret.responseText);
                    if (!Json.success) {
                        Ext.Msg.alert(i18n.get('label.warning'), Json.message);
                        return;
                    }
                    var units = Json.dimension.sitoolsUnits;
                    this.dimensionName = Json.dimension.name;
                    for (var i = 0; i < units.length; i++) {
                        this.storeUnits.add(new Ext.data.Record(units[i]));
                    }
                }, 
                failure : alertFailure,
                callback : function () {
                    this.unitsLoaded = true;
                    this.showWinUnits(event);
                }
            });
        }
        else {
            this.showWinUnits(event);
        }
    }, 
    
    /**
     * Create and show a {Ext.Window} window with the loaded units 
     * build the gridUnits. 
     * @param {} event The click event to get coordinates for the window
     */
    showWinUnits : function (event) {

        var cmUnits = new Ext.grid.ColumnModel({
            columns : [ {
                header : i18n.get('headers.name'),
                dataIndex : 'label',
                width : 100
            }],
            defaults : {
                sortable : true,
                width : 100
            }
        });

        var smUnits = new Ext.grid.RowSelectionModel({
            singleSelect : true
        });

        this.gridUnits = new Ext.grid.GridPanel({
            autoScroll : true,
            store : this.storeUnits,
            cm : cmUnits,
            sm : smUnits, 
            layout : 'fit', 
            listeners : {
                scope : this, 
                rowClick : function (grid, rowIndex) {
                    this.onValidateUnits();
                }
            }
        });
        var winUnit = new Ext.Window({
            layout : 'fit', 
            width : 200, 
            title : i18n.get('title.unitList'),
            modal : true,
            height : 300, 
            items : [this.gridUnits], 
            buttons : [{
                text : i18n.get('label.ok'), 
                handler : this.onValidateUnits, 
                scope : this
            }, {
                text : i18n.get('label.cancel'), 
                scope : winUnit, 
                handler : function () {
                    this.ownerCt.ownerCt.close();                
                }
            }]
        }); 
        
        winUnit.show();
        winUnit.setPosition(event.getXY()[0], event.getXY()[1]);
    }, 
    /**
     * update property this.userDimension and this.userUnit, depending on the selected record in this.gridUnits
     * update the label of the button withe the new unit
     */
    onValidateUnits : function () {
        var rec = this.gridUnits.getSelectionModel().getSelected();
        if (Ext.isEmpty(rec)) {
            Ext.Msg.alert(i18n.get('label.error'), i18n.get('label.noSelection'));
            return;
        }
        this.userUnit = rec.data;
        this.userDimension = this.dimensionName;
        var btn = this.getEl().query("button")[0];
        if (! Ext.isEmpty(btn)) {
        	this.getEl().query("button")[0].update(rec.get('label'));
        }
        this.gridUnits.ownerCt.close();
    }, 
//    /**
//     * Return the unit corresponding to a given column Alias
//     * @param {String} columnAlias the column Alias to retrieve
//     * @return {} the unit founded
//     */
//    getColumnUnit : function (columnAlias) {
//    	if (Ext.isEmpty(this.datasetCm)) {
//    		return;
//    	}
//    	var result;
//    	Ext.each(this.datasetCm, function(column){
//    		if (column.columnAlias == columnAlias) {
//    			result = column.unit;
//    		}
//    	});
//    	return result;
//    }, 
    /**
     * build a {Ext.Container} container with 
     * <ul><li>a {Ext.Button} button if column unit is not null and administrator defines a dimension</li>
     * <li>A simple text if column unit is not null and administrator not defines a dimension</li>
     * <li>null when column unit is null</li></ul> 
     * @return {} null or the builded container
     */
    getUnitComponent : function () {
	    var columnUnit = this.context.getRefUnit(this);
        //the administrator defines a dimension for this component
	    // and the column unit is not null
        if (!Ext.isEmpty(this.dimensionId)) {
            var btn = new Ext.Button({
                scope : this, 
                text : Ext.isEmpty(columnUnit) ? "    " : columnUnit.label, 
                width : 90,
                handler : function (b, e) {
                    this.loadUnits(e);
                    //this.userDimension = this.dimensionId;
                }
            });
            unit = new Ext.Container({
            	layout : "hbox", 
            	layoutConfig : {
            		pack : "center", 
            		align : "middle"
            	},
            	margins : {top:0, right:0, bottom:0, left:10}, 
	        	width : 100, 
            	items : [btn]
            });
        }
        else {
            if (!Ext.isEmpty(columnUnit)) {
                unit = new Ext.Container({
		    		html : columnUnit.label, 
		    		margins : {top:0, right:0, bottom:0, left:10}, 
	        		flex : 1
		    	});
            }
            else {
                unit = null;
            }
            
        }
        return unit;
    	
    }
});


/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * managediframe version 2.1.5
 * url : https://code.google.com/p/managediframe/
 */
/*!
 * ux.ManagedIFrame for ExtJS Library 3.1+
 * Copyright(c) 2008-2009 Active Group, Inc.
 * licensing@theactivegroup.com
 * http://licensing.theactivegroup.com
 */
 /**
  * @class Ext.ux.plugin.VisibilityMode
  * @version 1.3.1
  * @author Doug Hendricks. doug[always-At]theactivegroup.com
  * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
  * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
  * Commercial Developer License (CDL) is available at http://licensing.theactivegroup.com.
  * @singleton
  * @static
  * @desc This plugin provides an alternate mechanism for hiding Ext.Elements and a new hideMode for Ext.Components.<br />
  * <p>It is generally designed for use with all browsers <b>except</b> Internet Explorer, but may used on that Browser as well.
  * <p>If included in a Component as a plugin, it sets it's hideMode to 'nosize' and provides a new supported
  * CSS rule that sets the height and width of an element and all child elements to 0px (rather than
  * 'display:none', which causes DOM reflow to occur and re-initializes nested OBJECT, EMBED, and IFRAMES elements)
  * @example
   var div = Ext.get('container');
   new Ext.ux.plugin.VisibilityMode().extend(div);
   //You can override the Element (instance) visibilityCls to any className you wish at any time
   div.visibilityCls = 'my-hide-class';
   div.hide() //or div.setDisplayed(false);

   // In Ext Layouts:
   someContainer.add({
     xtype:'flashpanel',
     plugins: [new Ext.ux.plugin.VisibilityMode() ],
     ...
    });

   // or, Fix a specific Container only and all of it's child items:
   // Note: An upstream Container may still cause Reflow issues when hidden/collapsed

    var V = new Ext.ux.plugin.VisibilityMode({ bubble : false }) ;
    new Ext.TabPanel({
     plugins     : V,
     defaults    :{ plugins: V },
     items       :[....]
    });
  */

 Ext.namespace('Ext.ux.plugin');
 Ext.onReady(function(){

   /* This important rule solves many of the <object/iframe>.reInit issues encountered
    * when setting display:none on an upstream(parent) element (on all Browsers except IE).
    * This default rule enables the new Panel:hideMode 'nosize'. The rule is designed to
    * set height/width to 0 cia CSS if hidden or collapsed.
    * Additional selectors also hide 'x-panel-body's within layouts to prevent
    * container and <object, img, iframe> bleed-thru.
    */
    var CSS = Ext.util.CSS;
    if(CSS){
        CSS.getRule('.x-hide-nosize') || //already defined?
            CSS.createStyleSheet('.x-hide-nosize{height:0px!important;width:0px!important;border:none!important;zoom:1;}.x-hide-nosize * {height:0px!important;width:0px!important;border:none!important;zoom:1;}');
        CSS.refreshCache();
    }

});

(function(){

      var El = Ext.Element, A = Ext.lib.Anim, supr = El.prototype;
      var VISIBILITY = "visibility",
        DISPLAY = "display",
        HIDDEN = "hidden",
        NONE = "none";

      var fx = {};

      fx.El = {

            /**
             * Sets the CSS display property. Uses originalDisplay if the specified value is a boolean true.
             * @param {Mixed} value Boolean value to display the element using its default display, or a string to set the display directly.
             * @return {Ext.Element} this
             */
           setDisplayed : function(value) {
                var me=this;
                me.visibilityCls ? (me[value !== false ?'removeClass':'addClass'](me.visibilityCls)) :
                    supr.setDisplayed.call(me, value);
                return me;
            },

            /**
             * Returns true if display is not "none" or the visibilityCls has not been applied
             * @return {Boolean}
             */
            isDisplayed : function() {
                return !(this.hasClass(this.visibilityCls) || this.isStyle(DISPLAY, NONE));
            },
            // private
            fixDisplay : function(){
                var me = this;
                supr.fixDisplay.call(me);
                me.visibilityCls && me.removeClass(me.visibilityCls);
            },

            /**
             * Checks whether the element is currently visible using both visibility, display, and nosize class properties.
             * @param {Boolean} deep (optional) True to walk the dom and see if parent elements are hidden (defaults to false)
             * @return {Boolean} True if the element is currently visible, else false
             */
            isVisible : function(deep) {
                var vis = this.visible ||
                    (!this.isStyle(VISIBILITY, HIDDEN) &&
                        (this.visibilityCls ?
                            !this.hasClass(this.visibilityCls) :
                                !this.isStyle(DISPLAY, NONE))
                      );

                  if (deep !== true || !vis) {
                    return vis;
                  }

                  var p = this.dom.parentNode,
                      bodyRE = /^body/i;

                  while (p && !bodyRE.test(p.tagName)) {
                    if (!Ext.fly(p, '_isVisible').isVisible()) {
                      return false;
                    }
                    p = p.parentNode;
                  }
                  return true;

            },
            //Assert isStyle method for Ext 2.x
            isStyle: supr.isStyle || function(style, val) {
                return this.getStyle(style) == val;
            }

        };

 //Add basic capabilities to the Ext.Element.Flyweight class
 Ext.override(El.Flyweight, fx.El);

 Ext.ux.plugin.VisibilityMode = function(opt) {

    Ext.apply(this, opt||{});

    var CSS = Ext.util.CSS;

    if(CSS && !Ext.isIE && this.fixMaximizedWindow !== false && !Ext.ux.plugin.VisibilityMode.MaxWinFixed){
        //Prevent overflow:hidden (reflow) transitions when an Ext.Window is maximize.
        CSS.updateRule ( '.x-window-maximized-ct', 'overflow', '');
        Ext.ux.plugin.VisibilityMode.MaxWinFixed = true;  //only updates the CSS Rule once.
    }

   };


  Ext.extend(Ext.ux.plugin.VisibilityMode , Object, {

       /**
        * @cfg {Boolean} bubble If true, the VisibilityMode fixes are also applied to parent Containers which may also impact DOM reflow.
        * @default true
        */
      bubble              :  true,

      /**
      * @cfg {Boolean} fixMaximizedWindow If not false, the ext-all.css style rule 'x-window-maximized-ct' is disabled to <b>prevent</b> reflow
      * after overflow:hidden is applied to the document.body.
      * @default true
      */
      fixMaximizedWindow  :  true,

      /**
       *
       * @cfg {array} elements (optional) A list of additional named component members to also adjust visibility for.
       * <br />By default, the plugin handles most scenarios automatically.
       * @default null
       * @example ['bwrap','toptoolbar']
       */

      elements       :  null,

      /**
       * @cfg {String} visibilityCls A specific CSS classname to apply to Component element when hidden/made visible.
       * @default 'x-hide-nosize'
       */

      visibilityCls   : 'x-hide-nosize',

      /**
       * @cfg {String} hideMode A specific hideMode value to assign to affected Components.
       * @default 'nosize'
       */
      hideMode  :   'nosize' ,

      ptype     :  'uxvismode',
      /**
      * Component plugin initialization method.
      * @param {Ext.Component} c The Ext.Component (or subclass) for which to apply visibilityMode treatment
      */
      init : function(c) {

        var hideMode = this.hideMode || c.hideMode,
            plugin = this,
            bubble = Ext.Container.prototype.bubble,
            changeVis = function(){

                var els = [this.collapseEl, this.actionMode].concat(plugin.elements||[]);

                Ext.each(els, function(el){
                    plugin.extend( this[el] || el );
                },this);

                var cfg = {
                    visFixed  : true,
                    animCollapse : false,
                    animFloat   : false,
                    hideMode  : hideMode,
                    defaults  : this.defaults || {}
                };

                cfg.defaults.hideMode = hideMode;

                Ext.apply(this, cfg);
                Ext.apply(this.initialConfig || {}, cfg);

            };

         c.on('render', function(){

            // Bubble up the layout and set the new
            // visibility mode on parent containers
            // which might also cause DOM reflow when
            // hidden or collapsed.
            if(plugin.bubble !== false && this.ownerCt){

               bubble.call(this.ownerCt, function(){
                  this.visFixed || this.on('afterlayout', changeVis, this, {single:true} );
               });
             }

             changeVis.call(this);

          }, c, {single:true});

     },
     /**
      * @param {Element/Array} el The Ext.Element (or Array of Elements) to extend visibilityCls handling to.
      * @param {String} visibilityCls The className to apply to the Element when hidden.
      * @return this
      */
     extend : function(el, visibilityCls){
        el && Ext.each([].concat(el), function(e){

            if(e && e.dom){
                 if('visibilityCls' in e)return;  //already applied or defined?
                 Ext.apply(e, fx.El);
                 e.visibilityCls = visibilityCls || this.visibilityCls;
            }
        },this);
        return this;
     }

  });

  Ext.preg && Ext.preg('uxvismode', Ext.ux.plugin.VisibilityMode );
  /** @sourceURL=<uxvismode.js> */
  Ext.provide && Ext.provide('uxvismode');
})();/* global Ext El ElFrame ELD*/
/*
 * ******************************************************************************
 * This file is distributed on an AS IS BASIS WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * ***********************************************************************************
 * License: multidom.js is offered under an MIT License.
 * Donations are welcomed: http://donate.theactivegroup.com
 */

 /**
  * @class multidom
  * @version 2.14
  * @license MIT
  * @author Doug Hendricks. Forum ID: <a href="http://extjs.com/forum/member.php?u=8730">hendricd</a>
  * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
  * @copyright 2007-2010, Active Group, Inc. All rights reserved.
  * @description [Designed For Ext Core and ExtJs Frameworks (using ext-base adapter only) 3.0 or higher ONLY]
  * The multidom library extends (overloads) Ext Core DOM methods and functions to
  * provide document-targeted access to the documents loaded in external (FRAME/IFRAME)
  * documents.
  * <p>It maintains seperate DOM Element caches (and more) for each document instance encountered by the
  * framework, permitting safe access to DOM Elements across document instances that may share
  * the same Element id or name.  In essence, multidom extends the functionality provided by Ext Core
  * into any child document without having to load the Core library into the frame's global context.
  * <h3>Custom Element classes.</h3>
  * The Ext.get method is enhanced to support resolution of the custom Ext.Element implementations.
  * (The ux.ManagedIFrame 2 Element class is an example of such a class.)
  * <p>For example: If you were retrieving the Ext.Element instance for an IFRAME and the class
  * Ext.Element.IFRAME were defined:
  * <pre><code>Ext.get('myFrame')</pre></code>
  * would return an instance of Ext.Element.IFRAME for 'myFrame' if it were found.
  * @example
   // return the Ext.Element with an id 'someDiv' located in external document hosted by 'iframe'
   var iframe = Ext.get('myFrame');
   var div = Ext.get('someDiv', iframe.getFrameDocument()); //Firefox example
   if(div){
     div.center();
    }
   Note: ux.ManagedIFrame provides an equivalent 'get' method of it's own to access embedded DOM Elements
   for the document it manages.
   <pre><code>iframe.get('someDiv').center();</pre></code>

   Likewise, you can retrieve the raw Element of another document with:
   var el = Ext.getDom('myDiv', iframe.getFrameDocument());
 */

 (function(){

    /*
     * Ext.Element and Ext.lib.DOM enhancements.
     * Primarily provides the ability to interact with any document context
     * (not just the one Ext was loaded into).
     */
   var El = Ext.Element,
       ElFrame,
       ELD = Ext.lib.Dom,
       A = Ext.lib.Anim,
       Evm = Ext.EventManager,
       E = Ext.lib.Event,
       DOC = document,
       emptyFn = function(){},
       OP = Object.prototype,
       OPString = OP.toString,
       bodyTag = /^body/i,
       HTMLDoc = '[object HTMLDocument]';
       
   if(!Ext.elCache || parseInt( Ext.version.replace(/\./g,''),10) < 311 ) {
    alert ('Ext Release '+Ext.version+' is not supported');
   }

   /**
    * @private
    */
   Ext._documents= {}; 
   Ext._documents[Ext.id(document,'_doc')]=Ext.elCache;

   /**
    * @private
    * Resolve the Element cache for a given element/window/document context.
    */
   var resolveCache = ELD.resolveDocumentCache = function(el, cacheId){
        
        /**
         * MUST re-assert Ext.elCache !! 
         * because of privately scoped references to Ext.elCache in the framework itself.
         */
        Ext._documents[Ext.id(document,'_doc')]=Ext.elCache;
        
        var doc = GETDOC(el),
            c = Ext.isDocument(doc) ? Ext.id(doc) : cacheId,
            cache = Ext._documents[c] || null;
         
         return cache || (c ? Ext._documents[c] = {}: null);
     },
     clearCache = ELD.clearDocumentCache = function(cacheId){
       delete  Ext._documents[cacheId];
     };

   El.addMethods || ( El.addMethods = function(ov){ Ext.apply(El.prototype, ov||{}); });
   
   Ext.removeNode =  function(n){
         var dom = n ? n.dom || n : null,
             el, elc, elCache = resolveCache(dom), parent;

            //clear out any references if found in the El.cache(s)
            if(dom && (elc = elCache[dom.id]) && (el = elc.el) ){
                if(el.dom){
                    Ext.enableNestedListenerRemoval ? Evm.purgeElement(el.dom, true) : Evm.removeAll(el.dom);
                }
                delete elCache[dom.id];
                delete el.dom;
                delete el._context;
                el = null;
            }
            //No removal for window, documents, or bodies
            if(dom && !dom.navigator && !Ext.isDocument(dom) && !bodyTag.test(dom.tagName)){
                (parent = dom.parentElement || dom.parentNode) && parent.removeChild(dom);
            }
            dom = parent = null;
    };

    var overload = function(pfn, fn ){
           var f = typeof pfn === 'function' ? pfn : function t(){};
           var ov = f._ovl; //call signature hash
           if(!ov){
               ov = { base: f};
               ov[f.length|| 0] = f;
               f= function t(){  //the proxy stub
                  var o = arguments.callee._ovl;
                  var fn = o[arguments.length] || o.base;
                  //recursion safety
                  return fn && fn != arguments.callee ? fn.apply(this,arguments): undefined;
               };
           }
           var fnA = [].concat(fn);
           for(var i=0,l=fnA.length; i<l; ++i){
             //ensures no duplicate call signatures, but last in rules!
             ov[fnA[i].length] = fnA[i];
           }
           f._ovl= ov;
           var t = null;
           return f;
       };

    Ext.applyIf( Ext, {
        overload : overload( overload,
           [
             function(fn){ return overload(null, fn);},
             function(obj, mname, fn){
                 return obj[mname] = overload(obj[mname],fn);}
          ]),

        isArray : function(v){
           return !!v && OPString.apply(v) == '[object Array]';
        },

        isObject:function(obj){
            return !!obj && typeof obj == 'object';
        },

        /**
         * HTMLDocument assertion with optional accessibility testing
         * @param {HTMLELement} el The DOM Element to test
         * @param {Boolean} testOrigin (optional) True to test "same-origin" access
         *
         */
        isDocument : function(el, testOrigin){
            var elm = el ? el.dom || el : null;
            var test = elm && ((OPString.apply(elm) == HTMLDoc) || (elm && elm.nodeType == 9));
            if(test && testOrigin){
                try{
                    test = !!elm.location;
                }
                catch(e){return false;}
            }
            return test;
        },

        isWindow : function(el){
          var elm = el ? el.dom || el : null;
          return elm ? !!elm.navigator || OPString.apply(elm) == "[object Window]" : false;
        },

        isIterable : function(v){
            //check for array or arguments
            if(Ext.isArray(v) || v.callee){
                return true;
            }
            //check for node list type
            if(/NodeList|HTMLCollection/.test(OPString.call(v))){
                return true;
            }
            //NodeList has an item and length property
            //IXMLDOMNodeList has nextNode method, needs to be checked first.
            return ((typeof v.nextNode != 'undefined' || v.item) && Ext.isNumber(v.length));
  
        },
        isElement : function(obj){
            return obj && Ext.type(obj)== 'element';
        },

        isEvent : function(obj){
            return OPString.apply(obj) == '[object Event]' || (Ext.isObject(obj) && !Ext.type(o.constructor) && (window.event && obj.clientX && obj.clientX == window.event.clientX));
        },

        isFunction: function(obj){
            return !!obj && typeof obj == 'function';
        },

        /**
         * Determine whether a specified DOMEvent is supported by a given HTMLElement or Object.
         * @param {String} type The eventName (without the 'on' prefix)
         * @param {HTMLElement/Object/String} testEl (optional) A specific HTMLElement/Object to test against, otherwise a tagName to test against.
         * based on the passed eventName is used, or DIV as default.
         * @return {Boolean} True if the passed object supports the named event.
         */
        isEventSupported : function(evName, testEl){
             var TAGNAMES = {
                  'select':'input',
                  'change':'input',
                  'submit':'form',
                  'reset':'form',
                  'load':'img',
                  'error':'img',
                  'abort':'img'
                },
                //Cached results
                cache = {},
                onPrefix = /^on/i,
                //Get a tokenized string of the form nodeName:type
                getKey = function(type, el){
                    var tEl = Ext.getDom(el);
                    return (tEl ?
                           (Ext.isElement(tEl) || Ext.isDocument(tEl) ?
                                tEl.nodeName.toLowerCase() :
                                    el.self ? '#window' : el || '#object')
                       : el || 'div') + ':' + type;
                };

            return function (evName, testEl) {
              evName = (evName || '').replace(onPrefix,'');
              var el, isSupported = false;
              var eventName = 'on' + evName;
              var tag = (testEl ? testEl : TAGNAMES[evName]) || 'div';
              var key = getKey(evName, tag);

              if(key in cache){
                //Use a previously cached result if available
                return cache[key];
              }

              el = Ext.isString(tag) ? DOC.createElement(tag): testEl;
              isSupported = (!!el && (eventName in el));

              isSupported || (isSupported = window.Event && !!(String(evName).toUpperCase() in window.Event));

              if (!isSupported && el) {
                el.setAttribute && el.setAttribute(eventName, 'return;');
                isSupported = Ext.isFunction(el[eventName]);
              }
              //save the cached result for future tests
              cache[key] = isSupported;
              el = null;
              return isSupported;
            };

        }()
    });


    /**
     * @private
     * Determine Ext.Element[tagName] or Ext.Element (default)
     */
    var assertClass = function(el){
    	
    	return El;
        return El[(el.tagName || '-').toUpperCase()] || El;

      };

    var libFlyweight;
    function fly(el, doc) {
        if (!libFlyweight) {
            libFlyweight = new Ext.Element.Flyweight();
        }
        libFlyweight.dom = Ext.getDom(el, null, doc);
        return libFlyweight;
    }


    Ext.apply(Ext, {
    /*
     * Overload Ext.get to permit Ext.Element access to other document objects
     * This implementation maintains safe element caches for each document queried.
     *
     */

      get : El.get = function(el, doc){         //document targeted
            if(!el ){ return null; }
            var isDoc = Ext.isDocument(el); 
            
            Ext.isDocument(doc) || (doc = DOC);
            
            var ex, elm, id, cache = resolveCache(doc);
            if(typeof el == "string"){ // element id
                elm = Ext.getDom(el, null, doc);
                if(!elm) return null;
                if(cache[el] && cache[el].el){
                    ex = cache[el].el;
                    ex.dom = elm;
                }else{
                    ex = El.addToCache(new (assertClass(elm))(elm, null, doc));
                }
                return ex;
            
            }else if(isDoc){

                if(!Ext.isDocument(el, true)){ return false; }  //is it accessible
                cache = resolveCache(el);

                if(cache[Ext.id(el)] && cache[el.id].el){
                    return cache[el.id].el;
                }
                // create a bogus element object representing the document object
                var f = function(){};
                f.prototype = El.prototype;
                var docEl = new f();
                docEl.dom = el;
                docEl.id = Ext.id(el,'_doc');
                docEl._isDoc = true;
                El.addToCache( docEl, null, cache);
                return docEl;
                        
             }else if( el instanceof El ){ 
                
                // refresh dom element in case no longer valid,
                // catch case where it hasn't been appended
                 
                if(el.dom){
                    el.id = Ext.id(el.dom);
                }else{
                    el.dom = el.id ? Ext.getDom(el.id, true) : null;
                }
                if(el.dom){
	                cache = resolveCache(el);
	                (cache[el.id] || 
	                       (cache[el.id] = {data : {}, events : {}}
	                       )).el = el; // in case it was created directly with Element(), let's cache it
                }
                return el;
                
            }else if(el.tagName || Ext.isWindow(el)){ // dom element
                cache = resolveCache(el);
                id = Ext.id(el);
                if(cache[id] && (ex = cache[id].el)){
                    ex.dom = el;
                }else{
                    ex = El.addToCache(new (assertClass(el))(el, null, doc), null, cache); 
                }
                return ex;

            }else if(el.isComposite){
                return el;

            }else if(Ext.isArray(el)){
                return Ext.get(doc,doc).select(el);
            }
           return null;

    },

     /**
      * Ext.getDom to support targeted document contexts
      */
     getDom : function(el, strict, doc){
        var D = doc || DOC;
        if(!el || !D){
            return null;
        }
        if (el.dom){
            return el.dom;
        } else {
            if (Ext.isString(el)) {
                var e = D.getElementById(el);
                // IE returns elements with the 'name' and 'id' attribute.
                // we do a strict check to return the element with only the id attribute
                if (e && Ext.isIE && strict) {
                    if (el == e.getAttribute('id')) {
                        return e;
                    } else {
                        return null;
                    }
                }
                return e;
            } else {
                return el;
            }
        }
            
     },
     /**
     * Returns the current/specified document body as an {@link Ext.Element}.
     * @param {HTMLDocument} doc (optional)
     * @return Ext.Element The document's body
     */
     getBody : function(doc){
            var D = ELD.getDocument(doc) || DOC;
            return Ext.get(D.body || D.documentElement);
       },

     getDoc :Ext.overload([
       Ext.getDoc,
       function(doc){ return Ext.get(doc,doc); }
       ])
   });

   // private method for getting and setting element data
    El.data = function(el, key, value){
        el = El.get(el);
        if (!el) {
            return null;
        }
        var c = resolveCache(el)[el.id].data;
        if(arguments.length == 2){
            return c[key];
        }else{
            return (c[key] = value);
        }
    };
    
    El.addToCache = function(el, id, cache ){
        id = id || Ext.id(el);
        var C = cache || resolveCache(el);
        C[id] = {
            el:  el.dom ? el : Ext.get(el),
            data: {},
            events: {}
        };
        var d = C[id].el.dom;
        (d.getElementById || d.navigator) && (C[id].skipGC = true);
        return C[id].el;
    };
    
    El.removeFromCache = function(el, cache){
        if(el && el.id){
            var C = cache || resolveCache(el);
            delete C[el.id];
        }
    };
    
    /*
     * Add new Visibility Mode to element (sets height and width to 0px instead of display:none )
     */
    El.OFFSETS = 3;
    El.ASCLASS = 4;
    
    El.visibilityCls = 'x-hide-nosize';

    var propCache = {},
        camelRe = /(-[a-z])/gi,
        camelFn = function(m, a){ return a.charAt(1).toUpperCase(); },
        opacityRe = /alpha\(opacity=(.*)\)/i,
        trimRe = /^\s+|\s+$/g,
        marginRightRe = /marginRight/,
        propFloat = Ext.isIE ? 'styleFloat' : 'cssFloat',
        view = DOC.defaultView,
        VISMODE = 'visibilityMode',
        ASCLASS  = "asclass",
        ORIGINALDISPLAY = 'originalDisplay',
        PADDING = "padding",
        MARGIN = "margin",
        BORDER = "border",
        LEFT = "-left",
        RIGHT = "-right",
        TOP = "-top",
        BOTTOM = "-bottom",
        WIDTH = "-width",
        MATH = Math,
        OPACITY = "opacity",
        VISIBILITY = "visibility",
        DISPLAY = "display",
        OFFSETS = "offsets",
        NOSIZE = 'nosize',
        ASCLASS  = "asclass",
        HIDDEN = "hidden",
        NONE = "none", 
        ISVISIBLE = 'isVisible',
        ISCLIPPED = 'isClipped',
        OVERFLOW = 'overflow',
        OVERFLOWX = 'overflow-x',
        OVERFLOWY = 'overflow-y',
        ORIGINALCLIP = 'originalClip',
        XMASKED = "x-masked",
        XMASKEDRELATIVE = "x-masked-relative",
        // special markup used throughout Ext when box wrapping elements
        borders = {l: BORDER + LEFT + WIDTH, r: BORDER + RIGHT + WIDTH, t: BORDER + TOP + WIDTH, b: BORDER + BOTTOM + WIDTH},
        paddings = {l: PADDING + LEFT, r: PADDING + RIGHT, t: PADDING + TOP, b: PADDING + BOTTOM},
        margins = {l: MARGIN + LEFT, r: MARGIN + RIGHT, t: MARGIN + TOP, b: MARGIN + BOTTOM},
        data = El.data,
        GETDOM = Ext.getDom,
        GET = Ext.get,
        DH = Ext.DomHelper,
        propRe = /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate)$/,
        CSS = Ext.util.CSS,  //Not available in Ext Core.
        getDisplay = function(dom){
            var d = data(dom, ORIGINALDISPLAY);
            if(d === undefined){
                data(dom, ORIGINALDISPLAY, d = '');
            }
            return d;
        },
        getVisMode = function(dom){
            var m = data(dom, VISMODE);
            if(m === undefined){
                data(dom, VISMODE, m = El.prototype.visibilityMode)
            }
            return m;
        };

    function chkCache(prop) {
        return propCache[prop] || (propCache[prop] = prop == 'float' ? propFloat : prop.replace(camelRe, camelFn));
    };


    El.addMethods({
        /**
         * Resolves the current document context of this Element
         */
        getDocument : function(){
           return this._context || (this._context = GETDOC(this));
        },

        /**
      * Removes this element from the DOM and deletes it from the cache
      * @param {Boolean} cleanse (optional) Perform a cleanse of immediate childNodes as well.
      * @param {Boolean} deep (optional) Perform a deep cleanse of all nested childNodes as well.
      */

        remove : function(cleanse, deep){
            
          var dom = this.dom;
          //this.isMasked() && this.unmask();
          if(dom){
            Ext.removeNode(dom);
            delete this._context;
            delete this.dom;
          }
        },

         /**
         * Appends the passed element(s) to this element
         * @param {String/HTMLElement/Array/Element/CompositeElement} el
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} this
         */
        appendChild: function(el, doc){
            return GET(el, doc || this.getDocument()).appendTo(this);
        },

        /**
         * Appends this element to the passed element
         * @param {Mixed} el The new parent element
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} this
         */
        appendTo: function(el, doc){
            GETDOM(el, false, doc || this.getDocument()).appendChild(this.dom);
            return this;
        },

        /**
         * Inserts this element before the passed element in the DOM
         * @param {Mixed} el The element before which this element will be inserted
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} this
         */
        insertBefore: function(el, doc){
            (el = GETDOM(el, false, doc || this.getDocument())).parentNode.insertBefore(this.dom, el);
            return this;
        },

        /**
         * Inserts this element after the passed element in the DOM
         * @param {Mixed} el The element to insert after
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} this
         */
        insertAfter: function(el, doc){
            (el = GETDOM(el, false, doc || this.getDocument())).parentNode.insertBefore(this.dom, el.nextSibling);
            return this;
        },

        /**
         * Inserts (or creates) an element (or DomHelper config) as the first child of this element
         * @param {Mixed/Object} el The id or element to insert or a DomHelper config to create and insert
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} The new child
         */
        insertFirst: function(el, returnDom){
            el = el || {};
            if(el.nodeType || el.dom || typeof el == 'string'){ // element
                el = GETDOM(el);
                this.dom.insertBefore(el, this.dom.firstChild);
                return !returnDom ? GET(el) : el;
            }else{ // dh config
                return this.createChild(el, this.dom.firstChild, returnDom);
            }
        },

        /**
         * Replaces the passed element with this element
         * @param {Mixed} el The element to replace
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} this
         */
        replace: function(el, doc){
            el = GET(el, doc || this.getDocument());
            this.insertBefore(el);
            el.remove();
            return this;
        },

        /**
         * Replaces this element with the passed element
         * @param {Mixed/Object} el The new element or a DomHelper config of an element to create
         * @param {Document} doc (optional) specific document context for the Element search
         * @return {Ext.Element} this
         */
        replaceWith: function(el, doc){
            var me = this;
            if(el.nodeType || el.dom || typeof el == 'string'){
                el = GETDOM(el, false, doc || me.getDocument());
                me.dom.parentNode.insertBefore(el, me.dom);
            }else{
                el = DH.insertBefore(me.dom, el);
            }
            var C = resolveCache(me);
            Ext.removeNode(me.dom);
            me.id = Ext.id(me.dom = el);

            El.addToCache(me.isFlyweight ? new (assertClass(me.dom))(me.dom, null, C) : me);     
            return me;
        },


        /**
         * Inserts an html fragment into this element
         * @param {String} where Where to insert the html in relation to this element - beforeBegin, afterBegin, beforeEnd, afterEnd.
         * @param {String} html The HTML fragment
         * @param {Boolean} returnEl (optional) True to return an Ext.Element (defaults to false)
         * @return {HTMLElement/Ext.Element} The inserted node (or nearest related if more than 1 inserted)
         */
        insertHtml : function(where, html, returnEl){
            var el = DH.insertHtml(where, this.dom, html);
            return returnEl ? Ext.get(el, GETDOC(el)) : el;
        },
             
        
        /**
         * Checks whether the element is currently visible using both visibility and display properties.
         * @return {Boolean} True if the element is currently visible, else false
         */
        isVisible : function(deep) {
            var me=this,
                dom = me.dom,
                p = dom.parentNode,
                visible = data(dom, ISVISIBLE);  //use the cached value if registered
               
            if(typeof visible != 'boolean'){ 
               
	            //Determine the initial state based on display states
	            visible = !me.hasClass(me.visibilityCls || El.visibilityCls) && 
	                      !me.isStyle(VISIBILITY, HIDDEN) && 
	                      !me.isStyle(DISPLAY, NONE); 
	                      
	            data(dom, ISVISIBLE, visible);
            }
            
                
            if(deep !== true || !visible){
                return visible;
            }
            while(p && !bodyTag.test(p.tagName)){
                if(!Ext.fly(p, '_isVisible').isVisible()){
                    return false;
                }
                p = p.parentNode;
            }
            return true;
            
        },
                
        /**
         * Sets the visibility of the element (see details). If the visibilityMode is set to Element.DISPLAY, it will use
         * the display property to hide the element, otherwise it uses visibility. The default is to hide and show using the visibility property.
         * @param {Boolean} visible Whether the element is visible
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object, or one of four
         *         possible hideMode strings: 'display, visibility, offsets, asclass'
         * @return {Ext.Element} this
         */
        setVisible : function(visible, animate){
            var me = this, 
                dom = me.dom,
                visMode = getVisMode(dom);
           
            // hideMode string override
            if (typeof animate == 'string'){
                switch (animate) {
                    case DISPLAY:
                        visMode = El.DISPLAY;
                        break;
                    case VISIBILITY:
                        visMode = El.VISIBILITY;
                        break;
                    case OFFSETS:
                        visMode = El.OFFSETS;
                        break;
                    case NOSIZE:
                    case ASCLASS:
                        visMode = El.ASCLASS;
                        break;
                }
                me.setVisibilityMode(visMode);
                animate = false;
            }
             
            if (!animate || !me.anim) {
                if(visMode == El.ASCLASS ){
                    
                    me[visible?'removeClass':'addClass'](me.visibilityCls || El.visibilityCls);
                    
                } else if (visMode == El.DISPLAY){
                    
                    return me.setDisplayed(visible);
                    
                } else if (visMode == El.OFFSETS){
                    
                    if (!visible){
                        me.hideModeStyles = {
                            position: me.getStyle('position'),
                            top: me.getStyle('top'),
                            left: me.getStyle('left')
                        };
                        me.applyStyles({position: 'absolute', top: '-10000px', left: '-10000px'});
                    } else {
                        me.applyStyles(me.hideModeStyles || {position: '', top: '', left: ''});
                        delete me.hideModeStyles;
                    }
                
                }else{
                    me.fixDisplay();
                    dom.style.visibility = visible ? "visible" : HIDDEN;
                }
            }else{
                // closure for composites            
                if(visible){
                    me.setOpacity(.01);
                    me.setVisible(true);
                }
                me.anim({opacity: { to: (visible?1:0) }},
                        me.preanim(arguments, 1),
                        null,
                        .35,
                        'easeIn',
                        function(){
                            visible || me.setVisible(false).setOpacity(1);
                        });
            }
            data(dom, ISVISIBLE, visible);  //set logical visibility state
            return me;
        },
        
        hasMetrics  : function(){
            var me = this;
            return me.isVisible() || (getVisMode(me.dom) == El.VISIBILITY);     
        },
        /**
         * Sets the CSS display property. Uses originalDisplay if the specified value is a boolean true.
         * @param {Mixed} value Boolean value to display the element using its default display, or a string to set the display directly.
         * @return {Ext.Element} this
         */
        setDisplayed : function(value) {
            var dom = this.dom,
                visMode = getVisMode(dom);
            
            if(typeof value == "boolean"){
               
               if(visMode == El.ASCLASS){
                  return this.setVisible(value);
               }
               data(this.dom, ISVISIBLE, value);
               value = value ? getDisplay(dom) : NONE;
            }
            this.setStyle(DISPLAY, value);
            return this;
        },
        
                
        /**
         * Convenience method for setVisibilityMode(Element.DISPLAY)
         * @param {String} display (optional) What to set display to when visible
         * @return {Ext.Element} this
         */
        enableDisplayMode : function(display){      
            this.setVisibilityMode(El.DISPLAY);
            if(!Ext.isEmpty(display)){
                data(this.dom, ORIGINALDISPLAY, display);
            }
            return this;
        },
        
        
        scrollIntoView : function(container, hscroll){
                var d = this.getDocument(),
                    c = Ext.getDom(container, null, d) || Ext.getBody(d).dom,
                    el = this.dom,
                    o = this.getOffsetsTo(c),
                    l = o[0] + c.scrollLeft,
		            t = o[1] + c.scrollTop,
		            b = t + el.offsetHeight,
		            r = l + el.offsetWidth,
		            ch = c.clientHeight,
		            ct = parseInt(c.scrollTop, 10),
		            cl = parseInt(c.scrollLeft, 10),
		            cb = ct + ch,
		            cr = cl + c.clientWidth;
                    
                if(el.offsetHeight > ch || t < ct){
                    c.scrollTop = t;
                }else if(b > cb){
                    c.scrollTop = b-ch;
                }
                // corrects IE, other browsers will ignore
                c.scrollTop = c.scrollTop; 
                if(hscroll !== false){
                    if(el.offsetWidth > c.clientWidth || l < cl){
                        c.scrollLeft = l;
                    }else if(r > cr){
                        c.scrollLeft = r-c.clientWidth;
                    }
                    c.scrollLeft = c.scrollLeft;
                }
                return this;
        },

        contains : function(el){
            try {
                return !el ? false : ELD.isAncestor(this.dom, el.dom ? el.dom : el);
            } catch(e) {
                return false;
            }
        },

        /**
         * Returns the current scroll position of the element.
         * @return {Object} An object containing the scroll position in the format {left: (scrollLeft), top: (scrollTop)}
         */
        getScroll : function(){
            var d = this.dom,
            doc = this.getDocument(),
            body = doc.body,
            docElement = doc.documentElement,
            l,
            t,
            ret;

            if(Ext.isDocument(d) || d == body){
                if(Ext.isIE && ELD.docIsStrict(doc)){
                    l = docElement.scrollLeft;
                    t = docElement.scrollTop;
                }else{
                    l = window.pageXOffset;
                    t = window.pageYOffset;
                }
                ret = {left: l || (body ? body.scrollLeft : 0), top: t || (body ? body.scrollTop : 0)};
            }else{
                ret = {left: d.scrollLeft, top: d.scrollTop};
            }
            return ret;
        },
        /**
         * Normalizes currentStyle and computedStyle.
         * @param {String} property The style property whose value is returned.
         * @return {String} The current value of the style property for this element.
         */
        getStyle : function(){
            var getStyle =
             view && view.getComputedStyle ?
                function GS(prop){
                    var el = !this._isDoc ? this.dom : null,
                        v,
                        cs,
                        out,
                        display,
                        wk = Ext.isWebKit,
                        display,
                        style;

                    if(!el || !el.style) return null;
                    style = el.style;
                    prop = chkCache(prop);
                    cs = view.getComputedStyle(el, null);
                    out = (cs) ? cs[prop]: null;
                           
                    // Fix bug caused by this: https://bugs.webkit.org/show_bug.cgi?id=13343
                    if(wk){
                        if(out && marginRightRe.test(prop) &&
                            style.position != 'absolute' && 
                            out != '0px'){
		                        display = style.display;
		                        style.display = 'inline-block';
		                        out = view.getComputedStyle(el, null)[prop];
		                        style.display = display;
	                    }else if(out == 'rgba(0, 0, 0, 0)'){
                            //Webkit returns rgb values for transparent.
	                        out = 'transparent';
	                    }
                    }
                    return out || style[prop];
                } :
                function GS(prop){ //IE < 9
                   var el = !this._isDoc ? this.dom : null,
                        m,
                        cs,
                        style;
                    if(!el || !el.style) return null;
                    style = el.style;
                    if (prop == OPACITY ) {
                        if (style.filter.match) {
                            if(m = style.filter.match(opacityRe)){
                                var fv = parseFloat(m[1]);
                                if(!isNaN(fv)){
                                    return fv ? fv / 100 : 0;
                                }
                            }
                        }
                        return 1;
                    }
                    prop = chkCache(prop);
                    return ((cs = el.currentStyle) ? cs[prop] : null) || el.style[prop];
                };
                var GS = null;
                return getStyle;
        }(),
        /**
         * Wrapper for setting style properties, also takes single object parameter of multiple styles.
         * @param {String/Object} property The style property to be set, or an object of multiple styles.
         * @param {String} value (optional) The value to apply to the given property, or null if an object was passed.
         * @return {Ext.Element} this
         */
        setStyle : function(prop, value){
            if(this._isDoc || Ext.isDocument(this.dom)) return this;
            var tmp, style;
                
            if (typeof prop != 'object') {
                tmp = {};
                tmp[prop] = value;
                prop = tmp;
            }
            for (style in prop) {
                if(prop.hasOwnProperty(style)) {
                    value = prop[style];
	                style == OPACITY ?
	                    this.setOpacity(value) :
	                    this.dom.style[chkCache(style)] = value;
                }
            }
            return this;
        },
        /**
        * Centers the Element in either the viewport, or another Element.
        * @param {Mixed} centerIn (optional) The element in which to center the element.
        */
        center : function(centerIn){
            return this.alignTo(centerIn || this.getDocument(), 'c-c');
        },
        
        /**
         * Puts a mask over this element to disable user interaction. Requires core.css.
         * This method can only be applied to elements which accept child nodes.
         * @param {String} msg (optional) A message to display in the mask
         * @param {String} msgCls (optional) A css class to apply to the msg element
         * @return {Element} The mask element
         */
        mask : function(msg, msgCls){
            var me = this,
                dom = me.dom,
                dh = Ext.DomHelper,
                EXTELMASKMSG = "ext-el-mask-msg",
                el, 
                mask;
                
            if(me.getStyle("position") == "static"){
                me.addClass(XMASKEDRELATIVE);
            }
            if((el = data(dom, 'maskMsg'))){
                el.remove();
            }
            if((el = data(dom, 'mask'))){
                el.remove();
            }
    
            mask = dh.append(dom, {cls : "ext-el-mask"}, true);
            data(dom, 'mask', mask);
    
            me.addClass(XMASKED);
            mask.setDisplayed(true);
            if(typeof msg == 'string'){
                var mm = dh.append(dom, {cls : EXTELMASKMSG, cn:{tag:'div'}}, true);
                data(dom, 'maskMsg', mm);
                mm.dom.className = msgCls ? EXTELMASKMSG + " " + msgCls : EXTELMASKMSG;
                mm.dom.firstChild.innerHTML = msg;
                mm.setDisplayed(true);
                mm.center(me);
            }
            if(Ext.isIE && !(Ext.isIE7 && Ext.isStrict) && me.getStyle('height') == 'auto'){ // ie will not expand full height automatically
                mask.setSize(undefined, me.getHeight());
            }
            return mask;
        },
    
        /**
         * Removes a previously applied mask.
         */
        unmask : function(){
            var me = this,
                dom = me.dom,
                mask = data(dom, 'mask'),
                maskMsg = data(dom, 'maskMsg');
            if(mask){
                if(maskMsg){
                    maskMsg.remove();
                    data(dom, 'maskMsg', undefined);
                }
                mask.remove();
                data(dom, 'mask', undefined);
            }
            me.removeClass([XMASKED, XMASKEDRELATIVE]);
        },
        
        /**
         * Returns true if this element is masked
         * @return {Boolean}
         */
        isMasked : function(){
            var m = data(this.dom, 'mask');
            return m && m.isVisible();
        },

        /**
        * Calculates the x, y to center this element on the screen
        * @return {Array} The x, y values [x, y]
        */
        getCenterXY : function(){
            return this.getAlignToXY(this.getDocument(), 'c-c');
        },
        /**
         * Gets the x,y coordinates specified by the anchor position on the element.
         * @param {String} anchor (optional) The specified anchor position (defaults to "c").  See {@link #alignTo}
         * for details on supported anchor positions.
         * @param {Boolean} local (optional) True to get the local (element top/left-relative) anchor position instead
         * of page coordinates
         * @param {Object} size (optional) An object containing the size to use for calculating anchor position
         * {width: (target width), height: (target height)} (defaults to the element's current size)
         * @return {Array} [x, y] An array containing the element's x and y coordinates
         */
        getAnchorXY : function(anchor, local, s){
            //Passing a different size is useful for pre-calculating anchors,
            //especially for anchored animations that change the el size.
            anchor = (anchor || "tl").toLowerCase();
            s = s || {};

            var me = this,  doc = this.getDocument(),
                vp = me.dom == doc.body || me.dom == doc,
                w = s.width || vp ? ELD.getViewWidth(false,doc) : me.getWidth(),
                h = s.height || vp ? ELD.getViewHeight(false,doc) : me.getHeight(),
                xy,
                r = Math.round,
                o = me.getXY(),
                scroll = me.getScroll(),
                extraX = vp ? scroll.left : !local ? o[0] : 0,
                extraY = vp ? scroll.top : !local ? o[1] : 0,
                hash = {
                    c  : [r(w * .5), r(h * .5)],
                    t  : [r(w * .5), 0],
                    l  : [0, r(h * .5)],
                    r  : [w, r(h * .5)],
                    b  : [r(w * .5), h],
                    tl : [0, 0],
                    bl : [0, h],
                    br : [w, h],
                    tr : [w, 0]
                };

            xy = hash[anchor];
            return [xy[0] + extraX, xy[1] + extraY];
        },

        /**
         * Anchors an element to another element and realigns it when the window is resized.
         * @param {Mixed} element The element to align to.
         * @param {String} position The position to align to.
         * @param {Array} offsets (optional) Offset the positioning by [x, y]
         * @param {Boolean/Object} animate (optional) True for the default animation or a standard Element animation config object
         * @param {Boolean/Number} monitorScroll (optional) True to monitor body scroll and reposition. If this parameter
         * is a number, it is used as the buffer delay (defaults to 50ms).
         * @param {Function} callback The function to call after the animation finishes
         * @return {Ext.Element} this
         */
        anchorTo : function(el, alignment, offsets, animate, monitorScroll, callback){
            var me = this,
                dom = me.dom;

            function action(){
                fly(dom).alignTo(el, alignment, offsets, animate);
                Ext.callback(callback, fly(dom));
            };

            Ext.EventManager.onWindowResize(action, me);

            if(!Ext.isEmpty(monitorScroll)){
                Ext.EventManager.on(window, 'scroll', action, me,
                    {buffer: !isNaN(monitorScroll) ? monitorScroll : 50});
            }
            action.call(me); // align immediately
            return me;
        },

        /**
         * Returns the current scroll position of the element.
         * @return {Object} An object containing the scroll position in the format {left: (scrollLeft), top: (scrollTop)}
         */
        getScroll : function(){
            var d = this.dom,
                doc = this.getDocument(),
                body = doc.body,
                docElement = doc.documentElement,
                l,
                t,
                ret;

            if(d == doc || d == body){
                if(Ext.isIE && ELD.docIsStrict(doc)){
                    l = docElement.scrollLeft;
                    t = docElement.scrollTop;
                }else{
                    l = window.pageXOffset;
                    t = window.pageYOffset;
                }
                ret = {left: l || (body ? body.scrollLeft : 0), top: t || (body ? body.scrollTop : 0)};
            }else{
                ret = {left: d.scrollLeft, top: d.scrollTop};
            }
            return ret;
        },

        /**
         * Gets the x,y coordinates to align this element with another element. See {@link #alignTo} for more info on the
         * supported position values.
         * @param {Mixed} element The element to align to.
         * @param {String} position The position to align to.
         * @param {Array} offsets (optional) Offset the positioning by [x, y]
         * @return {Array} [x, y]
         */
        getAlignToXY : function(el, p, o){
            var doc;
            el = Ext.get(el, doc = this.getDocument());

            if(!el || !el.dom){
                throw "Element.getAlignToXY with an element that doesn't exist";
            }

            o = o || [0,0];
            p = (p == "?" ? "tl-bl?" : (!/-/.test(p) && p != "" ? "tl-" + p : p || "tl-bl")).toLowerCase();

            var me = this,
                d = me.dom,
                a1,
                a2,
                x,
                y,
                //constrain the aligned el to viewport if necessary
                w,
                h,
                r,
                dw = ELD.getViewWidth(false,doc) -10, // 10px of margin for ie
                dh = ELD.getViewHeight(false,doc)-10, // 10px of margin for ie
                p1y,
                p1x,
                p2y,
                p2x,
                swapY,
                swapX,
                docElement = doc.documentElement,
                docBody = doc.body,
                scrollX = (docElement.scrollLeft || docBody.scrollLeft || 0)+5,
                scrollY = (docElement.scrollTop || docBody.scrollTop || 0)+5,
                c = false, //constrain to viewport
                p1 = "",
                p2 = "",
                m = p.match(/^([a-z]+)-([a-z]+)(\?)?$/);

            if(!m){
               throw "Element.getAlignToXY with an invalid alignment " + p;
            }

            p1 = m[1];
            p2 = m[2];
            c = !!m[3];

            //Subtract the aligned el's internal xy from the target's offset xy
            //plus custom offset to get the aligned el's new offset xy
            a1 = me.getAnchorXY(p1, true);
            a2 = el.getAnchorXY(p2, false);

            x = a2[0] - a1[0] + o[0];
            y = a2[1] - a1[1] + o[1];

            if(c){
               w = me.getWidth();
               h = me.getHeight();
               r = el.getRegion();
               //If we are at a viewport boundary and the aligned el is anchored on a target border that is
               //perpendicular to the vp border, allow the aligned el to slide on that border,
               //otherwise swap the aligned el to the opposite border of the target.
               p1y = p1.charAt(0);
               p1x = p1.charAt(p1.length-1);
               p2y = p2.charAt(0);
               p2x = p2.charAt(p2.length-1);
               swapY = ((p1y=="t" && p2y=="b") || (p1y=="b" && p2y=="t"));
               swapX = ((p1x=="r" && p2x=="l") || (p1x=="l" && p2x=="r"));


               if (x + w > dw + scrollX) {
                    x = swapX ? r.left-w : dw+scrollX-w;
               }
               if (x < scrollX) {
                   x = swapX ? r.right : scrollX;
               }
               if (y + h > dh + scrollY) {
                    y = swapY ? r.top-h : dh+scrollY-h;
                }
               if (y < scrollY){
                   y = swapY ? r.bottom : scrollY;
               }
            }

            return [x,y];
        },
            // private ==>  used outside of core
        adjustForConstraints : function(xy, parent, offsets){
            return this.getConstrainToXY(parent || this.getDocument(), false, offsets, xy) ||  xy;
        },

        // private ==>  used outside of core
        getConstrainToXY : function(el, local, offsets, proposedXY){
            var os = {top:0, left:0, bottom:0, right: 0};

            return function(el, local, offsets, proposedXY){
                var doc = this.getDocument();
                el = Ext.get(el, doc);
                offsets = offsets ? Ext.applyIf(offsets, os) : os;

                var vw, vh, vx = 0, vy = 0;
                if(el.dom == doc.body || el.dom == doc){
                    vw = ELD.getViewWidth(false,doc);
                    vh = ELD.getViewHeight(false,doc);
                }else{
                    vw = el.dom.clientWidth;
                    vh = el.dom.clientHeight;
                    if(!local){
                        var vxy = el.getXY();
                        vx = vxy[0];
                        vy = vxy[1];
                    }
                }

                var s = el.getScroll();

                vx += offsets.left + s.left;
                vy += offsets.top + s.top;

                vw -= offsets.right;
                vh -= offsets.bottom;

                var vr = vx + vw,
                    vb = vy + vh,
                    xy = proposedXY || (!local ? this.getXY() : [this.getLeft(true), this.getTop(true)]);
                    x = xy[0], y = xy[1],
                    offset = this.getConstrainOffset(),
                    w = this.dom.offsetWidth + offset, 
                    h = this.dom.offsetHeight + offset;

                // only move it if it needs it
                var moved = false;

                // first validate right/bottom
                if((x + w) > vr){
                    x = vr - w;
                    moved = true;
                }
                if((y + h) > vb){
                    y = vb - h;
                    moved = true;
                }
                // then make sure top/left isn't negative
                if(x < vx){
                    x = vx;
                    moved = true;
                }
                if(y < vy){
                    y = vy;
                    moved = true;
                }
                return moved ? [x, y] : false;
            };
        }(),
        
        // private, used internally
	    getConstrainOffset : function(){
	        return 0;
	    },
	    
        /**
        * Calculates the x, y to center this element on the screen
        * @return {Array} The x, y values [x, y]
        */
        getCenterXY : function(){
            return this.getAlignToXY(Ext.getBody(this.getDocument()), 'c-c');
        },
       
        /**
        * Centers the Element in either the viewport, or another Element.
        * @param {Mixed} centerIn (optional) The element in which to center the element.
        */
        center : function(centerIn){
            return this.alignTo(centerIn || Ext.getBody(this.getDocument()), 'c-c');
        } ,

        /**
         * Looks at this node and then at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @param {Number/Mixed} maxDepth (optional) The max depth to search as a number or element (defaults to 50 || document.body)
         * @param {Boolean} returnEl (optional) True to return a Ext.Element object instead of DOM node
         * @return {HTMLElement} The matching DOM node (or null if no match was found)
         */
        findParent : function(simpleSelector, maxDepth, returnEl){
            var p = this.dom,
                D = this.getDocument(),
                b = D.body,
                depth = 0,
                stopEl;
            if(Ext.isGecko && OPString.call(p) == '[object XULElement]') {
                return null;
            }
            maxDepth = maxDepth || 50;
            if (isNaN(maxDepth)) {
                stopEl = Ext.getDom(maxDepth, null, D);
                maxDepth = Number.MAX_VALUE;
            }
            while(p && p.nodeType == 1 && depth < maxDepth && p != b && p != stopEl){
                if(Ext.DomQuery.is(p, simpleSelector)){
                    return returnEl ? Ext.get(p, D) : p;
                }
                depth++;
                p = p.parentNode;
            }
            return null;
        },
        /**
         *  Store the current overflow setting and clip overflow on the element - use <tt>{@link #unclip}</tt> to remove
         * @return {Ext.Element} this
         */
        clip : function(){
            var me = this,
                dom = me.dom;
                
            if(!data(dom, ISCLIPPED)){
                data(dom, ISCLIPPED, true);
                data(dom, ORIGINALCLIP, {
                    o: me.getStyle(OVERFLOW),
                    x: me.getStyle(OVERFLOWX),
                    y: me.getStyle(OVERFLOWY)
                });
                me.setStyle(OVERFLOW, HIDDEN);
                me.setStyle(OVERFLOWX, HIDDEN);
                me.setStyle(OVERFLOWY, HIDDEN);
            }
            return me;
        },
    
        /**
         *  Return clipping (overflow) to original clipping before <tt>{@link #clip}</tt> was called
         * @return {Ext.Element} this
         */
        unclip : function(){
            var me = this,
                dom = me.dom;
                
            if(data(dom, ISCLIPPED)){
                data(dom, ISCLIPPED, false);
                var o = data(dom, ORIGINALCLIP);
                if(o.o){
                    me.setStyle(OVERFLOW, o.o);
                }
                if(o.x){
                    me.setStyle(OVERFLOWX, o.x);
                }
                if(o.y){
                    me.setStyle(OVERFLOWY, o.y);
                }
            }
            return me;
        },
        
        getViewSize : function(){
            var doc = this.getDocument(),
                d = this.dom,
                isDoc = (d == doc || d == doc.body);

            // If the body, use Ext.lib.Dom
            if (isDoc) {
                var extdom = Ext.lib.Dom;
                return {
                    width : extdom.getViewWidth(),
                    height : extdom.getViewHeight()
                }

            // Else use clientHeight/clientWidth
            } else {
                return {
                    width : d.clientWidth,
                    height : d.clientHeight
                }
            }
        },
        /**
        * <p>Returns the dimensions of the element available to lay content out in.<p>
        *
        * getStyleSize utilizes prefers style sizing if present, otherwise it chooses the larger of offsetHeight/clientHeight and offsetWidth/clientWidth.
        * To obtain the size excluding scrollbars, use getViewSize
        *
        * Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.
        */

        getStyleSize : function(){
            var me = this,
                w, h,
                doc = this.getDocument(),
                d = this.dom,
                isDoc = (d == doc || d == doc.body),
                s = d.style;

            // If the body, use Ext.lib.Dom
            if (isDoc) {
                var extdom = Ext.lib.Dom;
                return {
                    width : extdom.getViewWidth(),
                    height : extdom.getViewHeight()
                }
            }
            // Use Styles if they are set
            if(s.width && s.width != 'auto'){
                w = parseFloat(s.width);
                if(me.isBorderBox()){
                   w -= me.getFrameWidth('lr');
                }
            }
            // Use Styles if they are set
            if(s.height && s.height != 'auto'){
                h = parseFloat(s.height);
                if(me.isBorderBox()){
                   h -= me.getFrameWidth('tb');
                }
            }
            // Use getWidth/getHeight if style not set.
            return {width: w || me.getWidth(true), height: h || me.getHeight(true)};
        }
    });
   
    Ext.apply(ELD , {
        /**
         * Resolve the current document context of the passed Element
         */
        getDocument : function(el, accessTest){
          var dom= null;
          try{
            dom = Ext.getDom(el, null, null); //will fail if El.dom is non "same-origin" document
          }catch(ex){}

          var isDoc = Ext.isDocument(dom);
          if(isDoc){
            if(accessTest){
                return Ext.isDocument(dom, accessTest) ? dom : null;
            }
            return dom;
          }
          return dom ?
                dom.ownerDocument ||  //Element
                dom.document //Window
                : null;
        },

        /**
         * Return the Compatability Mode of the passed document or Element
         */
        docIsStrict : function(doc){
            return (Ext.isDocument(doc) ? doc : this.getDocument(doc)).compatMode == "CSS1Compat";
        },

        getViewWidth : Ext.overload ([
           ELD.getViewWidth || function(full){},
            function() { return this.getViewWidth(false);},
            function(full, doc) {
                return full ? this.getDocumentWidth(doc) : this.getViewportWidth(doc);
            }]
         ),

        getViewHeight : Ext.overload ([
            ELD.getViewHeight || function(full){},
            function() { return this.getViewHeight(false);},
            function(full, doc) {
                return full ? this.getDocumentHeight(doc) : this.getViewportHeight(doc);
            }]),

        getDocumentHeight: Ext.overload([
           ELD.getDocumentHeight || emptyFn,
           function(doc) {
            if(doc=this.getDocument(doc)){
              return Math.max(
                 !this.docIsStrict(doc) ? doc.body.scrollHeight : doc.documentElement.scrollHeight
                 , this.getViewportHeight(doc)
                 );
            }
            return undefined;
           }
         ]),

        getDocumentWidth: Ext.overload([
           ELD.getDocumentWidth || emptyFn,
           function(doc) {
              if(doc=this.getDocument(doc)){
                return Math.max(
                 !this.docIsStrict(doc) ? doc.body.scrollWidth : doc.documentElement.scrollWidth
                 , this.getViewportWidth(doc)
                 );
              }
              return undefined;
            }
        ]),

        getViewportHeight: Ext.overload([
           ELD.getViewportHeight || emptyFn,
           function(doc){
             if(doc=this.getDocument(doc)){
                if(Ext.isIE){
                    return this.docIsStrict(doc) ? doc.documentElement.clientHeight : doc.body.clientHeight;
                }else{
                    return doc.defaultView.innerHeight;
                }
             }
             return undefined;
           }
        ]),

        getViewportWidth: Ext.overload([
           ELD.getViewportWidth || emptyFn,
           function(doc) {
              if(doc=this.getDocument(doc)){
                return !this.docIsStrict(doc) && !Ext.isOpera ? doc.body.clientWidth :
                   Ext.isIE ? doc.documentElement.clientWidth : doc.defaultView.innerWidth;
              }
              return undefined;
            }
        ]),

        getXY : Ext.overload([
            ELD.getXY || emptyFn,
            function(el, doc) {
                if(typeof el=='string'){
	                el = Ext.getDom(el, null, doc);
	                var D= this.getDocument(el),
	                    bd = D ? (D.body || D.documentElement): null;
	
	                if(!el || !bd || el == bd){ return [0, 0]; }
                }
                return this.getXY(el);
            }
          ])
    });

    var GETDOC = ELD.getDocument,
        flies = El._flyweights;

    /**
     * @private
     * Add Ext.fly support for targeted document contexts
     */
    
    Ext.fly = El.fly = function(el, named, doc){
        var ret = null;
        named = named || '_global';

        if (el = Ext.getDom(el, null, doc)) {
            (ret = flies[named] = (flies[named] || new El.Flyweight())).dom = el;
            Ext.isDocument(el) && (ret._isDoc = true);
        }
        return ret;
    };

    var flyFn = function(){};
    flyFn.prototype = El.prototype;

    // dom is optional
    El.Flyweight = function(dom){
       this.dom = dom;
    };

    El.Flyweight.prototype = new flyFn();
    El.Flyweight.prototype.isFlyweight = true;
    
    function addListener(el, ename, fn, task, wrap, scope){
        el = Ext.getDom(el);
        if(!el){ return; }

        var id = Ext.id(el),
            cache = resolveCache(el);
            cache[id] || El.addToCache(el, id, cache);
            
         var es = cache[id].events || {}, wfn;

        wfn = E.on(el, ename, wrap);
        es[ename] = es[ename] || [];
        es[ename].push([fn, wrap, scope, wfn, task]);

        // this is a workaround for jQuery and should somehow be removed from Ext Core in the future
        // without breaking ExtJS.
        if(el.addEventListener && ename == "mousewheel" ){ 
            var args = ["DOMMouseScroll", wrap, false];
            el.addEventListener.apply(el, args);
            Ext.EventManager.addListener(window, 'beforeunload', function(){
                el.removeEventListener.apply(el, args);
            });
        }
        if(ename == "mousedown" && DOC == el){ // fix stopped mousedowns on the document
            Ext.EventManager.stoppedMouseDownEvent.addListener(wrap);
        }
    };

    function createTargeted(h, o){
        return function(){
            var args = Ext.toArray(arguments);
            if(o.target == Ext.EventObject.setEvent(args[0]).target){
                h.apply(this, args);
            }
        };
    };

    function createBuffered(h, o, task){
        return function(e){
            // create new event object impl so new events don't wipe out properties
            task.delay(o.buffer, h, null, [new Ext.EventObjectImpl(e)]);
        };
    };

    function createSingle(h, el, ename, fn, scope){
        return function(e){
            Ext.EventManager.removeListener(el, ename, fn, scope);
            h(e);
        };
    };

    function createDelayed(h, o, fn){
        return function(e){
            var task = new Ext.util.DelayedTask(h);
            (fn.tasks || (fn.tasks = [])).push(task);
            task.delay(o.delay || 10, h, null, [new Ext.EventObjectImpl(e)]);
        };
    };

    function listen(element, ename, opt, fn, scope){
        var o = !Ext.isObject(opt) ? {} : opt,
            el = Ext.getDom(element), task;

        fn = fn || o.fn;
        scope = scope || o.scope;

        if(!el){
            throw "Error listening for \"" + ename + '\". Element "' + element + '" doesn\'t exist.';
        }
        function h(e){
            // prevent errors while unload occurring
            if(!window.Ext){ return; }
            e = Ext.EventObject.setEvent(e);
            var t;
            if (o.delegate) {
                if(!(t = e.getTarget(o.delegate, el))){
                    return;
                }
            } else {
                t = e.target;
            }
            if (o.stopEvent) {
                e.stopEvent();
            }
            if (o.preventDefault) {
               e.preventDefault();
            }
            if (o.stopPropagation) {
                e.stopPropagation();
            }
            if (o.normalized) {
                e = e.browserEvent;
            }

            fn.call(scope || el, e, t, o);
        };
        if(o.target){
            h = createTargeted(h, o);
        }
        if(o.delay){
            h = createDelayed(h, o, fn);
        }
        if(o.single){
            h = createSingle(h, el, ename, fn, scope);
        }
        if(o.buffer){
            task = new Ext.util.DelayedTask(h);
            h = createBuffered(h, o, task);
        }

        addListener(el, ename, fn, task, h, scope);
        return h;
    };

    Ext.apply(Evm ,{
         addListener : Evm.on = function(element, eventName, fn, scope, options){
            if(typeof eventName == 'object'){
                var o = eventName, e, val;
                for(e in o){
                    if(!o.hasOwnProperty(e)) {
                        continue;
                    }
                    val = o[e];
                    if(!propRe.test(e)){
                        if(Ext.isFunction(val)){
                            // shared options
                            listen(element, e, o, val, o.scope);
                        }else{
                            // individual options
                            listen(element, e, val);
                        }
                    }
                }
            } else {
                listen(element, eventName, options, fn, scope);
            }
        },

        /**
         * Removes an event handler from an element.  The shorthand version {@link #un} is equivalent.  Typically
         * you will use {@link Ext.Element#removeListener} directly on an Element in favor of calling this version.
         * @param {String/HTMLElement} el The id or html element from which to remove the listener.
         * @param {String} eventName The name of the event.
         * @param {Function} fn The handler function to remove. <b>This must be a reference to the function passed into the {@link #addListener} call.</b>
         * @param {Object} scope If a scope (<b><code>this</code></b> reference) was specified when the listener was added,
         * then this must refer to the same object.
         */
        removeListener : Evm.un = function(element, eventName, fn, scope){
            var el = Ext.getDom(element);
            el && Ext.get(el);
            var elCache = el ? resolveCache(el) : {},
                f = el && ((elCache[el.id]||{events:{}}).events)[eventName] || [],
                wrap, i, l, k, len, fnc, evs;

            for (i = 0, len = f.length; i < len; i++) {
                /* 0 = Original Function,
                   1 = Event Manager Wrapped Function,
                   2 = Scope,
                   3 = Adapter Wrapped Function,
                   4 = Buffered Task
                */
                if (Ext.isArray(fnc = f[i]) && fnc[0] == fn && (!scope || fnc[2] == scope)) {
                    fnc[4] && fnc[4].cancel();
                    k = fn.tasks && fn.tasks.length;
                    if(k) {
                        while(k--) {
                            fn.tasks[k].cancel();
                        }
                        delete fn.tasks;
                    }
                    wrap = fnc[1];
                    E.un(el, eventName, E.extAdapter ? fnc[3] : wrap);
                    
                    // jQuery workaround that should be removed from Ext Core
                    if(wrap && eventName == "mousewheel" && el.addEventListener ){
                        el.removeEventListener("DOMMouseScroll", wrap, false);
                    }
        
                    if(wrap && eventName == "mousedown" && DOC == el){ // fix stopped mousedowns on the document
                        Ext.EventManager.stoppedMouseDownEvent.removeListener(wrap);
                    }
                    
                    f.splice(i,1);
                    if (f.length === 0) {
                        delete elCache[el.id].events[eventName];
                    }
                    evs = elCache[el.id].events;
                    for (k in evs) {
                        if(evs.hasOwnProperty(k)) {
	                         return false;
	                    }
                    }
                    elCache[el.id].events = {};
                    return false;
                }
            }

            
        },

        /**
         * Removes all event handers from an element.  Typically you will use {@link Ext.Element#removeAllListeners}
         * directly on an Element in favor of calling this version.
         * @param {String/HTMLElement} el The id or html element from which to remove all event handlers.
         */
        removeAll : function(el){
            if (!(el = Ext.getDom(el))) {
                return;
            }
            var id = el.id,
                elCache = resolveCache(el)||{},
                es = elCache[id] || {},
                ev = es.events || {},
                f, i, len, ename, fn, k, wrap;

            for(ename in ev){
                if(ev.hasOwnProperty(ename)){
                    f = ev[ename];
                    /* 0 = Original Function,
                       1 = Event Manager Wrapped Function,
                       2 = Scope,
                       3 = Adapter Wrapped Function,
                       4 = Buffered Task
                    */
                    for (i = 0, len = f.length; i < len; i++) {
                        fn = f[i];
                        fn[4] && fn[4].cancel();
                        if(fn[0] && fn[0].tasks && (k = fn[0].tasks.length)) {
                            while(k--) {
                                fn[0].tasks[k].cancel();
                            }
                            delete fn.tasks;
                        }
                        
                        wrap =  fn[1];
                        E.un(el, ename, E.extAdapter ? fn[3] : wrap);

                        // jQuery workaround that should be removed from Ext Core
                        if(wrap && el.addEventListener && ename == "mousewheel"){
                            el.removeEventListener("DOMMouseScroll", wrap, false);
                        }

                        // fix stopped mousedowns on the document
                        if(wrap && (DOC == el) && ename == "mousedown"){
                            Ext.EventManager.stoppedMouseDownEvent.removeListener(wrap);
                        }
                    }
                }
            }
            elCache[id] && (elCache[id].events = {});
        },

        getListeners : function(el, eventName) {
            el = Ext.getDom(el);
            if (!el) {
                return;
            }
            var id = (Ext.get(el)||{}).id,
                elCache = resolveCache(el),
                es = ( elCache[id] || {} ).events || {};

            return es[eventName] || null;
        },

        purgeElement : function(el, recurse, eventName) {
            el = Ext.getDom(el);
            var id = Ext.id(el),
                elCache = resolveCache(el),
                es = (elCache[id] || {}).events || {},
                i, f, len;
            if (eventName) {
                if (es.hasOwnProperty(eventName)) {
                    f = es[eventName];
                    for (i = 0, len = f.length; i < len; i++) {
                        Evm.removeListener(el, eventName, f[i][0]);
                    }
                }
            } else {
                Evm.removeAll(el);
            }
            if (recurse && el && el.childNodes) {
                for (i = 0, len = el.childNodes.length; i < len; i++) {
                    Evm.purgeElement(el.childNodes[i], recurse, eventName);
                }
            }
        }
    });
    
    // deprecated, call from EventManager
    E.getListeners = function(el, eventName) {
       return Ext.EventManager.getListeners(el, eventName);
    };

    /** @sourceURL=<multidom.js> */
    Ext.provide && Ext.provide('multidom');
 })();/* global Ext */
/*
 * Copyright 2007-2010, Active Group, Inc.  All rights reserved.
 * ******************************************************************************
 * This file is distributed on an AS IS BASIS WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * ***********************************************************************************
 * @version 2.1.4
 * [For Ext 3.1.1 or higher only]
 *
 * License: ux.ManagedIFrame, ux.ManagedIFrame.Panel, ux.ManagedIFrame.Portlet, ux.ManagedIFrame.Window  
 * are licensed under the terms of the Open Source GPL 3.0 license:
 * http://www.gnu.org/licenses/gpl.html
 *
 * Commercial use is prohibited without a Commercial Developement License. See
 * http://licensing.theactivegroup.com.
 *
 * Donations are welcomed: http://donate.theactivegroup.com
 *
 */
 
(function(){
    
    var El = Ext.Element, 
        ElFrame, 
        ELD = Ext.lib.Dom,
        EMPTYFN = function(){},
        OP = Object.prototype,
        addListener = function () {
            var handler;
            if (window.addEventListener) {
                handler = function F(el, eventName, fn, capture) {
                    el.addEventListener(eventName, fn, !!capture);
                };
            } else if (window.attachEvent) {
                handler = function F(el, eventName, fn, capture) {
                    el.attachEvent("on" + eventName, fn);
                };
            } else {
                handler = function F(){};
            }
            var F = null; //Gbg collect
            return handler;
        }(),
       removeListener = function() {
            var handler;
            if (window.removeEventListener) {
                handler = function F(el, eventName, fn, capture) {
                    el.removeEventListener(eventName, fn, (capture));
                };
            } else if (window.detachEvent) {
                handler = function F(el, eventName, fn) {
                    el.detachEvent("on" + eventName, fn);
                };
            } else {
                handler = function F(){};
            }
            var F = null; //Gbg collect
            return handler;
        }();
 
  //assert multidom support: REQUIRED for Ext 3 or higher!
  if(typeof ELD.getDocument != 'function'){
     alert("MIF 2.1.4 requires multidom support" );
  }
  //assert Ext 3.1.1+ 
  if(!Ext.elCache || parseInt( Ext.version.replace(/\./g,''),10) < 311 ) {
    alert ('Ext Release '+Ext.version+' is not supported');
   }
  
  Ext.ns('Ext.ux.ManagedIFrame', 'Ext.ux.plugin');
  
  var MIM, MIF = Ext.ux.ManagedIFrame, MIFC;
  var frameEvents = ['documentloaded',
                     'domready',
                     'focus',
                     'blur',
                     'resize',
                     'scroll',
                     'unload',
                     'scroll',
                     'exception', 
                     'message',
                     'reset'];
                     
    var reSynthEvents = new RegExp('^('+frameEvents.join('|')+ ')', 'i');

    /**
     * @class Ext.ux.ManagedIFrame.Element
     * @extends Ext.Element
     * @version 2.1.4 
     * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a> 
     * @author Doug Hendricks. Forum ID: <a href="http://extjs.com/forum/member.php?u=8730">hendricd</a> 
     * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
     * @copyright 2007-2010, Active Group, Inc. All rights reserved.
     * @constructor Create a new Ext.ux.ManagedIFrame.Element directly. 
     * @param {String/HTMLElement} element
     * @param {Boolean} forceNew (optional) By default the constructor checks to see if there is already an instance of this element in the cache and if there is it returns the same instance. This will skip that check (useful for extending this class).
     * @param {DocumentElement} (optional) Document context uses to resolve an Element search by its id.
     */
     
    Ext.ux.ManagedIFrame.Element = Ext.extend(Ext.Element, {
                         
            constructor : function(element, forceNew, doc ){
                var d = doc || document,
                	elCache  = ELD.resolveDocumentCache(d),
                    dom = Ext.getDom(element, false, d);
                
                if(!dom || !(/^(iframe|frame)/i).test(dom.tagName)) { // invalid id/element
                    return null;
                }
                var id = Ext.id(dom);
                
                /**
                 * The DOM element
                 * @type HTMLElement
                 */
                this.dom = dom;
                
                /**
                 * The DOM element ID
                 * @type String
                 */
                this.id = id ;
                
                (elCache[id] || 
                   (elCache[id] = {
                     el: this,
                     events : {},
                     data : {}
                    })
                ).el = this;
                
                this.dom.name || (this.dom.name = this.id);
                 
                if(Ext.isIE){
                     document.frames && (document.frames[this.dom.name] || (document.frames[this.dom.name] = this.dom));
                 }
                 
                this.dom.ownerCt = this;
                MIM.register(this);

                if(!this._observable){
	                    (this._observable = new Ext.util.Observable()).addEvents(
	                    
	                    /**
	                     * Fires when the iFrame has reached a loaded/complete state.
	                     * @event documentloaded
	                     * @param {Ext.ux.MIF.Element} this
	                     */
	                    'documentloaded',
	                    
	                    /**
	                     * Fires ONLY when an iFrame's Document(DOM) has reach a
	                     * state where the DOM may be manipulated ('same origin' policy)
	                     * Note: This event is only available when overwriting the iframe
	                     * document using the update or load methods and "same-origin"
	                     * documents. Returning false from the eventHandler stops further event
	                     * (documentloaded) processing.
	                     * @event domready 
	                     * @param {Ext.ux.MIF.Element} this
	                     */
	
	                    'domready',
	                    
	                    /**
	                     * Fires when the frame actions raise an error
	                     * @event exception
	                     * @param {Ext.ux.MIF.Element} this.iframe
	                     * @param {Error/string} exception
	                     */
	                     'exception',
	                     
	                    /**
	                     * Fires when the frame's window is resized.  This event, when raised from a "same-origin" frame,
	                     * will send current height/width reports with the event.
	                     * @event resize
	                     * @param {Ext.ux.MIF.Element} this.iframe
	                     * @param {Object} documentSize A height/width object signifying the new document size
	                     * @param {Object} viewPortSize A height/width object signifying the size of the frame's viewport
	                     * @param {Object} viewSize A height/width object signifying the size of the frame's view
	                     */
	                     'resize',
	                     
	                    /**
	                     * Fires upon receipt of a message generated by window.sendMessage
	                     * method of the embedded Iframe.window object
	                     * @event message
	                     * @param {Ext.ux.MIF} this.iframe
	                     * @param {object}
	                     *            message (members: type: {string} literal "message", data
	                     *            {Mixed} [the message payload], domain [the document domain
	                     *            from which the message originated ], uri {string} the
	                     *            document URI of the message sender source (Object) the
	                     *            window context of the message sender tag {string} optional
	                     *            reference tag sent by the message sender
	                     * <p>Alternate event handler syntax for message:tag filtering Fires upon
	                     * receipt of a message generated by window.sendMessage method which
	                     * includes a specific tag value of the embedded Iframe.window object
	                     */
	                    'message',
	
	                    /**
	                     * Fires when the frame is blurred (loses focus).
	                     * @event blur
	                     * @param {Ext.ux.MIF} this
	                     * @param {Ext.Event}
	                     *            Note: This event is only available when overwriting the
	                     *            iframe document using the update method and to pages
	                     *            retrieved from a "same domain". Returning false from the
	                     *            eventHandler [MAY] NOT cancel the event, as this event is
	                     *            NOT ALWAYS cancellable in all browsers.
	                     */
	                     'blur',
	
	                    /**
	                     * Fires when the frame gets focus. Note: This event is only available
	                     * when overwriting the iframe document using the update method and to
	                     * pages retrieved from a "same domain". Returning false from the
	                     * eventHandler [MAY] NOT cancel the event, as this event is NOT ALWAYS
	                     * cancellable in all browsers.
	                     * @event focus
	                     * @param {Ext.ux.MIF.Element} this
	                     * @param {Ext.Event}
	                     *
	                    */
	                    'focus',
	
	                    /**
	                     * Note: This event is only available when overwriting the iframe
	                     * document using the update method and to pages retrieved from a "same-origin"
	                     * domain. Note: Opera does not raise this event.
	                     * @event unload * Fires when(if) the frames window object raises the unload event
	                     * @param {Ext.ux.MIF.Element} this.
	                     * @param {Ext.Event}
	                     */
	                     'unload',
	                     
	                     /**
	                     * Note: This event is only available when overwriting the iframe
	                     * document using the update method and to pages retrieved from a "same-origin"
	                     * domain.  To prevent numerous scroll events from being raised use the buffer listener 
	                     * option to limit the number of times the event is raised.
	                     * @event scroll 
	                     * @param {Ext.ux.MIF.Element} this.
	                     * @param {Ext.Event}
	                     */
	                     'scroll',
	                     
	                    /**
	                     * Fires when the iFrame has been reset to a neutral domain state (blank document).
	                     * @event reset
	                     * @param {Ext.ux.MIF.Element} this
	                     */
	                    'reset'
	                 );
	                    //  Private internal document state events.
	                 this._observable.addEvents('_docready','_docload');
                 } 
                 
                 // Hook the Iframes loaded and error state handlers
                 this.on(
                    Ext.isIE? 'readystatechange' : 'load', 
                    this.loadHandler, 
                    this, 
                    /**
                     * Opera still fires LOAD events for images within the FRAME as well,
                     * so we'll buffer hopefully catching one of the later events
                     */ 
                    Ext.isOpera ? {buffer: this.operaLoadBuffer|| 2000} : null
                 );
                 this.on('error', this.loadHandler, this);
            },

            /** @private
             * Removes the MIFElement interface from the FRAME Element.
             * It does NOT remove the managed FRAME from the DOM.  Use the {@link Ext.#ux.ManagedIFrame.Element-remove} method to perfom both functions.
             */
            destructor   :  function () {

                MIM.deRegister(this);
                this.removeAllListeners();
                Ext.destroy(this.frameShim, this.DDM);
                this.hideMask(true);
                delete this.loadMask;
                this.reset(); 
                this.manager = null;
                this.dom.ownerCt = null;
            },
            
            /**
             * Deep cleansing childNode Removal
             * @param {Boolean} forceReclean (optional) By default the element
             * keeps track if it has been cleansed already so
             * you can call this over and over. However, if you update the element and
             * need to force a reclean, you can pass true.
             * @param {Boolean} deep (optional) Perform a deep cleanse of all childNodes as well.
             */
            cleanse : function(forceReclean, deep){
                if(this.isCleansed && forceReclean !== true){
                    return this;
                }
                var d = this.dom, n = d.firstChild, nx;
                while(d && n){
                     nx = n.nextSibling;
                     deep && Ext.fly(n).cleanse(forceReclean, deep);
                     Ext.removeNode(n);
                     n = nx;
                }
                this.isCleansed = true;
                return this;
            },

            /** (read-only) The last known URI set programmatically by the Component
             * @property  
             * @type {String|Function}
             */
            src     : null,

            /** (read-only) For "same-origin" frames only.  Provides a reference to
             * the Ext.util.CSS singleton to manipulate the style sheets of the frame's
             * embedded document.
             *
             * @property
             * @type Ext.util.CSS
             */
            CSS     : null,

            /** Provides a reference to the managing Ext.ux.MIF.Manager instance.
             *
             * @property
             * @type Ext.ux.MIF.Manager
             */
            manager : null,
            
            /**
             * @cfg {Number} operaLoadBuffer Listener buffer time (in milliseconds) to buffer
             * Opera's errant load events (fired for inline images as well) for IFRAMES.
             */
            operaLoadBuffer   : 2000,

            /**
              * @cfg {Boolean} disableMessaging False to enable cross-frame messaging API
              * @default true
              *
              */
            disableMessaging  :  true,

             /**
              * @cfg {Integer} domReadyRetries 
              * Maximum number of domready event detection retries for IE.  IE does not provide
              * a native DOM event to signal when the frames DOM may be manipulated, so a polling process
              * is used to determine when the documents BODY is available. <p> Certain documents may not contain
              * a BODY tag:  eg. MHT(rfc/822), XML, or other non-HTML content. Detection polling will stop after this number of 2ms retries 
              * or when the documentloaded event is raised.</p>
              * @default 7500 (* 2 = 15 seconds) 
              */
            domReadyRetries   :  7500,
            
            /**
             * True to set focus on the frame Window as soon as its document
             * reports loaded.  <p>(Many external sites use IE's document.createRange to create 
             * DOM elements, but to be successful, IE requires that the FRAME have focus before
             * such methods are called)</p>
             * @cfg focusOnLoad
             * @default true if IE
             */
            focusOnLoad   : Ext.isIE,
            
            /**
              * Toggles raising of events for URL actions that the Component did not initiate. 
              * @cfg {Boolean} eventsFollowFrameLinks set true to propogate domready and documentloaded
              * events anytime the IFRAME's URL changes
              * @default true
              */
            eventsFollowFrameLinks   : true,
           

            /**
             * Removes the FRAME from the DOM and deletes it from the cache
             */
            remove  : function(){
                this.destructor.apply(this, arguments);
                ElFrame.superclass.remove.apply(this,arguments);
            },
            
            /**
             * Return the ownerDocument property of the IFRAME Element.
             * (Note: This is not the document context of the FRAME's loaded document. 
             * See the getFrameDocument method for that.)
             */
            getDocument :  
                function(){ return this.dom ? this.dom.ownerDocument : document;},
            
            /**
	         * Loads the frame Element with the response from a form submit to the 
	         * specified URL with the ManagedIframe.Element as it's submit target.
	         *
	         * @param {Object} submitCfg A config object containing any of the following options:
	         * <pre><code>
	         *      myIframe.submitAsTarget({
	         *         form : formPanel.form,  //optional Ext.FormPanel, Ext form element, or HTMLFormElement
	         *         url: &quot;your-url.php&quot;,
             *         action : (see url) ,
	         *         params: {param1: &quot;foo&quot;, param2: &quot;bar&quot;}, // or URL encoded string or function that returns either
	         *         callback: yourFunction,  //optional, called with the signature (frame)
	         *         scope: yourObject, // optional scope for the callback
	         *         method: 'POST', //optional form.method 
             *         encoding : "multipart/form-data" //optional, default = HTMLForm default  
	         *      });
	         *
	         * </code></pre>
             * @return {Ext.ux.ManagedIFrame.Element} this
	         *
	         */
            submitAsTarget : function(submitCfg){
                var opt = submitCfg || {}, 
                D = this.getDocument(),
  	            form = Ext.getDom(
                       opt.form ? opt.form.form || opt.form: null, false, D) || 
                  Ext.DomHelper.append(D.body, { 
                    tag: 'form', 
                    cls : 'x-hidden x-mif-form',
                    encoding : 'multipart/form-data'
                  }),
                formFly = Ext.fly(form, '_dynaForm'),
                formState = {
                    target: form.target || '',
                    method: form.method || '',
                    encoding: form.encoding || '',
                    enctype: form.enctype || '',
                    action: form.action || '' 
                 },
                encoding = opt.encoding || form.encoding,
                method = opt.method || form.method || 'POST';
        
                formFly.set({
                   target  : this.dom.name,
                   method  : method,
                   encoding: encoding,
                   action  : opt.url || opt.action || form.action
                });
                
                if(method == 'POST' || !!opt.enctype){
                    formFly.set({enctype : opt.enctype || form.enctype || encoding});
                }
                
		        var hiddens, hd, ps;
                // add any additional dynamic params
		        if(opt.params && (ps = Ext.isFunction(opt.params) ? opt.params() : opt.params)){ 
		            hiddens = [];
                     
		            Ext.iterate(ps = typeof ps == 'string'? Ext.urlDecode(ps, false): ps, 
                        function(n, v){
		                    Ext.fly(hd = D.createElement('input')).set({
		                     type : 'hidden',
		                     name : n,
		                     value: v
                            });
		                    form.appendChild(hd);
		                    hiddens.push(hd);
		                });
		        }
		
		        opt.callback && 
                    this._observable.addListener('_docready',opt.callback, opt.scope,{single:true});
                     
                this._frameAction = true;
                this._targetURI = location.href;
		        this.showMask();
		        
		        //slight delay for masking
		        (function(){
                    
		            form.submit();
                    // remove dynamic inputs
		            hiddens && Ext.each(hiddens, Ext.removeNode, Ext);

                    //Remove if dynamically generated, restore state otherwise
		            if(formFly.hasClass('x-mif-form')){
                        formFly.remove();
                    }else{
                        formFly.set(formState);
                    }
                    delete El._flyweights['_dynaForm'];
                    formFly = null;
		            this.hideMask(true);
		        }).defer(100, this);
                
                return this;
		    },

            /**
             * @cfg {String} resetUrl Frame document reset string for use with the {@link #Ext.ux.ManagedIFrame.Element-reset} method.
             * Defaults:<p> For IE on SSL domains - the current value of Ext.SSL_SECURE_URL<p> "about:blank" for all others.
             */
            resetUrl : (function(){
                return Ext.isIE && Ext.isSecure ? Ext.SSL_SECURE_URL : 'about:blank';
            })(),

            /**
             * Sets the embedded Iframe src property. Note: invoke the function with
             * no arguments to refresh the iframe based on the current src value.
             *
             * @param {String/Function} url (Optional) A string or reference to a Function that
             *            returns a URI string when called
             * @param {Boolean} discardUrl (Optional) If not passed as <tt>false</tt>
             *            the URL of this action becomes the default SRC attribute
             *            for this iframe, and will be subsequently used in future
             *            setSrc calls (emulates autoRefresh by calling setSrc
             *            without params).
             * @param {Function} callback (Optional) A callback function invoked when the
             *            frame document has been fully loaded.
             * @param {Object} scope (Optional) scope by which the callback function is
             *            invoked.
             */
            setSrc : function(url, discardUrl, callback, scope) {
                var src = url || this.src || this.resetUrl;
                
                var O = this._observable;
                this._unHook();
                Ext.isFunction(callback) && O.addListener('_docload', callback, scope||this, {single:true});
                this.showMask();
                (discardUrl !== true) && (this.src = src);
                var s = this._targetURI = (Ext.isFunction(src) ? src() || '' : src);
                try {
                    this._frameAction = true; // signal listening now
                    this.dom.src = s;
                    this.checkDOM();
                } catch (ex) {
                    O.fireEvent.call(O, 'exception', this, ex);
                }
                return this;
            },

            /**
             * Sets the embedded Iframe location using its replace method (precluding a history update). 
             * Note: invoke the function with no arguments to refresh the iframe based on the current src value.
             *
             * @param {String/Function} url (Optional) A string or reference to a Function that
             *            returns a URI string when called
             * @param {Boolean} discardUrl (Optional) If not passed as <tt>false</tt>
             *            the URL of this action becomes the default SRC attribute
             *            for this iframe, and will be subsequently used in future
             *            setSrc calls (emulates autoRefresh by calling setSrc
             *            without params).
             * @param {Function} callback (Optional) A callback function invoked when the
             *            frame document has been fully loaded.
             * @param {Object} scope (Optional) scope by which the callback function is
             *            invoked.
             *
             */
            setLocation : function(url, discardUrl, callback, scope) {

                var src = url || this.src || this.resetUrl;
                var O = this._observable;
                this._unHook();
                Ext.isFunction(callback) && O.addListener('_docload', callback, scope||this, {single:true});
                this.showMask();
                var s = this._targetURI = (Ext.isFunction(src) ? src() || '' : src);
                if (discardUrl !== true) {
                    this.src = src;
                }
                try {
                    this._frameAction = true; // signal listening now
                    this.getWindow().location.replace(s);
                    this.checkDOM();
                } catch (ex) {
                    O.fireEvent.call(O,'exception', this, ex);
                }
                return this;
            },

            /**
             * Resets the frame to a neutral (blank document) state without
             * loadMasking.
             *
             * @param {String}
             *            src (Optional) A specific reset string (eg. 'about:blank')
             *            to use for resetting the frame.
             * @param {Function}
             *            callback (Optional) A callback function invoked when the
             *            frame reset is complete.
             * @param {Object}
             *            scope (Optional) scope by which the callback function is
             *            invoked.
             */
            reset : function(src, callback, scope) {
                
                this._unHook();
                var loadMaskOff = false,
                    s = src, 
                    win = this.getWindow(),
                    O = this._observable;
                    
                if(this.loadMask){
                    loadMaskOff = this.loadMask.disabled;
                    this.loadMask.disabled = false;
                 }
                this.hideMask(true);
                
                if(win){
                    this.isReset= true;
                    var cb = callback;
	                O.addListener('_docload',
	                  function(frame) {
	                    if(this.loadMask){
	                        this.loadMask.disabled = loadMaskOff;
	                    };
	                    Ext.isFunction(cb) &&  (cb = cb.apply(scope || this, arguments));
                        O.fireEvent("reset", this);
	                }, this, {single:true});
	            
                    Ext.isFunction(s) && ( s = src());
                    s = this._targetURI = Ext.isEmpty(s, true)? this.resetUrl: s;
                    win.location ? (win.location.href = s) : O.fireEvent('_docload', this);
                }
                
                return this;
            },

           /**
            * @private
            * Regular Expression filter pattern for script tag removal.
            * @cfg {regexp} scriptRE script removal RegeXp
            * Default: "/(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/gi"
            */
            scriptRE : /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/gi,

            /**
             * Write(replacing) string content into the IFrames document structure
             * @param {String} content The new content
             * @param {Boolean} loadScripts
             * (optional) true to also render and process embedded scripts
             * @param {Function} callback (Optional) A callback function invoked when the
             * frame document has been written and fully loaded. @param {Object}
             * scope (Optional) scope by which the callback function is invoked.
             */
            update : function(content, loadScripts, callback, scope) {
                loadScripts = loadScripts || this.getUpdater().loadScripts || false;
                content = Ext.DomHelper.markup(content || '');
                content = loadScripts === true ? content : content.replace(this.scriptRE, "");
                var doc;
                if ((doc = this.getFrameDocument()) && !!content.length) {
                    this._unHook();
                    this.src = null;
                    this.showMask();
                    Ext.isFunction(callback) &&
                        this._observable.addListener('_docload', callback, scope||this, {single:true});
                    this._targetURI = location.href;
                    doc.open();
                    this._frameAction = true;
                    doc.write(content);
                    doc.close();
                    this.checkDOM();

                } else {
                    this.hideMask(true);
                    Ext.isFunction(callback) && callback.call(scope, this);
                }
                
                return this;
            },
            
            /**
             * Executes a Midas command on the current document, current selection, or the given range.
             * @param {String} command The command string to execute in the frame's document context.
             * @param {Booloean} userInterface (optional) True to enable user interface (if supported by the command)
             * @param {Mixed} value (optional)
             * @param {Boolean} validate If true, the command is validated to ensure it's invocation is permitted.
             * @return {Boolean} indication whether command execution succeeded
             */
            execCommand : function(command, userInterface, value, validate){
               var doc, assert;
               if ((doc = this.getFrameDocument()) && !!command) {
                  try{
                      Ext.isIE && this.getWindow().focus();
	                  assert = validate && Ext.isFunction(doc.queryCommandEnabled) ? 
	                    doc.queryCommandEnabled(command) : true;
                  
                      return assert && doc.execCommand(command, !!userInterface, value);
                  }catch(eex){return false;}
               }
               return false;
                
            },

            /**
             * Sets the current DesignMode attribute of the Frame's document
             * @param {Boolean/String} active True (or "on"), to enable designMode
             * 
             */
            setDesignMode : function(active){
               var doc;
               (doc = this.getFrameDocument()) && 
                 (doc.designMode = (/on|true/i).test(String(active))?'on':'off');
            },
            
            /**
            * Gets this element's Updater
            * 
            * @return {Ext.ux.ManagedIFrame.Updater} The Updater
            */
            getUpdater : function(){
               return this.updateManager || 
                    (this.updateManager = new MIF.Updater(this));
                
            },

            /**
             * Method to retrieve frame's history object.
             * @return {object} or null if permission was denied
             */
            getHistory  : function(){
                var h=null;
                try{ h=this.getWindow().history; }catch(eh){}
                return h;
            },
            
            /**
             * Method to retrieve embedded frame Element objects. Uses simple
             * caching (per frame) to consistently return the same object.
             * Automatically fixes if an object was recreated with the same id via
             * AJAX or DOM.
             *
             * @param {Mixed}
             *            el The id of the node, a DOM Node or an existing Element.
             * @return {Element} The Element object (or null if no matching element
             *         was found)
             */
            get : function(el) {
                var doc = this.getFrameDocument();
                return doc? Ext.get(el, doc) : doc=null;
            },

            /**
             * Gets the globally shared flyweight Element for the frame, with the
             * passed node as the active element. Do not store a reference to this
             * element - the dom node can be overwritten by other code.
             *
             * @param {String/HTMLElement}
             *            el The dom node or id
             * @param {String}
             *            named (optional) Allows for creation of named reusable
             *            flyweights to prevent conflicts (e.g. internally Ext uses
             *            "_internal")
             * @return {Element} The shared Element object (or null if no matching
             *         element was found)
             */
            fly : function(el, named) {
                var doc = this.getFrameDocument();
                return doc ? Ext.fly(el, named, doc) : null;
            },

            /**
             * Return the dom node for the passed string (id), dom node, or
             * Ext.Element relative to the embedded frame document context.
             *
             * @param {Mixed} el
             * @return HTMLElement
             */
            getDom : function(el) {
                var d;
                if (!el || !(d = this.getFrameDocument())) {
                    return (d=null);
                }
                return Ext.getDom(el, d);
            },
            
            /**
             * Creates a {@link Ext.CompositeElement} for child nodes based on the
             * passed CSS selector (the selector should not contain an id).
             *
             * @param {String} selector The CSS selector
             * @param {Boolean} unique (optional) True to create a unique Ext.Element for
             *            each child (defaults to false, which creates a single
             *            shared flyweight object)
             * @return {Ext.CompositeElement/Ext.CompositeElementLite} The composite element
             */
            select : function(selector, unique) {
                var d; return (d = this.getFrameDocument()) ? Ext.Element.select(selector,unique, d) : d=null;
            },

            /**
             * Selects frame document child nodes based on the passed CSS selector
             * (the selector should not contain an id).
             *
             * @param {String} selector The CSS selector
             * @return {Array} An array of the matched nodes
             */
            query : function(selector) {
                var d; return (d = this.getFrameDocument()) ? Ext.DomQuery.select(selector, d): null;
            },
            
            /**
             * Removes a DOM Element from the embedded document
             * @param {Element/String} node The node id or node Element to remove
             */
            removeNode : Ext.removeNode,
            
            /**
             * @private execScript sandbox and messaging interface
             */ 
            _renderHook : function() {
                this._windowContext = null;
                this.CSS = this.CSS ? this.CSS.destroy() : null;
                this._hooked = false;
                try {
                    if (this.writeScript('(function(){(window.hostMIF = parent.document.getElementById("'
                                    + this.id
                                    + '").ownerCt)._windowContext='
                                    + (Ext.isIE
                                            ? 'window'
                                            : '{eval:function(s){return new Function("return ("+s+")")();}}')
                                    + ';})()')) {
                        var w, p = this._frameProxy, D = this.getFrameDocument();
                        if(w = this.getWindow()){
                            p || (p = this._frameProxy = this._eventProxy.createDelegate(this));    
                            addListener(w, 'focus', p);
                            addListener(w, 'blur', p);
                            addListener(w, 'resize', p);
                            addListener(w, 'unload', p);
                            D && addListener(Ext.isIE ? w : D, 'scroll', p);
                        }
                        
                        D && (this.CSS = new Ext.ux.ManagedIFrame.CSS(D));
                       
                    }
                } catch (ex) {}
                return this.domWritable();
            },
            
             /** @private : clear all event listeners and Element cache */
            _unHook : function() {
                if (this._hooked) {
                    
                    this._windowContext && (this._windowContext.hostMIF = null);
                    this._windowContext = null;
                
                    var w, p = this._frameProxy;
                    if(p && this.domWritable() && (w = this.getWindow())){
                        removeListener(w, 'focus', p);
                        removeListener(w, 'blur', p);
                        removeListener(w, 'resize', p);
                        removeListener(w, 'unload', p);
                        removeListener(Ext.isIE ? w : this.getFrameDocument(), 'scroll', p);
                    }
                }
                
                ELD.clearDocumentCache && ELD.clearDocumentCache(this.id);
                this.CSS = this.CSS ? this.CSS.destroy() : null;
                this.domFired = this._frameAction = this.domReady = this._hooked = false;
            },
            
            /** @private */
            _windowContext : null,

            /**
             * If sufficient privilege exists, returns the frame's current document
             * as an HTMLElement.
             *
             * @return {HTMLElement} The frame document or false if access to document object was denied.
             */
            getFrameDocument : function() {
                var win = this.getWindow(), doc = null;
                try {
                    doc = (Ext.isIE && win ? win.document : null)
                            || this.dom.contentDocument
                            || window.frames[this.dom.name].document || null;
                } catch (gdEx) {
                    
                    ELD.clearDocumentCache && ELD.clearDocumentCache(this.id);
                    return false; // signifies probable access restriction
                }
                doc = (doc && Ext.isFunction(ELD.getDocument)) ? ELD.getDocument(doc,true) : doc;
                
                return doc;
            },

            /**
             * Returns the frame's current HTML document object as an
             * {@link Ext.Element}.
             * @return {Ext.Element} The document
             */
            getDoc : function() {
                var D = this.getFrameDocument();
                return Ext.get(D,D); 
            },
            
            /**
             * If sufficient privilege exists, returns the frame's current document
             * body as an HTMLElement.
             *
             * @return {HTMLElement} The frame document body or Null if access to
             *         document object was denied.
             */
            getBody : function() {
                var d;
                return (d = this.getFrameDocument()) ? this.get(d.body || d.documentElement) : null;
            },

            /**
             * Attempt to retrieve the frames current URI via frame's document object
             * @return {string} The frame document's current URI or the last know URI if permission was denied.
             */
            getDocumentURI : function() {
                var URI, d;
                try {
                    URI = this.src && (d = this.getFrameDocument()) ? d.location.href: null;
                } catch (ex) { // will fail on NON-same-origin domains
                }
                return URI || (Ext.isFunction(this.src) ? this.src() : this.src);
                // fallback to last known
            },

           /**
            * Attempt to retrieve the frames current URI via frame's Window object
            * @return {string} The frame document's current URI or the last know URI if permission was denied.
            */
            getWindowURI : function() {
                var URI, w;
                try {
                    URI = (w = this.getWindow()) ? w.location.href : null;
                } catch (ex) {
                } // will fail on NON-same-origin domains
                return URI || (Ext.isFunction(this.src) ? this.src() : this.src);
                // fallback to last known
            },

            /**
             * Returns the frame's current window object.
             *
             * @return {Window} The frame Window object.
             */
            getWindow : function() {
                var dom = this.dom, win = null;
                try {
                    win = dom.contentWindow || window.frames[dom.name] || null;
                } catch (gwEx) {}
                return win;
            },
            
            /**
             * Scrolls a frame document's child element into view within the passed container.
             * @param {String} child The id of the element to scroll into view. 
             * @param {Mixed} container (optional) The container element to scroll (defaults to the frame's document.body).  Should be a 
             * string (id), dom node, or Ext.Element.
             * @param {Boolean} hscroll (optional) False to disable horizontal scroll (defaults to true)
             * @return {Ext.ux.ManagedIFrame.Element} this 
             */ 
            scrollChildIntoView : function(child, container, hscroll){
                this.fly(child, '_scrollChildIntoView').scrollIntoView(this.getDom(container) || this.getBody().dom, hscroll);
                return this;
            },

            /**
             * Print the contents of the Iframes (if we own the document)
             * @return {Ext.ux.ManagedIFrame.Element} this 
             */
            print : function() {
                try {
                    var win;
                    if( win = this.getWindow()){
                        Ext.isIE && win.focus();
                        win.print();
                    }
                } catch (ex) {
                    throw new MIF.Error('printexception' , ex.description || ex.message || ex);
                }
                return this;
            },

            /**
             * Returns the general DOM modification capability (same-origin status) of the frame. 
             * @return {Boolean} accessible If True, the frame's inner DOM can be manipulated, queried, and
             * Event Listeners set.
             */
            domWritable : function() {
                return !!Ext.isDocument(this.getFrameDocument(),true) //test access
                    && !!this._windowContext;
            },

            /**
             * eval a javascript code block(string) within the context of the
             * Iframes' window object.
             * @param {String} block A valid ('eval'able) script source block.
             * @param {Boolean} useDOM  if true, inserts the function
             * into a dynamic script tag, false does a simple eval on the function
             * definition. (useful for debugging) <p> Note: will only work after a
             * successful iframe.(Updater) update or after same-domain document has
             * been hooked, otherwise an exception is raised.
             * @return {Mixed}  
             */
            execScript : function(block, useDOM) {
                try {
                    if (this.domWritable()) {
                        if (useDOM) {
                            this.writeScript(block);
                        } else {
                            return this._windowContext.eval(block);
                        }
                    } else {
                        throw new MIF.Error('execscript-secure-context');
                    }
                } catch (ex) {
                    this._observable.fireEvent.call(this._observable,'exception', this, ex);
                    return false;
                }
                return true;
            },

            /**
             * Write a script block into the iframe's document
             * @param {String} block A valid (executable) script source block.
             * @param {object} attributes Additional Script tag attributes to apply to the script
             * Element (for other language specs [vbscript, Javascript] etc.) <p>
             * Note: writeScript will only work after a successful iframe.(Updater)
             * update or after same-domain document has been hooked, otherwise an
             * exception is raised.
             */
            writeScript : function(block, attributes) {
                attributes = Ext.apply({}, attributes || {}, {
                            type : "text/javascript",
                            text : block
                        });
                try {
                    var head, script, doc = this.getFrameDocument();
                    if (doc && typeof doc.getElementsByTagName != 'undefined') {
                        if (!(head = doc.getElementsByTagName("head")[0])) {
                            // some browsers (Webkit, Safari) do not auto-create
                            // head elements during document.write
                            head = doc.createElement("head");
                            doc.getElementsByTagName("html")[0].appendChild(head);
                        }
                        if (head && (script = doc.createElement("script"))) {
                            for (var attrib in attributes) {
                                if (attributes.hasOwnProperty(attrib)
                                        && attrib in script) {
                                    script[attrib] = attributes[attrib];
                                }
                            }
                            return !!head.appendChild(script);
                        }
                    }
                } catch (ex) {
                    this._observable.fireEvent.call(this._observable, 'exception', this, ex);

                }finally{
                    script = head = null;
                }
                return false;
            },

            /**
             * Eval a function definition into the iframe window context.
             * @param {String/Object} fn Name of the function or function map
             * object: {name:'encodeHTML',fn:Ext.util.Format.htmlEncode}
             * @param {Boolean} useDOM  if true, inserts the fn into a dynamic script tag,
             * false does a simple eval on the function definition
             * @param {Boolean} invokeIt if true, the function specified is also executed in the
             * Window context of the frame. Function arguments are not supported.
             * @example <pre><code> var trim = function(s){ return s.replace(/^\s+|\s+$/g,''); }; 
             * iframe.loadFunction('trim');
             * iframe.loadFunction({name:'myTrim',fn:String.prototype.trim || trim});</code></pre>
             */
            loadFunction : function(fn, useDOM, invokeIt) {
                var name = fn.name || fn;
                var fnSrc = fn.fn || window[fn];
                name && fnSrc && this.execScript(name + '=' + fnSrc, useDOM); // fn.toString coercion
                invokeIt && this.execScript(name + '()'); // no args only
            },

            /**
             * @private
             * Evaluate the Iframes readyState/load event to determine its
             * 'load' state, and raise the 'domready/documentloaded' event when
             * applicable.
             */
            loadHandler : function(e, target) {
                
                var rstatus = (this.dom||{}).readyState || (e || {}).type ;
                
                if (this.eventsFollowFrameLinks || this._frameAction || this.isReset ) {
                                       
	                switch (rstatus) {
	                    case 'domready' : // MIF
                        case 'DOMFrameContentLoaded' :
	                    case 'domfail' : // MIF
	                        this._onDocReady (rstatus);
	                        break;
	                    case 'load' : // Gecko, Opera, IE
	                    case 'complete' :
                            var frame = this;
	                        this._frameAction && setTimeout( function(){frame._onDocLoaded(rstatus); }, .01);
                            this._frameAction = false;
	                        break;
	                    case 'error':
	                        this._observable.fireEvent.apply(this._observable,['exception', this].concat(arguments));
	                        break;
	                    default :
	                }
                    this.frameState = rstatus;
                }
                
            },

            /**
             * @private
             * @param {String} eventName
             */
            _onDocReady  : function(eventName ){
                var w, obv = this._observable, D;
                try {
                    if(!this.isReset && this.focusOnLoad && (w = this.getWindow())){
                        w.focus(); 
                    }
                    (D = this.getDoc()) && (D.isReady = true);
                } catch(ex){}
                
                //raise internal event regardless of state.
                obv.fireEvent("_docready", this);
               
                if ( !this.domFired && 
                     (this._hooked = this._renderHook())) {
                        // Only raise if sandBox injection succeeded (same origin)
                        this.domFired = true;
                        this.isReset || obv.fireEvent.call(obv, 'domready', this);
                }
                
                this.domReady = true;
                this.hideMask();
            },

            /**
             * @private
             * @param {String} eventName
             */
            _onDocLoaded  : function(eventName ){
                var obv = this._observable, w;
                this.domReady || this._onDocReady('domready');
                
                obv.fireEvent("_docload", this);  //invoke any callbacks
                this.isReset || obv.fireEvent("documentloaded", this);
                this.hideMask(true);
                this._frameAction = this.isReset = false;
            },

            /**
             * @private
             * Poll the Iframes document structure to determine DOM ready
             * state, and raise the 'domready' event when applicable.
             */
            checkDOM : function( win) {
                if ( Ext.isGecko ) { return; } 
                // initialise the counter
                var n = 0, frame = this, domReady = false,
                    b, l, d, 
                    max = this.domReadyRetries || 2500, //default max 5 seconds 
                    polling = false,
                    startLocation = (this.getFrameDocument() || {location : {}}).location.href;
                (function() { // DOM polling for IE and others
                    d = frame.getFrameDocument() || {location : {}};
                    // wait for location.href transition
                    polling = (d.location.href !== startLocation || d.location.href === frame._targetURI);
                    if ( frame.domReady) { return;}
                    domReady = polling && ((b = frame.getBody()) && !!(b.dom.innerHTML || '').length) || false;
                    // null href is a 'same-origin' document access violation,
                    // so we assume the DOM is built when the browser updates it
                    if (d.location.href && !domReady && (++n < max)) {
                        setTimeout(arguments.callee, 2); // try again
                        return;
                    }
                    frame.loadHandler({ type : domReady ? 'domready' : 'domfail'});
                })();
            },
            
            /**
            * @private 
            */
            filterEventOptionsRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate)$/,

           /**
            * @private override to handle synthetic events vs DOM events
            */
            addListener : function(eventName, fn, scope, options){

                if(typeof eventName == "object"){
                    var o = eventName;
                    for(var e in o){
                        if(this.filterEventOptionsRe.test(e)){
                            continue;
                        }
                        if(typeof o[e] == "function"){
                            // shared options
                            this.addListener(e, o[e], o.scope,  o);
                        }else{
                            // individual options
                            this.addListener(e, o[e].fn, o[e].scope, o[e]);
                        }
                    }
                    return;
                }

                if(reSynthEvents.test(eventName)){
                    var O = this._observable; 
                    if(O){
                        O.events[eventName] || (O.addEvents(eventName)); 
                        O.addListener.call(O, eventName, fn, scope || this, options) ;}
                }else {
                    ElFrame.superclass.addListener.call(this, eventName,
                            fn, scope || this, options);
                }
                return this;
            },

            /**
             * @private override
             * Removes an event handler from this element.
             */
            removeListener : function(eventName, fn, scope){
                var O = this._observable;
                if(reSynthEvents.test(eventName)){
                    O && O.removeListener.call(O, eventName, fn, scope || this, options);
                }else {
                  ElFrame.superclass.removeListener.call(this, eventName, fn, scope || this);
              }
              return this;
            },

            /**
             * Removes all previous added listeners from this element
             * @private override
             */
            removeAllListeners : function(){
                Ext.EventManager.removeAll(this.dom);
                var O = this._observable;
                O && O.purgeListeners.call(this._observable);
                return this;
            },
            
            /**
             * Forcefully show the defined loadMask
             * @param {String} msg Mask text to display during the mask operation, defaults to previous defined
             * loadMask config value.
             * @param {String} msgCls The CSS class to apply to the loading message element (defaults to "x-mask-loading")
             * @param {String} maskCls The CSS class to apply to the mask element
             */
            showMask : function(msg, msgCls, maskCls) {
                var lmask = this.loadMask;
                if (lmask && !lmask.disabled ){
                    this.mask(msg || lmask.msg, msgCls || lmask.msgCls, maskCls || lmask.maskCls, lmask.maskEl);
                }
            },
            
            /**
             * Hide the defined loadMask 
             * @param {Boolean} forced True to hide the mask regardless of document ready/loaded state.
             */
            hideMask : function(forced) {
                var tlm = this.loadMask || {};
                if (forced || (tlm.hideOnReady && this.domReady)) {
                     this.unmask();
                }
            },
            
            /**
             * Puts a mask over the FRAME to disable user interaction. Requires core.css.
             * @param {String} msg (optional) A message to display in the mask
             * @param {String} msgCls (optional) A css class to apply to the msg element
             * @param {String} maskCls (optional) A css class to apply to the mask element
             * @param {String/Element} maskEl (optional) A targeted Element (parent of the IFRAME) to use the masking agent
             * @return {Element} The mask element
             */
            mask : function(msg, msgCls, maskCls, maskEl){
                this._mask && this.unmask();
                var p = Ext.get(maskEl) || this.parent('.ux-mif-mask-target') || this.parent();
                if(p.getStyle("position") == "static" && 
                    !p.select('iframe,frame,object,embed').elements.length){
                        p.addClass("x-masked-relative");
                }
                
                p.addClass("x-masked");
                
                this._mask = Ext.DomHelper.append(p, {cls: maskCls || "ux-mif-el-mask"} , true);
                this._mask.setDisplayed(true);
                this._mask._agent = p;
                
                if(typeof msg == 'string'){
                     this._maskMsg = Ext.DomHelper.append(p, {cls: msgCls || "ux-mif-el-mask-msg" , style: {visibility:'hidden'}, cn:{tag:'div', html:msg}}, true);
                     this._maskMsg
                        .setVisibilityMode(Ext.Element.VISIBILITY)
                        .center(p).setVisible(true);
                }
                if(Ext.isIE && !(Ext.isIE7 && Ext.isStrict) && this.getStyle('height') == 'auto'){ // ie will not expand full height automatically
                    this._mask.setSize(undefined, this._mask.getHeight());
                }
                return this._mask;
            },

            /**
             * Removes a previously applied mask.
             */
            unmask : function(){
                
                var a;
                if(this._mask){
                    (a = this._mask._agent) && a.removeClass(["x-masked-relative","x-masked"]);
                    if(this._maskMsg){
                        this._maskMsg.remove();
                        delete this._maskMsg;
                    }
                    this._mask.remove();
                    delete this._mask;
                }
             },

             /**
              * Creates an (frontal) transparent shim agent for the frame.  Used primarily for masking the frame during drag operations.
              * @return {Ext.Element} The new shim element.
              * @param {String} imgUrl Optional Url of image source to use during shimming (defaults to Ext.BLANK_IMAGE_URL).
              * @param {String} shimCls Optional CSS style selector for the shimming agent. (defaults to 'ux-mif-shim' ).
              * @return (HTMLElement} the shim element
              */
             createFrameShim : function(imgUrl, shimCls ){
                 this.shimCls = shimCls || this.shimCls || 'ux-mif-shim';
                 this.frameShim || (this.frameShim = this.next('.'+this.shimCls) ||  //already there ?
                  Ext.DomHelper.append(
                     this.dom.parentNode,{
                         tag : 'img',
                         src : imgUrl|| Ext.BLANK_IMAGE_URL,
                         cls : this.shimCls ,
                         galleryimg : "no"
                    }, true)) ;
                 this.frameShim && (this.frameShim.autoBoxAdjust = false); 
                 return this.frameShim;
             },
             
             /**
              * Toggles visibility of the (frontal) transparent shim agent for the frame.  Used primarily for masking the frame during drag operations.
              * @param {Boolean} show Optional True to activate the shim, false to hide the shim agent.
              */
             toggleShim : function(show){
                var shim = this.frameShim || this.createFrameShim();
                var cls = this.shimCls + '-on';
                !show && shim.removeClass(cls);
                show && !shim.hasClass(cls) && shim.addClass(cls);
             },

            /**
             * Loads this panel's iframe immediately with content returned from an XHR call.
             * @param {Object/String/Function} config A config object containing any of the following options:
             * <pre><code>
             *      frame.load({
             *         url: &quot;your-url.php&quot;,
             *         params: {param1: &quot;foo&quot;, param2: &quot;bar&quot;}, // or encoded string
             *         callback: yourFunction,
             *         scope: yourObject, // optional scope for the callback
             *         discardUrl: false,
             *         nocache: false,
             *         text: &quot;Loading...&quot;,
             *         timeout: 30,
             *         scripts: false,
             *         //optional custom renderer
             *         renderer:{render:function(el, response, updater, callback){....}}  
             *      });
             * </code></pre>
             * The only required property is url. The optional properties
             *            nocache, text and scripts are shorthand for
             *            disableCaching, indicatorText and loadScripts and are used
             *            to set their associated property on this panel Updater
             *            instance.
             * @return {Ext.ManagedIFrame.Element} this
             */
            load : function(loadCfg) {
                var um;
                if (um = this.getUpdater()) {
                    if (loadCfg && loadCfg.renderer) {
                        um.setRenderer(loadCfg.renderer);
                        delete loadCfg.renderer;
                    }
                    um.update.apply(um, arguments);
                }
                return this;
            },

             /** @private
              * Frame document event proxy
              */
             _eventProxy : function(e) {
                 if (!e) return;
                 e = Ext.EventObject.setEvent(e);
                 var be = e.browserEvent || e, er, args = [e.type, this];
                 
                 if (!be['eventPhase']
                         || (be['eventPhase'] == (be['AT_TARGET'] || 2))) {
                            
                     if(e.type == 'resize'){
	                    var doc = this.getFrameDocument();
	                    doc && (args.push(
	                        { height: ELD.getDocumentHeight(doc), width : ELD.getDocumentWidth(doc) },
	                        { height: ELD.getViewportHeight(doc), width : ELD.getViewportWidth(doc) },
	                        { height: ELD.getViewHeight(false, doc), width : ELD.getViewWidth(false, doc) }
	                      ));  
	                 }
                     
                     er =  this._observable ? 
                           this._observable.fireEvent.apply(this._observable, args.concat(
                              Array.prototype.slice.call(arguments,0))) 
                           : null;
                 
	                 // same-domain unloads should clear ElCache for use with the
	                 // next document rendering
	                 (e.type == 'unload') && this._unHook();
                     
                 }
                 return er;
            },
            
            /**
	         * dispatch a message to the embedded frame-window context (same-origin frames only)
	         * @name sendMessage
	         * @param {Mixed} message The message payload.  The payload can be any supported JS type. 
	         * @param {String} tag Optional reference tag 
	         * @param {String} origin Optional domain designation of the sender (defaults
	         * to document.domain).
	         */
	        sendMessage : function(message, tag, origin) {
	          //(implemented by mifmsg.js )
	        },
            
            /**
	         * Dispatch a cross-document message (per HTML5 specification) if the browser supports it natively.
	         * @name postMessage
	         * @param {String} message Required message payload (String only)
	         * @param {String} origin (Optional) Site designation of the sender (defaults
	         * to the current site in the form: http://site.example.com ). 
	         * <p>Notes:  on IE8, this action is synchronous.<br/>
             * Messaging support requires that the optional messaging driver source 
             * file (mifmsg.js) is also included in your project.
             * 
	         */
	        postMessage : function(message ,origin ){
	            //(implemented by mifmsg.js )
	        }

    });
   
    ElFrame = Ext.Element.IFRAME = Ext.Element.FRAME = Ext.ux.ManagedIFrame.Element;
    
      
    var fp = ElFrame.prototype;
    /**
     * @ignore
     */
    Ext.override ( ElFrame , {
          
    /**
     * Appends an event handler (shorthand for {@link #addListener}).
     * @param {String} eventName The type of event to handle
     * @param {Function} fn The handler function the event invokes
     * @param {Object} scope (optional) The scope (this element) of the handler function
     * @param {Object} options (optional) An object containing standard {@link #addListener} options
     * @member Ext.Element
     * @method on
     */
        on :  fp.addListener,
        
    /**
     * Removes an event handler from this element (shorthand for {@link #removeListener}).
     * @param {String} eventName the type of event to remove
     * @param {Function} fn the method the event invokes
     * @return {MIF.Element} this
     * @member Ext.Element
     * @method un
     */
        un : fp.removeListener,
        
        getUpdateManager : fp.getUpdater
    });

  /**
   * @class Ext.ux.ManagedIFrame.ComponentAdapter
   * @version 2.1.4 
   * @author Doug Hendricks. doug[always-At]theactivegroup.com
   * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
   * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
   * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
   * @constructor
   * @desc
   * Abstract class.  This class should not be instantiated.
   */
  
   Ext.ux.ManagedIFrame.ComponentAdapter = function(){}; 
   Ext.ux.ManagedIFrame.ComponentAdapter.prototype = {
       
        /** @property */
        version : 2.14,
        
        /**
         * @cfg {String} defaultSrc the default src property assigned to the Managed Frame when the component is rendered.
         * @default null
         */
        defaultSrc : null,
        
        /**
         * @cfg {String} unsupportedText Text to display when the IFRAMES/FRAMESETS are disabled by the browser.
         *
         */
        unsupportedText : 'Inline frames are NOT enabled\/supported by your browser.',
        
        hideMode   : !Ext.isIE && !!Ext.ux.plugin.VisibilityMode ? 'nosize' : 'display',
        
        animCollapse  : Ext.isIE ,

        animFloat  : Ext.isIE ,
        
        /**
          * @cfg {Boolean} disableMessaging False to enable cross-frame messaging API
          * @default true
          *
          */
        disableMessaging : true, 
        
        /**
          * @cfg {Boolean} eventsFollowFrameLinks set true to propagate domready and documentloaded
          * events anytime the IFRAME's URL changes
          * @default true
          */
        eventsFollowFrameLinks   : true,
        
        /**
         * @cfg {object} frameConfig Frames DOM configuration options
         * This optional configuration permits override of the IFRAME's DOM attributes
         * @example
          frameConfig : {
              name : 'framePreview',
              frameborder : 1,
              allowtransparency : true
             }
         */
        frameConfig  : null,
        
        /**
         * @cfg focusOnLoad True to set focus on the frame Window as soon as its document
         * reports loaded.  (Many external sites use IE's document.createRange to create 
         * DOM elements, but to be successfull IE requires that the FRAME have focus before
         * the method is called)
         * @default false (true for Internet Explorer)
         */
        focusOnLoad   : Ext.isIE,
        
        /**
         * @property {Object} frameEl An {@link #Ext.ux.ManagedIFrame.Element} reference to rendered frame Element.
         */
        frameEl : null, 
  
        /**
         * @cfg {Boolean} useShim
         * True to use to create a transparent shimming agent for use in masking the frame during
         * drag operations.
         * @default false
         */
        useShim   : false,

        /**
         * @cfg {Boolean} autoScroll
         * True to use overflow:'auto' on the frame element and show scroll bars automatically when necessary,
         * false to clip any overflowing content (defaults to true).
         * @default true
         */
        autoScroll: true,
        
         /**
         * @cfg {String/Object} autoLoad
         * Loads this Components frame after the Component is rendered with content returned from an
         * XHR call or optionally from a form submission.  See {@link #Ext.ux.ManagedIFrame.ComponentAdapter-load} and {@link #Ext.ux.ManagedIFrame.ComponentAdapter-submitAsTarget} methods for
         * available configuration options.
         * @default null
         */
        autoLoad: null,
        
        /** @private */
        getId : function(){
             return this.id   || (this.id = "mif-comp-" + (++Ext.Component.AUTO_ID));
        },
        
        stateEvents : ['documentloaded'],
        
        stateful    : false,
        
        /**
         * Sets the autoScroll state for the frame.
         * @param {Boolean} auto True to set overflow:auto on the frame, false for overflow:hidden
         * @return {Ext.ux.ManagedIFrame.Component} this
         */
        setAutoScroll : function(auto){
            var scroll = Ext.value(auto, this.autoScroll === true);
            this.rendered && this.getFrame() &&  
                this.frameEl.setOverflow( (this.autoScroll = scroll) ? 'auto':'hidden');
            return this;
        },
        
        getContentTarget : function(){
            return this.getFrame();
        },
        
        /**
         * Returns the Ext.ux.ManagedIFrame.Element of the frame.
         * @return {Ext.ux.ManagedIFrame.Element} this.frameEl 
         */
        getFrame : function(){
             if(this.rendered){
                if(this.frameEl){ return this.frameEl;}
                var f = this.items && this.items.first ? this.items.first() : null;
                f && (this.frameEl = f.frameEl);
                return this.frameEl;
             }
             return null;
            },
        
        /**
         * Returns the frame's current window object.
         *
         * @return {Window} The frame Window object.
         */
        getFrameWindow : function() {
            return this.getFrame() ? this.frameEl.getWindow() : null;
        },

        /**
         * If sufficient privilege exists, returns the frame's current document
         * as an HTMLElement.
         *
         * @return {HTMLElement} The frame document or false if access to
         *         document object was denied.
         */
        getFrameDocument : function() {
            return this.getFrame() ? this.frameEl.getFrameDocument() : null;
        },

        /**
         * Get the embedded iframe's document as an Ext.Element.
         *
         * @return {Ext.Element object} or null if unavailable
         */
        getFrameDoc : function() {
            return this.getFrame() ? this.frameEl.getDoc() : null;
        },

        /**
         * If sufficient privilege exists, returns the frame's current document
         * body as an HTMLElement.
         *
         * @return {Ext.Element} The frame document body or Null if access to
         *         document object was denied.
         */
        getFrameBody : function() {
            return this.getFrame() ? this.frameEl.getBody() : null;
        },
        
        /**
         * Reset the embedded frame to a neutral domain state and clear its contents
          * @param {String}src (Optional) A specific reset string (eg. 'about:blank')
         *            to use for resetting the frame.
         * @param {Function} callback (Optional) A callback function invoked when the
         *            frame reset is complete.
         * @param {Object} scope (Optional) scope by which the callback function is
         *            invoked.
         * @return {Ext.ux.ManagedIFrame.Component} this
         */
        resetFrame : function() {
            this.getFrame() && this.frameEl.reset.apply(this.frameEl, arguments);
            return this;
        },
        
        /**
         * Loads the Components frame with the response from a form submit to the 
         * specified URL with the ManagedIframe.Element as it's submit target.
         * @param {Object} submitCfg A config object containing any of the following options:
         * <pre><code>
         *      mifPanel.submitAsTarget({
         *         form : formPanel.form,  //optional Ext.FormPanel, Ext form element, or HTMLFormElement
         *         url: &quot;your-url.php&quot;,
         *         params: {param1: &quot;foo&quot;, param2: &quot;bar&quot;}, // or a URL encoded string
         *         callback: yourFunction,  //optional
         *         scope: yourObject, // optional scope for the callback
         *         method: 'POST', //optional form.action (default:'POST')
         *         encoding : "multipart/form-data" //optional, default HTMLForm default
         *      });
         *
         * </code></pre>
         *
         * @return {Ext.ux.ManagedIFrame.Component} this
         */
        submitAsTarget  : function(submitCfg){
            this.getFrame() && this.frameEl.submitAsTarget.apply(this.frameEl, arguments);
            return this;
        },
        
        /**
         * Loads this Components's frame immediately with content returned from an
         * XHR call.
         *
         * @param {Object/String/Function} loadCfg A config object containing any of the following
         *            options:
         *
         * <pre><code>
         *      mifPanel.load({
         *         url: &quot;your-url.php&quot;,
         *         params: {param1: &quot;foo&quot;, param2: &quot;bar&quot;}, // or a URL encoded string
         *         callback: yourFunction,
         *         scope: yourObject, // optional scope for the callback
         *         discardUrl: false,
         *         nocache: false,
         *         text: &quot;Loading...&quot;,
         *         timeout: 30,
         *         scripts: false,
         *         submitAsTarget : false,  //optional true, to use Form submit to load the frame (see submitAsTarget method)
         *         renderer:{render:function(el, response, updater, callback){....}}  //optional custom renderer
         *      });
         *
         * </code></pre>
         *
         * The only required property is url. The optional properties
         *            nocache, text and scripts are shorthand for
         *            disableCaching, indicatorText and loadScripts and are used
         *            to set their associated property on this panel Updater
         *            instance.
         * @return {Ext.ux.ManagedIFrame.Component} this
         */
        load : function(loadCfg) {
            if(loadCfg && this.getFrame()){
                var args = arguments;
                this.resetFrame(null, function(){ 
                    loadCfg.submitAsTarget ?
                    this.submitAsTarget.apply(this,args):
                    this.frameEl.load.apply(this.frameEl,args);
                },this);
            }
            this.autoLoad = loadCfg;
            return this;
        },

        /** @private */
        doAutoLoad : function() {
            this.autoLoad && this.load(typeof this.autoLoad == 'object' ? 
                this.autoLoad : { url : this.autoLoad });
        },

        /**
         * Get the {@link #Ext.ux.ManagedIFrame.Updater} for this panel's iframe. Enables
         * Ajax-based document replacement of this panel's iframe document.
         *
         * @return {Ext.ux.ManagedIFrame.Updater} The Updater
         */
        getUpdater : function() {
            return this.getFrame() ? this.frameEl.getUpdater() : null;
        },
        
        /**
         * Sets the embedded Iframe src property. Note: invoke the function with
         * no arguments to refresh the iframe based on the current src value.
         *
         * @param {String/Function} url (Optional) A string or reference to a Function that
         *            returns a URI string when called
         * @param {Boolean} discardUrl (Optional) If not passed as <tt>false</tt>
         *            the URL of this action becomes the default SRC attribute
         *            for this iframe, and will be subsequently used in future
         *            setSrc calls (emulates autoRefresh by calling setSrc
         *            without params).
         * @param {Function} callback (Optional) A callback function invoked when the
         *            frame document has been fully loaded.
         * @param {Object} scope (Optional) scope by which the callback function is
         *            invoked.
         * @return {Ext.ux.ManagedIFrame.Component} this
         */
        setSrc : function(url, discardUrl, callback, scope) {
            this.getFrame() && this.frameEl.setSrc.apply(this.frameEl, arguments);
            return this;
        },

        /**
         * Sets the embedded Iframe location using its replace method. Note: invoke the function with
         * no arguments to refresh the iframe based on the current src value.
         *
         * @param {String/Function} url (Optional) A string or reference to a Function that
         *            returns a URI string when called
         * @param {Boolean} discardUrl (Optional) If not passed as <tt>false</tt>
         *            the URL of this action becomes the default SRC attribute
         *            for this iframe, and will be subsequently used in future
         *            setSrc calls (emulates autoRefresh by calling setSrc
         *            without params).
         * @param {Function} callback (Optional) A callback function invoked when the
         *            frame document has been fully loaded.
         * @param {Object} scope (Optional) scope by which the callback function is
         *            invoked.
         * @return {Ext.ux.ManagedIFrame.Component} this
         */
        setLocation : function(url, discardUrl, callback, scope) {
           this.getFrame() && this.frameEl.setLocation.apply(this.frameEl, arguments);
           return this;
        },

        /**
         * @private //Make it state-aware
         */
        getState : function() {
            var URI = this.getFrame() ? this.frameEl.getDocumentURI() || null : null;
            var state = this.supr().getState.call(this);
            state = Ext.apply(state || {}, 
                {defaultSrc : Ext.isFunction(URI) ? URI() : URI,
                 autoLoad   : this.autoLoad
                });
            return state;
        },
        
        /**
         * @private
         */
        setMIFEvents : function(){
            
            this.addEvents(

                    /**
                     * Fires when the iFrame has reached a loaded/complete state.
                     * @event documentloaded
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} frameEl
                     */
                    'documentloaded',  
                      
                    /**
                     * Fires ONLY when an iFrame's Document(DOM) has reach a
                     * state where the DOM may be manipulated (ie same domain policy)
                     * Note: This event is only available when overwriting the iframe
                     * document using the update method and to pages retrieved from a "same
                     * domain". Returning false from the eventHandler stops further event
                     * (documentloaded) processing.
                     * @event domready 
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} this.frameEl
                     */
                    'domready',
                    /**
                     * Fires when the frame actions raise an error
                     * @event exception
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.MIF.Element} frameEl
                     * @param {Error/string} exception
                     */
                    'exception',

                    /**
                     * Fires upon receipt of a message generated by window.sendMessage
                     * method of the embedded Iframe.window object
                     * @event message
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} this.frameEl
                     * @param {object}
                     *            message (members: type: {string} literal "message", data
                     *            {Mixed} [the message payload], domain [the document domain
                     *            from which the message originated ], uri {string} the
                     *            document URI of the message sender source (Object) the
                     *            window context of the message sender tag {string} optional
                     *            reference tag sent by the message sender
                     * <p>Alternate event handler syntax for message:tag filtering Fires upon
                     * receipt of a message generated by window.sendMessage method which
                     * includes a specific tag value of the embedded Iframe.window object
                     *
                     */
                    'message',

                    /**
                     * Fires when the frame is blurred (loses focus).
                     * @event blur
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} frameEl
                     * @param {Ext.Event} e Note: This event is only available when overwriting the
                     *            iframe document using the update method and to pages
                     *            retrieved from a "same domain". Returning false from the
                     *            eventHandler [MAY] NOT cancel the event, as this event is
                     *            NOT ALWAYS cancellable in all browsers.
                     */
                    'blur',

                    /**
                     * Fires when the frame gets focus. Note: This event is only available
                     * when overwriting the iframe document using the update method and to
                     * pages retrieved from a "same domain". Returning false from the
                     * eventHandler [MAY] NOT cancel the event, as this event is NOT ALWAYS
                     * cancellable in all browsers.
                     * @event focus
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} frameEl
                     * @param {Ext.Event} e
                     *
                    */
                    'focus',
                    
                     /**
                     * Note: This event is only available when overwriting the iframe
                     * document using the update method and to pages retrieved from a "same-origin"
                     * domain.  To prevent numerous scroll events from being raised use the <i>buffer</i> listener 
                     * option to limit the number of times the event is raised.
                     * @event scroll 
                     * @param {Ext.ux.MIF.Element} this.
                     * @param {Ext.Event}
                     */
                    'scroll',
                    
                    /**
                     * Fires when the frames window is resized. Note: This event is only available
                     * when overwriting the iframe document using the update method and to
                     * pages retrieved from a "same domain". 
                     * @event resize
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} frameEl
                     * @param {Ext.Event} e
                     * @param {Object} documentSize A height/width object signifying the new document size
                     * @param {Object} viewPortSize A height/width object signifying the size of the frame's viewport
                     * @param {Object} viewSize A height/width object signifying the size of the frame's view
                     *
                    */
                    'resize',
                    
                    /**
                     * Fires when(if) the frames window object raises the unload event
                     * Note: This event is only available when overwriting the iframe
                     * document using the update method and to pages retrieved from a "same-origin"
                     * domain. Note: Opera does not raise this event.
                     * @event unload 
                     * @memberOf Ext.ux.ManagedIFrame.ComponentAdapter
                     * @param {Ext.ux.ManagedIFrame.Element} frameEl
                     * @param {Ext.Event}
                     */
                    'unload',
                    
                    /**
                     * Fires when the iFrame has been reset to a neutral domain state (blank document).
                     * @event reset
                     * @param {Ext.ux.ManagedIFrame.Element} frameEl
                     */
                    'reset'
                );
        },
        
        /**
         * dispatch a message to the embedded frame-window context (same-origin frames only)
         * @name sendMessage
         * @memberOf Ext.ux.ManagedIFrame.Element
         * @param {Mixed} message The message payload.  The payload can be any supported JS type. 
         * @param {String} tag Optional reference tag 
         * @param {String} origin Optional domain designation of the sender (defaults
         * to document.domain).
         */
        sendMessage : function(message, tag, origin) {
       
          //(implemented by mifmsg.js )
        },
        //Suspend (and queue) host container events until the child MIF.Component is rendered.
        onAdd : function(C){
             C.relayTarget && this.suspendEvents(true); 
        },
        
        initRef: function() {
      
	        if(this.ref){
	            var t = this,
	                levels = this.ref.split('/'),
	                l = levels.length,
	                i;
	            for (i = 0; i < l; i++) {
	                if(t.ownerCt){
	                    t = t.ownerCt;
	                }
	            }
	            this.refName = levels[--i];
	            t[this.refName] || (t[this.refName] = this);
	            
	            this.refOwner = t;
	        }
	    }
      
   };
   
   /*
    * end Adapter
    */
   
  /**
   * @class Ext.ux.ManagedIFrame.Component
   * @extends Ext.BoxComponent
   * @version 2.1.4 
   * @author Doug Hendricks. doug[always-At]theactivegroup.com
   * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
   * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
   * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
   * @constructor
   * @base Ext.ux.ManagedIFrame.ComponentAdapter
   * @param {Object} config The config object
   */
  Ext.ux.ManagedIFrame.Component = Ext.extend(Ext.BoxComponent , { 
            
            ctype     : "Ext.ux.ManagedIFrame.Component",
            
            /** @private */
            initComponent : function() {
               
                var C = {
	                monitorResize : this.monitorResize || (this.monitorResize = !!this.fitToParent),
	                plugins : (this.plugins ||[]).concat(
	                    this.hideMode === 'nosize' && Ext.ux.plugin.VisibilityMode ? 
		                    [new Ext.ux.plugin.VisibilityMode(
		                        {hideMode :'nosize',
		                         elements : ['bwrap']
		                        })] : [] )
                  };
                  
                MIF.Component.superclass.initComponent.call(
                  Ext.apply(this,
                    Ext.apply(this.initialConfig, C)
                    ));
                    
                this.setMIFEvents();
            },   

            /** @private */
            onRender : function(ct, position){
                
                //default child frame's name to that of MIF-parent id (if not specified on frameCfg).
                var frCfg = this.frameCfg || this.frameConfig || (this.relayTarget ? {name : this.relayTarget.id}: {}) || {};
                
                //backward compatability with MIF 1.x
                var frDOM = frCfg.autoCreate || frCfg;
                frDOM = Ext.apply({tag  : 'iframe', id: Ext.id()}, frDOM);
                
                var el = Ext.getDom(this.el);

                (el && el.tagName == 'iframe') || 
                  (this.autoEl = Ext.apply({
                                    name : frDOM.id,
                                    frameborder : 0
                                   }, frDOM ));
                 
                MIF.Component.superclass.onRender.apply(this, arguments);
               
                if(this.unsupportedText){
                    ct.child('noframes') || ct.createChild({tag: 'noframes', html : this.unsupportedText || null});  
                }   
                var frame = this.el ;
                
                var F;
                if( F = this.frameEl = (this.el ? new MIF.Element(this.el.dom, true): null)){
                    
                    Ext.apply(F,{
                        ownerCt          : this.relayTarget || this,
                        disableMessaging : Ext.value(this.disableMessaging, true),
                        focusOnLoad      : Ext.value(this.focusOnLoad, Ext.isIE),
                        eventsFollowFrameLinks : Ext.value(this.eventsFollowFrameLinks ,true)
                    });
                    F.ownerCt.frameEl = F;
                    F.addClass('ux-mif'); 
                    if (this.loadMask) {
                        //resolve possible maskEl by Element name eg. 'body', 'bwrap', 'actionEl'
                        var mEl = this.loadMask.maskEl;
                        F.loadMask = Ext.apply({
                                    disabled    : false,
                                    hideOnReady : false,
                                    msgCls      : 'ext-el-mask-msg x-mask-loading',  
                                    maskCls     : 'ext-el-mask'
                                },
                                {
                                  maskEl : F.ownerCt[String(mEl)] || F.parent('.' + String(mEl)) || F.parent('.ux-mif-mask-target') || mEl 
                                },
                                Ext.isString(this.loadMask) ? {msg:this.loadMask} : this.loadMask
                              );
                        Ext.get(F.loadMask.maskEl) && Ext.get(F.loadMask.maskEl).addClass('ux-mif-mask-target');
                    }
                    
                    F._observable && 
                        (this.relayTarget || this).relayEvents(F._observable, frameEvents.concat(this._msgTagHandlers || []));
                        
                    delete this.contentEl;
                    
                    //Template support for writable frames
                    
                 }
            },
            
            /** @private */
            afterRender  : function(container) {
                MIF.Component.superclass.afterRender.apply(this,arguments);
                
                // only resize (to Parent) if the panel is NOT in a layout.
                // parentNode should have {style:overflow:hidden;} applied.
                if (this.fitToParent && !this.ownerCt) {
                    var pos = this.getPosition(), size = (Ext.get(this.fitToParent)
                            || this.getEl().parent()).getViewSize();
                    this.setSize(size.width - pos[0], size.height - pos[1]);
                }

                this.getEl().setOverflow('hidden'); //disable competing scrollers
                this.setAutoScroll();
                var F;
               /* Enable auto-Shims if the Component participates in (nested?)
                * border layout.
                * Setup event handlers on the SplitBars and region panels to enable the frame
                * shims when needed
                */
                if(F = this.frameEl){
                    var ownerCt = this.ownerCt;
                    while (ownerCt) {
                        ownerCt.on('afterlayout', function(container, layout) {
                            Ext.each(['north', 'south', 'east', 'west'],
                                    function(region) {
                                        var reg;
                                        if ((reg = layout[region]) && 
                                             reg.split && reg.split.dd &&
                                             !reg._splitTrapped) {
                                               reg.split.dd.endDrag = reg.split.dd.endDrag.createSequence(MIM.hideShims, MIM );
                                               reg.split.on('beforeresize',MIM.showShims,MIM);
                                               reg._splitTrapped = MIM._splitTrapped = true;
                                        }
                            }, this);
                        }, this, { single : true}); // and discard
                        ownerCt = ownerCt.ownerCt; // nested layouts?
                    }
                    /*
                     * Create an img shim if the component participates in a layout or forced
                     */
                    if(!!this.ownerCt || this.useShim ){ this.frameShim = F.createFrameShim(); }
                    this.getUpdater().showLoadIndicator = this.showLoadIndicator || false;
                    
                    //Resume Parent containers' events callback
                    var resumeEvents = this.relayTarget && this.ownerCt ?                         
                       this.ownerCt.resumeEvents.createDelegate(this.ownerCt) : null;
                       
                    if (this.autoload) {
                       this.doAutoLoad();
                    } else if(this.tpl && (this.frameData || this.data)) {
                       F.update(this.tpl.apply(this.frameData || this.data), true, resumeEvents);
                       delete this.frameData;
                       delete this.data;
                       return;
                    } else if(this.frameMarkup  || this.html) {
                       F.update(this.frameMarkup  || this.html , true, resumeEvents);
                       delete this.html;
                       delete this.frameMarkup;
                       return;
                    } else {
                       if (this.defaultSrc) {
                            F.setSrc(this.defaultSrc, false);
                       } else {
                            /* If this is a no-action frame, reset it first, then resume parent events
                             * allowing access to a fully reset frame by upstream afterrender/layout events
                             */ 
                            F.reset(null, resumeEvents);
                            return;
                       }
                    }
                    resumeEvents && resumeEvents();
                }
            },
            
            /** @private */
            beforeDestroy : function() {
                var F;
                if(F = this.getFrame()){
                    F.remove();
                    this.frameEl = this.frameShim = null;
                }
                this.relayTarget && (this.relayTarget.frameEl = null);
                MIF.Component.superclass.beforeDestroy.call(this);
            }
    });

    Ext.override(MIF.Component, MIF.ComponentAdapter.prototype);
    Ext.reg('mif', MIF.Component);
   
    /*
    * end Component
    */
    
  /**
   * @private
   * this function renders a child MIF.Component to MIF.Panel and MIF.Window
   * designed to be called by the constructor of higher-level MIF.Components only.
   */
  function embed_MIF(config){
    
    config || (config={});
    config.layout = 'fit';
    config.items = {
             xtype    : 'mif',
               ref    : 'mifChild',
            useShim   : true,
                  tpl : Ext.value(config.tpl , this.tpl),
           autoScroll : Ext.value(config.autoScroll , this.autoScroll),
          defaultSrc  : Ext.value(config.defaultSrc , this.defaultSrc),
         frameMarkup  : Ext.value(config.html , this.html),
           frameData  : Ext.value(config.data , this.data),
            loadMask  : Ext.value(config.loadMask , this.loadMask),
    disableMessaging  : Ext.value(config.disableMessaging, this.disableMessaging),
 eventsFollowFrameLinks : Ext.value(config.eventsFollowFrameLinks, this.eventsFollowFrameLinks),
         focusOnLoad  : Ext.value(config.focusOnLoad, this.focusOnLoad),
          frameConfig : Ext.value(config.frameConfig || config.frameCfg , this.frameConfig),
          relayTarget : this  //direct relay of events to the parent component
        };
    delete config.html;
    delete config.data;
    this.setMIFEvents();
    return config; 
    
  };
    
  /**
   * @class Ext.ux.ManagedIFrame.Panel
   * @extends Ext.Panel
   * @version 2.1.4 
   * @author Doug Hendricks. doug[always-At]theactivegroup.com
   * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
   * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
   * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
   * @constructor
   * @base Ext.ux.ManagedIFrame.ComponentAdapter
   * @param {Object} config The config object
   */

  Ext.ux.ManagedIFrame.Panel = Ext.extend( Ext.Panel , {
        ctype       : 'Ext.ux.ManagedIFrame.Panel',
        bodyCssClass: 'ux-mif-mask-target',
        constructor : function(config){
            MIF.Panel.superclass.constructor.call(this, embed_MIF.call(this, config));
         }
  });
  
  Ext.override(MIF.Panel, MIF.ComponentAdapter.prototype);
  Ext.reg('iframepanel', MIF.Panel);
    /*
    * end Panel
    */

    /**
     * @class Ext.ux.ManagedIFrame.Portlet
     * @extends Ext.ux.ManagedIFrame.Panel
     * @version 2.1.4 
     * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
     * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a> 
     * @author Doug Hendricks. Forum ID: <a href="http://extjs.com/forum/member.php?u=8730">hendricd</a> 
     * @copyright 2007-2010, Active Group, Inc. All rights reserved.
     * @constructor Create a new Ext.ux.ManagedIFramePortlet 
     * @param {Object} config The config object
     */

    Ext.ux.ManagedIFrame.Portlet = Ext.extend(Ext.ux.ManagedIFrame.Panel, {
                ctype      : "Ext.ux.ManagedIFrame.Portlet",
                anchor     : '100%',
                frame      : true,
                collapseEl : 'bwrap',
                collapsible: true,
                draggable  : true,
                cls        : 'x-portlet'
                
            });
            
    Ext.reg('iframeportlet', MIF.Portlet);
   /*
    * end Portlet
    */
    
  /**
   * @class Ext.ux.ManagedIFrame.Window
   * @extends Ext.Window
   * @version 2.1.4 
   * @author Doug Hendricks. 
   * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
   * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
   * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
   * @constructor
   * @base Ext.ux.ManagedIFrame.ComponentAdapter
   * @param {Object} config The config object
   */
    
  Ext.ux.ManagedIFrame.Window = Ext.extend( Ext.Window , 
       {
            ctype       : "Ext.ux.ManagedIFrame.Window",
            bodyCssClass: 'ux-mif-mask-target',
            constructor : function(config){
			    MIF.Window.superclass.constructor.call(this, embed_MIF.call(this, config));
            }
    });
    Ext.override(MIF.Window, MIF.ComponentAdapter.prototype);
    Ext.reg('iframewindow', MIF.Window);
    
    /*
    * end Window
    */
    
    /**
     * @class Ext.ux.ManagedIFrame.Updater
     * @extends Ext.Updater
     * @version 2.1.4 
     * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
     * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a> 
     * @author Doug Hendricks. Forum ID: <a href="http://extjs.com/forum/member.php?u=8730">hendricd</a> 
     * @copyright 2007-2010, Active Group, Inc. All rights reserved.
     * @constructor Creates a new Ext.ux.ManagedIFrame.Updater instance.
     * @param {String/Object} el The element to bind the Updater instance to.
     */
    Ext.ux.ManagedIFrame.Updater = Ext.extend(Ext.Updater, {
    
       /**
         * Display the element's "loading" state. By default, the element is updated with {@link #indicatorText}. This
         * method may be overridden to perform a custom action while this Updater is actively updating its contents.
         */
        showLoading : function(){
            this.showLoadIndicator && this.el && this.el.mask(this.indicatorText);
            
        },
        
        /**
         * Hide the Frames masking agent.
         */
        hideLoading : function(){
            this.showLoadIndicator && this.el && this.el.unmask();
        },
        
        // private
        updateComplete : function(response){
            MIF.Updater.superclass.updateComplete.apply(this,arguments);
            this.hideLoading();
        },
    
        // private
        processFailure : function(response){
            MIF.Updater.superclass.processFailure.apply(this,arguments);
            this.hideLoading();
        }
        
    }); 
    
    
    var styleCamelRe = /(-[a-z])/gi;
    var styleCamelFn = function(m, a) {
        return a.charAt(1).toUpperCase();
    };
    
    /**
     * @class Ext.ux.ManagedIFrame.CSS
     * Stylesheet interface object
     * @version 2.1.4 
     * @author Doug Hendricks. doug[always-At]theactivegroup.com
     * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
     * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
     * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
     */
    Ext.ux.ManagedIFrame.CSS = function(hostDocument) {
        var doc;
        if (hostDocument) {
            doc = hostDocument;
            return {
                rules : null,
                /** @private */
                destroy  :  function(){  return doc = null; },

                /**
                 * Creates a stylesheet from a text blob of rules. These rules
                 * will be wrapped in a STYLE tag and appended to the HEAD of
                 * the document.
                 *
                 * @param {String}
                 *            cssText The text containing the css rules
                 * @param {String} id An (optional) id to add to the stylesheet for later removal
                 * @return {StyleSheet}
                 */
                createStyleSheet : function(cssText, id) {
                    var ss;
                    if (!doc)return;
                    var head = doc.getElementsByTagName("head")[0];
                    var rules = doc.createElement("style");
                    rules.setAttribute("type", "text/css");
                    Ext.isString(id) && rules.setAttribute("id", id);

                    if (Ext.isIE) {
                        head.appendChild(rules);
                        ss = rules.styleSheet;
                        ss.cssText = cssText;
                    } else {
                        try {
                            rules.appendChild(doc.createTextNode(cssText));
                        } catch (e) {
                            rules.cssText = cssText;
                        }
                        head.appendChild(rules);
                        ss = rules.styleSheet
                                ? rules.styleSheet
                                : (rules.sheet || doc.styleSheets[doc.styleSheets.length - 1]);
                    }
                    this.cacheStyleSheet(ss);
                    return ss;
                },

                /**
                 * Removes a style or link tag by id
                 *
                 * @param {String}
                 *            id The id of the tag
                 */
                removeStyleSheet : function(id) {

                    if (!doc || !id)return;
                    var existing = doc.getElementById(id);
                    if (existing) {
                        existing.parentNode.removeChild(existing);
                    }
                },

                /**
                 * Dynamically swaps an existing stylesheet reference for a new
                 * one
                 *
                 * @param {String}
                 *            id The id of an existing link tag to remove
                 * @param {String}
                 *            url The href of the new stylesheet to include
                 */
                swapStyleSheet : function(id, url) {
                    if (!doc)return;
                    this.removeStyleSheet(id);
                    var ss = doc.createElement("link");
                    ss.setAttribute("rel", "stylesheet");
                    ss.setAttribute("type", "text/css");
                    Ext.isString(id) && ss.setAttribute("id", id);
                    ss.setAttribute("href", url);
                    doc.getElementsByTagName("head")[0].appendChild(ss);
                },

                /**
                 * Refresh the rule cache if you have dynamically added stylesheets
                 * @return {Object} An object (hash) of rules indexed by selector
                 */
                refreshCache : function() {
                    return this.getRules(true);
                },

                // private
                cacheStyleSheet : function(ss, media) {
                    this.rules || (this.rules = {});
                    
                     try{// try catch for cross domain access issue
			          
				          Ext.each(ss.cssRules || ss.rules || [], 
				            function(rule){ 
				              this.hashRule(rule, ss, media);
				          }, this);  
				          
				          //IE @imports
				          Ext.each(ss.imports || [], 
				           function(sheet){
				              sheet && this.cacheStyleSheet(sheet,this.resolveMedia([sheet, sheet.parentStyleSheet]));
				           }
				          ,this);
			          
			        }catch(e){}
                },
                 // @private
			   hashRule  :  function(rule, sheet, mediaOverride){
			      
			      var mediaSelector = mediaOverride || this.resolveMedia(rule);
			      
			      //W3C @media
			      if( rule.cssRules || rule.rules){
			          this.cacheStyleSheet(rule, this.resolveMedia([rule, rule.parentRule ]));
			      } 
			      
			       //W3C @imports
			      if(rule.styleSheet){ 
			         this.cacheStyleSheet(rule.styleSheet, this.resolveMedia([rule, rule.ownerRule, rule.parentStyleSheet]));
			      }
			      
			      rule.selectorText && 
			        Ext.each((mediaSelector || '').split(','), 
			           function(media){
			            this.rules[((media ? media.trim() + ':' : '') + rule.selectorText).toLowerCase()] = rule;
			        }, this);
			      
			   },
			
			   /**
			    * @private
			    * @param {Object/Array} rule CSS Rule (or array of Rules/sheets) to evaluate media types.
			    * @return a comma-delimited string of media types. 
			    */
			   resolveMedia  : function(rule){
			        var media;
			        Ext.each([].concat(rule),function(r){
			            if(r && r.media && r.media.length){
			                media = r.media;
			                return false;
			            }
			        });
			        return media ? (Ext.isIE ? String(media) : media.mediaText ) : '';
			     },

                /**
                 * Gets all css rules for the document
                 *
                 * @param {Boolean}
                 *            refreshCache true to refresh the internal cache
                 * @return {Object} An object (hash) of rules indexed by
                 *         selector
                 */
                getRules : function(refreshCache) {
                    if (!this.rules || refreshCache) {
                        this.rules = {};
                        if (doc) {
                            var ds = doc.styleSheets;
                            for (var i = 0, len = ds.length; i < len; i++) {
                                try {
                                    this.cacheStyleSheet(ds[i]);
                                } catch (e) {}
                            }
                        }
                    }
                    return this.rules;
                },

               /**
			    * Gets an an individual CSS rule by selector(s)
			    * @param {String/Array} selector The CSS selector or an array of selectors to try. The first selector that is found is returned.
			    * @param {Boolean} refreshCache true to refresh the internal cache if you have recently updated any rules or added styles dynamically
			    * @param {String} mediaSelector Name of optional CSS media context (eg. print, screen)
			    * @return {CSSRule} The CSS rule or null if one is not found
			    */
                getRule : function(selector, refreshCache, mediaSelector) {
                    var rs = this.getRules(refreshCache);

			        if(Ext.type(mediaSelector) == 'string'){
			            mediaSelector = mediaSelector.trim() + ':';
			        }else{
			            mediaSelector = '';
			        }
			
			        if(!Ext.isArray(selector)){
			            return rs[(mediaSelector + selector).toLowerCase()];
			        }
			        var select;
			        for(var i = 0; i < selector.length; i++){
			            select = (mediaSelector + selector[i]).toLowerCase();
			            if(rs[select]){
			                return rs[select];
			            }
			        }
			        return null;
                },

               /**
			    * Updates a rule property
			    * @param {String/Array} selector If it's an array it tries each selector until it finds one. Stops immediately once one is found.
			    * @param {String} property The css property
			    * @param {String} value The new value for the property
			    * @param {String} mediaSelector Name(s) of optional media contexts. Multiple may be specified, delimited by commas (eg. print,screen)
			    * @return {Boolean} true If a rule was found and updated
			    */
                updateRule : function(selector, property, value, mediaSelector){
    
			         Ext.each((mediaSelector || '').split(','), function(mediaSelect){    
			            if(!Ext.isArray(selector)){
			                var rule = this.getRule(selector, false, mediaSelect);
			                if(rule){
			                    rule.style[property.replace(camelRe, camelFn)] = value;
			                    return true;
			                }
			            }else{
			                for(var i = 0; i < selector.length; i++){
			                    if(this.updateRule(selector[i], property, value, mediaSelect)){
			                        return true;
			                    }
			                }
			            }
			            return false;
			         }, this);
                }
            };
        }
    };

    /**
     * @class Ext.ux.ManagedIFrame.Manager
     * @version 2.1.4 
	 * @author Doug Hendricks. doug[always-At]theactivegroup.com
	 * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
	 * @copyright 2007-2010, Active Group, Inc.  All rights reserved.
	 * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a>
	 * @singleton
     */
    Ext.ux.ManagedIFrame.Manager = function() {
        var frames = {};
        var implementation = {
            // private DOMFrameContentLoaded handler for browsers (Gecko, Webkit, Opera) that support it.
            _DOMFrameReadyHandler : function(e) {
                try {
                    var $frame ;
                    if ($frame = e.target.ownerCt){
                        $frame.loadHandler.call($frame,e);
                    }
                } catch (rhEx) {} //nested iframes will throw when accessing target.id
            },
            /**
             * @cfg {String} shimCls
             * @default "ux-mif-shim"
             * The default CSS rule applied to MIF image shims to toggle their visibility.
             */
            shimCls : 'ux-mif-shim',

            /** @private */
            register : function(frame) {
                frame.manager = this;
                frames[frame.id] = frames[frame.name] = {ref : frame };
                return frame;
            },
            /** @private */
            deRegister : function(frame) {
                delete frames[frame.id];
                delete frames[frame.name];
                
            },
            /**
             * Toggles the built-in MIF shim off on all visible MIFs
             * @methodOf Ext.ux.MIF.Manager
             *
             */
            hideShims : function() {
                var mm = MIF.Manager;
                mm.shimsApplied && Ext.select('.' + mm.shimCls, true).removeClass(mm.shimCls+ '-on');
                mm.shimsApplied = false;
            },

            /**
             * Shim ALL MIFs (eg. when a region-layout.splitter is on the move or before start of a drag operation)
             * @methodOf Ext.ux.MIF.Manager
             */
            showShims : function() {
                var mm = MIF.Manager;
                !mm.shimsApplied && Ext.select('.' + mm.shimCls, true).addClass(mm.shimCls+ '-on');
                mm.shimsApplied = true;
            },

            /**
             * Retrieve a MIF instance by its DOM ID
             * @methodOf Ext.ux.MIF.Manager
             * @param {Ext.ux.MIF/string} id
             */
            getFrameById : function(id) {
                return typeof id == 'string' ? (frames[id] ? frames[id].ref
                        || null : null) : null;
            },

            /**
             * Retrieve a MIF instance by its DOM name
             * @methodOf Ext.ux.MIF.Manager
             * @param {Ext.ux.MIF/string} name
             */
            getFrameByName : function(name) {
                return this.getFrameById(name);
            },

            /** @private */
            // retrieve the internal frameCache object
            getFrameHash : function(frame) {
                return frames[frame.id] || frames[frame.id] || null;
            },

            /** @private */
            destroy : function() {
                if (document.addEventListener && !Ext.isOpera) {
                      window.removeEventListener("DOMFrameContentLoaded", this._DOMFrameReadyHandler , false);
                }
            }
        };
        // for Gecko and any who might support it later 
        document.addEventListener && !Ext.isOpera &&
            window.addEventListener("DOMFrameContentLoaded", implementation._DOMFrameReadyHandler , false);

        Ext.EventManager.on(window, 'beforeunload', implementation.destroy, implementation);
        return implementation;
    }();
    
    MIM = MIF.Manager;
    MIM.showDragMask = MIM.showShims;
    MIM.hideDragMask = MIM.hideShims;
    
    /**
     * Shim all MIF's during a Window drag operation.
     */
    var winDD = Ext.Window.DD;
    Ext.override(winDD, {
       startDrag : winDD.prototype.startDrag.createInterceptor(MIM.showShims),
       endDrag   : winDD.prototype.endDrag.createInterceptor(MIM.hideShims)
    });

    //Previous release compatibility
    Ext.ux.ManagedIFramePanel = MIF.Panel;
    Ext.ux.ManagedIFramePortlet = MIF.Portlet;
    Ext.ux.ManagedIframe = function(el,opt){
        
        var args = Array.prototype.slice.call(arguments, 0),
            el = Ext.get(args[0]),
            config = args[0];

        if (el && el.dom && el.dom.tagName == 'IFRAME') {
            config = args[1] || {};
        } else {
            config = args[0] || args[1] || {};

            el = config.autoCreate ? Ext.get(Ext.DomHelper.append(
                    config.autoCreate.parent || Ext.getBody(), Ext.apply({
                        tag : 'iframe',
                        frameborder : 0,
                        cls : 'x-mif',
                        src : (Ext.isIE && Ext.isSecure)? Ext.SSL_SECURE_URL: 'about:blank'
                    }, config.autoCreate)))
                    : null;

            if(el && config.unsupportedText){
                Ext.DomHelper.append(el.dom.parentNode, {tag:'noframes',html: config.unsupportedText } );
            }
        }
        
        var mif = new MIF.Element(el,true);
        if(mif){
            Ext.apply(mif, {
                disableMessaging : Ext.value(config.disableMessaging , true),
                focusOnLoad : Ext.value(config.focusOnLoad , Ext.isIE),
                eventsFollowFrameLinks : Ext.value(config.eventsFollowFrameLinks ,true),
                loadMask : !!config.loadMask ? Ext.apply({
                            msg : 'Loading..',
                            msgCls : 'x-mask-loading',
                            maskEl : null,
                            hideOnReady : false,
                            disabled : false
                        }, config.loadMask) : false,
                _windowContext : null
                
            });
            
            config.listeners && mif.on(config.listeners);
            
            if(!!config.html){
                mif.update(config.html);
            } else {
                !!config.src && mif.setSrc(config.src);
            }
        }
        
        return mif;   
    };

    /**
     * Internal Error class for ManagedIFrame Components
	 * @class Ext.ux.ManagedIFrame.Error
     * @extends Ext.Error
     * @version 2.1.4 
     * @donate <a target="tag_donate" href="http://donate.theactivegroup.com"><img border="0" src="http://www.paypal.com/en_US/i/btn/x-click-butcc-donate.gif" border="0" alt="Make a donation to support ongoing development"></a>
     * @license <a href="http://www.gnu.org/licenses/gpl.html">GPL 3.0</a> 
     * @author Doug Hendricks. Forum ID: <a href="http://extjs.com/forum/member.php?u=8730">hendricd</a> 
     * @copyright 2007-2010, Active Group, Inc. All rights reserved.
	 * @constructor 
     * @param {String} message
     * @param {Mixed} arg optional argument to include in Error object.
	 */
	Ext.ux.ManagedIFrame.Error = Ext.extend(Ext.Error, {
	    constructor : function(message, arg) {
	        this.arg = arg;
	        Ext.Error.call(this, message);
	    },
	    name : 'Ext.ux.ManagedIFrame'
	});
    
	Ext.apply(Ext.ux.ManagedIFrame.Error.prototype, {
	    lang: {
	        'documentcontext-remove': 'An attempt was made to remove an Element from the wrong document context.',
	        'execscript-secure-context': 'An attempt was made at script execution within a document context with limited access permissions.',
	        'printexception': 'An Error was encountered attempting the print the frame contents (document access is likely restricted).'
	    }
	});
    
    /** @private */
    Ext.onReady(function() {
            // Generate CSS Rules but allow for overrides.
            var CSS = new Ext.ux.ManagedIFrame.CSS(document), rules = [];

            CSS.getRule('.ux-mif-fill')|| (rules.push('.ux-mif-fill{height:100%;width:100%;}'));
            CSS.getRule('.ux-mif-mask-target')|| (rules.push('.ux-mif-mask-target{position:relative;zoom:1;}'));
            CSS.getRule('.ux-mif-el-mask')|| (rules.push(
              '.ux-mif-el-mask {z-index: 100;position: absolute;top:0;left:0;-moz-opacity: 0.5;opacity: .50;*filter: alpha(opacity=50);width: 100%;height: 100%;zoom: 1;} ',
              '.ux-mif-el-mask-msg {z-index: 1;position: absolute;top: 0;left: 0;border:1px solid;background:repeat-x 0 -16px;padding:2px;} ',
              '.ux-mif-el-mask-msg div {padding:5px 10px 5px 10px;border:1px solid;cursor:wait;} '
              ));


            if (!CSS.getRule('.ux-mif-shim')) {
                rules.push('.ux-mif-shim {z-index:8500;position:absolute;top:0px;left:0px;background:transparent!important;overflow:hidden;display:none;}');
                rules.push('.ux-mif-shim-on{width:100%;height:100%;display:block;zoom:1;}');
                rules.push('.ext-ie6 .ux-mif-shim{margin-left:5px;margin-top:3px;}');
            }
            
            if (!CSS.getRule('.x-hide-nosize')){ 
                rules.push ('.x-hide-nosize{height:0px!important;width:0px!important;visibility:hidden!important;border:none!important;zoom:1;}.x-hide-nosize * {height:0px!important;width:0px!important;visibility:hidden!important;border:none!important;zoom:1;}');
            }
  
            !!rules.length && CSS.createStyleSheet(rules.join(' '), 'mifCSS');
            
        });

    /** @sourceURL=<mif.js> */
    Ext.provide && Ext.provide('mif');
})();/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
Ext.ns('Ext.ux.tree');

/**
 * @class Ext.ux.tree.TreeGridSorter
 * @extends Ext.tree.TreeSorter
 * Provides sorting of nodes in a {@link Ext.ux.tree.TreeGrid}.  The TreeGridSorter automatically monitors events on the
 * associated TreeGrid that might affect the tree's sort order (beforechildrenrendered, append, insert and textchange).
 * Example usage:<br />
 * <pre><code>
 new Ext.ux.tree.TreeGridSorter(myTreeGrid, {
     folderSort: true,
     dir: "desc",
     sortType: function(node) {
         // sort by a custom, typed attribute:
         return parseInt(node.id, 10);
     }
 });
 </code></pre>
 * @constructor
 * @param {TreeGrid} tree
 * @param {Object} config
 */
Ext.ux.tree.TreeGridSorter = Ext.extend(Ext.tree.TreeSorter, {
    /**
     * @cfg {Array} sortClasses The CSS classes applied to a header when it is sorted. (defaults to <tt>['sort-asc', 'sort-desc']</tt>)
     */
    sortClasses : ['sort-asc', 'sort-desc'],
    /**
     * @cfg {String} sortAscText The text displayed in the 'Sort Ascending' menu item (defaults to <tt>'Sort Ascending'</tt>)
     */
    sortAscText : 'Sort Ascending',
    /**
     * @cfg {String} sortDescText The text displayed in the 'Sort Descending' menu item (defaults to <tt>'Sort Descending'</tt>)
     */
    sortDescText : 'Sort Descending',

    constructor : function(tree, config) {
        if(!Ext.isObject(config)) {
            config = {
                property: tree.columns[0].dataIndex || 'text',
                folderSort: true
            }
        }

        Ext.ux.tree.TreeGridSorter.superclass.constructor.apply(this, arguments);

        this.tree = tree;
        tree.on('headerclick', this.onHeaderClick, this);
        tree.ddAppendOnly = true;

        var me = this;
        this.defaultSortFn = function(n1, n2){

            var desc = me.dir && me.dir.toLowerCase() == 'desc',
                prop = me.property || 'text',
                sortType = me.sortType,
                caseSensitive = me.caseSensitive === true,
                leafAttr = me.leafAttr || 'leaf',
                attr1 = n1.attributes,
                attr2 = n2.attributes;

            if(me.folderSort){
                if(attr1[leafAttr] && !attr2[leafAttr]){
                    return 1;
                }
                if(!attr1[leafAttr] && attr2[leafAttr]){
                    return -1;
                }
            }
            var prop1 = attr1[prop],
                prop2 = attr2[prop],
                v1 = sortType ? sortType(prop1) : (caseSensitive ? prop1 : prop1.toUpperCase());
                v2 = sortType ? sortType(prop2) : (caseSensitive ? prop2 : prop2.toUpperCase());
                
            if(v1 < v2){
                return desc ? +1 : -1;
            }else if(v1 > v2){
                return desc ? -1 : +1;
            }else{
                return 0;
            }
        };

        tree.on('afterrender', this.onAfterTreeRender, this, {single: true});
        tree.on('headermenuclick', this.onHeaderMenuClick, this);
    },

    onAfterTreeRender : function() {
        if(this.tree.hmenu){
            this.tree.hmenu.insert(0,
                {itemId:'asc', text: this.sortAscText, cls: 'xg-hmenu-sort-asc'},
                {itemId:'desc', text: this.sortDescText, cls: 'xg-hmenu-sort-desc'}
            );
        }
        this.updateSortIcon(0, 'asc');
    },

    onHeaderMenuClick : function(c, id, index) {
        if(id === 'asc' || id === 'desc') {
            this.onHeaderClick(c, null, index);
            return false;
        }
    },

    onHeaderClick : function(c, el, i) {
        if(c && !this.tree.headersDisabled){
            var me = this;

            me.property = c.dataIndex;
            me.dir = c.dir = (c.dir === 'desc' ? 'asc' : 'desc');
            me.sortType = c.sortType;
            me.caseSensitive === Ext.isBoolean(c.caseSensitive) ? c.caseSensitive : this.caseSensitive;
            me.sortFn = c.sortFn || this.defaultSortFn;

            this.tree.root.cascade(function(n) {
                if(!n.isLeaf()) {
                    me.updateSort(me.tree, n);
                }
            });

            this.updateSortIcon(i, c.dir);
        }
    },

    // private
    updateSortIcon : function(col, dir){
        var sc = this.sortClasses,
            hds = this.tree.innerHd.select('td').removeClass(sc);
        hds.item(col).addClass(sc[dir == 'desc' ? 1 : 0]);
    }
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
/**
 * @class Ext.tree.ColumnResizer
 * @extends Ext.util.Observable
 */
Ext.tree.ColumnResizer = Ext.extend(Ext.util.Observable, {
    /**
     * @cfg {Number} minWidth The minimum width the column can be dragged to.
     * Defaults to <tt>14</tt>.
     */
    minWidth: 14,

    constructor: function(config){
        Ext.apply(this, config);
        Ext.tree.ColumnResizer.superclass.constructor.call(this);
    },

    init : function(tree){
        this.tree = tree;
        tree.on('render', this.initEvents, this);
    },

    initEvents : function(tree){
        tree.mon(tree.innerHd, 'mousemove', this.handleHdMove, this);
        this.tracker = new Ext.dd.DragTracker({
            onBeforeStart: this.onBeforeStart.createDelegate(this),
            onStart: this.onStart.createDelegate(this),
            onDrag: this.onDrag.createDelegate(this),
            onEnd: this.onEnd.createDelegate(this),
            tolerance: 3,
            autoStart: 300
        });
        this.tracker.initEl(tree.innerHd);
        tree.on('beforedestroy', this.tracker.destroy, this.tracker);
    },

    handleHdMove : function(e, t){
        var hw = 5,
            x = e.getPageX(),
            hd = e.getTarget('.x-treegrid-hd', 3, true);
        
        if(hd){                                 
            var r = hd.getRegion(),
                ss = hd.dom.style,
                pn = hd.dom.parentNode;
            
            if(x - r.left <= hw && hd.dom !== pn.firstChild) {
                var ps = hd.dom.previousSibling;
                while(ps && Ext.fly(ps).hasClass('x-treegrid-hd-hidden')) {
                    ps = ps.previousSibling;
                }
                if(ps) {                    
                    this.activeHd = Ext.get(ps);
    				ss.cursor = Ext.isWebKit ? 'e-resize' : 'col-resize';
                }
            } else if(r.right - x <= hw) {
                var ns = hd.dom;
                while(ns && Ext.fly(ns).hasClass('x-treegrid-hd-hidden')) {
                    ns = ns.previousSibling;
                }
                if(ns) {
                    this.activeHd = Ext.get(ns);
    				ss.cursor = Ext.isWebKit ? 'w-resize' : 'col-resize';                    
                }
            } else{
                delete this.activeHd;
                ss.cursor = '';
            }
        }
    },

    onBeforeStart : function(e){
        this.dragHd = this.activeHd;
        return !!this.dragHd;
    },

    onStart : function(e){
        this.dragHeadersDisabled = this.tree.headersDisabled;
        this.tree.headersDisabled = true;
        this.proxy = this.tree.body.createChild({cls:'x-treegrid-resizer'});
        this.proxy.setHeight(this.tree.body.getHeight());

        var x = this.tracker.getXY()[0];

        this.hdX = this.dragHd.getX();
        this.hdIndex = this.tree.findHeaderIndex(this.dragHd);

        this.proxy.setX(this.hdX);
        this.proxy.setWidth(x-this.hdX);

        this.maxWidth = this.tree.outerCt.getWidth() - this.tree.innerBody.translatePoints(this.hdX).left;
    },

    onDrag : function(e){
        var cursorX = this.tracker.getXY()[0];
        this.proxy.setWidth((cursorX-this.hdX).constrain(this.minWidth, this.maxWidth));
    },

    onEnd : function(e){
        var nw = this.proxy.getWidth(),
            tree = this.tree,
            disabled = this.dragHeadersDisabled;
        
        this.proxy.remove();
        delete this.dragHd;
        
        tree.columns[this.hdIndex].width = nw;
        tree.updateColumnWidths();
        
        setTimeout(function(){
            tree.headersDisabled = disabled;
        }, 100);
    }
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
/**
 * @class Ext.ux.tree.TreeGridNodeUI
 * @extends Ext.tree.TreeNodeUI
 */
Ext.ux.tree.TreeGridNodeUI = Ext.extend(Ext.tree.TreeNodeUI, {
    isTreeGridNodeUI: true,

    renderElements : function(n, a, targetNode, bulkRender){
        var t = n.getOwnerTree(),
            cols = t.columns,
            c = cols[0],
            i, buf, len;

        this.indentMarkup = n.parentNode ? n.parentNode.ui.getChildIndent() : '';

        buf = [
             '<tbody class="x-tree-node">',
                '<tr ext:tree-node-id="', n.id ,'" class="x-tree-node-el x-tree-node-leaf ', a.cls, '">',
                    '<td class="x-treegrid-col">',
                        '<span class="x-tree-node-indent">', this.indentMarkup, "</span>",
                        '<img src="', this.emptyIcon, '" class="x-tree-ec-icon x-tree-elbow" />',
                        '<img src="', a.icon || this.emptyIcon, '" class="x-tree-node-icon', (a.icon ? " x-tree-node-inline-icon" : ""), (a.iconCls ? " "+a.iconCls : ""), '" unselectable="on" />',
                        '<a hidefocus="on" class="x-tree-node-anchor" href="', a.href ? a.href : '#', '" tabIndex="1" ',
                            a.hrefTarget ? ' target="'+a.hrefTarget+'"' : '', '>',
                        '<span unselectable="on">', (c.tpl ? c.tpl.apply(a) : a[c.dataIndex] || c.text), '</span></a>',
                    '</td>'
        ];

        for(i = 1, len = cols.length; i < len; i++){
            c = cols[i];
            buf.push(
                    '<td class="x-treegrid-col ', (c.cls ? c.cls : ''), '">',
                        '<div unselectable="on" class="x-treegrid-text"', (c.align ? ' style="text-align: ' + c.align + ';"' : ''), '>',
                            (c.tpl ? c.tpl.apply(a) : a[c.dataIndex]),
                        '</div>',
                    '</td>'
            );
        }

        buf.push(
            '</tr><tr class="x-tree-node-ct"><td colspan="', cols.length, '">',
            '<table class="x-treegrid-node-ct-table" cellpadding="0" cellspacing="0" style="table-layout: fixed; display: none; width: ', t.innerCt.getWidth() ,'px;"><colgroup>'
        );
        for(i = 0, len = cols.length; i<len; i++) {
            buf.push('<col style="width: ', (cols[i].hidden ? 0 : cols[i].width) ,'px;" />');
        }
        buf.push('</colgroup></table></td></tr></tbody>');

        if(bulkRender !== true && n.nextSibling && n.nextSibling.ui.getEl()){
            this.wrap = Ext.DomHelper.insertHtml("beforeBegin", n.nextSibling.ui.getEl(), buf.join(''));
        }else{
            this.wrap = Ext.DomHelper.insertHtml("beforeEnd", targetNode, buf.join(''));
        }

        this.elNode = this.wrap.childNodes[0];
        this.ctNode = this.wrap.childNodes[1].firstChild.firstChild;
        var cs = this.elNode.firstChild.childNodes;
        this.indentNode = cs[0];
        this.ecNode = cs[1];
        this.iconNode = cs[2];
        this.anchor = cs[3];
        this.textNode = cs[3].firstChild;
    },

    // private
    animExpand : function(cb){
        this.ctNode.style.display = "";
        Ext.ux.tree.TreeGridNodeUI.superclass.animExpand.call(this, cb);
    }
});

Ext.ux.tree.TreeGridRootNodeUI = Ext.extend(Ext.tree.TreeNodeUI, {
    isTreeGridNodeUI: true,

    // private
    render : function(){
        if(!this.rendered){
            this.wrap = this.ctNode = this.node.ownerTree.innerCt.dom;
            this.node.expanded = true;
        }

        if(Ext.isWebKit) {
            // weird table-layout: fixed issue in webkit
            var ct = this.ctNode;
            ct.style.tableLayout = null;
            (function() {
                ct.style.tableLayout = 'fixed';
            }).defer(1);
        }
    },

    destroy : function(){
        if(this.elNode){
            Ext.dd.Registry.unregister(this.elNode.id);
        }
        delete this.node;
    },

    collapse : Ext.emptyFn,
    expand : Ext.emptyFn
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
/**
 * @class Ext.ux.tree.TreeGridLoader
 * @extends Ext.tree.TreeLoader
 */
Ext.ux.tree.TreeGridLoader = Ext.extend(Ext.tree.TreeLoader, {
    createNode : function(attr) {
        if (!attr.uiProvider) {
            attr.uiProvider = Ext.ux.tree.TreeGridNodeUI;
        }
        return Ext.tree.TreeLoader.prototype.createNode.call(this, attr);
    },
    processResponse : function(response, node, callback, scope){
        var json = response.responseText,
            children,
            newNode,
            i = 0,
            len;
        try {
            if (!(children = response.responseData)) {
                children = Ext.decode(json);
                if (this.root) {
                    if (!this.getRoot) {
                        this.getRoot = Ext.data.JsonReader.prototype.createAccessor(this.root);
                   }
                   children = this.getRoot(children);
                }
            }
            node.beginUpdate();
            for(len = children.length; i < len; i++){
                if(newNode = this.createNode(children[i])){
                    node.appendChild(newNode);
                }
            }
            node.endUpdate();
            this.runCallback(callback, scope || node, [node]);
        }catch(e){
            this.handleFailure(response);
        }
    }
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
(function() {
    Ext.override(Ext.list.Column, {
        init : function() {    
            var types = Ext.data.Types,
                st = this.sortType;
                    
            if(this.type){
                if(Ext.isString(this.type)){
                    this.type = Ext.data.Types[this.type.toUpperCase()] || types.AUTO;
                }
            }else{
                this.type = types.AUTO;
            }

            // named sortTypes are supported, here we look them up
            if(Ext.isString(st)){
                this.sortType = Ext.data.SortTypes[st];
            }else if(Ext.isEmpty(st)){
                this.sortType = this.type.sortType;
            }
        }
    });

    Ext.tree.Column = Ext.extend(Ext.list.Column, {});
    Ext.tree.NumberColumn = Ext.extend(Ext.list.NumberColumn, {});
    Ext.tree.DateColumn = Ext.extend(Ext.list.DateColumn, {});
    Ext.tree.BooleanColumn = Ext.extend(Ext.list.BooleanColumn, {});

    Ext.reg('tgcolumn', Ext.tree.Column);
    Ext.reg('tgnumbercolumn', Ext.tree.NumberColumn);
    Ext.reg('tgdatecolumn', Ext.tree.DateColumn);
    Ext.reg('tgbooleancolumn', Ext.tree.BooleanColumn);
})();
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
/**
 * @class Ext.ux.tree.TreeGrid
 * @extends Ext.tree.TreePanel
 * 
 * @xtype treegrid
 */
Ext.ux.tree.TreeGrid = Ext.extend(Ext.tree.TreePanel, {
    rootVisible : false,
    useArrows : true,
    lines : false,
    borderWidth : Ext.isBorderBox ? 0 : 2, // the combined left/right border for each cell
    cls : 'x-treegrid',

    columnResize : true,
    enableSort : true,
    reserveScrollOffset : true,
    enableHdMenu : true,
    
    columnsText : 'Columns',

    initComponent : function() {
        if(!this.root) {
            this.root = new Ext.tree.AsyncTreeNode({text: 'Root'});
        }
        
        // initialize the loader
        var l = this.loader;
        if(!l){
            l = new Ext.ux.tree.TreeGridLoader({
                dataUrl: this.dataUrl,
                requestMethod: this.requestMethod,
                store: this.store
            });
        }else if(Ext.isObject(l) && !l.load){
            l = new Ext.ux.tree.TreeGridLoader(l);
        }
        this.loader = l;
                            
        Ext.ux.tree.TreeGrid.superclass.initComponent.call(this);                    
        
        this.initColumns();
        
        if(this.enableSort) {
            this.treeGridSorter = new Ext.ux.tree.TreeGridSorter(this, this.enableSort);
        }
        
        if(this.columnResize){
            this.colResizer = new Ext.tree.ColumnResizer(this.columnResize);
            this.colResizer.init(this);
        }
        
        var c = this.columns;
        if(!this.internalTpl){                                
            this.internalTpl = new Ext.XTemplate(
                '<div class="x-grid3-header">',
                    '<div class="x-treegrid-header-inner">',
                        '<div class="x-grid3-header-offset">',
                            '<table style="table-layout: fixed;" cellspacing="0" cellpadding="0" border="0"><colgroup><tpl for="columns"><col /></tpl></colgroup>',
                            '<thead><tr class="x-grid3-hd-row">',
                            '<tpl for="columns">',
                            '<td class="x-grid3-hd x-grid3-cell x-treegrid-hd" style="text-align: {align};" id="', this.id, '-xlhd-{#}">',
                                '<div class="x-grid3-hd-inner x-treegrid-hd-inner" unselectable="on">',
                                     this.enableHdMenu ? '<a class="x-grid3-hd-btn" href="#"></a>' : '',
                                     '{header}<img class="x-grid3-sort-icon" src="', Ext.BLANK_IMAGE_URL, '" />',
                                 '</div>',
                            '</td></tpl>',
                            '</tr></thead>',
                        '</table>',
                    '</div></div>',
                '</div>',
                '<div class="x-treegrid-root-node">',
                    '<table class="x-treegrid-root-table" cellpadding="0" cellspacing="0" style="table-layout: fixed;"></table>',
                '</div>'
            );
        }
        
        if(!this.colgroupTpl) {
            this.colgroupTpl = new Ext.XTemplate(
                '<colgroup><tpl for="columns"><col style="width: {width}px"/></tpl></colgroup>'
            );
        }
    },

    initColumns : function() {
        var cs = this.columns,
            len = cs.length, 
            columns = [],
            i, c;

        for(i = 0; i < len; i++){
            c = cs[i];
            if(!c.isColumn) {
                c.xtype = c.xtype ? (/^tg/.test(c.xtype) ? c.xtype : 'tg' + c.xtype) : 'tgcolumn';
                c = Ext.create(c);
            }
            c.init(this);
            columns.push(c);
            
            if(this.enableSort !== false && c.sortable !== false) {
                c.sortable = true;
                this.enableSort = true;
            }
        }

        this.columns = columns;
    },

    onRender : function(){
        Ext.tree.TreePanel.superclass.onRender.apply(this, arguments);

        this.el.addClass('x-treegrid');
        
        this.outerCt = this.body.createChild({
            cls:'x-tree-root-ct x-treegrid-ct ' + (this.useArrows ? 'x-tree-arrows' : this.lines ? 'x-tree-lines' : 'x-tree-no-lines')
        });
        
        this.internalTpl.overwrite(this.outerCt, {columns: this.columns});
        
        this.mainHd = Ext.get(this.outerCt.dom.firstChild);
        this.innerHd = Ext.get(this.mainHd.dom.firstChild);
        this.innerBody = Ext.get(this.outerCt.dom.lastChild);
        this.innerCt = Ext.get(this.innerBody.dom.firstChild);
        
        this.colgroupTpl.insertFirst(this.innerCt, {columns: this.columns});
        
        if(this.hideHeaders){
            this.el.child('.x-grid3-header').setDisplayed('none');
        }
        else if(this.enableHdMenu !== false){
            this.hmenu = new Ext.menu.Menu({id: this.id + '-hctx'});
            if(this.enableColumnHide !== false){
                this.colMenu = new Ext.menu.Menu({id: this.id + '-hcols-menu'});
                this.colMenu.on({
                    scope: this,
                    beforeshow: this.beforeColMenuShow,
                    itemclick: this.handleHdMenuClick
                });
                this.hmenu.add({
                    itemId:'columns',
                    hideOnClick: false,
                    text: this.columnsText,
                    menu: this.colMenu,
                    iconCls: 'x-cols-icon'
                });
            }
            this.hmenu.on('itemclick', this.handleHdMenuClick, this);
        }
    },

    setRootNode : function(node){
        node.attributes.uiProvider = Ext.ux.tree.TreeGridRootNodeUI;        
        node = Ext.ux.tree.TreeGrid.superclass.setRootNode.call(this, node);
        if(this.innerCt) {
            this.colgroupTpl.insertFirst(this.innerCt, {columns: this.columns});
        }
        return node;
    },
    
    clearInnerCt : function(){
        if(Ext.isIE){
            var dom = this.innerCt.dom;
            while(dom.firstChild){
                dom.removeChild(dom.firstChild);
            }
        }else{
            Ext.ux.tree.TreeGrid.superclass.clearInnerCt.call(this);
        }
    },
    
    initEvents : function() {
        Ext.ux.tree.TreeGrid.superclass.initEvents.apply(this, arguments);

        this.mon(this.innerBody, 'scroll', this.syncScroll, this);
        this.mon(this.innerHd, 'click', this.handleHdDown, this);
        this.mon(this.mainHd, {
            scope: this,
            mouseover: this.handleHdOver,
            mouseout: this.handleHdOut
        });
    },
    
    onResize : function(w, h) {
        Ext.ux.tree.TreeGrid.superclass.onResize.apply(this, arguments);
        
        var bd = this.innerBody.dom;
        var hd = this.innerHd.dom;

        if(!bd){
            return;
        }

        if(Ext.isNumber(h)){
            bd.style.height = this.body.getHeight(true) - hd.offsetHeight + 'px';
        }

        if(Ext.isNumber(w)){                        
            var sw = Ext.num(this.scrollOffset, Ext.getScrollBarWidth());
            if(this.reserveScrollOffset || ((bd.offsetWidth - bd.clientWidth) > 10)){
                this.setScrollOffset(sw);
            }else{
                var me = this;
                setTimeout(function(){
                    me.setScrollOffset(bd.offsetWidth - bd.clientWidth > 10 ? sw : 0);
                }, 10);
            }
        }
    },

    updateColumnWidths : function() {
        var cols = this.columns,
            colCount = cols.length,
            groups = this.outerCt.query('colgroup'),
            groupCount = groups.length,
            c, g, i, j;

        for(i = 0; i<colCount; i++) {
            c = cols[i];
            for(j = 0; j<groupCount; j++) {
                g = groups[j];
                g.childNodes[i].style.width = (c.hidden ? 0 : c.width) + 'px';
            }
        }
        
        for(i = 0, groups = this.innerHd.query('td'), len = groups.length; i<len; i++) {
            c = Ext.fly(groups[i]);
            if(cols[i] && cols[i].hidden) {
                c.addClass('x-treegrid-hd-hidden');
            }
            else {
                c.removeClass('x-treegrid-hd-hidden');
            }
        }

        var tcw = this.getTotalColumnWidth();                        
        Ext.fly(this.innerHd.dom.firstChild).setWidth(tcw + (this.scrollOffset || 0));
        this.outerCt.select('table').setWidth(tcw);
        this.syncHeaderScroll();
        this.fireEvent("updateColumnWidths");
    },
                    
    getVisibleColumns : function() {
        var columns = [],
            cs = this.columns,
            len = cs.length,
            i;
            
        for(i = 0; i<len; i++) {
            if(!cs[i].hidden) {
                columns.push(cs[i]);
            }
        }        
        return columns;
    },

    getTotalColumnWidth : function() {
        var total = 0;
        for(var i = 0, cs = this.getVisibleColumns(), len = cs.length; i<len; i++) {
            total += cs[i].width;
        }
        return total;
    },

    setScrollOffset : function(scrollOffset) {
        this.scrollOffset = scrollOffset;                        
        this.updateColumnWidths();
    },

    // private
    handleHdDown : function(e, t){
        var hd = e.getTarget('.x-treegrid-hd');

        if(hd && Ext.fly(t).hasClass('x-grid3-hd-btn')){
            var ms = this.hmenu.items,
                cs = this.columns,
                index = this.findHeaderIndex(hd),
                c = cs[index],
                sort = c.sortable;
                
            e.stopEvent();
            Ext.fly(hd).addClass('x-grid3-hd-menu-open');
            this.hdCtxIndex = index;
            
            this.fireEvent('headerbuttonclick', ms, c, hd, index);
            
            this.hmenu.on('hide', function(){
                Ext.fly(hd).removeClass('x-grid3-hd-menu-open');
            }, this, {single:true});
            
            this.hmenu.show(t, 'tl-bl?');
        }
        else if(hd) {
            var index = this.findHeaderIndex(hd);
            this.fireEvent('headerclick', this.columns[index], hd, index);
        }
    },

    // private
    handleHdOver : function(e, t){                    
        var hd = e.getTarget('.x-treegrid-hd');                        
        if(hd && !this.headersDisabled){
            index = this.findHeaderIndex(hd);
            this.activeHdRef = t;
            this.activeHdIndex = index;
            var el = Ext.get(hd);
            this.activeHdRegion = el.getRegion();
            el.addClass('x-grid3-hd-over');
            this.activeHdBtn = el.child('.x-grid3-hd-btn');
            if(this.activeHdBtn){
                this.activeHdBtn.dom.style.height = (hd.firstChild.offsetHeight-1)+'px';
            }
        }
    },
    
    // private
    handleHdOut : function(e, t){
        var hd = e.getTarget('.x-treegrid-hd');
        if(hd && (!Ext.isIE || !e.within(hd, true))){
            this.activeHdRef = null;
            Ext.fly(hd).removeClass('x-grid3-hd-over');
            hd.style.cursor = '';
        }
    },
                    
    findHeaderIndex : function(hd){
        hd = hd.dom || hd;
        var cs = hd.parentNode.childNodes;
        for(var i = 0, c; c = cs[i]; i++){
            if(c == hd){
                return i;
            }
        }
        return -1;
    },
    
    // private
    beforeColMenuShow : function(){
        var cols = this.columns,  
            colCount = cols.length,
            i, c;                        
        this.colMenu.removeAll();                    
        for(i = 1; i < colCount; i++){
            c = cols[i];
            if(c.hideable !== false){
                this.colMenu.add(new Ext.menu.CheckItem({
                    itemId: 'col-' + i,
                    text: c.header,
                    checked: !c.hidden,
                    hideOnClick:false,
                    disabled: c.hideable === false
                }));
            }
        }
    },
                    
    // private
    handleHdMenuClick : function(item){
        var index = this.hdCtxIndex,
            id = item.getItemId();
        
        if(this.fireEvent('headermenuclick', this.columns[index], id, index) !== false) {
            index = id.substr(4);
            if(index > 0 && this.columns[index]) {
                this.setColumnVisible(index, !item.checked);
            }     
        }
        
        return true;
    },
    
    setColumnVisible : function(index, visible) {
        this.columns[index].hidden = !visible;        
        this.updateColumnWidths();
    },

    /**
     * Scrolls the grid to the top
     */
    scrollToTop : function(){
        this.innerBody.dom.scrollTop = 0;
        this.innerBody.dom.scrollLeft = 0;
    },

    // private
    syncScroll : function(){
        this.syncHeaderScroll();
        var mb = this.innerBody.dom;
        this.fireEvent('bodyscroll', mb.scrollLeft, mb.scrollTop);
    },

    // private
    syncHeaderScroll : function(){
        var mb = this.innerBody.dom;
        this.innerHd.dom.scrollLeft = mb.scrollLeft;
        this.innerHd.dom.scrollLeft = mb.scrollLeft; // second time for IE (1/2 time first fails, other browsers ignore)
    },
    
    registerNode : function(n) {
        Ext.ux.tree.TreeGrid.superclass.registerNode.call(this, n);
        if(!n.uiProvider && !n.isRoot && !n.ui.isTreeGridNodeUI) {
            n.ui = new Ext.ux.tree.TreeGridNodeUI(n);
        }
    }
});

Ext.reg('treegrid', Ext.ux.tree.TreeGrid);/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext,window*/
function utils_logout(reload) {
    if (Ext.isEmpty(reload)) {
        reload = true;
    }
    Ext.util.Cookies.set('userLogin', '');
    Ext.util.Cookies.clear('userLogin');
    Ext.util.Cookies.set('hashCode', '');
    Ext.Ajax.defaultHeaders.Authorization = '';
    if (reload) {
        window.location.reload();
    }	
	    
}
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document, window, SitoolsDesk*/
Ext.namespace('sitools.widget');

/**
 * @cfg {string} urlFeed The feed URL
 * @cfg {string} feedType the type of the feed ("atom_1.0" or "rss_2")
 * @cfg {string} feedSource the source of the feed (OPENSEARCH or CLASSIC)
 * @requires sitools.user.component.openSearchResultFeed
 */
sitools.widget.FeedGridFlux = function (config) {
    
    this.datasetName = config.datasetName;
    function clickOnRow(self, rowIndex, e) {
        e.stopEvent();
        var rec = self.store.getAt(rowIndex);
        if (Ext.isEmpty(rec)) {
            return;
        }
        // si on est pas sur le bureau
        if (Ext.isEmpty(window) || Ext.isEmpty(window.SitoolsDesk)) {
            var component = new sitools.widget.feedItemDetails({
                record : rec
            });
            var win = new Ext.Window({
                stateful : false,
                title : i18n.get('label.viewFeedDetail'),
                width : 400,
                height : 600,
                shim : false,
                animCollapse : false,
                constrainHeader : true,
                layout : 'fit',
                modal : true
            });
            win.add(component);
            win.show();
        } else {
            var componentCfg = {
                record : rec
            };
            var jsObj = sitools.widget.feedItemDetails;

            var windowConfig = {
                id : "viewFeedDetail",
                title : i18n.get('label.viewFeedDetail'),
                saveToolbar : false
            };
            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj, true);

        }
    }

    Ext.apply(this);
    this.layout = "fit";
    this.urlFeed = config.urlFeed;
    
    var gridPanel;
    if (config.feedSource !== undefined && config.feedSource === "OPENSEARCH") {
        gridPanel = new sitools.user.component.openSearchResultFeed(config);
    } else {
        config.listeners = {
            rowdblclick : clickOnRow
        };
        if (config.feedType !== undefined && config.feedType === "atom_1.0") {
            gridPanel = new sitools.widget.atom1FeedReader(config);
        } else {
            gridPanel = new sitools.widget.rss2FeedReader(config);
        }
    }

    this.btnSubscribeRss = new Ext.Button({
        text : i18n.get('label.subscribeRss'),
        cls : 'services-toolbar-btn',
        icon : loadUrl.get('APP_URL') + '/common/res/images/icons/rss.png',
        handler : this.subscribeRss
     });
     
     this.bbar = {
         xtype : 'toolbar',
         cls : "services-toolbar", 
         defaults : {
             scope : this
         },
         items : [ this.btnSubscribeRss ]
     };
    
    this.items = [ gridPanel ];

    sitools.widget.FeedGridFlux.superclass.constructor.call(this);
};

Ext.extend(sitools.widget.FeedGridFlux, Ext.Panel, {
    componentType : "feeds",
    _getSettings : function () {
        return {
        	objectName : "feedsReader"
        };
    },
    
    subscribeRss : function () {
        window.open(this.urlFeed, '_blank');
    },
    border : false

});

Ext.reg('appfeedgridflux', sitools.widget.FeedGridFlux);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document,window,SitoolsDesk*/
Ext.namespace('sitools.widget');

/**
 * @param urlFeed :
 *            The feed URL
 */
sitools.widget.rss2FeedReader = function (config) {
    Ext.apply(this);
    this.layout = "fit";
    this.storeFeedsRecords = new Ext.data.Store({
        autoLoad : true,
        sortInfo : {field : 'pubDate', direction : "DESC"},
        proxy : new Ext.data.HttpProxy({
            url : config.urlFeed,
            restful : true,
            listeners : {
                scope : this,
                exception : onRequestFeedException
            }
        }),
        reader : new Ext.data.XmlReader({
            record : 'item'
        }, [ 'title', 'author', {
            name : 'pubDate',
            type : 'date'
        }, 'link', 'description', 'content', 'guid', {
        	name : 'imageUrl',
        	mapping : "enclosure@url"
        }, {
        	name : 'imageType',
        	mapping : "enclosure@type"
        }])
    });

    var columns = [ {
        id : 'image',
        header : "Image",
        dataIndex : 'imageUrl',
        sortable : false,
        width : 120
        ,
        renderer : this.imageRenderer
    }, {
        id : 'title',
        header : "Title",
        dataIndex : 'title',
        sortable : true,
        width : 460,
        scope : this,
        renderer : this.formatTitle
    }, {
        header : "Author",
        dataIndex : 'author',
        width : 100,
        hidden : true,
        sortable : true
    }, {
        id : 'last',
        header : "Date",
        dataIndex : 'pubDate',
        width : 150,
        renderer : this.formatDate,
        sortable : true,
        hidden : true
    } ];
    
    sitools.widget.rss2FeedReader.superclass.constructor.call(this, {
        // height : 300,
        columns : columns,
        store : this.storeFeedsRecords,
        loadMask : {
            msg : i18n.get("label.loadingFeed")
        },
        sm : new Ext.grid.RowSelectionModel({
            singleSelect : true
        }),
        autoExpandColumn : 'title',
        hideHeaders : true,
        viewConfig : {
            forceFit : true,
            enableRowBody : true,
            showPreview : true,
            getRowClass : this.applyRowClass
        },
        listeners : config.listeners
        
    });

    // this.on('rowcontextmenu', this.onContextClick, this);
    // this.on('beforeShow',this.loadData);
};

Ext.extend(sitools.widget.rss2FeedReader, Ext.grid.GridPanel, {

   
    loadData : function () {
        this.loadFeed('http://feeds.feedburner.com/extblog');
        this.doLayout();
    },

    loadFeed : function (url) {
        this.store.baseParams = {
            feed : url
        };
        this.store.load();
    },

    togglePreview : function (show) {
        this.view.showPreview = show;
        this.view.refresh();
    },

    // within this function "this" is actually the GridView
    applyRowClass : function (record, rowIndex, p, ds) {
        if (this.showPreview) {
            var xf = Ext.util.Format;
            //p.body = '<p class=sous-titre-flux>' + record.data.description + '</p>';
            p.body = '<p class=sous-titre-flux>' + xf.ellipsis(xf.stripTags(record.data.description), 300) + '</p>';
            return 'x-grid3-row-expanded';
        }
        return 'x-grid3-row-collapsed';
    },

    formatDate : function (date) {
        if (!date) {
            return '';
        }
        var now = new Date();
        var d = now.clearTime(true);
        if (date instanceof Date){
            var notime = date.clearTime(true).getTime();
            if (notime == d.getTime()) {
                return 'Today ' + date.dateFormat('g:i a');
            }
            d = d.add('d', -6);
            if (d.getTime() <= notime) {
                return date.dateFormat('D g:i a');
            }
            return date.dateFormat('n/j g:i a');
        }
        else {
            return date;
        }
    },

    formatTitle : function (value, p, record) {
        var link = record.data.link;
        var xf = Ext.util.Format;
        var author = (Ext.isEmpty(record.data.author)) ? "" : record.data.author;
        var dateFormat = this.formatDate(record.data.pubDate);
        var res = "";
        if (link !== undefined && link !== "") {
            res = String.format('<div class="topic"><a href="{0}" title="{1}" target="_blank"><span class="rss_feed_title">{2}</span></a><br/><span class="author">{3}</span></div>', link, value, 
                    xf.ellipsis(xf.stripTags(value), 50), author);
        } else {
            res = String.format('<div class="topic"><span class="rss_feed_title">{0}</span><br/><span class="author">{1}</span></div>', xf.ellipsis(xf.stripTags(value), 50), author);
        }
        if (dateFormat != "" && dateFormat != null ){
            res += String.format('<p id="feeds-date">{0}</p>', dateFormat);
        }
        return res;
    }, 
    
    imageRenderer : function (value, p, record) {
    	if (Ext.isEmpty(value) || Ext.isEmpty(record.data.imageType)) {
            return "";
        }
        if (record.data.imageType.substr(0, 5) != "image") {
        	return "";
        }
		return String.format('<img src="{0}" width="50px">', value);
    },
    
    sortByDate : function (direction){
        this.storeFeedsRecords.sort('pubDate', direction);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document*/
Ext.namespace('sitools.widget');

/**
 * Displays a grid of atom1 format feeds
 * @class sitools.widget.atom1FeedReader
 * @extends Ext.grid.GridPanel
 * @cfg {string} datasetId The Dataset id,
 * @cfg {string} urlFeed The url to request feed
 * @cfg {string} datasetName The dataset name
 * @cfg {string} feedSource
 * @cfg {boolean} autoLoad store configuration
 */
sitools.widget.atom1FeedReader = function (config) {
	Ext.apply(this);
	this.layout = "fit";
	this.storeFeedsRecords = new Ext.data.Store({
        autoLoad : true,
        sortInfo : {field : 'pubDate', direction : "DESC"},
	    proxy : new Ext.data.HttpProxy({
	        url : config.urlFeed,
	        restful : true,
            listeners : {
                scope : this,
                exception : onRequestFeedException
            }
	    // url : 'http://extjs.com/forum/external.php?type=RSS2'
	    }),
	    reader : new Ext.data.XmlReader({
            record : 'entry'
        }, [ 'title',
             {
                name : 'author', 
                mapping : "author.name"
             }, {
            name : 'pubDate',
            mapping : 'updated',
            type : 'date'
          }, {
              name : 'link',
              mapping: "link@href"
             },
             { 
                 name : 'description',
                 mapping : 'content'
             },
             'content',
        	{
               name : 'imageUrl',
            	createAccessor : function (data, field) {
            		var q = Ext.DomQuery;
            		// select node link with attribute type like image%
            		var node = q.selectNode("link[type^=image]", data);
            		var result = {};
            		if (Ext.isEmpty(node)) {
            			return result;
            		}
            		Ext.each(node.attributes, function (attribute) {
            			result[attribute.name] = attribute.value;
            		});
            		return result;
            	}
        	}
        ])

	});

	var columns = [ {
        id : 'image',
        header : "Image",
        dataIndex : 'imageUrl',
        sortable : false,
        width : 120
        ,
        renderer : this.imageRenderer
    }, {
        id : 'title',
        header : "Title",
        dataIndex : 'title',
        sortable : true,
        width : 460,
        scope : this,
        renderer : this.formatTitle
    }, {
        header : "Author",
        dataIndex : 'author',
        width : 100,
        hidden : true,
        sortable : true
    }, {
        id : 'last',
        header : "Date",
        dataIndex : 'pubDate',
        width : 150,
        renderer : this.formatDate,
        sortable : true,
        hidden : true
    } ];

	sitools.widget.atom1FeedReader.superclass.constructor.call(this, {
	    // height : 300,
	    columns : columns,
	    store : this.storeFeedsRecords,
	    loadMask : {
            msg : i18n.get("label.loadingFeed")
        },
	    sm : new Ext.grid.RowSelectionModel({
		    singleSelect : true
	    }),
	    autoExpandColumn : 'title',
	    hideHeaders : true,
	    viewConfig : {
	        forceFit : true,
	        enableRowBody : true,
	        showPreview : true,
	        getRowClass : this.applyRowClass
	    },
        listeners : config.listeners
	});
};

Ext.extend(sitools.widget.atom1FeedReader, Ext.grid.GridPanel, {
    /**
     * Load the feeds with the given url
     * @param {string} url
     */
    loadFeed : function (url) {
        this.store.baseParams = {
            feed : url
        };
        this.store.load();
    },

    /**
     * switch from preview to complete view
     * @param {boolean} show
     */
    togglePreview : function (show) {
        this.view.showPreview = show;
        this.view.refresh();
    },

    /**
     * override the method getRowClass 
     * @param {Record} record The {@link Ext.data.Record} corresponding to the current row.
     * @param {Number} index The row index.
     * @param {Object} rowParams A config object that is passed to the row template during rendering that allows
     * customization of various aspects of a grid row.
     * <p>If {@link #enableRowBody} is configured <b><tt></tt>true</b>, then the following properties may be set
     * by this function, and will be used to render a full-width expansion row below each grid row:</p>
     * <ul>
     * <li><code>body</code> : String <div class="sub-desc">An HTML fragment to be used as the expansion row's body content (defaults to '').</div></li>
     * <li><code>bodyStyle</code> : String <div class="sub-desc">A CSS style specification that will be applied to the expansion row's &lt;tr> element. (defaults to '').</div></li>
     * </ul>
     * The following property will be passed in, and may be appended to:
     * <ul>
     * <li><code>tstyle</code> : String <div class="sub-desc">A CSS style specification that willl be applied to the &lt;table> element which encapsulates
     * both the standard grid row, and any expansion row.</div></li>
     * </ul>
     * @param {Store} store The {@link Ext.data.Store} this grid is bound to
     */
    applyRowClass : function (record, rowIndex, p, ds) {
        if (this.showPreview) {
            var xf = Ext.util.Format;
            if (record.data.summary != "" && record.data.summary != undefined){
                p.body = '<p class=sous-titre-flux>' + xf.ellipsis(xf.stripTags(record.data.summary), 300) + '</p>';
                return 'x-grid3-row-expanded';
            }
        }
        return 'x-grid3-row-collapsed';
    },

    /**
     * Custom date format
     * @param {Date} date the input date
     * @return {String} the date formated
     */
    formatDate : function (date) {
        if (!date) {
            return '';
        }
        var now = new Date();
        var d = now.clearTime(true);
        if (date instanceof Date){
            var notime = date.clearTime(true).getTime();
            if (notime == d.getTime()) {
                return 'Today ' + date.dateFormat('g:i a');
            }
            d = d.add('d', -6);
            if (d.getTime() <= notime) {
                return date.dateFormat('D g:i a');
            }
            return date.dateFormat('n/j g:i a');
        }
        else {
            return date;
        }
    },

    /**
     * Custom renderer for title columns
     * @param {} value the value to format
     * @param {} p
     * @param {Ext.data.Record} record
     * @return {String} The title value formatted.
     */
    formatTitle : function (value, p, record) {
        var author = (record.data.author.name !== undefined) ? record.data.author.name : "";
        var link = record.data.link;
        var xf = Ext.util.Format;
        var dateFormat = this.formatDate(record.data.updated);
        var author = (record.data.author.name !== undefined) ? record.data.author.name : "";
        var authorEmail = (record.data.author.email !== undefined) ? record.data.author.email : "";
        var res = "";
        if (link !== undefined && link !== "") {
            res = String.format('<div class="topic"><a href="{0}" title="{1}" target="_blank"><span class="rss_feed_title">{2}</span></a><br/><span class="author">{3}</span></div>', link, value, 
                    xf.ellipsis(xf.stripTags(value), 50), author);
        } else {
            res = String.format('<div class="topic"><span class="rss_feed_title">{0}</span><br/><span class="author">{1}</span></div>', xf.ellipsis(xf.stripTags(value), 50), author);
        }
        if (dateFormat != "" && dateFormat != undefined ){
            res += String.format('<p id="feeds-date">{0}</p>', dateFormat);
        }
        return res;

    }, 
    imageRenderer : function (value, p, record) {
    	if (Ext.isEmpty(value) || Ext.isEmpty(value.href)) {
            return "";
        }
        if (value.type.substr(0, 5) != "image") {
        	return "";
        }
		return String.format('<img src="{0}" width="50px">', value.href);
    },
    
    sortByDate : function (direction){
        this.storeFeedsRecords.sort('pubDate', direction);
    }

});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n,document*/
Ext.namespace('sitools.widget');

/**
 * @param urlFeed :
 *            The feed URL
 */
sitools.widget.feedItemDetails = Ext.extend(Ext.Panel, {

    initComponent : function () {

        this.layout = "fit";

        var record = this.record;
        
        if (!Ext.isEmpty(record)) {
            
            this.store = new Ext.data.JsonStore({
                idProperty: 'title',
                fields: [
                    {name : 'title'},
                    {name : 'pubDate', type: 'date', dateFormat: 'timestamp'},
                    {name : 'published', type: 'date', dateFormat: 'timestamp'},
                    {name : 'author'}, 
                    {name : 'link'},
                    {name : 'description'},
                    {name : 'imageUrl'},
                    {name : 'image'}
                ],
                listeners : {
                    scope : this,
                    add : function (store, records, ind){
                        if (record.data.imageUrl == undefined && record.data.image != undefined){
                            record.data.image = record.data.imageUrl;
                        }
                        if (records[0].data.pubDate != ""){
                            records[0].data.pubDate = this.formatDate(records[0].data.pubDate);
                        }
                    }
                }
            });
            
            this.store.add(record);
            
            this.tpl = new Ext.XTemplate(
                    '<tpl for=".">',
                        '<div class="feed-article">',
                            '<tpl if="this.isDisplayable(imageUrl)">',
                                '<div class="feed-img">',
                                    '<img src="{imageUrl}" title="{title}" width="70" height="70"/>',
                                '</div>',
                            '</tpl>',
                            '<p class="feed-title"> {title} </p>',
                            '<tpl if="this.isDisplayable(pubDate)">',
                                '<div class="feed-date-detail">',
                                    '<b> Date : </b> {pubDate} ',
                                '</div>',
                            '</tpl>',
                            '<tpl if="this.isDisplayable(author)">',
                                '<div class="feed-author">',
                                    '<b> Author : </b> {author} ',
                                '</div>',
                            '</tpl>',
                            '<div class="feed-description">',
                                '{description}',
                            '</div>',
                            '<div class="feed-complementary">',
                                '<p style="padding-bottom: 3px;"> <b> Link : </b> <a href="{link}" target="_blank" title="{title}">{link}</a> </p>',
                                '<tpl if="this.isDisplayable(imageUrl)">',
                                    '<p> <b> Image Url : </b> <a href="{imageUrl}" target="_blank">{imageUrl}</a> </p>',
                                '</tpl>',
                            '</div>',
                        '</div>',
                    '</tpl>',
                    {
                        compiled : true,
                        isDisplayable : function (item) {
                            if (item != "" && item != undefined){
                                return true;
                            }
                            else {
                                return false;
                            }
                        }
                    }
            );
            
            this.feedsDataview = new Ext.DataView({
              id: 'detailFeed-view',
              autoScroll : true,
              layout: 'fit',
              store : this.store,
              tpl : this.tpl,
              cls : 'detailFeed-view',
              emptyText: i18n.get('label.nothingToDisplay')
            });

            this.componentType = 'feedDetails';
            this.items = [ this.feedsDataview ];
        }

        sitools.widget.feedItemDetails.superclass.initComponent.call(this);
    },
    
    formatDate : function (date) {
        if (!date) {
            return '';
        }
        var now = new Date();
        var d = now.clearTime(true);
        if (date instanceof Date){
            var notime = date.clearTime(true).getTime();
            if (notime == d.getTime()) {
                return 'Today ' + date.dateFormat('g:i a');
            }
            d = d.add('d', -6);
            if (d.getTime() <= notime) {
                return date.dateFormat('D g:i a');
            }
            return date.dateFormat('n/j g:i a');
        }
        else {
            return date;
        }
    }, 
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }
    
    
    
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext,window*/
function utils_logout(reload) {
    if (Ext.isEmpty(reload)) {
        reload = true;
    }
    Ext.util.Cookies.set('userLogin', '');
    Ext.util.Cookies.clear('userLogin');
    Ext.util.Cookies.set('hashCode', '');
    Ext.Ajax.defaultHeaders.Authorization = '';
    if (reload) {
        window.location.reload();
    }	
	    
}
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * global Ext, sitools, ID, i18n, document, showResponse, alertFailure, locale,
 * ImageChooser, showHelp, loadUrl, SitoolsDesk, projectGlobal, getDesktop
 */
Ext.namespace('sitools.user.desktop.navProfile');

/**
 * Object to expose methods in desktop Mode
 * 
 * @class sitools.user.desktop.navProfile.desktop
 * 
 */
sitools.user.desktop.navProfile.desktop = {
    /**
     * The name of the context
     */
    context : "desktop",
    /**
     * method called by SitoolsDesk. It should create all components in Sitools
     * except modules. the default comportement is create a new window in
     * desktop and add a taskButton in desktop TaskBar
     * 
     * @cfg {} componentCfg the component Configuration.
     * @cfg {} windowSettings the window Settings
     * @cfg {boolean} reloadComp true to rebuild component if exists
     * @cfg {string} JsObj The jsObject to instanciate.
     */
    createComponent : function (config) {
        var desktop = getDesktop();
        var componentCfg = config.componentCfg;
        var component = new config.JsObj(componentCfg);
        var windowSettings = config.windowSettings;
        // déléguer au composant l'ouverture
        if (Ext.isFunction(component.showMeInDesktopNav)) {
            component.showMeInDesktopNav(component, config);
            return;
        }

        var reloadComp = config.reloadComp;

        if (Ext.isEmpty(component._getSettings)) {
            component._getSettings = function () {
                return {};
            };
        }

        var newwin;
        var winHeight = windowSettings.winHeight || DEFAULT_WIN_HEIGHT;
        var winWidth = windowSettings.winWidth || DEFAULT_WIN_WIDTH;

        var x = windowSettings.x;
        var y = windowSettings.y;

        var desktopEl = getDesktop().getDesktopEl();

        if (x < desktopEl.dom.offsetLeft) {
            x = desktopEl.dom.offsetLeft;
        }
        if (y < desktopEl.dom.offsetTop) {
            y = desktopEl.dom.offsetTop;
        }
        if (x + winWidth > desktopEl.dom.offsetLeft + desktopEl.dom.offsetWidth) {
            winWidth = desktopEl.dom.offsetLeft + desktopEl.dom.offsetLeft - x;
        }
        if (y + winHeight > desktopEl.dom.offsetTop + desktopEl.dom.offsetHeight) {
            winHeight = desktopEl.dom.offsetTop + desktopEl.dom.offsetHeight - y;
        }

        var tbar;
        if (!Ext.isEmpty(windowSettings.toolbarItems)) {
            // Create the toolbar with the windowSettings.toolbarItems
            tbar = new Ext.Toolbar({
                xtype : 'toolbar',
                items : windowSettings.toolbarItems,
                cls : 'toolbar'
            });
        }

        var fileName = "";
        var title = windowSettings.title;
        if (windowSettings.type === "form") {
            fileName = windowSettings.type + componentCfg.formName;
        } else if (windowSettings.type === "data" && Ext.isDefined(component.getWindowTitle)) {
            title = component.getWindowTitle(windowSettings.datasetDescription, windowSettings.datasetName);
        } else {
            fileName = windowSettings.type;
        }

        var winListeners = {};
        Ext.apply(winListeners, windowSettings.listeners);
        Ext.apply(winListeners, {
            render : function (me) {
                me.getEl().fadeIn({
                    duration : .5
                });
            }
        });

        newwin = desktop.createWindow({
            id : windowSettings.id,
            stateful : false,
            title : title,
            width : winWidth,
            iconCls : windowSettings.iconCls,
            height : winHeight,
            shim : false,
            tbar : tbar,
            animCollapse : false,
            x : x,
            y : y,
            constrainHeader : true,
            layout : 'fit',
            specificType : 'componentWindow',
            datasetName : windowSettings.datasetName,
            datasetDescription : windowSettings.datasetDescription,
            fileName : fileName,
            component : component,
            autoscroll : true,
            typeWindow : windowSettings.type,
            maximized : windowSettings.maximized,
            listeners : winListeners,
            tools : [ {
                id : "save",
                scope : this,
                qtip : i18n.get('label.saveSettings'),
                handler : function (event, toolEl, window) {
                    if (projectGlobal.isAdmin) {
                        var ctxMenu = new Ext.menu.Menu({
                            items : [ '<b class="menu-title">' + i18n.get('label.chooseSave') + '</b>', {
                                text : i18n.get("label.myself"),
                                handler : function () {
                                    window.saveSettings(window.component._getSettings(), false);
                                }
                            }, {
                                text : i18n.get("label.publicUser"),
                                handler : function () {
                                    window.saveSettings(window.component._getSettings(), true);
                                }
                            } ]
                        });
                        ctxMenu.showAt(event.getXY());

                    } else {
                        window.saveSettings(window.component._getSettings());
                    }
                },
                hidden : Ext.isEmpty(userLogin) || !windowSettings.saveToolbar
            } ]
        });
        var pos, size;

        pos = windowSettings.position;
        size = windowSettings.size;
        if (size !== null) {
            size = Ext.decode(size);
            newwin.setSize(size);
        } else {
            size = newwin.getSize();
            size.width = size.width + 1;

            newwin.setSize(size);
        }
        newwin.show();

        newwin.add(component);

        if (!Ext.isEmpty(pos)) {
            pos = Ext.decode(pos);
            newwin.setPosition(pos);
        }

        // Permet d'ajuster les fenêtres qui sont maximisées à l'espace du
        // bureau
        if (SitoolsDesk.desktopMaximizeMode) {
            SitoolsDesk.getDesktop().minimize();
            SitoolsDesk.getDesktop().maximize();
        } else {
            SitoolsDesk.getDesktop().maximize();
            SitoolsDesk.getDesktop().minimize();
        }

        newwin.doLayout();
    },
    /**
     * method called by SitoolsDesk. It should create all modules in Sitools.
     * the default comportement is create a new window in desktop.
     * 
     * @param {}
     *            The module description
     * @returns {Ext.app.Module} the created window.
     */
    openModule : function (module) {
        var desktop = getDesktop();

        var win = desktop.getWindow(module.id);
        if (!win) {

            win = desktop.createWindow({
                id : module.id,
                stateful : false,
                title : i18n.get(module.title),
                width : module.defaultWidth,
                height : module.defaultHeight,
                iconCls : module.icon,
                x : module.x,
                y : module.y,
                shim : false,
                animCollapse : false,
                constrainHeader : true,
                layout : 'fit',
                specificType : "moduleWindow",
                listeners : {
                    render : function (me) {
                        me.getEl().fadeIn({
                            duration : 0.5
                        });
                    }
                },
                items : [ {
                    id : module.id + "_module",
                    noBorder : true,
                    layout : 'fit',
                    xtype : module.xtype,
                    moduleProperties : module.properties,
                    listProjectModulesConfig : module.listProjectModulesConfig
                } ]
            });
            if (!Ext.isEmpty(projectGlobal.preferences)) {
                Ext.each(projectGlobal.preferences.windowSettings, function (preference) {
                    if (preference.windowSettings.moduleId == module.id) {
                        if (preference.windowSettings.maximized) {
                            win.minimize();
                            win.maximize();
                        } else {
                            var pos = preference.windowSettings.position;
                            var size = preference.windowSettings.size;

                            if (pos !== null && size !== null) {
                                pos = Ext.decode(pos);
                                size = Ext.decode(size);

                                win.setPosition(pos);
                                win.setSize(size);
                            }

                        }
                    }
                });
            }

        } else {
            desktop.getManager().bringToFront(win);
        }

        win.show();
        return win;
    },

    /**
     * Do nothing in fixed mode
     */
    initNavbar : function () {
        return;
    },

    /**
     * Specific multiDataset search context methods
     */
    multiDataset : {
        /**
         * Returns the right object to show multiDs results
         * 
         * @returns
         */
        getObjectResults : function () {
            return sitools.user.component.forms.resultsProjectForm;
        },
        /**
         * Handler of the button show data in the
         * {sitools.user.component.forms.resultsProjectForm} object
         * 
         * @param {Ext.grid.GridPanel}
         *            grid the grid results
         * @param {int}
         *            rowIndex the index of the clicked row
         * @param {int}
         *            colIndex the index of the column
         * @returns
         */
        showDataset : function (grid, rowIndex, colIndex) {
            var rec = grid.getStore().getAt(rowIndex);
            if (Ext.isEmpty(rec)) {
                return;
            }
            if (rec.get('status') == "REQUEST_ERROR") {
                return;
            }
            sitools.user.clickDatasetIcone(rec.get("url"), "data", {
                formMultiDsParams : this.formMultiDsParams
            });
        }
    },
    taskbar : {
        getContextMenuItems : function () {
            return [ {
                text : 'Restore',
                handler : function () {
                    if (!this.win.isVisible()) {
                        this.win.show();
                    } else {
                        this.win.restore();
                    }
                },
                scope : this
            }, {
                text : 'Minimize',
                handler : this.win.minimize,
                scope : this.win
            }, {
                text : 'Maximize',
                handler : this.win.maximize,
                scope : this.win
            }, '-', {
                text : 'Close',
                handler : this.closeWin.createDelegate(this, this.win, true),
                scope : this.win
            } ];

        },
        handleTaskButton : function (btn) {
            var win = btn.win;
            if (win.minimized || win.hidden) {
                win.show();
            } else if (win == win.manager.getActive()) {
                win.minimize();
            } else {
                win.toFront();
            }
        },
        closeWin : function (cMenu, e, win) {
            if (!win.isVisible()) {
                win.show();
            } else {
                win.restore();
            }
            win.close();
        },
        beforeShowCtxMenu : function () {
            var items = this.cmenu.items.items;
            var w = this.win;
            items[0].setDisabled(w.maximized !== true && w.hidden !== true);
            items[1].setDisabled(w.minimized === true);
            items[2].setDisabled(w.maximized === true || w.hidden === true);
        },
        /**
         * Add home and remove panel button to taskbar in desktop mode
         */
        initTaskbar : function () {
            SitoolsDesk.getDesktop().taskbar.setEnableWarning(false);
            var showDesktopButton = new Ext.Button({
                action : "minimize",
                handler : function (btn) {
                    if (btn.action === "minimize") {
                        SitoolsDesk.minifyAllWindows();
                        btn.action = "maximize";
                    } else {
                        SitoolsDesk.openAllWindows();
                        btn.action = "minimize";
                    }
                },
                scale : "medium",
                tooltip : {
                    html : i18n.get("label.showDesktopButton"),
                    anchor : 'bottom',
                    trackMouse : false
                },
                template : new Ext.Template('<table cellspacing="0" class="x-btn {3}"><tbody><tr>', '<td><em class="{5} unselectable="on">',
                        '<button type="{1}" id="btn-showDesk" style="height:29px; width:18px;">{0}</button>', '</em></td>', '<td><i>&#160;</i></td>',
                        "</tr></tbody></table>")
            });
            var removeActivePanel = new Ext.Button({
                scope : this,
                handler : function () {
                    SitoolsDesk.removeAllWindows();
                },
                scale : "medium",
                icon : "/sitools/common/res/images/taskbar/black/close-icon.png",
                iconCls : 'taskbarButtons-icon',
                tooltip : {
                    html : i18n.get('label.removeActiveModule'),
                    anchor : 'bottom',
                    trackMouse : false
                },
                template : new Ext.Template('<table cellspacing="0" class="x-btn {3}" style="padding-left: 25px;"><tbody><tr>', '<td><i>&#160;</i></td>',
                        '<td><em class="{5} unselectable="on">', '<button type="{1}" style="height:28px; width:28px; padding-left:12px;">{0}</button>',
                        '</em></td>', '<td><i>&#160;</i></td>', "</tr></tbody></table>")

            });
            SitoolsDesk.getDesktop().taskbar.staticButtonPanel.addStaticButton(showDesktopButton);
            SitoolsDesk.getDesktop().taskbar.staticButtonPanel.addStaticButton(removeActivePanel);
        }
    },

    /**
     * @return the specific JS View to display form
     */
    getFormOpenMode : function () {
        return sitools.user.component.forms.mainContainer;
    },

    /**
     * @return the specific JS View to display dataset
     */
    getDatasetOpenMode : function (dataset) {
        return dataset.datasetView.jsObject;
    },

    /**
     * @param componentCfg
     *            the component to add the property
     * @param dataset
     *            the object which contains properties to add
     * @return the component with the new properties
     */
    addSpecificFormParameters : function (componentCfg, dataset) {
        return componentCfg;
    },

    /**
     * Add specifics columns to project graph module in function of the
     * navigation mode
     * 
     * @param columnsModel
     *            the columns to display in project graph module
     * @return the coumns with specifics columns added (or not)
     */
    manageProjectGraphColumns : function (columnsModel) {
        return columnsModel.push({
            width : 90,
            header : Ext.util.Format.ellipsis(i18n.get("label.forms"), 12),
            // cls : "grid-column-color",
            tpl : new Ext.XTemplate('{[datasetId=""]}', '<tpl if="this.exists(datasetId) && authorized==\'true\'">{url:this.getIcone}</tpl>', {
                exists : function (o) {
                    return typeof o !== 'undefined' && o !== null && o !== '';
                },
                getIcone : function (value) {
                    return "<a href='#' onClick='sitools.user.clickDatasetIcone(\"" + value + "\", \"forms\"); return false;'><img src='"
                            + loadUrl.get('APP_URL') + "/common/res/images/icons/form_list_small.png'></img></a>";
                },
                // XTemplate configuration:
                compiled : true,
                disableFormats : false
            }),
            align : 'center'
        });
    },

    /**
     * Add icon form to datasetView Album depending to navigation mode
     * 
     * @param value
     * @return nu
     */
    manageDatasetViewAlbumIconForm : function (value) {
        return "<a href='#' onClick='sitools.user.clickDatasetIcone(\"" + value + "\", \"forms\"); return false;'><img src='" + loadUrl.get('APP_URL')
                + "/common/res/images/icons/32x32/form_list_32.png'></a>";
    },

    /**
     * Add icon definition and form to dataset Explorer depending to navigation
     * mode
     * 
     * @param commonTreeUtils
     */
    manageDatasetExplorerShowDefinitionAndForms : function (commonTreeUtils, node, dataset) {
        commonTreeUtils.addShowDefinition(node, dataset);
        commonTreeUtils.addForm(node, dataset);

        return commonTreeUtils;
    },
    /**
     * Called when desktop is saved. Loop through all windows of the desktop and
     * save settings for each window.
     * 
     * @param forPublicUser
     * @returns {Array} an Array containing all window settings
     */
    getDesktopSettings : function (forPublicUser) {
        var desktopSettings = [];
        getDesktop().getManager().each(function (window) {
            var componentSettings;
            if (!Ext.isEmpty(window.specificType) && (window.specificType === 'componentWindow' || window.specificType === 'moduleWindow')) {
                // Bug 3358501 : add a test on Window.saveSettings.
                if (Ext.isFunction(window.saveSettings)) {
                    var component = window.get(0);

                    componentSettings = component._getSettings();
                    desktopSettings.push(window.saveSettings(componentSettings, forPublicUser));
                }
            }
        });
        return desktopSettings;
    },
    /**
     * Load the module Window corresponding to the project Preference. 1 - load
     * the module Windows 2 - load the Component windows (actually only "data",
     * "form" && "formProject" type window)
     */
    loadPreferences : function (scope) {
        // Chargement des composants ouverts.
        Ext.each(projectGlobal.preferences.windowSettings, function (pref) {
            // 1° cas : les fenêtres de modules
            if (Ext.isEmpty(pref.windowSettings.typeWindow)) {
                var moduleId = pref.windowSettings.moduleId;

                var module = SitoolsDesk.app.getModule(moduleId);
                if (!Ext.isEmpty(module) && Ext.isEmpty(module.divIdToDisplay)) {
                    var win = module.openModule();
                    var pos = pref.windowSettings.position;
                    var size = pref.windowSettings.size;

                    // TODO, refactoring, set size in openmodule method.... like
                    // for typeWindow=data (dataset window)
                    if (pos !== null && size !== null) {
                        pos = Ext.decode(pos);
                        size = Ext.decode(size);

                        win.setPosition(pos[0], pos[1]);
                        win.setSize(size);

                        getDesktop().layout();
                    }
                }
            }
            // les autres fenêtres : on nne traite que les cas
            // windowSettings.typeWindow == "data"
            else {
                var type = pref.windowSettings.typeWindow;
                var componentCfg, jsObj, windowSettings;
                if (type === "data") {
                    var datasetUrl = pref.componentSettings.datasetUrl;
                    Ext.Ajax.request({
                        method : "GET",
                        url : datasetUrl,
                        success : function (ret) {
                            var Json = Ext.decode(ret.responseText);
                            if (showResponse(ret)) {
                                var dataset = Json.dataset;
                                var componentCfg, javascriptObject;
                                var windowConfig = {
                                    datasetName : dataset.name,
                                    datasetDescription : dataset.description,
                                    type : type,
                                    saveToolbar : true,
                                    toolbarItems : [],
                                    iconCls : "dataviews"
                                };

                                javascriptObject = eval(dataset.datasetView.jsObject);

                                // add the toolbarItems configuration
                                Ext.apply(windowConfig, {
                                    id : type + dataset.id
                                });

                                if (dataset.description !== "") {
                                    windowConfig.title = dataset.description;
                                } else {
                                    windowConfig.title = "Diplay data :" + dataset.name;
                                }
                                componentCfg = {
                                    dataUrl : dataset.sitoolsAttachementForUsers,
                                    datasetId : dataset.id,
                                    datasetCm : dataset.columnModel,
                                    datasetName : dataset.name,
                                    datasetViewConfig : dataset.datasetViewConfig,
                                    dictionaryMappings : dataset.dictionaryMappings,
                                    preferencesPath : "/" + dataset.name,
                                    preferencesFileName : "datasetOverview"
                                };
                                SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);

                            }
                        },
                        failure : alertFailure
                    });
                }
                if (type === "formProject") {
                    jsObj = sitools.user.component.forms.projectForm;
                    componentCfg = {
                        formId : pref.componentSettings.formId,
                        formName : pref.componentSettings.formName,
                        formParameters : pref.componentSettings.formParameters,
                        formWidth : pref.componentSettings.formWidth,
                        formHeight : pref.componentSettings.formHeight,
                        formCss : pref.componentSettings.formCss,
                        properties : pref.componentSettings.properties,
                        urlServicePropertiesSearch : pref.componentSettings.urlServicePropertiesSearch,
                        urlServiceDatasetSearch : pref.componentSettings.urlServiceDatasetSearch,
                        preferencesPath : pref.componentSettings.preferencesPath,
                        preferencesFileName : pref.componentSettings.preferencesFileName,
                        formZones : pref.componentSettings.formZones
                    };
                    windowSettings = {
                        type : "formProject",
                        title : i18n.get('label.forms') + " : " + pref.componentSettings.formName,
                        id : "formProject" + pref.componentSettings.formId,
                        saveToolbar : true,
                        datasetName : pref.componentSettings.formName,
                        winWidth : 600,
                        winHeight : 600,
                        iconCls : "form"
                    };
                    SitoolsDesk.addDesktopWindow(windowSettings, componentCfg, jsObj);

                }
                if (type === "form") {
                    jsObj = sitools.user.component.forms.mainContainer;
                    componentCfg = {
                        dataUrl : pref.componentSettings.dataUrl,
                        dataset : pref.componentSettings.dataset,
                        formId : pref.componentSettings.formId,
                        formName : pref.componentSettings.formName,
                        formParameters : pref.componentSettings.formParameters,
                        formZones : pref.componentSettings.zones,
                        formWidth : pref.componentSettings.formWidth,
                        formHeight : pref.componentSettings.formHeight,
                        formCss : pref.componentSettings.formCss,
                        preferencesPath : pref.componentSettings.preferencesPath,
                        preferencesFileName : pref.componentSettings.preferencesFileName
                    };

                    windowSettings = {
                        datasetName : pref.componentSettings.dataset.name,
                        type : "form",
                        title : i18n.get('label.forms') + " : " + pref.componentSettings.dataset.name + "." + pref.componentSettings.formName,
                        id : "form" + pref.componentSettings.dataset.id + pref.componentSettings.formId,
                        saveToolbar : true,
                        iconCls : "form"
                    };
                    SitoolsDesk.addDesktopWindow(windowSettings, componentCfg, jsObj);
                }
            }
        }, scope);

    },

    /**
     * Close every window in desktop mode.
     */
    removeAllWindows : function () {
        SitoolsDesk.getDesktop().getManager().each(function (win) {
            win.close();
        });
    },

    /**
     * Close the passed window in desktop mode.
     */
    removeWindow : function (win) {
        win.close();
    }
};
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, locale, ImageChooser, 
 showHelp, loadUrl*/
Ext.namespace('sitools.user.desktop.navProfile');

/**
 * Object to expose methods in fixed Mode
 * @class sitools.user.desktop.navProfile.fixed
 * 
 */
sitools.user.desktop.navProfile.fixed = {
    /**
     * The name of the context
     */
    context : "fixed", 
    /**
     * method called by SitoolsDesk. 
     * It should create all components in Sitools except modules. 
     * the default comportement is create a new panel in desktop. 
     * @cfg {} componentCfg the component Configuration. 
     * @cfg {} windowSettings the window Settings (contains the title)
     * @cfg {boolean} reloadComp not used in this context
     * @cfg {string} JsObj The jsObject to instanciate. 
     */
    createComponent : function (config) {
        var component = new config.JsObj(config.componentCfg);
        var windowSettings = config.windowSettings;
        
        //déléguer au composant l'ouverture
        if (Ext.isFunction(component.showMeInFixedNav)) {
            component.showMeInFixedNav(component, config);
            return;
        }
        
        SitoolsDesk.removeActivePanel();
        var desktop = getDesktop();
        
        var desktopEl = desktop.getDesktopEl();
        Ext.apply(component, {
            height : desktopEl.getHeight()
        });
        
       
        desktop.activePanel = desktop.createPanel({
            title : windowSettings.title, 
            border : false, 
//          cls : "sitools-module-panel", 
            layout : 'fit', 
            height : desktop.getDesktopEl().getHeight(), 
            width : desktop.getDesktopEl().getWidth(), 
            iconCls : windowSettings.iconCls,
            renderTo : desktop.getDesktopEl(), 
            noBorder : true, 
            items : [component], 
            type : windowSettings.type,
            specificType : "component",
            listeners : {
                render : function (me){
                    me.getEl().fadeIn({
                        duration: .5
                    });
                }, 
                resizeDesktop : function (me) {
                    me.setSize(desktop.getDesktopEl().getSize());
                    
                    var child = me.items.items[0];
                    if (child && child.getEl()) {
                        child.fireEvent("resize", child, me.body.getWidth(), me.body.getHeight(), child.getWidth(), child.getHeight());
                    }
                }, 
                maximizeDesktop : function (me) {
                    me.fireEvent("resize", me);
                }, 
                minimizeDesktop : function (me) {
                    me.fireEvent("resize", me);
                }
            }
            
        });
//        SitoolsDesk.addToHistory(desktop.activePanel);
        
    }, 
    /**
     * method called by SitoolsDesk. 
     * It should create all modules in Sitools. 
     * the default comportement is create a new panel in desktop.
     * @param {} The module description
     * @returns {Ext.app.Module} the created panel. 
     */
    openModule : function (module) {
        var desktop = getDesktop();
        SitoolsDesk.removeActivePanel();
        //Minimiser toutes les fenêtres actives ou les détruire si elles ne peuvent pas être minimisées.
        SitoolsDesk.minifyAllWindows();
        
        var panelToOpen = Ext.getCmp(module.id);
        if (panelToOpen) {
            panelToOpen.setSize(SitoolsDesk.getDesktop().getDesktopEl().getSize());
            SitoolsDesk.getDesktop().activePanel = panelToOpen;
            panelToOpen.show();
            return panelToOpen;
        }
        
        desktop.activePanel = desktop.createPanel({
            id : module.id,
            border : false, 
            title : i18n.get(module.title), 
            cls : "sitools-module-panel", 
            layout : 'fit', 
            specificType : "module", 
            iconCls : module.icon,
            height : desktop.getDesktopEl().getHeight(), 
            width : desktop.getDesktopEl().getWidth(), 
            renderTo : desktop.getDesktopEl(), 
            noBorder : true, 
            items : [ {
                noBorder : true, 
                layout : 'fit',
                xtype : module.xtype, 
                moduleProperties : module.properties,
                listProjectModulesConfig : module.listProjectModulesConfig
            }], 
            listeners : {
                render : function (me){
                    me.getEl().fadeIn({
                        duration: .5
                    });
                }, 
                resizeDesktop : function (me) {
                    me.setSize(desktop.getDesktopEl().getSize());
                    
                    var child = me.items.items[0];
                    if (child && child.getEl()) {
                        child.fireEvent("resize", child, me.body.getWidth(), me.body.getHeight(), child.getWidth(), child.getHeight());
                    }
                }, 
                maximizeDesktop : function (me) {
                    me.fireEvent("resize", me);
                }, 
                minimizeDesktop : function (me) {
                    me.fireEvent("resize", me);
                }
            }
            
        });
//        SitoolsDesk.addToHistory(desktop.activePanel);
        return desktop.activePanel;
        
    },
    
    /**
     * Specific multiDataset search context methods
     */
    multiDataset : {
        /**
         * Returns the right object to show multiDs results
         * @returns
         */
        getObjectResults : function () {
            return sitools.user.component.forms.overviewResultsProjectForm;
        }, 
        /**
         * Handler of the button show data in the {sitools.user.component.forms.resultsProjectForm} object 
         * @param {Ext.grid.GridPanel} grid the grid results
         * @param {int} rowIndex the index of the clicked row
         * @param {int} colIndex the index of the column
         * @returns
         */
        showDataset : function (grid, rowIndex, colIndex) {
            var rec = grid.getStore().getAt(rowIndex);
            if (Ext.isEmpty(rec)) {
                return;
            }
            if (rec.get('status') == "REQUEST_ERROR") {
                return;
            }
            
            Ext.Ajax.request({
                method : "GET", 
                url : rec.get('url'), 
                scope : this, 
                success : function (ret) {
                    var Json = Ext.decode(ret.responseText);
                    if (showResponse(ret)) {
                        var dataset = Json.dataset;
                        var componentCfg, JsObj;
                        
                        JsObj = eval(dataset.datasetView.jsObject);
                        componentCfg = {
                            title : dataset.name, 
                            closable : true, 
                            dataUrl : dataset.sitoolsAttachementForUsers,
                            datasetId : dataset.Id,
                            datasetCm : dataset.columnModel, 
                            datasetName : dataset.name,
                            dictionaryMappings : dataset.dictionaryMappings,
                            datasetViewConfig : dataset.datasetViewConfig, 
                            sitoolsAttachementForUsers : dataset.sitoolsAttachementForUsers, 
                            formMultiDsParams : this.formMultiDsParams
                        };
                        var dataview = new JsObj(componentCfg);
                        
                        this.ownerCt.southPanel.add(dataview);
                        this.ownerCt.southPanel.setVisible(true);
                        this.ownerCt.southPanel.expand();
                        this.ownerCt.southPanel.setActiveTab(this.ownerCt.southPanel.items.length - 1);
                        this.ownerCt.doLayout();
                    }
                }, 
                failure : alertFailure
            });

        }
        
    },
    taskbar : {
        getContextMenuItems : function () {
            return [ {
                text : 'Close',
                handler : this.closeWin.createDelegate(this, this.win, true),
                scope : this.win
            } ];
        
        }, 
        handleTaskButton : function (btn, event) {
            var panel = btn.win;
            SitoolsDesk.removeActivePanel();
            panel.setSize(SitoolsDesk.getDesktop().getDesktopEl().getSize());
            SitoolsDesk.getDesktop().activePanel = panel;
            panel.show();
        }, 
        closeWin : function (cMenu, e, win) {
            var tb = getDesktop().taskbar;
            if (getDesktop().activePanel == win) {
                SitoolsDesk.removeActivePanel();
            }
            var btn = win.taskButton;
            var btnToActive = tb.getPreviousBtn(btn) || tb.getNextBtn(btn);
            if (btnToActive) {
                SitoolsDesk.navProfile.taskbar.handleTaskButton.call(this, btnToActive);
            }
            
            win.destroy();
            tb.removeTaskButton(btn);
        }, 
        beforeShowCtxMenu : function () {
            return true;

        }, 


        initTaskbar : function () {
            SitoolsDesk.getDesktop().taskbar.setEnableWarning(true); 
            var removeActivePanel = new Ext.Button({
                scope : this, 
                handler : function () {
                    SitoolsDesk.removeAllWindows(false);
                },
                scale : "medium", 
                icon : "/sitools/common/res/images/taskbar/black/close-icon.png", 
                iconCls : 'taskbarButtons-icon',
                tooltip : {
                    html : i18n.get('label.removeAllPanels'), 
                    anchor : 'bottom', 
                    trackMouse : false
                }, 
                template : new Ext.Template('<table cellspacing="0" style="padding-right:0px;" class="x-btn {3}"><tbody><tr>',
                        '<td><i>&#160;</i></td>',
                        '<td><em class="{5} unselectable="on">',
                        '<button type="{1}" style="height:28px; width:28px;">{0}</button>', '</em></td>',
                        '<td><i>&#160;</i></td>', "</tr></tbody></table>")

            });
            var previous = new Ext.Button({
                scope : this, 
                handler : function () {
                    var tb = SitoolsDesk.getDesktop().taskbar;
                    var activeBtn = tb.getActiveButton();
                    var btnToActive = tb.getPreviousBtn(activeBtn);
                    if (btnToActive) {
                        SitoolsDesk.navProfile.taskbar.handleTaskButton.call(this, btnToActive);
                    }
                }, 
                scale : "medium", 
                icon : "/sitools/common/res/images/taskbar/black/arrow-left-black.png", 
                iconCls : 'taskbarButtons-icon',
                tooltip : {
                    html : i18n.get('label.previous'), 
                    anchor : 'bottom', 
                    trackMouse : false
                }, 
                template : new Ext.Template('<table cellspacing="0" style="padding-right:0px;" class="x-btn {3}"><tbody><tr>',
                        '<td><i>&#160;</i></td>',
                        '<td><em class="{5} unselectable="on">',
                        '<button type="{1}" style="height:28px; width:28px;">{0}</button>', '</em></td>',
                        '<td><i>&#160;</i></td>', "</tr></tbody></table>")

            });
            var next = new Ext.Button({
                scope : this, 
                handler : function () {
                    var tb = SitoolsDesk.getDesktop().taskbar;
                    var activeBtn = tb.getActiveButton();
                    var btnToActive = tb.getNextBtn(activeBtn);
                    if (btnToActive) {
                        SitoolsDesk.navProfile.taskbar.handleTaskButton.call(this, btnToActive);
                    }
                }, 
                scale : "medium", 
                icon : "/sitools/common/res/images/taskbar/black/arrow-right-black.png", 
                iconCls : 'taskbarButtons-icon',
                tooltip : {
                    html : i18n.get('label.next'), 
                    anchor : 'bottom', 
                    trackMouse : false
                }, 
                template : new Ext.Template('<table cellspacing="0" style="padding-right:0px;" class="x-btn {3}"><tbody><tr>',
                        '<td><i>&#160;</i></td>',
                        '<td><em class="{5} unselectable="on">',
                        '<button type="{1}" style="height:28px; width:28px;">{0}</button>', '</em></td>',
                        '<td><i>&#160;</i></td>', "</tr></tbody></table>")

            });

            SitoolsDesk.getDesktop().taskbar.staticButtonPanel.addStaticButton(previous);
            SitoolsDesk.getDesktop().taskbar.staticButtonPanel.addStaticButton(next);
            SitoolsDesk.getDesktop().taskbar.staticButtonPanel.addStaticButton(removeActivePanel);
        }
    },
    
    /**
     * Add home and remove panel button to navbar in fixed mode
     */
    initNavbar : function () {
        return;
    },
    
    /**
     * @return the specific JS View to display form
     */
    getFormOpenMode : function (){
        return sitools.user.component.DatasetOverview;
    },
    
    /**
     * @return the specific JS View to display dataset
     */
    getDatasetOpenMode : function (dataset){
        return sitools.user.component.DatasetOverview;
    },
    
    /**
     * @param componentCfg
     *      the component to add the property
     * @param dataset
     *      the object which contains properties to add
     * @return the component with the new properties
     */
    addSpecificFormParameters : function (componentCfg, dataset){
        componentCfg.sitoolsAttachementForUsers = dataset.sitoolsAttachementForUsers;
        return componentCfg;
    },
    
    /**
     * Add specifics columns to project graph module
     *  in function of the navigation mode
     * 
     * @param columnsModel
     *          the columns to display in project graph module
     * @return the coumns with specifics columns added (or not)
     */
    manageProjectGraphColumns : function (columnsModel) {
       return columnsModel;
    },
    
    /**
     * Add icon form to datasetView Album depending to navigation mode
     * 
     * @param value
     * @return nu
     */
    manageDatasetViewAlbumIconForm : function (value){
        return null;
        return "<a href='#' onClick='sitools.user.clickDatasetIcone(\"" + value
        + "\", \"forms\"); return false;'><img src='" + loadUrl.get('APP_URL')
        + "/common/res/images/icons/form_list_small.png'></a>";
    },
    
    /**
     * Add icon definition to dataset Explorer depending to navigation mode
     * @param commonTreeUtils
     */
    manageDatasetExplorerShowDefinitionAndForms : function (commonTreeUtils, node, dataset){
        return;
    }, 
    /**
     * Called when desktop is saved. 
     * Add the active panel id to the desktopSettings 
     * @param forPublicUser
     * @returns {Array} an array containing the activePanelId. 
     */
    getDesktopSettings : function (forPublicUser) {
        var windowSettings = {}, activePanel = getDesktop().activePanel;
        if (activePanel) {
            if (activePanel.specificType === 'module') {
                windowSettings = {
                    activeModuleId : activePanel.id,
                    specificType : 'module'
                };
            } else {
                //get the component, first item of the activePanel
                var component = activePanel.getComponent(0);                    
                componentSettings = component._getSettings();
                windowSettings = {
                    componentSettings : componentSettings,
                    specificType : 'component',
                    type : activePanel.type
                };
                                
            }
        }
        return windowSettings;
    }, 
    /**
     * Load the module Window corresponding to the project Preference. 
     * 1 - load the module Windows
     */
    loadPreferences : function (scope) {
        //Chargement du composant ouvert.
        var pref = projectGlobal.preferences.windowSettings; 
        if (pref.specificType == "module") {
            var module = SitoolsDesk.app.getModule(pref.activeModuleId);
            if (!Ext.isEmpty(module) && Ext.isEmpty(module.divIdToDisplay)) {
                module.openModule();
            }
        } else {
//            var type = pref.type;
            
            // En mode fixed, on n'ouvre jamais des data directement, passe toujours pas form
            
//            var type = "form";
            var type = pref.type;
            var jsObj = sitools.user.component.DatasetOverview;
            
            if (type === "form" || type === "data") {
                var componentCfg = {
                    dataUrl : pref.componentSettings.dataUrl,
                    dataset : pref.componentSettings.dataset, 
                    formId : pref.componentSettings.formId,
                    formName : pref.componentSettings.formName,
                    formParameters : pref.componentSettings.formParameters,
                    formWidth : pref.componentSettings.formWidth,
                    formHeight : pref.componentSettings.formHeight, 
                    formCss : pref.componentSettings.formCss, 
                    preferencesPath : pref.componentSettings.preferencesPath,
                    activeTab : pref.componentSettings.formsActivePanel,
                    customFormWidth : pref.componentSettings.formsPanelWidth,
                    preferencesFileName : pref.componentSettings.preferencesFileName
                };

                componentCfg.sitoolsAttachementForUsers = pref.componentSettings.sitoolsAttachementForUsers;

                var title;
                if (!Ext.isEmpty(pref.componentSettings.formId)) {
                    title = i18n.get('label.forms') + " : " + pref.componentSettings.datasetName + "." + pref.componentSettings.formName;                     
                } else {
                    title = i18n.get('label.dataTitle') + " : " + pref.componentSettings.datasetName;                    
                }                
                
                var windowSettings = {
                    datasetName : pref.componentSettings.datasetName, 
                    type : type, 
                    title :  title,
                    id : type + pref.componentSettings.datasetId, 
                    saveToolbar : true, 
                    iconCls : "form"
                };  
                SitoolsDesk.addDesktopWindow(windowSettings, componentCfg, jsObj);
            }
        }
    },
    
    /**
     * Close every panel in fixed mode. 
     */
    removeAllWindows : function (quietParam) {
        var quiet = Ext.isEmpty(quietParam) ? true : quietParam;
        var btns = SitoolsDesk.getDesktop().taskbar.getAllTaskButtons();
        if (Ext.isEmpty(btns) && !quiet) {
            var tmp = new Ext.ux.Notification({
                iconCls : 'x-icon-information',
                title : i18n.get('label.information'),
                html : i18n.get("label.desktopAlreadyEmpty"),
                autoDestroy : true,
                hideDelay : 1000
            }).show(document);
            return;
        }
        Ext.each(btns, function (btn) {
            SitoolsDesk.navProfile.taskbar.closeWin(null, null, btn.win);
        });
    },
    
    /**
     * Close the passed window in desktop mode. 
     */
    removeWindow : function (win) {
        win.destroy();
    }
    
};
/***************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * SITools2 is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/*global alertFailure, showResponse, loadUrl, showVersion, userPreferences:true, modulesExistants:true, utils_logout, sitools, userStorage, publicStorage, DEFAULT_PREFERENCES_FOLDER, 
 getDesktop, Ext, window, i18n, SitoolsDesk, userLogin, projectGlobal, createModule, sql2ext, dules, DEFAULT_WIN_HEIGHT, DEFAULT_WIN_WIDTH, 
 loadPreferences, getConfigAndCreateModule, desktopReady, publicStorage, document, locale*/
/*
 * @include "../../../client-public/js/desktop/App.js"
 * @include "../../../client-public/js/desktop/Desktop.js"
 * @include "../sitoolsProject.js"
 */
/**
 * <a href="http://sourceforge.net/tracker/?func=detail&aid=3358501&group_id=531341&atid=2158259">[3358501]</a><br/>
 * 2011/08/03 D.Arpin {Some windows did not have saveSettings Method. In this case, don't save this window Settings}
 */
Ext.namespace('Ext.ux', "sitools.user.desktop");
/**
 * Main Application of sitools desktop
 * When instanciate, it will : 
 *  - build an instance of Ext.app.App ()
 *  - launch initProject on projectGlobal object.
 *  
 * @requires Ext.app.App
 * @class sitools.user.Desktop.App
 */
sitools.user.desktop.App = function () {
	/**
	 * Initialize every modules that should be displayed in a specific Div. 
	 * For each of them, creates a Ext.Panel renderTo the div defined in project administration.
	 */
	function initModulesDiv(modules) {
		Ext.each(projectGlobal.modulesInDiv, function (module) {
			var contentEl = Ext.get(module.divIdToDisplay);
			if (Ext.isEmpty(contentEl)) {
				Ext.Msg.alert(i18n.get('label.error'), String.format(i18n
										.get('label.invalidModuleDivId'),
								module.name, module.divIdToDisplay));
			} else {
				module = new Ext.Panel({
					id : module.id,
					border : false,
					cls : "sitools-module-panel",
					layout : 'fit',
					renderTo : module.divIdToDisplay,
					forceLayout : true,
					height : contentEl.getHeight(),
					width : contentEl.getWidth(),
                    items : [ {
                        layout : 'fit',
                        xtype : module.xtype,
                        listProjectModulesConfig : module.listProjectModulesConfig,
                        moduleProperties : module.properties
                    } ],
					listeners : {
						resize : function (me) {
							if (!SitoolsDesk.desktopMaximizeMode && module.container) {
								me.setSize(Ext.get(module.container).getSize());
							}

						},
						maximizeDesktop : function (me) {
							me.hide();
							me.doLayout();
						},
						minimizeDesktop : function (me) {
						    if (module.container) {
                                me.setSize(Ext.get(module.container).getSize());
                            }
							me.show();
							me.doLayout();
						}
					}

				});
				SitoolsDesk.app.modulesInDiv.push(module);
			}
		});
	}

	/**
	 * Initialize The footer : 
	 * Build a {sitools.user.component.bottom.Bottom}
	 */
	function initBottom() {
		var modules = projectGlobal.modules;
        var bottom = new sitools.user.component.bottom.Bottom({
            id : "bottomCompId"
        });
	}

	/**
	 * Initialize The headers : 
	 * Build a {sitools.user.component.entete.Entete} and render it to x-headers div.
	 */
	function initEntete() {
		var entete = new sitools.user.component.entete.Entete({
				renderTo : "x-headers",
				id : "headersCompId",
				htmlContent : projectGlobal.htmlHeader,
				modules : projectGlobal.modules,
				listeners : {
					resize : function (me) {
						me.setSize(SitoolsDesk.getEnteteEl().getSize());
					}
				}
			});

	}
	/**
	 * <p>Create each module.</p> 
	 * <p>1 - request the project to get All modules defined. </p>
	 * <p>2 - As callback, create a module for each module of the project. 
	 *     In case user is logged, will check if the module is in the preference list, before adding module.</p>
	 */
	function callbackRESTCreateProject() {
		// tableau de modules a passer a l'application
		var modules = [];

		// Check for user authorization
		var isAuthorized = false;
		Ext.Ajax.request({
			scope : this,
			url : projectGlobal.sitoolsAttachementForUsers,
			method : 'GET',
			success : function(response) {
				var data = Ext.decode(response.responseText);
				isAuthorized = true;
				if (data.project.maintenance) {
					desktopReady.call(this);
					Ext.get('ux-taskbar').mask();
					var alertWindow = new Ext.Window({
							title : i18n.get('label.maintenance'),
							width : 600,
							height : 400,
							autoScroll : true,
							closable : false,
							items : [{
									xtype : 'panel',
									layout : 'fit',
									autoScroll : true,
									html : data.project.maintenanceText,
									padding : "5"
								}],
							modal : true
					    });
					alertWindow.show();
					return;
				}
				//we get the configured modules, now we have to create each Module object. 
				projectGlobal.modules = data.project.modules;
				projectGlobal.modulesInDiv = [];

				//Mise a l'écart des modules qui s'affichent dans une div
				Ext.each(projectGlobal.modules, function (module) {
							if (!Ext.isEmpty(module.divIdToDisplay)) {
								projectGlobal.modulesInDiv.push(module);
							}
						}, this);

				SitoolsDesk.modulesACharger = projectGlobal.modules.size();		
				
				if (SitoolsDesk.modulesACharger === 0) {
					Ext.Msg.alert(i18n.get("label.warning"), i18n
									.get("label.noModules"));
					SitoolsDesk.fireEvent('allJsIncludesDone', this);
				}
				
				getListOfModulesAndCreateModules(projectGlobal.sitoolsAttachementForUsers, projectGlobal.modules);		
				
			},
			failure : function (response) {
				Ext.get('ux-taskbar').mask();
				Ext.Msg.alert('Status', i18n.get('warning.not.authorized'),
						function () {
							window.location = loadUrl.get('APP_URL') + loadUrl.get('APP_CLIENT_USER_URL');
						});
				return;
			}
		});
	}

	/**
	 * Called on a desktop Resize. 
	 * It will redefine the height and size of desktop Element. 
	 * Fires events for each component so that they can resize according to their container
	 * Fires event resizeDesktop on activePanel
	 * Fires event resize on entete and bottom component.
	 * Fires event resize on each module representation included in a specific Div  
	 */
	function fireResize(newW, newH) {
		var desktop = SitoolsDesk.getDesktop();
		if (SitoolsDesk.desktopMaximizeMode) {
			desktop.getDesktopAndTaskBarEl().setHeight(Ext.getBody()
					.getHeight()
					- this.getEnteteEl().getHeight());
			desktop.getDesktopAndTaskBarEl().setWidth(Ext.getBody()
					.getWidth());
			desktop.getDesktopEl().setHeight(Ext.getBody().getHeight()
					- this.getEnteteEl().getHeight()
					- desktop.taskbar.tbPanel.getHeight());
			desktop.getDesktopEl().setWidth(Ext.getBody().getWidth());
		}
		if (!Ext.isEmpty(desktop.activePanel)) {
			desktop.activePanel.fireEvent("resizeDesktop",
					desktop.activePanel);
		}
		SitoolsDesk.getEnteteComp().fireEvent("resize",
				SitoolsDesk.getEnteteComp(), newW, newH);
		SitoolsDesk.getEnteteComp().fireEvent("windowResize",
				SitoolsDesk.getEnteteComp(), newW, newH);
		SitoolsDesk.getBottomComp().fireEvent("resize",
				SitoolsDesk.getBottomComp(), newW, newH);
		SitoolsDesk.getBottomComp().fireEvent("windowResize",
				SitoolsDesk.getBottomComp(), newW, newH);
		for (var int = 0; int < projectGlobal.modulesInDiv.length; int++) {
			var module = projectGlobal.modulesInDiv[int];
			var panel = Ext.getCmp(module.id);
			panel.fireEvent("resize", panel, newW, newH);
		}
	}

	/**
	 * Method called to instanciate the right profile object to get specific methods accdording to the navigation profile. 
	 * @returns
	 */
	function initNavigationMode() {
		if (projectGlobal.navigationMode === "desktop") {
			SitoolsDesk.navProfile = sitools.user.desktop.navProfile.desktop;
		} else {
			SitoolsDesk.navProfile = sitools.user.desktop.navProfile.fixed;
		}
	}

	/**
	 * Method called on allJsIncludesDone event. 
	 * After that, we are sure that every needed JS is loaded. 
	 * First load the user preferences
	 */
	function _onAllJsIncludesDone() {
		initNavigationMode();
//		SitoolsDesk.loadPreferences(this);

		this.fireEvent('modulesLoaded');
	}
	
    /**
     * Initialize every modules that should be displayed in a specific Div. 
     * For each of them, creates a Ext.Panel renderTo the div defined in project administration.
     */
    function checkModules(modules, callback) {
        var errorModules = [];
        Ext.each(projectGlobal.modules, function (module) {
            var moduleName = module.name;
            
            var xtype = module.xtype;            
            var func = xtype + ".openModule";
            try {
                if (!Ext.isEmpty(xtype) && Ext.isFunction(eval(func))) {
                    eval(func);
                }
                
            } catch (err) {
                errorModules.push(moduleName);
            }
        }, this);
        if (!Ext.isEmpty(errorModules)) {
            var moduleNames = "";
            Ext.each(errorModules, function (moduleName) {
                moduleNames += "<br/> - " + moduleName;
            });
            var msg = String.format(i18n.get("label.cannotLoadModules"), moduleNames);
            Ext.Msg.alert(i18n.get("label.warning"), msg, function () {
                onAllInit.call(this);
            }, this);
            var window = Ext.MessageBox.getDialog(i18n.get("label.warning"));
            var pos = window.getPosition();
            pos[1] = pos[1] - 200;
            window.setPosition(pos);
        }
        else {
            onAllInit.call(this);
        }
    }
	

	/**
	 * Method called on moduleLoaded event.
	 * Add home and remove panel button to taskbar or navbar
	 * (depending desktop or fixed mode)
	 */
	function initTaskAndNavBar() {
		SitoolsDesk.navProfile.taskbar.initTaskbar();
		SitoolsDesk.navProfile.initNavbar();
	}

	function onAllInit() {
	    SitoolsDesk.loadPreferences(this);
        initEntete();
        initBottom();
        initTaskAndNavBar();
        initModulesDiv(projectGlobal.modules);

        if (projectGlobal.preferences
                && projectGlobal.preferences.projectSettings
                && projectGlobal.preferences.projectSettings.desktopMaximizeMode) {
            getDesktop().maximize();
        }
      //when preferences are loaded fireEvent Ready.
        this.fireEvent('ready');
    }
	
	/**
	 * Called on modulesLoaded event. 
	 * After modules are loaded and built, initialize the headers and footer components
	 * Load every modules defined to be displayed in a specific div. 
	 */
	function _onModulesLoaded() {
	    checkModules.call(this, projectGlobal.modules, onAllInit);
	}
	
	/**
	 * Initialize the project. 
	 * Load sql2Ext settings, 
	 * Call the projectGloabal initProject method
	 */
	function initProject() {
		//Add the app listeners
		SitoolsDesk.app.addListener("allJsIncludesDone", _onAllJsIncludesDone);
		SitoolsDesk.app.addListener("ready", desktopReady);
		SitoolsDesk.app.addListener("modulesLoaded", _onModulesLoaded);

        sql2ext.load(loadUrl.get('APP_URL') + "/conf/sql2ext.properties");

		//handle windowResize event 
		Ext.EventManager.onWindowResize(fireResize, SitoolsDesk);

		projectGlobal.initProject(callbackRESTCreateProject);

		// Ext.QuickTips.init();

		// Apply a set of config properties to the singleton
        Ext.apply(Ext.QuickTips.getQuickTip(), {
            maxWidth : 200,
            minWidth : 100,
            showDelay : 50,
            trackMouse : true
        });
	}

	/**
	 * Called when deletePrefButton is pressed. 
	 * Remove the public Preferences.
	 */
	function deletePublicPref() {
		publicStorage.remove();
	}

	/**
	 * Called when login is pressed.
	 * Show a {sitools.userProfile.Login} window
	 */
	function _onLogin() {
	    sitools.userProfile.LoginUtils.connect({
            closable : true,
            url : loadUrl.get('APP_URL') + '/login',
            register : loadUrl.get('APP_URL') + '/inscriptions/user',
            reset : loadUrl.get('APP_URL') + '/resetPassword'
        });
	}

	/**
	 * Called when logout is pressed.
	 */
	function _onLogout() {
	    sitools.userProfile.LoginUtils.logout();
	}

	/**
	 * private 
	 * Create the component according to the componentCfg and JsObj param. 
	 * Uses the navProfile to create either a window or a panel. 
	 * 
	 * @param {} windowSettings  
	 *      {string} id (required) : windowId
	 *      {string} title (required) : windowTitle, 
	 *      {string} datasetName (required) : datasetName, 
	 *      {string} moduleId : String
	 *      {} position : [xpos, ypos]
	 *      {} size : {
	 *          width : w
	 *          height : h
	 *      }
	 *      {string} specificType : sitoolsSpecificType
	 *      [Ext.Button] toolbarItems 
	 * @param {} componentCfg  Object containing the configuration
	 * @param {string} JsObj the name of the Javascript Object used to build the component inside the window
	 * @param {boolean} reloadComp true to reload the window (only in desktop navigation moede)
	 * @returns
	 */
	function addWinData(windowSettings, componentCfg, JsObj, reloadComp) {
		var desktop = getDesktop();
		var win = desktop.getWindow(windowSettings.id);
		if (win) {
			if (reloadComp) {
				win.removeAll();
				win.add(new JsObj(componentCfg));
				win.doLayout();
			}
			if (win.minimized) {
				win.show();
			}
			win.toFront();
			return;
		}
		//Create the component according to the navigation profile.
		try {
            SitoolsDesk.navProfile.createComponent({
                componentCfg : componentCfg,
                windowSettings : windowSettings,
                reloadComp : reloadComp,
                JsObj : JsObj
            });

		} catch (r) {
			Ext.Msg.alert(i18n.get("label.warning"), i18n
							.get("label.nocomponentfound"));
			throw (r);
		}
	}

	/**
	 * Unmask desktop Elements
	 */
	function desktopReady() {
		if (Ext.getBody().isMasked()) {
			Ext.getBody().unmask();
		}
		

		if (!Ext.isEmpty(SitoolsDesk.getEnteteComp())) {
		    Ext.get("ux-taskbar").setVisible(true);
		    SitoolsDesk.getEnteteComp().fireEvent("desktopReady", SitoolsDesk.getEnteteComp());
		}
		
        document.onkeypress = function (event) {
            if (event.keyCode === event.DOM_VK_F1) {
                // cancel browser app event handler for F1 key
                event.stopPropagation();
                event.preventDefault();
            }
        };
	}

	/**
	 * Mask all the desktop element. 
	 */
	function maskDesktop() {
		Ext.getBody().mask(i18n.get("label.loadingSitools"));
		Ext.get("ux-taskbar").hide();
	}

	/**
	 * Build a Ext.app.Module according to the config. 
	 * Includes All Css and Js defined in the module configuration. 
	 * Especially defined the default method openModule called to open a Module. 
	 * 
	 * @param {} the module Configuration. 
	 * @returns {Ext.app.Module} 
	 */
	function createModule(config) {
		function includeCss(url) {
			var headID = document.getElementsByTagName("head")[0];
			var newCss = document.createElement('link');
			newCss.type = 'text/css';
			newCss.rel = 'stylesheet';
			newCss.href = url;
			newCss.media = 'screen';
			// pas possible de monitorer l'evenement onload sur une balise link
			headID.appendChild(newCss);
		}

		function includeJs(ConfUrls, indexAInclure) {
			//Test if all inclusions are done for this module
			if (indexAInclure < ConfUrls.length) {
				// if not : include the Js Script
				var DSLScript = document.createElement("script");
				DSLScript.type = "text/javascript";
				DSLScript.onload = includeJs.createDelegate(this, [ConfUrls,
								indexAInclure + 1]);
				DSLScript.onreadystatechange = includeJs.createDelegate(this, 
				        [ConfUrls, indexAInclure + 1]);
				//keep loading even if there is an error
				DSLScript.onerror = includeJs.createDelegate(this, 
				        [ConfUrls, indexAInclure + 1]);

				DSLScript.src = ConfUrls[indexAInclure].url;

				var headID = document.getElementsByTagName('head')[0];
				headID.appendChild(DSLScript);
			} else {
				//if all includes are done, Add 1 to the modulesCharges 
				SitoolsDesk.modulesCharges++;
				//test if all modules are loaded.
				if (SitoolsDesk.modulesCharges === SitoolsDesk.modulesACharger) {
					//End of loading all Javascript files.  
					SitoolsDesk.app.fireEvent('allJsIncludesDone', this);
				}
			}
		}
		
		var module = new Ext.app.Module(Ext.apply(config, {
			init : function () {
				// s'il y a des dependances
				if (config.dependencies) {
					if (config.dependencies.css) {
						Ext.each(config.dependencies.css, function (dependenceCss) {
									includeCss(dependenceCss.url);
								});
					}

					if (config.dependencies.js) {
						includeJs(config.dependencies.js, 0);
					}

				} else {
					SitoolsDesk.app.modulesCharges++;
				}

			},

			getWindow : function () {
				return Ext.getCmp(config.id);
			},
			openModule : function () {
				var desktop = getDesktop();
				return SitoolsDesk.navProfile.openModule(module);
			}
		}));
		return module;

	}
	/**
	 * Request the module configuration and call createModule method. 
	 * @warning Old version, do not use
	 */
	function getConfigAndCreateModule(config) {
		Ext.Ajax.request({
			method : "GET",
			url : loadUrl.get('APP_URL') + loadUrl.get('APP_PROJECTS_MODULES_URL') + "/" + config.id,
			scope : this,
			success : function (response) {
				var json = Ext.decode(response.responseText);
				if (json.success) {
					var configModule = Ext.applyIf(config, json.projectModule || {});
					var module = createModule(configModule);
					SitoolsDesk.app.modules.push(module);
				} else {
					Ext.Msg.alert(i18n.get('label.error'), String.format(i18n
											.get('label.undefinedModule'),
									config.name));
					//if all includes are done, Add 1 to the modulesCharges 
					SitoolsDesk.modulesCharges++;
					//test if all modules are loaded.
					if (SitoolsDesk.modulesCharges === SitoolsDesk.modulesACharger) {
						//End of loading all Javascript files.  
						SitoolsDesk.app.fireEvent('allJsIncludesDone', this);
					}
				}
			},
			failure : alertFailure
		});
	}
	
	function findProjectModuleConfig(configs, id) {
        var configOut = null;
        Ext.each(configs, function (conf) {
            if (conf.id === id) {
                configOut = conf;
                return;
            }
        }, this);
        return configOut;
    }
	
	/**
	 * Gets the list of modules for the project and creates all the modules
	 * @recommanded New version of getConfigAndCreateModule
	 */
	function getListOfModulesAndCreateModules(projectAttachment, configs) {
		Ext.Ajax.request({
			method : "GET",
			url : projectAttachment + "/projectModules",
			scope : this,
			success : function (response) {
				var json = Ext.decode(response.responseText);
				Ext.each(json.data, function (projectModule) {
					var projectConfig = findProjectModuleConfig(configs, projectModule.id);
					if (!Ext.isEmpty(projectConfig)) {
						var configModule = Ext.applyIf(projectConfig, projectModule	|| {});
						var module = createModule(configModule);						
						SitoolsDesk.app.modules.push(module);
					}
					else {
						Ext.Msg.alert(i18n.get('label.error'), String.format(i18n
											.get('label.undefinedModule'),
									projectModule.name));		
									
						//if all includes are done, Add 1 to the modulesCharges 
						SitoolsDesk.modulesCharges++;
						//test if all modules are loaded.
						if (SitoolsDesk.modulesCharges === SitoolsDesk.modulesACharger) {
							//End of loading all Javascript files.  
							SitoolsDesk.app.fireEvent('allJsIncludesDone', this);
						}
					}					
				}, this);
			},
			failure : alertFailure
		});		
	}
	

	

	/**
	 * Instanciation of a Ext.app.App object. 
	 * Overrides some methods. 
	 * @returns {Ext.app.App} the application. 
	 */
	function createApplication() {
		return new Ext.app.App({
			//initialize app
			init : function () {
				Ext.QuickTips.init();
				Ext.state.Manager.setProvider(new Ext.state.CookieProvider());
				//WTF with IE...
				if (Ext.isIE) {
					Ext.Msg.confirm(i18n.get('label.warning'), i18n
									.get('label.IEWarning'),
							function (buttonId) {
								if (buttonId === "yes") {
									maskDesktop();
									initProject();
								} else {
									window.location
											.replace("https://www.google.com/chrome/index.html");
								}
							});

				} else {
					maskDesktop();
					initProject();
				}

			},
			//overrides getModules
			getModules : function () {
				return this.modules;
			},
			//overrides getModulesInDiv
			getModulesInDiv : function () {
				return this.modulesInDiv;
			},
			//overrides
			findModule : function (moduleId) {
				var result = null;
				Ext.each(this.modules.concat(this.modulesInDiv), function (module) {
					if (module.id === moduleId) {
						result = module;
					}
				});
				return result;
			},
			//add some method 
			saveWindowSettings : function (forPublicUser) {
				var desktopSettings = SitoolsDesk.navProfile
						.getDesktopSettings(forPublicUser);

				userPreferences = {};
				userPreferences.windowSettings = desktopSettings;
				var projectSettings = {};
//				if (!Ext.isEmpty(SitoolsDesk.getDesktop().activePanel)) {
//					projectSettings.activeModuleId = SitoolsDesk.getDesktop().activePanel.id;
//				}
				projectSettings.desktopMaximizeMode = SitoolsDesk.desktopMaximizeMode;
				projectSettings.navigationMode = projectGlobal.navigationMode;

				userPreferences.projectSettings = projectSettings;
				if (forPublicUser) {
					publicStorage.set("desktop", "/"
									+ DEFAULT_PREFERENCES_FOLDER + "/"
									+ projectGlobal.projectName,
							userPreferences);
				} else {
					userStorage.set("desktop", "/" + DEFAULT_PREFERENCES_FOLDER
									+ "/" + projectGlobal.projectName,
							userPreferences);
				}
			}
		});
	}

	/**
	 * Find the portal preferences. 
	 * @param portalPrefCb A method to call after portal Preferences Request. 
	 */
	function getPortalPreferences(portalPrefCb) {
		if (!Ext.isEmpty(userLogin)) {
			var portalPrefSuccess = function (response) {
				if (Ext.isEmpty(response.responseText)) {
					return;
				}
				try {
					var json = Ext.decode(response.responseText);
					if (!Ext.isEmpty(json.language)) {
						this.app.language = json.language;
					}
				} catch (err) {
				    return;
				}
			};

			var filePath = "/" + DEFAULT_PREFERENCES_FOLDER + '/portal';

			userStorage.get("portal", filePath, this, portalPrefSuccess,
					Ext.emptyFn, portalPrefCb);
		} else {
			portalPrefCb.call(this);
		}

	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - //

	return {
		maxSizeHistory : 5,

		history : [],

		/**
		 * the Navigation profile. 
		 */
		navProfile : null,

		activeComponent : null,
		/**
		 * True if desktop is maximized, false otherwize
		 */
		desktopMaximizeMode : false,

		/**
		 * {integer} modulesCharges The number of loaded Modules
		 */
		modulesCharges : 0,

		/**
		 * {integer} modulesACharger The number of modules to load at start.
		 */
		modulesACharger : 0,
		/**
		 * the sitools Ext.app.App instance
		 * @type Ext.app.App
		 */
		app : this.app,

		/**
		 * Method called to historize the navigation in the desktop.  
		 * @param {} panel The panel to be historized.
		 * @returns
		 */
		addToHistory : function (panel) {
			panel.rendered = false;
			SitoolsDesk.history.push(panel);
		},

		/**
		 * The entry Point of SITools application. 
		 * Create the Ext.app.App stored as SitoolsDesk.app. 
		 * Load the context files (loadUrl, i18n, ...)
		 * After All, call SitoolsDesk.app.initApp() to instanciate an Ext.Desktop.
		 * @returns
		 */
		initDesktopApplication : function () {
			// START HERE !!!
			Ext.QuickTips.init();
			
			if (!Ext.isEmpty(Ext.util.Cookies.get('userLogin'))) {
				var auth = Ext.util.Cookies.get('hashCode');

				Ext.Ajax.defaultHeaders = {
					"Authorization" : auth,
					"Accept" : "application/json",
					"X-User-Agent" : "Sitools"
				};
			} else {
				Ext.Ajax.defaultHeaders = {
					"Accept" : "application/json",
					"X-User-Agent" : "Sitools"
				};
			}

			//Instanciation de l'objet Ext.app.App. 
			this.app = createApplication();

			//récupération de la langue contenue dans le cookie, ou à défaut, au niveau du navigateur. 
			this.app.language = locale.getLocale();

			/* Définition des appels en cascade :
			 *  - méthode N°1 : loadUrl.load (Chargements des urls dynamiques)
			 *  - méthode N°2 : getPortalPreferences (Chargement des préférences du portail)
			 *  - méthode N°3 : i18n.load (Chargement du fichier de langue défini)
			 *  - méthode N°4 : projectGlobal.getUserRoles (Récupération du rôle de l'utilisateur)
			 *  - méthode N°5 : SitoolsDesk.app.initApp (Instancie l'objet Ext.Desktop et appel à SitoolsDesk.app.init())
			 *  
			 */
			var initApplication = function () {
				SitoolsDesk.app.initApp();
			};
			var i18nCb = function () {
				projectGlobal.getUserRoles(initApplication);
			};
			var portalPrefCb = function () {
				i18n.load('/sitools/res/i18n/' + SitoolsDesk.app.language + '/gui.properties', i18nCb);
			};
			var callbackSiteMap = function () {
				getPortalPreferences(portalPrefCb);
			};
			loadUrl.load('/sitools/client-user/siteMap', callbackSiteMap);

		},

		/**
		 * public dynamically add a new application to the desktop
		 * 
		 * 1. moduleFactory.createModule 
		 * 2. ajout du module dans le fisheyeMenu
		 */
		addApplication : function (composant) {
			modulesExistants = SitoolsDesk.app.getModules();
			if (!modulesExistants) {
				modulesExistants = [];
			}

			var nouveauModule = getConfigAndCreateModule(composant, this);
			modulesExistants.push(nouveauModule);

			SitoolsDesk.app.addModule(nouveauModule);
		},

		/**
		 * public dynamically remove an application from the desktop
		 * 
		 * On supprime son icone du menu demarrer et du fisheyeMenu ainsi que de
		 * la liste des modules existants
		 */
		removeApplication : function (idApplication) {
			var moduleToRemove = SitoolsDesk.app.getModule(idApplication);
			modulesExistants = SitoolsDesk.app.getModules();
			SitoolsDesk.app.removeModule(moduleToRemove);
		},

		/**
		 * Load the module Window corresponding to the project Preference. 
		 * 1 - load the module Windows
		 * 2 - load the Component windows (actually only "data", "form"  && "formProject" type window) 
		 */
		loadPreferences : function (scope) {
			if (!Ext.isEmpty(projectGlobal.preferences) && !Ext.isEmpty(projectGlobal.preferences.projectSettings)) {
				// Ne charge les préférences sauvegardées seulement si le navigationMode sauvegardé et le même que le courant
				if (projectGlobal.navigationMode == projectGlobal.preferences.projectSettings.navigationMode){
					SitoolsDesk.navProfile.loadPreferences(scope);
				}
				else {
					Ext.Msg.show({
						buttons :  Ext.MessageBox.OK,
						icon :  Ext.MessageBox.INFO,
						modal : true,
						closable : false,
						title : i18n.get('label.info'),
						msg : i18n.get('label.saveNavigationModeDoesntMatch')
					});
				}
			}
		},

		/**
		 * @method
		 * public load the preferences for a window if the user is logged and then build the window 
		 * 
		 * @param {} windowSettings Window Settings object build with attributes
		 *      {string} id (required) : windowId
		 *      {string} title (required) : windowTitle, 
		 *      {string} type (required if saveToolbar) : the type of the window, will determine the userStorage path
		 *          [forms, data]
		 *      {string} datasetName (required if saveToolbar) : name of the dataset, will determine the userStorage name
		 *      {string} urlPreferences (required if saveToolbar) : the url to request to get the userPreferences
		 *      {boolean} saveToolbar  : true if the saveSettings toolbar should be displayed
		 *          default false
		 * 
		 * @param {} component : the items to add to the Window
		 * @param {string} JsObj : the name of the Javascript Object used to build the component inside the window
		 */
		addDesktopWindow : function (windowSettings, component, JsObj,
				reloadComp) {
			if (Ext.isEmpty(windowSettings.saveToolbar)) {
				windowSettings.saveToolbar = false;
			}

			if (Ext.isEmpty(windowSettings.title)) {
				throw ("NoWinTitle");
			}

			if (Ext.isEmpty(reloadComp)) {
				reloadComp = false;
			}

			//If Window does not have save abilities.
			if (windowSettings.saveToolbar === false) {
				addWinData(windowSettings, component, JsObj, reloadComp);
				return;
			}

			//construction de l'url pour les préférences utilisateur. 
			var baseFilePath = "/" + DEFAULT_PREFERENCES_FOLDER + "/" + projectGlobal.projectName;

			var filePath = component.preferencesPath;
			var fileName = component.preferencesFileName;
			if (Ext.isEmpty(filePath) || Ext.isEmpty(fileName)) {
				addWinData(windowSettings, component, JsObj, reloadComp);
				return;
			}
			filePath = baseFilePath + filePath;

			//Méthod to call if no userPreferences found
			var addWinPublic = function (windowSettings, component, JsObj,
					reloadComp) {
				var successPublic = function (response, opts) {
					try {
						var json = Ext.decode(response.responseText);

						Ext.apply(windowSettings, json.windowSettings);
						Ext.apply(component, 
					        {
								userPreference : json.componentSettings
							});
						addWinData(windowSettings, component, JsObj, reloadComp);
					} catch (err) {
						addWinData(windowSettings, component, JsObj, reloadComp);
					}
				};

				var failurePublic = function (response, opts) {
					addWinData(windowSettings, component, JsObj, reloadComp);
				};

				publicStorage.get(fileName, filePath, this, successPublic,
						failurePublic);
			};

			if (Ext.isEmpty(userLogin)) {
				addWinPublic(windowSettings, component, JsObj, reloadComp);
			} else {
				//Méthode appelée si l'on trouve des préférences pour le user
				var successMethod = function (response, opts) {
					try {
						var json = Ext.decode(response.responseText);

						Ext.apply(windowSettings, json.windowSettings);
						Ext.apply(component, 
					        {
								userPreference : json.componentSettings
							});
						addWinData(windowSettings, component, JsObj, reloadComp);
					} catch (err) {
						addWinPublic(windowSettings, component, JsObj,
								reloadComp);
					}
				};
				//Si pas de préférences trouvées, on utilise addWinPublic
				var failureMethod = function (response, opts) {
					addWinPublic(windowSettings, component, JsObj, reloadComp);
				};

				userStorage.get(fileName, filePath, this, successMethod,
						failureMethod);
			}
		},
		/**
		 * Returns the Ext.Desktop instance. 
		 * @returns {Ext.Desktop}
		 */
		getDesktop : function () {
			return this.app.desktop;
		},
		/**
		 * Returns the desktop Header Element. 
		 * @returns {Ext.Element}
		 */
		getEnteteEl : function () {
			return Ext.get('x-headers');
		},
		/**
		 * Returns the panel charged of displaying headers of Sitools.
		 * @returns {sitools.user.component.entete.Entete} The headers component
		 */
		getEnteteComp : function () {
			return Ext.getCmp("headersCompId");
		},
		/**
		 * Returns the footer Element. 
		 * @returns {Ext.Element}
		 */
		getBottomEl : function () {
			return Ext.get('x-bottom');
		},
		/**
		 * Returns the panel charged of displaying bottom of Sitools.
		 * @returns {sitools.user.component.bottom.Bottom} The footer component
		 */
		getBottomComp : function () {
			return Ext.getCmp("bottomCompId");
		},
		/**
		 * Remove the active Panel in desktop (the module representation incrusted in background of the desktop)
		 * 
		 */
		removeActivePanel : function () {
			if (this.getDesktop().activePanel) {
				var panel = this.getDesktop().activePanel;
				this.getDesktop().activePanel = null;
				panel.hide();
				return;
			}
		},
		/**
		 * Close every window in desktop and panel in fixed mode
		 */
		removeAllWindows : function (quiet) {
			SitoolsDesk.navProfile.removeAllWindows(quiet);
		},
		/**
		 * Minify every window in desktop. 
		 */
		minifyAllWindows : function () {
			SitoolsDesk.getDesktop().getManager().each(function (win) {
						if (Ext.isFunction(win.minimize)) {
							win.minimize();
						} else {
							win.destroy();
						}

					});
		},
		/**
		 * Open and shows all hidden windows that have a taskButton  
		 * @returns
		 */
		openAllWindows : function () {
			SitoolsDesk.getDesktop().getManager().each(function (win) {
						if (!win.isVisible() && win.taskButton) {
							win.show();
						}
					});
		},

		/**
		 * Open a modal window in the desktop. 
		 * @param {Ext.Panel} panel the component to add to the modal window 
		 * @param {} config a config object containg windowSettings
		 * @returns
		 */
		openModalWindow : function (panel, config) {
			var windowConfig = config.windowSettings || {};
			Ext.apply(windowConfig, {
					modal : true,
					layout : 'fit'
				});

			if (!Ext.isEmpty(windowConfig.toolbarItems)) {
				Ext.apply(windowConfig, {
					tbar : {
						items : windowConfig.toolbarItems,
						cls : 'toolbar'
					},
					listeners : {
						afterrender : function (me) {
							if (me.getHeight() > Ext.getBody()
									.getHeight()) {
								me.setHeight(Ext.getBody().getHeight());
							}
							if (me.getWidth() > Ext.getBody()
									.getWidth()) {
								me.setWidth(Ext.getBody().getWidth());
							}
							me.doLayout();

						}
					}
				});
			}

			Ext.applyIf(windowConfig, {
				width : DEFAULT_WIN_WIDTH,
				height : DEFAULT_WIN_HEIGHT
			});
			var win = new Ext.Window(windowConfig);
			win.show();
			win.add(panel);
			win.setZIndex(12000);

			win.doLayout();
		},
		/**
		 * Open the sitools.user.component.help window
		 * @param {Ext.Button} b The pressed btn
		 * @param {Ext.event} e the click Event. 
		 * @returns
		 */
		showHelp : function (b, e) {
			var help = Ext.getCmp("helpWindow");
			if (!Ext.isEmpty(help)) {
				help.show();
				help.setZIndex(12000);
				return;
			}
			var componentCfg = {};
			help = new sitools.user.component.help();
			var config = {};
			config.windowSettings = {
				id : "helpWindow",
				title : i18n.get('label.help'),
				saveToolbar : false,
				closeAction : 'hide'
			};
			SitoolsDesk.openModalWindow(help, config);
		},
		
		showFormFromEditor : function (formUrl) {
	        Ext.Ajax.request({
	            url : formUrl,
	            method : 'GET', 
	            success : function (response) {
	                try {
	                    var json = Ext.decode(response.responseText);
	                    if (! json.success) {
	                        Ext.Msg.alert(i18n.get('label.error'), json.message);
	                        return;
	                    }
	                    var rec = {};
	                    rec.data = json.data[0];
	                    
	                    Ext.Ajax.request({
				            url : rec.data.parentUrl,
				            method : 'GET', 
				            success : function (response) {
				                try {
                                    var json2 = Ext.decode(response.responseText);
                                    var dataset = json2.dataset;

                                    var jsObj = SitoolsDesk.navProfile.getFormOpenMode();

                                    var componentCfg = {
                                        dataUrl : rec.data.parentUrl,
                                        dataset : dataset,
                                        formId : rec.data.id,
                                        formName : rec.data.name,
                                        formParameters : rec.data.parameters,
                                        formWidth : rec.data.width,
                                        formHeight : rec.data.height,
                                        formCss : rec.data.css,
                                        preferencesPath : "/" + dataset.name + "/forms",
                                        preferencesFileName : rec.data.name
                                    };

                                    SitoolsDesk.navProfile.addSpecificFormParameters(componentCfg, dataset);

                                    var windowSettings = {
                                        datasetName : dataset.name,
                                        type : "form",
                                        title : i18n.get('label.forms') + " : " + dataset.name + "." + rec.data.name,
                                        id : "form" + dataset.id + rec.data.id,
                                        saveToolbar : true,
                                        iconCls : "form"
                                    };

                                    SitoolsDesk.addDesktopWindow(windowSettings, componentCfg, jsObj);
                                    return;
                                } catch (err) {
                                    Ext.Msg.alert(i18n.get('label.error'), err);
                                    return;
                                }
				            }
                        });
	                }
	                catch (err) {
	                    Ext.Msg.alert(i18n.get('label.error'), err);
	                    return;
	                }
	                
	            }, 
	            failure : function () {
	                Ext.Msg.alert(i18n.get('label.error'), i18n.get('label.noActiveDatasetFound'));
	                return;
	            }
	        });
		}
	};
};
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, OpenLayers*/

Ext.ns("sitools.user.data");

sitools.user.data.featureReader = Ext.extend(GeoExt.data.FeatureReader, {
    totalRecords : null, 
    
    /**
     * Overrides parent method to call readRecords with entire response (containing the totalRecords)
     * @returns
     */
    read : function (response) {
		return this.readRecords(response);
	}, 
    /** api: method[readRecords]
     *  :param features: ``Array(OpenLayers.Feature.Vector)`` List of
     *      features for creating records
     *  :return: ``Object``  An object with ``records`` and ``totalRecords``
     *      properties.
     *  
     *  Create a data block containing :class:`GeoExt.data.FeatureRecord`
     *  objects from an array of features.
     */
    readRecords : function (response) {
        var result = sitools.user.data.featureReader.superclass.readRecords.call(this, response.features);

        
        return Ext.apply(result, {
            totalRecords : response.totalResults
        });
    }
});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, OpenLayers*/

Ext.ns("sitools.user.data");

sitools.user.data.FormatGeoJson = Ext.extend(OpenLayers.Format.GeoJSON, {
    totalProperty : null, 
	/**
     * APIMethod: read
     * Deserialize a GeoJSON string.
     *
     * Parameters:
     * json - {String} A GeoJSON string
     * type - {String} Optional string that determines the structure of
     *     the output.  Supported values are "Geometry", "Feature", and
     *     "FeatureCollection".  If absent or null, a default of
     *     "FeatureCollection" is assumed.
     * filter - {Function} A function which will be called for every key and
     *     value at every level of the final result. Each value will be
     *     replaced by the result of the filter function. This can be used to
     *     reform generic objects into instances of classes, or to transform
     *     date strings into Date objects.
     *
     * Returns: 
     * {Object} The return depends on the value of the type argument. If type
     *     is "FeatureCollection" (the default), the return will be an array
     *     of <OpenLayers.Feature.Vector>. If type is "Geometry", the input json
     *     must represent a single geometry, and the return will be an
     *     <OpenLayers.Geometry>.  If type is "Feature", the input json must
     *     represent a single feature, and the return will be an
     *     <OpenLayers.Feature.Vector>.
     */
    read: function (json, type, filter) {
        type = (type) ? type : "FeatureCollection";
        var results = null;
        var obj = null;
        if (typeof json == "string") {
            obj = OpenLayers.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if (!obj) {
            OpenLayers.Console.error("Bad JSON: " + json);
        } else if (typeof(obj.type) != "string") {
            OpenLayers.Console.error("Bad GeoJSON - no type: " + json);
        } else if (this.isValidType(obj, type)) {
            switch (type) {
                case "Geometry" :
                    try {
                        results = this.parseGeometry(obj);
                    } catch (err) {
                        OpenLayers.Console.error(err);
                    }
                    break;
                case "Feature":
                    try {
                        results = this.parseFeature(obj);
                        results.type = "Feature";
                    } catch(err) {
                        OpenLayers.Console.error(err);
                    }
                    break;
                case "FeatureCollection":
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch(obj.type) {
                        case "Feature":
                            try {
                                results.push(this.parseFeature(obj));
                            } catch(err) {
                                results = null;
                                OpenLayers.Console.error(err);
                            }
                            break;
                        case "FeatureCollection":
                            for(var i=0, len=obj.features.length; i<len; ++i) {
                                try {
                                    results.push(this.parseFeature(obj.features[i]));
                                } catch(err) {
                                    results = null;
                                    OpenLayers.Console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                var geom = this.parseGeometry(obj);
                                results.push(new OpenLayers.Feature.Vector(geom));
                            } catch(err) {
                                results = null;
                                OpenLayers.Console.error(err);
                            }
                    }
                break;
            }
        }
        return {
			features : results, 
			totalResults : obj[this.totalProperty]
        };
    }
});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, OpenLayers*/

Ext.ns("sitools.user.data");

sitools.user.data.ProtocolHttp = function (config) {
	sitools.user.data.ProtocolHttp.superclass.constructor.call(this, Ext.apply({
	    url: config.url,
	    totalProperty : config.totalProperty, 
	    format: new sitools.user.data.FormatGeoJson({
	    	totalProperty : config.totalProperty
	    })
	}));

};

Ext.extend(sitools.user.data.ProtocolHttp, OpenLayers.Protocol.HTTP, {
    /**
     * Method: handleResponse
     * Overrides the OpenLayers.Protocol.HTTP method : 
     * As we use a sitools.user.data.FormatGeoJson, the return of parseFeatures will be different : 
     * 
     * initial return of this.parseFeatures : Array of features
     * 
     * sitools.user.data.FormatGeoJson return : {
     * 		features : [], 
     * 		totalResults : {integer} (should be null if no totalProperty defined)
     * }
     * 
     * Called by CRUD specific handlers.
     *
     * Parameters:
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to
     *     any user callback.
     * options - {Object} The user options passed to the create, read, update,
     *     or delete call.
     */
    handleResponse: function(resp, options) {
        var request = resp.priv;
        if(options.callback) {
            if(request.status >= 200 && request.status < 300) {
                // success
                if(resp.requestType != "delete") {
                    //Here is the main changes : 
                	//resp.features = this.parseFeatures(request);
                	Ext.apply (resp, this.parseFeatures(request));
                }
                resp.code = OpenLayers.Protocol.Response.SUCCESS;
            } else {
                // failure
                resp.code = OpenLayers.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, resp);
        }
    }	
});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, OpenLayers*/

Ext.ns("sitools.user.data");

sitools.user.data.ProtocolProxy = function (config) {
	sitools.user.data.ProtocolProxy.superclass.constructor.call(this, Ext.apply({
		api : {
			create : Ext.emptyFn, 
			destroy : Ext.emptyFn, 
			read : Ext.emptyFn, 
			update : Ext.emptyFn
		}, 
		protocol: new sitools.user.data.ProtocolHttp({
		    url: config.url,
		    totalProperty : config.totalProperty, 
		    format: new OpenLayers.Format.GeoJSON()
		})
	}));

};

Ext.extend(sitools.user.data.ProtocolProxy, GeoExt.data.ProtocolProxy, {});
	/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
Ext.namespace('Ext.ux.grid.filter');

/** 
 * @class Ext.ux.grid.filter.Filter
 * @extends Ext.util.Observable
 * Abstract base class for filter implementations.
 */
Ext.ux.grid.filter.Filter = Ext.extend(Ext.util.Observable, {
    /**
     * @cfg {Boolean} active
     * Indicates the initial status of the filter (defaults to false).
     */
    active : false,
    /**
     * True if this filter is active.  Use setActive() to alter after configuration.
     * @type Boolean
     * @property active
     */
    /**
     * @cfg {String} dataIndex 
     * The {@link Ext.data.Store} dataIndex of the field this filter represents.
     * The dataIndex does not actually have to exist in the store.
     */
    dataIndex : null,
    /**
     * The filter configuration menu that will be installed into the filter submenu of a column menu.
     * @type Ext.menu.Menu
     * @property
     */
    menu : null,
    /**
     * @cfg {Number} updateBuffer
     * Number of milliseconds to wait after user interaction to fire an update. Only supported 
     * by filters: 'list', 'numeric', and 'string'. Defaults to 500.
     */
    updateBuffer : 500,

    constructor : function (config) {
        Ext.apply(this, config);
            
        this.addEvents(
            /**
             * @event activate
             * Fires when an inactive filter becomes active
             * @param {Ext.ux.grid.filter.Filter} this
             */
            'activate',
            /**
             * @event deactivate
             * Fires when an active filter becomes inactive
             * @param {Ext.ux.grid.filter.Filter} this
             */
            'deactivate',
            /**
             * @event serialize
             * Fires after the serialization process. Use this to attach additional parameters to serialization
             * data before it is encoded and sent to the server.
             * @param {Array/Object} data A map or collection of maps representing the current filter configuration.
             * @param {Ext.ux.grid.filter.Filter} filter The filter being serialized.
             */
            'serialize',
            /**
             * @event update
             * Fires when a filter configuration has changed
             * @param {Ext.ux.grid.filter.Filter} this The filter object.
             */
            'update'
        );
        Ext.ux.grid.filter.Filter.superclass.constructor.call(this);

        this.menu = new Ext.menu.Menu();
        this.init(config);
        if(config && config.value){
            this.setValue(config.value);
            this.setActive(config.active !== false, true);
            delete config.value;
        }
    },

    /**
     * Destroys this filter by purging any event listeners, and removing any menus.
     */
    destroy : function(){
        if (this.menu){
            this.menu.destroy();
        }
        this.purgeListeners();
    },

    /**
     * Template method to be implemented by all subclasses that is to
     * initialize the filter and install required menu items.
     * Defaults to Ext.emptyFn.
     */
    init : Ext.emptyFn,
    
    /**
     * Template method to be implemented by all subclasses that is to
     * get and return the value of the filter.
     * Defaults to Ext.emptyFn.
     * @return {Object} The 'serialized' form of this filter
     * @methodOf Ext.ux.grid.filter.Filter
     */
    getValue : Ext.emptyFn,
    
    /**
     * Template method to be implemented by all subclasses that is to
     * set the value of the filter and fire the 'update' event.
     * Defaults to Ext.emptyFn.
     * @param {Object} data The value to set the filter
     * @methodOf Ext.ux.grid.filter.Filter
     */	
    setValue : Ext.emptyFn,
    
    /**
     * Template method to be implemented by all subclasses that is to
     * return <tt>true</tt> if the filter has enough configuration information to be activated.
     * Defaults to <tt>return true</tt>.
     * @return {Boolean}
     */
    isActivatable : function(){
        return true;
    },
    
    /**
     * Template method to be implemented by all subclasses that is to
     * get and return serialized filter data for transmission to the server.
     * Defaults to Ext.emptyFn.
     */
    getSerialArgs : Ext.emptyFn,

    /**
     * Template method to be implemented by all subclasses that is to
     * validates the provided Ext.data.Record against the filters configuration.
     * Defaults to <tt>return true</tt>.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function(){
        return true;
    },

    /**
     * Returns the serialized filter data for transmission to the server
     * and fires the 'serialize' event.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     * @methodOf Ext.ux.grid.filter.Filter
     */
    serialize : function(){
        var args = this.getSerialArgs();
        this.fireEvent('serialize', args, this);
        return args;
    },

    /** @private */
    fireUpdate : function(){
        if (this.active) {
            this.fireEvent('update', this);
        }
        this.setActive(this.isActivatable());
    },
    
    /**
     * Sets the status of the filter and fires the appropriate events.
     * @param {Boolean} active        The new filter state.
     * @param {Boolean} suppressEvent True to prevent events from being fired.
     * @methodOf Ext.ux.grid.filter.Filter
     */
    setActive : function(active, suppressEvent){
        if(this.active != active){
            this.active = active;
            if (suppressEvent !== true) {
                this.fireEvent(active ? 'activate' : 'deactivate', this);
            }
        }
    }    
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/** 
 * @class Ext.ux.grid.filter.StringFilter
 * @extends Ext.ux.grid.filter.Filter
 * Filter by a configurable Ext.form.TextField
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>    
var filters = new Ext.ux.grid.GridFilters({
    ...
    filters: [{
        // required configs
        type: 'string',
        dataIndex: 'name',
        
        // optional configs
        value: 'foo',
        active: true, // default is false
        iconCls: 'ux-gridfilter-text-icon' // default
        // any Ext.form.TextField configs accepted
    }]
});
 * </code></pre>
 */
Ext.ux.grid.filter.StringFilter = Ext.extend(Ext.ux.grid.filter.Filter, {

    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',

    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    width: 125,
    
    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        Ext.applyIf(config, {
            enableKeyEvents: true,
            iconCls: this.iconCls,
            listeners: {
                scope: this,
                keyup: this.onInputKeyUp
            }
        });

        this.inputItem = new Ext.form.TextField(config); 
        this.menu.add(this.inputItem);
        this.updateTask = new Ext.util.DelayedTask(this.fireUpdate, this);
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.inputItem.getValue();
    },
    
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
    setValue : function (value) {
        this.inputItem.setValue(value);
        this.fireEvent('update', this);
    },

    /**
     * @private
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.inputItem.getValue().length > 0;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'string', value: this.getValue()};
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex);

        if(typeof val != 'string') {
            return (this.getValue().length === 0);
        }

        return val.toLowerCase().indexOf(this.getValue().toLowerCase()) > -1;
    },
    
    /**  
     * @private
     * Handler method called when there is a keyup event on this.inputItem
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN && field.isValid()) {
            e.stopEvent();
            this.menu.hide(true);
            return;
        }
        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});

//DA : ajout de l'opérateur de comparaison meme dans le cas d'un filtre de type String.
// Ajout de cotes autour de la valeur retournée
Ext.override (Ext.ux.grid.filter.StringFilter, {
	getSerialArgs : function () {
        return {type: 'string', value: this.getValue() , comparison: 'LIKE'};
    }
});

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/** 
 * @class Ext.ux.grid.filter.DateFilter
 * @extends Ext.ux.grid.filter.Filter
 * Filter by a configurable Ext.menu.DateMenu
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>    
var filters = new Ext.ux.grid.GridFilters({
    ...
    filters: [{
        // required configs
        type: 'date',
        dataIndex: 'dateAdded',
        
        // optional configs
        dateFormat: 'm/d/Y',  // default
        beforeText: 'Before', // default
        afterText: 'After',   // default
        onText: 'On',         // default
        pickerOpts: {
            // any DateMenu configs
        },

        active: true // default is false
    }]
});
 * </code></pre>
 */
Ext.ux.grid.filter.DateFilter = Ext.extend(Ext.ux.grid.filter.Filter, {
    /**
     * @cfg {String} afterText
     * Defaults to 'After'.
     */
    afterText : 'After',
    /**
     * @cfg {String} beforeText
     * Defaults to 'Before'.
     */
    beforeText : 'Before',
    /**
     * @cfg {Object} compareMap
     * Map for assigning the comparison values used in serialization.
     */
    compareMap : {
        before: 'lt',
        after:  'gt',
        on:     'eq'
    },
    /**
     * @cfg {String} dateFormat
     * The date format to return when using getValue.
     * Defaults to 'm/d/Y'.
     */
    dateFormat : SITOOLS_DATE_FORMAT,

    /**
     * @cfg {Date} maxDate
     * Allowable date as passed to the Ext.DatePicker
     * Defaults to undefined.
     */
    /**
     * @cfg {Date} minDate
     * Allowable date as passed to the Ext.DatePicker
     * Defaults to undefined.
     */
    /**
     * @cfg {Array} menuItems
     * The items to be shown in this menu
     * Defaults to:<pre>
     * menuItems : ['before', 'after', '-', 'on'],
     * </pre>
     */
    menuItems : ['before', 'after', '-', 'on'],

    /**
     * @cfg {Object} menuItemCfgs
     * Default configuration options for each menu item
     */
    menuItemCfgs : {
        selectOnFocus: true,
        width: 125
    },

    /**
     * @cfg {String} onText
     * Defaults to 'On'.
     */
    onText : 'On',
    
    /**
     * @cfg {Object} pickerOpts
     * Configuration options for the date picker associated with each field.
     */
    pickerOpts : {
    	showTime : true	
    },

    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        var menuCfg, i, len, item, cfg, Cls;

        menuCfg = Ext.apply(this.pickerOpts, {
            minDate: this.minDate, 
            maxDate: this.maxDate, 
            format:  this.dateFormat,
            listeners: {
                scope: this,
                select: this.onMenuSelect
            }
        });

        this.fields = {};
        for (i = 0, len = this.menuItems.length; i < len; i++) {
            item = this.menuItems[i];
            if (item !== '-') {
                cfg = {
                    itemId: 'range-' + item,
                    text: this[item + 'Text'],
                    menu: new Ext.menu.DateMenu(
                        Ext.apply(menuCfg, {
                            itemId: item
                        })
                    ),
                    listeners: {
                        scope: this,
                        checkchange: this.onCheckChange
                    }
                };
                Cls = Ext.menu.CheckItem;
                item = this.fields[item] = new Cls(cfg);
            }
            //this.add(item);
            this.menu.add(item);
        }
    },

    onCheckChange : function () {
        this.setActive(this.isActivatable());
        this.fireEvent('update', this);
    },

    /**  
     * @private
     * Handler method called when there is a keyup event on an input
     * item of this menu.
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN && field.isValid()) {
            e.stopEvent();
            this.menu.hide(true);
            return;
        }
    },

    /**
     * Handler for when the menu for a field fires the 'select' event
     * @param {Object} date
     * @param {Object} menuItem
     * @param {Object} value
     * @param {Object} picker
     */
    onMenuSelect : function (menuItem, value, picker) {
        var fields = this.fields,
            field = this.fields[menuItem.itemId];
        
        field.setChecked(true);
        
        if (field == fields.on) {
            fields.before.setChecked(false, true);
            fields.after.setChecked(false, true);
        } else {
            fields.on.setChecked(false, true);
            if (field == fields.after && fields.before.menu.picker.value < value) {
                fields.before.setChecked(false, true);
            } else if (field == fields.before && fields.after.menu.picker.value > value) {
                fields.after.setChecked(false, true);
            }
        }
        this.fireEvent('update', this);
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var key, result = {};
        for (key in this.fields) {
            if (this.fields[key].checked) {
                result[key] = this.fields[key].menu.picker.getValue();
            }
        }
        return result;
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     * @param {Boolean} preserve true to preserve the checked status
     * of the other fields.  Defaults to false, unchecking the
     * other fields
     */	
    setValue : function (value, preserve) {
        var key;
        for (key in this.fields) {
            if(value[key]){
                this.fields[key].menu.picker.setValue(value[key]);
                this.fields[key].setChecked(true);
            } else if (!preserve) {
                this.fields[key].setChecked(false);
            }
        }
        this.fireEvent('update', this);
    },

    /**
     * @private
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        var key;
        for (key in this.fields) {
            if (this.fields[key].checked) {
                return true;
            }
        }
        return false;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var args = [];
        for (var key in this.fields) {
            if(this.fields[key].checked){
                args.push({
                    type: 'date',
                    comparison: this.compareMap[key],
                    value: this.getFieldValue(key).format(this.dateFormat)
                });
            }
        }
        return args;
    },

    /**
     * Get and return the date menu picker value
     * @param {String} item The field identifier ('before', 'after', 'on')
     * @return {Date} Gets the current selected value of the date field
     */
    getFieldValue : function(item){
        return this.fields[item].menu.picker.getValue();
    },
    
    /**
     * Gets the menu picker associated with the passed field
     * @param {String} item The field identifier ('before', 'after', 'on')
     * @return {Object} The menu picker
     */
    getPicker : function(item){
        return this.fields[item].menu.picker;
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var key,
            pickerValue,
            val = record.get(this.dataIndex);
            
        if(!Ext.isDate(val)){
            return false;
        }
        val = val.clearTime(true).getTime();
        
        for (key in this.fields) {
            if (this.fields[key].checked) {
                pickerValue = this.getFieldValue(key).clearTime(true).getTime();
                if (key == 'before' && pickerValue <= val) {
                    return false;
                }
                if (key == 'after' && pickerValue >= val) {
                    return false;
                }
                if (key == 'on' && pickerValue != val) {
                    return false;
                }
            }
        }
        return true;
    }
});

////DA : Ajout de cotes autour de la valeur retournée
//Ext.override (Ext.ux.grid.filter.DateFilter, {
//    getSerialArgs : function () {
//        var args = [];
//        for (var key in this.fields) {
//            if(this.fields[key].checked){
//                args.push({
//                    type: 'date',
//                    comparison: this.compareMap[key],
//                    value: this.getFieldValue(key).format(this.dateFormat)
//                });
//            }
//        }
//        return args;
//    }
//});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/** 
 * @class Ext.ux.grid.filter.ListFilter
 * @extends Ext.ux.grid.filter.Filter
 * <p>List filters are able to be preloaded/backed by an Ext.data.Store to load
 * their options the first time they are shown. ListFilter utilizes the
 * {@link Ext.ux.menu.ListMenu} component.</p>
 * <p>Although not shown here, this class accepts all configuration options
 * for {@link Ext.ux.menu.ListMenu}.</p>
 * 
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>    
var filters = new Ext.ux.grid.GridFilters({
    ...
    filters: [{
        type: 'list',
        dataIndex: 'size',
        phpMode: true,
        // options will be used as data to implicitly creates an ArrayStore
        options: ['extra small', 'small', 'medium', 'large', 'extra large']
    }]
});
 * </code></pre>
 * 
 */
Ext.ux.grid.filter.ListFilter = Ext.extend(Ext.ux.grid.filter.Filter, {

    /**
     * @cfg {Array} options
     * <p><code>data</code> to be used to implicitly create a data store
     * to back this list when the data source is <b>local</b>. If the
     * data for the list is remote, use the <code>{@link #store}</code>
     * config instead.</p>
     * <br><p>Each item within the provided array may be in one of the
     * following formats:</p>
     * <div class="mdetail-params"><ul>
     * <li><b>Array</b> :
     * <pre><code>
options: [
    [11, 'extra small'], 
    [18, 'small'],
    [22, 'medium'],
    [35, 'large'],
    [44, 'extra large']
]
     * </code></pre>
     * </li>
     * <li><b>Object</b> :
     * <pre><code>
labelField: 'name', // override default of 'text'
options: [
    {id: 11, name:'extra small'}, 
    {id: 18, name:'small'}, 
    {id: 22, name:'medium'}, 
    {id: 35, name:'large'}, 
    {id: 44, name:'extra large'} 
]
     * </code></pre>
     * </li>
     * <li><b>String</b> :
     * <pre><code>
     * options: ['extra small', 'small', 'medium', 'large', 'extra large']
     * </code></pre>
     * </li>
     */
    /**
     * @cfg {Boolean} phpMode
     * <p>Adjust the format of this filter. Defaults to false.</p>
     * <br><p>When GridFilters <code>@cfg encode = false</code> (default):</p>
     * <pre><code>
// phpMode == false (default):
filter[0][data][type] list
filter[0][data][value] value1
filter[0][data][value] value2
filter[0][field] prod 

// phpMode == true:
filter[0][data][type] list
filter[0][data][value] value1, value2
filter[0][field] prod 
     * </code></pre>
     * When GridFilters <code>@cfg encode = true</code>:
     * <pre><code>
// phpMode == false (default):
filter : [{"type":"list","value":["small","medium"],"field":"size"}]

// phpMode == true:
filter : [{"type":"list","value":"small,medium","field":"size"}]
     * </code></pre>
     */
    phpMode : false,
    /**
     * @cfg {Ext.data.Store} store
     * The {@link Ext.data.Store} this list should use as its data source
     * when the data source is <b>remote</b>. If the data for the list
     * is local, use the <code>{@link #options}</code> config instead.
     */

    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     * @param {Object} config
     */
    init : function (config) {
        this.dt = new Ext.util.DelayedTask(this.fireUpdate, this);

        // if a menu already existed, do clean up first
        if (this.menu){
            this.menu.destroy();
        }
        this.menu = new Ext.ux.menu.ListMenu(config);
        this.menu.on('checkchange', this.onCheckChange, this);
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getSelected();
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
    setValue : function (value) {
        this.menu.setSelected(value);
        this.fireEvent('update', this);
    },

    /**
     * @private
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.getValue().length > 0;
    },
    
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var args = {type: 'list', value: this.phpMode ? this.getValue().join(',') : this.getValue()};
        return args;
    },

    /** @private */
    onCheckChange : function(){
        this.dt.delay(this.updateBuffer);
    },
    
    
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        return this.getValue().indexOf(record.get(this.dataIndex)) > -1;
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/** 
 * @class Ext.ux.grid.filter.NumericFilter
 * @extends Ext.ux.grid.filter.Filter
 * Filters using an Ext.ux.menu.RangeMenu.
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>    
var filters = new Ext.ux.grid.GridFilters({
    ...
    filters: [{
        type: 'numeric',
        dataIndex: 'price'
    }]
});
 * </code></pre> 
 */
Ext.ux.grid.filter.NumericFilter = Ext.extend(Ext.ux.grid.filter.Filter, {

    /**
     * @cfg {Object} fieldCls
     * The Class to use to construct each field item within this menu
     * Defaults to:<pre>
     * fieldCls : Ext.form.NumberField
     * </pre>
     */
    fieldCls : Ext.form.NumberField,
    /**
     * @cfg {Object} fieldCfg
     * The default configuration options for any field item unless superseded
     * by the <code>{@link #fields}</code> configuration.
     * Defaults to:<pre>
     * fieldCfg : {}
     * </pre>
     * Example usage:
     * <pre><code>
fieldCfg : {
    width: 150,
},
     * </code></pre>
     */
    /**
     * @cfg {Object} fields
     * The field items may be configured individually
     * Defaults to <tt>undefined</tt>.
     * Example usage:
     * <pre><code>
fields : {
    gt: { // override fieldCfg options
        width: 200,
        fieldCls: Ext.ux.form.CustomNumberField // to override default {@link #fieldCls}
    }
},
     * </code></pre>
     */
    /**
     * @cfg {Object} iconCls
     * The iconCls to be applied to each comparator field item.
     * Defaults to:<pre>
iconCls : {
    gt : 'ux-rangemenu-gt',
    lt : 'ux-rangemenu-lt',
    eq : 'ux-rangemenu-eq'
}
     * </pre>
     */
    iconCls : {
        gte : 'ux-rangemenu-gte',
        lte : 'ux-rangemenu-lte',
        eq : 'ux-rangemenu-eq',
        gt : 'ux-rangemenu-gt',
        lt : 'ux-rangemenu-lt'
    },

    /**
     * @cfg {Object} menuItemCfgs
     * Default configuration options for each menu item
     * Defaults to:<pre>
menuItemCfgs : {
    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    width: 125
}
     * </pre>
     */
    menuItemCfgs : {
        emptyText: 'Enter Filter Text...',
        selectOnFocus: true,
        width: 125, 
        decimalPrecision : 20
    },

    /**
     * @cfg {Array} menuItems
     * The items to be shown in this menu.  Items are added to the menu
     * according to their position within this array. Defaults to:<pre>
     * menuItems : ['lt','gt','-','eq']
     * </pre>
     */
    menuItems : ['lte', 'gte', '-', 'eq', '-', 'lt', 'gt'],

    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        // if a menu already existed, do clean up first
        if (this.menu){
            this.menu.destroy();
        }        
        this.menu = new Ext.ux.menu.RangeMenu(Ext.apply(config, {
            // pass along filter configs to the menu
            fieldCfg : this.fieldCfg || {},
            fieldCls : this.fieldCls,
            fields : this.fields || {},
            iconCls: this.iconCls,
            menuItemCfgs: this.menuItemCfgs,
            menuItems: this.menuItems,
            updateBuffer: this.updateBuffer
        }));
        // relay the event fired by the menu
        this.menu.on('update', this.fireUpdate, this);
    },
    
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getValue();
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
    setValue : function (value) {
        this.menu.setValue(value);
    },

    /**
     * @private
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        var values = this.getValue();
        for (key in values) {
            if (values[key] !== undefined) {
                return true;
            }
        }
        return false;
    },
    
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var key,
            args = [],
            values = this.menu.getValue();
        for (key in values) {
            args.push({
                type: 'numeric',
                comparison: key,
                value: values[key]
            });
        }
        return args;
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex),
            values = this.getValue();
        if (values.eq !== undefined && val != values.eq) {
            return false;
        }
        if (values.lt !== undefined && val >= values.lt) {
            return false;
        }
        if (values.gt !== undefined && val <= values.gt) {
            return false;
        }
        return true;
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/** 
 * @class Ext.ux.grid.filter.BooleanFilter
 * @extends Ext.ux.grid.filter.Filter
 * Boolean filters use unique radio group IDs (so you can have more than one!)
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>    
var filters = new Ext.ux.grid.GridFilters({
    ...
    filters: [{
        // required configs
        type: 'boolean',
        dataIndex: 'visible'

        // optional configs
        defaultValue: null, // leave unselected (false selected by default)
        yesText: 'Yes',     // default
        noText: 'No'        // default
    }]
});
 * </code></pre>
 */
Ext.ux.grid.filter.BooleanFilter = Ext.extend(Ext.ux.grid.filter.Filter, {
	/**
	 * @cfg {Boolean} defaultValue
	 * Set this to null if you do not want either option to be checked by default. Defaults to false.
	 */
	defaultValue : false,
	/**
	 * @cfg {String} yesText
	 * Defaults to 'Yes'.
	 */
	yesText : "yes",
	/**
	 * @cfg {String} noText
	 * Defaults to 'No'.
	 */
	noText : "no",
	
	comparison : 'eq', 

    /**  
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        this.yesText = i18n.get('label.true');
        this.noText = i18n.get('label.false');
        var gId = Ext.id();
		this.options = [
			new Ext.menu.CheckItem({text: this.yesText, group: gId, checked: this.defaultValue === true}),
			new Ext.menu.CheckItem({text: this.noText, group: gId, checked: this.defaultValue === false})];
		
		this.menu.add(this.options[0], this.options[1]);
		
		for(var i=0; i<this.options.length; i++){
			this.options[i].on('click', this.fireUpdate, this);
			this.options[i].on('checkchange', this.fireUpdate, this);
		}
	},
	
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
		return this.options[0].checked;
	},

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */	
	setValue : function (value) {
		this.options[value ? 0 : 1].setChecked(true);
	},

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
		var args = {type: 'boolean', comparison : this.comparison, value: this.getValue()};
		return args;
	},
	
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
		return record.get(this.dataIndex) == this.getValue();
	}
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
Ext.ns('Ext.ux.menu');

/** 
 * @class Ext.ux.menu.RangeMenu
 * @extends Ext.menu.Menu
 * Custom implementation of Ext.menu.Menu that has preconfigured
 * items for gt, lt, eq.
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>    

 * </code></pre> 
 */
Ext.ux.menu.RangeMenu = Ext.extend(Ext.menu.Menu, {

    constructor : function (config) {

        Ext.ux.menu.RangeMenu.superclass.constructor.call(this, config);

        this.addEvents(
            /**
             * @event update
             * Fires when a filter configuration has changed
             * @param {Ext.ux.grid.filter.Filter} this The filter object.
             */
            'update'
        );
      
        this.updateTask = new Ext.util.DelayedTask(this.fireUpdate, this);
    
        var i, len, item, cfg, Cls;

        for (i = 0, len = this.menuItems.length; i < len; i++) {
            item = this.menuItems[i];
            if (item !== '-') {
                // defaults
                cfg = {
                    itemId: 'range-' + item,
                    enableKeyEvents: true,
                    iconCls: this.iconCls[item] || 'no-icon',
                    listeners: {
                        scope: this,
                        keyup: this.onInputKeyUp
                    }
                };
                Ext.apply(
                    cfg,
                    // custom configs
                    Ext.applyIf(this.fields[item] || {}, this.fieldCfg[item]),
                    // configurable defaults
                    this.menuItemCfgs
                );
                Cls = cfg.fieldCls || this.fieldCls;
                item = this.fields[item] = new Cls(cfg);
            }
            this.add(item);
        }
    },

    /**
     * @private
     * called by this.updateTask
     */
    fireUpdate : function () {
        this.fireEvent('update', this);
    },
    
    /**
     * Get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var result = {}, key, field;
        for (key in this.fields) {
            field = this.fields[key];
            if (field.isValid() && String(field.getValue()).length > 0) {
                result[key] = field.getValue();
            }
        }
        return result;
    },
  
    /**
     * Set the value of this menu and fires the 'update' event.
     * @param {Object} data The data to assign to this menu
     */	
    setValue : function (data) {
        var key;
        for (key in this.fields) {
            this.fields[key].setValue(data[key] !== undefined ? data[key] : '');
        }
        this.fireEvent('update', this);
    },

    /**  
     * @private
     * Handler method called when there is a keyup event on an input
     * item of this menu.
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN && field.isValid()) {
            e.stopEvent();
            this.hide(true);
            return;
        }
        
        if (field == this.fields.eq) {
            if (this.fields.gt) {
                this.fields.gt.setValue(null);
            }
            if (this.fields.lt) {
                this.fields.lt.setValue(null);
            }
        }
        else {
            this.fields.eq.setValue(null);
        }
        
        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
Ext.namespace('Ext.ux.menu');

/** 
 * @class Ext.ux.menu.ListMenu
 * @extends Ext.menu.Menu
 * This is a supporting class for {@link Ext.ux.grid.filter.ListFilter}.
 * Although not listed as configuration options for this class, this class
 * also accepts all configuration options from {@link Ext.ux.grid.filter.ListFilter}.
 */
Ext.ux.menu.ListMenu = Ext.extend(Ext.menu.Menu, {
    /**
     * @cfg {String} labelField
     * Defaults to 'text'.
     */
    labelField :  'text',
    /**
     * @cfg {String} paramPrefix
     * Defaults to 'Loading...'.
     */
    loadingText : 'Loading...',
    /**
     * @cfg {Boolean} loadOnShow
     * Defaults to true.
     */
    loadOnShow : true,
    /**
     * @cfg {Boolean} single
     * Specify true to group all items in this list into a single-select
     * radio button group. Defaults to false.
     */
    single : false,

    constructor : function (cfg) {
        this.selected = [];
        this.addEvents(
            /**
             * @event checkchange
             * Fires when there is a change in checked items from this list
             * @param {Object} item Ext.menu.CheckItem
             * @param {Object} checked The checked value that was set
             */
            'checkchange'
        );
      
        Ext.ux.menu.ListMenu.superclass.constructor.call(this, cfg = cfg || {});
    
        if(!cfg.store && cfg.options){
            var options = [];
            for(var i=0, len=cfg.options.length; i<len; i++){
                var value = cfg.options[i];
                switch(Ext.type(value)){
                    case 'array':  options.push(value); break;
                    case 'object': options.push([value.id, value[this.labelField]]); break;
                    case 'string': options.push([value, value]); break;
                }
            }
            
            this.store = new Ext.data.Store({
                reader: new Ext.data.ArrayReader({id: 0}, ['id', this.labelField]),
                data:   options,
                listeners: {
                    'load': this.onLoad,
                    scope:  this
                }
            });
            this.loaded = true;
        } else {
            this.add({text: this.loadingText, iconCls: 'loading-indicator'});
            this.store.on('load', this.onLoad, this);
        }
    },

    destroy : function () {
        if (this.store) {
            this.store.destroy();    
        }
        Ext.ux.menu.ListMenu.superclass.destroy.call(this);
    },

    /**
     * Lists will initially show a 'loading' item while the data is retrieved from the store.
     * In some cases the loaded data will result in a list that goes off the screen to the
     * right (as placement calculations were done with the loading item). This adapter will
     * allow show to be called with no arguments to show with the previous arguments and
     * thus recalculate the width and potentially hang the menu from the left.
     */
    show : function () {
        var lastArgs = null;
        return function(){
            if(arguments.length === 0){
                Ext.ux.menu.ListMenu.superclass.show.apply(this, lastArgs);
            } else {
                lastArgs = arguments;
                if (this.loadOnShow && !this.loaded) {
                    this.store.load();
                }
                Ext.ux.menu.ListMenu.superclass.show.apply(this, arguments);
            }
        };
    }(),
    
    /** @private */
    onLoad : function (store, records) {
        var visible = this.isVisible();
        this.hide(false);
        
        this.removeAll(true);
        
        var gid = this.single ? Ext.id() : null;
        for(var i=0, len=records.length; i<len; i++){
            var item = new Ext.menu.CheckItem({
                text:    records[i].get(this.labelField), 
                group:   gid,
                checked: this.selected.indexOf(records[i].id) > -1,
                hideOnClick: false});
            
            item.itemId = records[i].id;
            item.on('checkchange', this.checkChange, this);
                        
            this.add(item);
        }
        
        this.loaded = true;
        
        if (visible) {
            this.show();
        }	
        this.fireEvent('load', this, records);
    },

    /**
     * Get the selected items.
     * @return {Array} selected
     */
    getSelected : function () {
        return this.selected;
    },
    
    /** @private */
    setSelected : function (value) {
        value = this.selected = [].concat(value);

        if (this.loaded) {
            this.items.each(function(item){
                item.setChecked(false, true);
                for (var i = 0, len = value.length; i < len; i++) {
                    if (item.itemId == value[i]) {
                        item.setChecked(true, true);
                    }
                }
            }, this);
        }
    },
    
    /**
     * Handler for the 'checkchange' event from an check item in this menu
     * @param {Object} item Ext.menu.CheckItem
     * @param {Object} checked The checked value that was set
     */
    checkChange : function (item, checked) {
        var value = [];
        this.items.each(function(item){
            if (item.checked) {
                value.push(item.itemId);
            }
        },this);
        this.selected = value;
        
        this.fireEvent('checkchange', item, checked);
    }    
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*!
 * Ext JS Library 3.2.0
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
Ext.namespace('Ext.ux.grid');

/**
 * @class Ext.ux.grid.GridFilters
 * @extends Ext.util.Observable
 * <p>GridFilter is a plugin (<code>ptype='gridfilters'</code>) for grids that
 * allow for a slightly more robust representation of filtering than what is
 * provided by the default store.</p>
 * <p>Filtering is adjusted by the user using the grid's column header menu
 * (this menu can be disabled through configuration). Through this menu users
 * can configure, enable, and disable filters for each column.</p>
 * <p><b><u>Features:</u></b></p>
 * <div class="mdetail-params"><ul>
 * <li><b>Filtering implementations</b> :
 * <div class="sub-desc">
 * Default filtering for Strings, Numeric Ranges, Date Ranges, Lists (which can
 * be backed by a Ext.data.Store), and Boolean. Additional custom filter types
 * and menus are easily created by extending Ext.ux.grid.filter.Filter.
 * </div></li>
 * <li><b>Graphical indicators</b> :
 * <div class="sub-desc">
 * Columns that are filtered have {@link #filterCls a configurable css class}
 * applied to the column headers.
 * </div></li>
 * <li><b>Paging</b> :
 * <div class="sub-desc">
 * If specified as a plugin to the grid's configured PagingToolbar, the current page
 * will be reset to page 1 whenever you update the filters.
 * </div></li>
 * <li><b>Automatic Reconfiguration</b> :
 * <div class="sub-desc">
 * Filters automatically reconfigure when the grid 'reconfigure' event fires.
 * </div></li>
 * <li><b>Stateful</b> :
 * Filter information will be persisted across page loads by specifying a
 * <code>stateId</code> in the Grid configuration.
 * <div class="sub-desc">
 * The filter collection binds to the
 * <code>{@link Ext.grid.GridPanel#beforestaterestore beforestaterestore}</code>
 * and <code>{@link Ext.grid.GridPanel#beforestatesave beforestatesave}</code>
 * events in order to be stateful.
 * </div></li>
 * <li><b>Grid Changes</b> :
 * <div class="sub-desc"><ul>
 * <li>A <code>filters</code> <i>property</i> is added to the grid pointing to
 * this plugin.</li>
 * <li>A <code>filterupdate</code> <i>event</i> is added to the grid and is
 * fired upon onStateChange completion.</li>
 * </ul></div></li>
 * <li><b>Server side code examples</b> :
 * <div class="sub-desc"><ul>
 * <li><a href="http://www.vinylfox.com/extjs/grid-filter-php-backend-code.php">PHP</a> - (Thanks VinylFox)</li>
 * <li><a href="http://extjs.com/forum/showthread.php?p=77326#post77326">Ruby on Rails</a> - (Thanks Zyclops)</li>
 * <li><a href="http://extjs.com/forum/showthread.php?p=176596#post176596">Ruby on Rails</a> - (Thanks Rotomaul)</li>
 * <li><a href="http://www.debatablybeta.com/posts/using-extjss-grid-filtering-with-django/">Python</a> - (Thanks Matt)</li>
 * <li><a href="http://mcantrell.wordpress.com/2008/08/22/extjs-grids-and-grails/">Grails</a> - (Thanks Mike)</li>
 * </ul></div></li>
 * </ul></div>
 * <p><b><u>Example usage:</u></b></p>
 * <pre><code>
var store = new Ext.data.GroupingStore({
    ...
});

var filters = new Ext.ux.grid.GridFilters({
    autoReload: false, //don&#39;t reload automatically
    local: true, //only filter locally
    // filters may be configured through the plugin,
    // or in the column definition within the column model configuration
    filters: [{
        type: 'numeric',
        dataIndex: 'id'
    }, {
        type: 'string',
        dataIndex: 'name'
    }, {
        type: 'numeric',
        dataIndex: 'price'
    }, {
        type: 'date',
        dataIndex: 'dateAdded'
    }, {
        type: 'list',
        dataIndex: 'size',
        options: ['extra small', 'small', 'medium', 'large', 'extra large'],
        phpMode: true
    }, {
        type: 'boolean',
        dataIndex: 'visible'
    }]
});
var cm = new Ext.grid.ColumnModel([{
    ...
}]);

var grid = new Ext.grid.GridPanel({
     ds: store,
     cm: cm,
     view: new Ext.grid.GroupingView(),
     plugins: [filters],
     height: 400,
     width: 700,
     bbar: new Ext.PagingToolbar({
         store: store,
         pageSize: 15,
         plugins: [filters] //reset page to page 1 if filters change
     })
 });

store.load({params: {start: 0, limit: 15}});

// a filters property is added to the grid
grid.filters
 * </code></pre>
 */
Ext.ux.grid.GridFilters = Ext.extend(Ext.util.Observable, {
    /**
     * @cfg {Boolean} autoReload
     * Defaults to true, reloading the datasource when a filter change happens.
     * Set this to false to prevent the datastore from being reloaded if there
     * are changes to the filters.  See <code>{@link updateBuffer}</code>.
     */
    autoReload : true,
    /**
     * @cfg {Boolean} encode
     * Specify true for {@link #buildQuery} to use Ext.util.JSON.encode to
     * encode the filter query parameter sent with a remote request.
     * Defaults to false.
     */
    /**
     * @cfg {Array} filters
     * An Array of filters config objects. Refer to each filter type class for
     * configuration details specific to each filter type. Filters for Strings,
     * Numeric Ranges, Date Ranges, Lists, and Boolean are the standard filters
     * available.
     */
    /**
     * @cfg {String} filterCls
     * The css class to be applied to column headers with active filters.
     * Defaults to <tt>'ux-filterd-column'</tt>.
     */
    filterCls : 'ux-filtered-column',
    /**
     * @cfg {Boolean} local
     * <tt>true</tt> to use Ext.data.Store filter functions (local filtering)
     * instead of the default (<tt>false</tt>) server side filtering.
     */
    local : false,
    /**
     * @cfg {String} menuFilterText
     * defaults to <tt>'Filters'</tt>.
     */
    menuFilterText : 'Filters',
    /**
     * @cfg {String} paramPrefix
     * The url parameter prefix for the filters.
     * Defaults to <tt>'filter'</tt>.
     */
    paramPrefix : 'filter',
    /**
     * @cfg {Boolean} showMenu
     * Defaults to true, including a filter submenu in the default header menu.
     */
    showMenu : true,
    /**
     * @cfg {String} stateId
     * Name of the value to be used to store state information.
     */
    stateId : undefined,
    /**
     * @cfg {Integer} updateBuffer
     * Number of milliseconds to defer store updates since the last filter change.
     */
    updateBuffer : 500,

    /** @private */
    constructor : function (config) {
        config = config || {};
        this.deferredUpdate = new Ext.util.DelayedTask(this.reload, this);
        this.filters = new Ext.util.MixedCollection();
        this.filters.getKey = function (o) {
            return o ? o.dataIndex : null;
        };
        this.addFilters(config.filters);
        delete config.filters;
        Ext.apply(this, config);
    },

    /** @private */
    init : function (grid) {
        if (grid instanceof Ext.grid.GridPanel) {
            this.grid = grid;

            this.bindStore(this.grid.getStore(), true);
            // assumes no filters were passed in the constructor, so try and use ones from the colModel
//            if(this.filters.getCount() == 0){
//                this.addFilters(this.grid.getColumnModel());
//            }

            this.grid.filters = this;

            this.grid.addEvents({'filterupdate': true});

            grid.on({
                scope: this,
                beforestaterestore: this.applyState,
                beforestatesave: this.saveState,
                beforedestroy: this.destroy,
                reconfigure: this.onReconfigure
            });

            if (grid.rendered){
                this.onRender();
            } else {
                grid.on({
                    scope: this,
                    single: true,
                    render: this.onRender
                });
            }

        } else if (grid instanceof Ext.PagingToolbar) {
            this.toolbar = grid;
        }
    },

    /**
     * @private
     * Handler for the grid's beforestaterestore event (fires before the state of the
     * grid is restored).
     * @param {Object} grid The grid object
     * @param {Object} state The hash of state values returned from the StateProvider.
     */
    applyState : function (grid, state) {
        var key, filter;
        this.applyingState = true;
        this.clearFilters();
        if (state.filters) {
            for (key in state.filters) {
                filter = this.filters.get(key);
                if (filter) {
                    filter.setValue(state.filters[key]);
                    filter.setActive(true);
                }
            }
        }
        this.deferredUpdate.cancel();
        if (this.local) {
            this.reload();
        }
        delete this.applyingState;
    },

    /**
     * Saves the state of all active filters
     * @param {Object} grid
     * @param {Object} state
     * @return {Boolean}
     */
    saveState : function (grid, state) {
        var filters = {};
        this.filters.each(function (filter) {
            if (filter.active) {
                filters[filter.dataIndex] = filter.getValue();
            }
        });
        return (state.filters = filters);
    },

    /**
     * @private
     * Handler called when the grid is rendered
     */
    onRender : function () {
        this.grid.getView().on('refresh', this.onRefresh, this);
        this.createMenu();
    },

    /**
     * @private
     * Handler called by the grid 'beforedestroy' event
     */
    destroy : function () {
        this.removeAll();
        this.purgeListeners();

        if(this.filterMenu){
            Ext.menu.MenuMgr.unregister(this.filterMenu);
            this.filterMenu.destroy();
             this.filterMenu = this.menu.menu = null;
        }
    },

    /**
     * Remove all filters, permanently destroying them.
     */
    removeAll : function () {
        if(this.filters){
            Ext.destroy.apply(Ext, this.filters.items);
            // remove all items from the collection
            this.filters.clear();
        }
    },


    /**
     * Changes the data store bound to this view and refreshes it.
     * @param {Store} store The store to bind to this view
     */
    bindStore : function(store, initial){
        if(!initial && this.store){
            if (this.local) {
                store.un('load', this.onLoad, this);
            } else {
                store.un('beforeload', this.onBeforeLoad, this);
            }
        }
        if(store){
            if (this.local) {
                store.on('load', this.onLoad, this);
            } else {
                store.on('beforeload', this.onBeforeLoad, this);
            }
        }
        this.store = store;
    },

    /**
     * @private
     * Handler called when the grid reconfigure event fires
     */
    onReconfigure : function () {
        this.bindStore(this.grid.getStore());
        this.store.clearFilter();
        this.removeAll();
        this.addFilters(this.grid.getColumnModel());
        this.updateColumnHeadings();
    },

    createMenu : function () {
        var view = this.grid.getView(),
            hmenu = view.hmenu;

        if (this.showMenu && hmenu) {

            this.sep  = hmenu.addSeparator();
            this.filterMenu = new Ext.menu.Menu({
                id: this.grid.id + '-filters-menu'
            });
            this.menu = hmenu.add({
                checked: false,
                itemId: 'filters',
                text: this.menuFilterText,
                menu: this.filterMenu
            });

            this.menu.on({
                scope: this,
                checkchange: this.onCheckChange,
                beforecheckchange: this.onBeforeCheck
            });
            hmenu.on('beforeshow', this.onMenu, this);
        }
        this.updateColumnHeadings();
    },

    /**
     * @private
     * Get the filter menu from the filters MixedCollection based on the clicked header
     */
    getMenuFilter : function () {
        var view = this.grid.getView();
        if (!view || view.hdCtxIndex === undefined) {
            return null;
        }
        return this.filters.get(
            view.cm.config[view.hdCtxIndex].dataIndex
        );
    },

    /**
     * @private
     * Handler called by the grid's hmenu beforeshow event
     */
    onMenu : function (filterMenu) {
        var filter = this.getMenuFilter();

        if (filter) {
/*
TODO: lazy rendering
            if (!filter.menu) {
                filter.menu = filter.createMenu();
            }
*/
            this.menu.menu = filter.menu;
            this.menu.setChecked(filter.active, false);
            // disable the menu if filter.disabled explicitly set to true
            this.menu.setDisabled(filter.disabled === true);
        }

        this.menu.setVisible(filter !== undefined);
        this.sep.setVisible(filter !== undefined);
    },

    /** @private */
    onCheckChange : function (item, value) {
        this.getMenuFilter().setActive(value);
    },

    /** @private */
    onBeforeCheck : function (check, value) {
        return !value || this.getMenuFilter().isActivatable();
    },

    /**
     * @private
     * Handler for all events on filters.
     * @param {String} event Event name
     * @param {Object} filter Standard signature of the event before the event is fired
     */
    onStateChange : function (event, filter) {
        if (event === 'serialize') {
            return;
        }

        if (filter == this.getMenuFilter()) {
            this.menu.setChecked(filter.active, false);
        }

        if ((this.autoReload || this.local) && !this.applyingState) {
            this.deferredUpdate.delay(this.updateBuffer);
        }
        this.updateColumnHeadings();

        if (!this.applyingState) {
            this.grid.saveState();
        }
        this.grid.fireEvent('filterupdate', this, filter);
    },

    /**
     * @private
     * Handler for store's beforeload event when configured for remote filtering
     * @param {Object} store
     * @param {Object} options
     */
    onBeforeLoad : function (store, options) {
        options.params = options.params || {};
        this.cleanParams(options.params);
        var params = this.buildQuery(this.getFilterData());
        Ext.apply(options.params, params);
        //save the options has last options in the store
        store.storeOptions(options);
    },

    /**
     * @private
     * Handler for store's load event when configured for local filtering
     * @param {Object} store
     * @param {Object} options
     */
    onLoad : function (store, options) {
        store.filterBy(this.getRecordFilter());
    },

    /**
     * @private
     * Handler called when the grid's view is refreshed
     */
    onRefresh : function () {
        this.updateColumnHeadings();
    },

    /**
     * Update the styles for the header row based on the active filters
     */
    updateColumnHeadings : function () {
        var view = this.grid.getView(),
            i, len, filter;
        if (view.mainHd) {
            for (i = 0, len = view.cm.config.length; i < len; i++) {
                filter = this.getFilter(view.cm.config[i].dataIndex);
                Ext.fly(view.getHeaderCell(i))[filter && filter.active ? 'addClass' : 'removeClass'](this.filterCls);
            }
        }
    },

    /** @private */
    reload : function () {
        if (this.local) {
            this.grid.store.clearFilter(true);
            this.grid.store.filterBy(this.getRecordFilter());
        } else {
            var start,
                store = this.grid.store;
            this.deferredUpdate.cancel();
            if (this.toolbar) {
                start = store.paramNames.start;
                if (store.lastOptions && store.lastOptions.params && store.lastOptions.params[start]) {
                    store.lastOptions.params[start] = 0;
                }
            }
            //set that there as been a new filter added, or one removed
            store.isNewFilter = true;
            store.reload();
        }
    },

    /**
     * Method factory that generates a record validator for the filters active at the time
     * of invokation.
     * @private
     */
    getRecordFilter : function () {
        var f = [], len, i;
        this.filters.each(function (filter) {
            if (filter.active) {
                f.push(filter);
            }
        });

        len = f.length;
        return function (record) {
            for (i = 0; i < len; i++) {
                if (!f[i].validateRecord(record)) {
                    return false;
                }
            }
            return true;
        };
    },

    /**
     * Adds a filter to the collection and observes it for state change.
     * @param {Object/Ext.ux.grid.filter.Filter} config A filter configuration or a filter object.
     * @return {Ext.ux.grid.filter.Filter} The existing or newly created filter object.
     */
    addFilter : function (config) {
        var Cls = this.getFilterClass(config.type),
            filter = config.menu ? config : (new Cls(config));
        this.filters.add(filter);

        Ext.util.Observable.capture(filter, this.onStateChange, this);
        return filter;
    },

    /**
     * Adds filters to the collection.
     * @param {Array/Ext.grid.ColumnModel} filters Either an Array of
     * filter configuration objects or an Ext.grid.ColumnModel.  The columns
     * of a passed Ext.grid.ColumnModel will be examined for a <code>filter</code>
     * property and, if present, will be used as the filter configuration object.
     */
    addFilters : function (filters) {
        if (filters) {
            var i, len, filter, cm = false, dI;
            if (filters instanceof Ext.grid.ColumnModel) {
                filters = filters.config;
                cm = true;
            }
            for (i = 0, len = filters.length; i < len; i++) {
                filter = false;
                if (cm) {
                    dI = filters[i].dataIndex;
                    cA = filters[i].columnAlias;
                    filter = filters[i].filter || filters[i].filterable;
                    if (filter){
                        filter = (filter === true) ? {} : filter;
                        Ext.apply(filter, {dataIndex:dI, columnAlias : cA});
                        // filter type is specified in order of preference:
                        //     filter type specified in config
                        //     type specified in store's field's type config
                        filter.type = filter.type || this.store.fields.get(dI).type.type;
                    }
                } else {
                    filter = filters[i];
                }
                // if filter config found add filter for the column
                if (filter) {
                    this.addFilter(filter);
                }
            }
        }
    },

    /**
     * Returns a filter for the given dataIndex, if one exists.
     * @param {String} dataIndex The dataIndex of the desired filter object.
     * @return {Ext.ux.grid.filter.Filter}
     */
    getFilter : function (dataIndex) {
        return this.filters.get(dataIndex);
    },

    /**
     * Turns all filters off. This does not clear the configuration information
     * (see {@link #removeAll}).
     */
    clearFilters : function () {
        this.filters.each(function (filter) {
            filter.setActive(false);
        });
    },

    /**
     * Returns an Array of the currently active filters.
     * @return {Array} filters Array of the currently active filters.
     */
    getFilterData : function () {
        var filters = [], i, len;

        this.filters.each(function (f) {
            if (f.active) {
                var d = [].concat(f.serialize());
                for (i = 0, len = d.length; i < len; i++) {
                    filters.push({
                    	field: f.dataIndex,
                        data: d[i]
                    });
                }
            }
        });
        return filters;
    },

    /**
     * Function to take the active filters data and build it into a query.
     * The format of the query depends on the <code>{@link #encode}</code>
     * configuration:
     * <div class="mdetail-params"><ul>
     *
     * <li><b><tt>false</tt></b> : <i>Default</i>
     * <div class="sub-desc">
     * Flatten into query string of the form (assuming <code>{@link #paramPrefix}='filters'</code>:
     * <pre><code>
filters[0][field]="someDataIndex"&
filters[0][data][comparison]="someValue1"&
filters[0][data][type]="someValue2"&
filters[0][data][value]="someValue3"&
     * </code></pre>
     * </div></li>
     * <li><b><tt>true</tt></b> :
     * <div class="sub-desc">
     * JSON encode the filter data
     * <pre><code>
filters[0][field]="someDataIndex"&
filters[0][data][comparison]="someValue1"&
filters[0][data][type]="someValue2"&
filters[0][data][value]="someValue3"&
     * </code></pre>
     * </div></li>
     * </ul></div>
     * Override this method to customize the format of the filter query for remote requests.
     * @param {Array} filters A collection of objects representing active filters and their configuration.
     *    Each element will take the form of {field: dataIndex, data: filterConf}. dataIndex is not assured
     *    to be unique as any one filter may be a composite of more basic filters for the same dataIndex.
     * @return {Object} Query keys and values
     */
    buildQuery : function (filters) {
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;

        if (!this.encode){
            for (i = 0; i < len; i++) {
                f = filters[i];
                root = [this.paramPrefix, '[', i, ']'].join('');
                p[root + '[field]'] = f.field;

                dataPrefix = root + '[data]';
                for (key in f.data) {
                    p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
                }
            }
        } else {
            tmp = [];
            for (i = 0; i < len; i++) {
                f = filters[i];
                tmp.push(Ext.apply(
                    {},
                    {field: f.field},
                    f.data
                ));
            }
            // only build if there is active filter
            if (tmp.length > 0){
                p[this.paramPrefix] = Ext.util.JSON.encode(tmp);
            }
        }
        return p;
    },

    /**
     * Removes filter related query parameters from the provided object.
     * @param {Object} p Query parameters that may contain filter related fields.
     */
    cleanParams : function (p) {
        // if encoding just delete the property
        if (this.encode) {
            delete p[this.paramPrefix];
        // otherwise scrub the object of filter data
        } else {
            var regex, key;
            regex = new RegExp('^' + this.paramPrefix + '\[[0-9]+\]');
            for (key in p) {
                if (regex.test(key)) {
                    delete p[key];
                }
            }
        }
    },

    /**
     * Function for locating filter classes, overwrite this with your favorite
     * loader to provide dynamic filter loading.
     * @param {String} type The type of filter to load ('Filter' is automatically
     * appended to the passed type; eg, 'string' becomes 'StringFilter').
     * @return {Class} The Ext.ux.grid.filter.Class
     */
    getFilterClass : function (type) {
        // map the supported Ext.data.Field type values into a supported filter
        switch(type) {
            case 'auto':
            case 'string':
              type = 'string';
              break;
            case 'int':
            case 'float':
              type = 'numeric';
              break;
            case 'date' :
            case 'dateAsString' :
              type = 'date'
              break;
        }
        return Ext.ux.grid.filter[type.substr(0, 1).toUpperCase() + type.substr(1) + 'Filter'];
    }
});

// register ptype
Ext.preg('gridfilters', Ext.ux.grid.GridFilters);

/**
 * Overrides the methods getFilterData and buildQuery
 * @class Ext.ux.grid.GridFiltersSpe
 * @extends Ext.ux.grid.GridFilters
 */
Ext.ux.grid.GridFiltersSpe = Ext.extend(Ext.ux.grid.GridFilters, {
    /**
     * Returns an Array of the currently active filters.
     * @return {Array} filters Array of the currently active filters.
     */
    getFilterData : function () {
	    var filters = [], i, len;
	
	    this.filters.each(function (f) {
	        if (f.active) {
	            var d = [].concat(f.serialize());
	            for (i = 0, len = d.length; i < len; i++) {
	                filters.push({
	                    //David Arpin : définir le columnAlias au niveau du champ
	                	columnAlias: f.columnAlias, 
	                    data: d[i]
	                });
	            }
	        }
	    });
	    return filters;
	}, 
    /**
     * Function to take the active filters data and build it into a query.
     * The format of the query depends on the <code>{@link #encode}</code>
     * configuration:
     * <div class="mdetail-params"><ul>
     *
     * <li><b><tt>false</tt></b> : <i>Default</i>
     * <div class="sub-desc">
     * Flatten into query string of the form (assuming <code>{@link #paramPrefix}='filters'</code>:
     * <pre><code>
filters[0][columnAlias]="someDataIndex"&
filters[0][data][comparison]="someValue1"&
filters[0][data][type]="someValue2"&
filters[0][data][value]="someValue3"&
     * </code></pre>
     * </div></li>
     * <li><b><tt>true</tt></b> :
     * <div class="sub-desc">
     * JSON encode the filter data
     * <pre><code>
filters[0][columnAlias]="someDataIndex"&
filters[0][data][comparison]="someValue1"&
filters[0][data][type]="someValue2"&
filters[0][data][value]="someValue3"&
     * </code></pre>
     * </div></li>
     * </ul></div>
     * Override this method to customize the format of the filter query for remote requests.
     * @param {Array} filters A collection of objects representing active filters and their configuration.
     *    Each element will take the form of {field: dataIndex, data: filterConf}. dataIndex is not assured
     *    to be unique as any one filter may be a composite of more basic filters for the same dataIndex.
     * @return {Object} Query keys and values
     */
    buildQuery : function (filters) {
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;

        if (!this.encode){
            for (i = 0; i < len; i++) {
                f = filters[i];
                root = [this.paramPrefix, '[', i, ']'].join('');
                p[root + '[columnAlias]'] = f.columnAlias;
                
                dataPrefix = root + '[data]';
                for (key in f.data) {
                    p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
                }
            }
        } else {
            tmp = [];
            for (i = 0; i < len; i++) {
                f = filters[i];
                tmp.push(Ext.apply(
                    {},
                    {columnAlias: f.columnAlias},
                    f.data
                ));
            }
            // only build if there is active filter
            if (tmp.length > 0){
                p[this.paramPrefix] = Ext.util.JSON.encode(tmp);
            }
        }
        return p;
    }
});
Ext.preg('gridfiltersspe', Ext.ux.grid.GridFiltersSpe);


/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/**
 * Ext.ux.grid.livegrid.GridPanel Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.GridPanel is licensed under the terms of the GNU Open
 * Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

/*global Ext, sitools, i18n, extColModelToSrv*/

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.GridPanel
 * @extends Ext.grid.GridPanel
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.GridPanel = Ext.extend(Ext.grid.GridPanel, {

    initComponent : function () {
        if (this.cls) {
            this.cls += ' ext-ux-livegrid';
        } else {
            this.cls = 'ext-ux-livegrid';
        }

        Ext.ux.grid.livegrid.GridPanel.superclass.initComponent.call(this);
    },

    /**
     * Overriden to make sure the attached store loads only when the grid has
     * been fully rendered if, and only if the store's "autoLoad" property is
     * set to true.
     * 
     */
    onRender : function (ct, position) {
        Ext.ux.grid.livegrid.GridPanel.superclass.onRender.call(this, ct, position);

        var ds = this.getStore();

        if (ds._autoLoad === true) {
            delete ds._autoLoad;
            ds.load();
        }
    },

    /**
     * Overriden since the original implementation checks for getCount() of the
     * store, not getTotalCount().
     * 
     */
    walkCells : function (row, col, step, fn, scope) {
        var ds = this.store;
        var _oF = ds.getCount;

        ds.getCount = ds.getTotalCount;

        var ret = Ext.ux.grid.livegrid.GridPanel.superclass.walkCells.call(this, row, col, step, fn, scope);

        ds.getCount = _oF;

        return ret;
    }

});
/**
 * Ext.ux.grid.livegrid.GridView Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.GridView is licensed under the terms of the GNU Open
 * Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.GridView
 * @extends Ext.grid.GridView
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.GridView = function (config) {

    this.addEvents({
        /**
         * @event beforebuffer Fires when the store is about to buffer new data.
         * @param {Ext.ux.BufferedGridView}
         *            this
         * @param {Ext.data.Store}
         *            store The store
         * @param {Number}
         *            rowIndex
         * @param {Number}
         *            visibleRows
         * @param {Number}
         *            totalCount
         * @param {Number}
         *            options The options with which the buffer request was
         *            called
         */
        'beforebuffer' : true,
        /**
         * @event buffer Fires when the store is finsihed buffering new data.
         * @param {Ext.ux.BufferedGridView}
         *            this
         * @param {Ext.data.Store}
         *            store The store
         * @param {Number}
         *            rowIndex
         * @param {Number}
         *            visibleRows
         * @param {Number}
         *            totalCount
         * @param {Object}
         *            options
         */
        'buffer' : true,
        /**
         * @event bufferfailure Fires when buffering failed.
         * @param {Ext.ux.BufferedGridView}
         *            this
         * @param {Ext.data.Store}
         *            store The store
         * @param {Object}
         *            options The options the buffer-request was initiated with
         */
        'bufferfailure' : true,
        /**
         * @event cursormove Fires when the the user scrolls through the data.
         * @param {Ext.ux.BufferedGridView}
         *            this
         * @param {Number}
         *            rowIndex The index of the first visible row in the grid
         *            absolute to it's position in the model.
         * @param {Number}
         *            visibleRows The number of rows visible in the grid.
         * @param {Number}
         *            totalCount
         */
        'cursormove' : true,
        /**
         * @event abortrequest Fires when the store is about to reload (this
         *        does NOT mean buffering). If you are using a custom proxy in
         *        your store, you should listen to this event and abort any
         *        ongoing server request established in your custom proxy.
         * @param {Ext.data.Store}
         *            store
         * @param {Object}
         *            options
         */
        'abortrequest' : true

    });

    /**
     * @cfg {Number} scrollDelay The number of microseconds a call to the
     *      onLiveScroll-lisener should be delayed when the scroll event fires
     */

    /**
     * @cfg {Number} bufferSize The number of records that will at least always
     *      be available in the store for rendering. This value will be send to
     *      the server as the <tt>limit</tt> parameter and should not change
     *      during the lifetime of a grid component. Note: In a paging grid,
     *      this number would indicate the page size. The value should be set
     *      high enough to make a userfirendly scrolling possible and should be
     *      greater than the sum of {nearLimit} and {visibleRows}. Usually, a
     *      value in between 150 and 200 is good enough. A lesser value will
     *      more often make the store re-request new data, while a larger number
     *      will make loading times higher.
     */

    /**
     * @cfg {Number} nearLimit This value represents a near value that is
     *      responsible for deciding if a request for new data is needed. The
     *      lesser the number, the more often new data will be requested. The
     *      number should be set to a value that lies in between 1/4 to 1/2 of
     *      the {bufferSize}.
     */

    /**
     * @cfg {Number} horizontalScrollOffset The height of a horizontal aligned
     *      scrollbar. The scrollbar is shown if the total width of all visible
     *      columns exceeds the width of the grid component. On Windows XP (IE7,
     *      FF2), this value defaults to 17.
     */
    this.horizontalScrollOffset = 17;

    /**
     * @type {Boolean} _checkEmptyBody Since Ext 3.0, &nbsp; would initially
     *       added to the mainBody as the first child if there are no rows to
     *       render. This element has to be removed when the first rows get
     *       added so the UI does not crash. This property is here to determine
     *       if this element was already removed, so we don't have to query
     *       innerHTML all the time.
     */
    this._checkEmptyBody = true;

    Ext.apply(this, config);

    this.templates = {};
    /**
     * The master template adds an addiiotnal scrollbar to make cursoring in the
     * data possible.
     */
    this.templates.master = new Ext.Template(
            '<div class="x-grid3" hidefocus="true"><div class="liveScroller"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>',
            '<div class="x-grid3-viewport"">',
            '<div class="x-grid3-header"><div class="x-grid3-header-inner"><div class="x-grid3-header-offset" style="{ostyle}">{header}</div></div><div class="x-clear"></div></div>',
            '<div class="x-grid3-scroller" style="overflow-y:hidden !important;"><div class="x-grid3-body" style="{bstyle}">{body}</div><a href="#" class="x-grid3-focus" tabIndex="-1"></a></div>',
            "</div>", '<div class="x-grid3-resize-marker">&#160;</div>',
            '<div class="x-grid3-resize-proxy">&#160;</div>', "</div>");

    // shorthands for often used parent classes
    this._gridViewSuperclass = Ext.ux.grid.livegrid.GridView.superclass;

    this._gridViewSuperclass.constructor.call(this);

};

Ext.extend(Ext.ux.grid.livegrid.GridView, Ext.ux.sitoolsGridView, {

    // {{{
    // --------------------------properties-------------------------------------

    /**
     * Stores the height of the header. Needed for recalculating scroller inset
     * height.
     * 
     * @param {Number}
     */
    hdHeight : 0,

    /**
     * Indicates wether the last row in the grid is clipped and thus not fully
     * display. 1 if clipped, otherwise 0.
     * 
     * @param {Number}
     */
    rowClipped : 0,

    /**
     * This is the actual y-scroller that does control sending request to the
     * server based upon the position of the scrolling cursor.
     * 
     * @param {Ext.Element}
     */
    liveScroller : null,

    /**
     * This array holds the divs that represent the amount of data in a given
     * repository. The sum of heights of this divs gets computed via the total
     * amount of records multiplied with the fixed(!) row height. There is a
     * total of 3 divs responsible for the scroll amount to prevent issues with
     * the max number of pxiels a div alone can grow in height.
     * 
     * @param {native
     *            HTMLObject}
     */
    liveScrollerInsets : null,

    /**
     * The <b>fixed</b> row height for <b>every</b> row in the grid. The value
     * is computed once the store has been loaded for the first time and used
     * for various calculations during the lifetime of the grid component, such
     * as the height of the scroller and the number of visible rows.
     * 
     * @param {Number}
     */
    rowHeight : -1,

    /**
     * Stores the number of visible rows that have to be rendered.
     * 
     * @param {Number}
     */
    visibleRows : 1,

    /**
     * Stores the last offset relative to a previously scroll action. This is
     * needed for deciding wether the user scrolls up or down.
     * 
     * @param {Number}
     */
    lastIndex : -1,

    /**
     * Stores the last visible row at position "0" in the table view before a
     * new scroll event was created and fired.
     * 
     * @param {Number}
     */
    lastRowIndex : 0,

    /**
     * Stores the value of the <tt>liveScroller</tt>'s <tt>scrollTop</tt>
     * DOM property.
     * 
     * @param {Number}
     */
    lastScrollPos : 0,

    /**
     * The current index of the row in the model that is displayed as the first
     * visible row in the view.
     * 
     * @param {Number}
     */
    rowIndex : 0,

    /**
     * Set to <tt>true</tt> if the store is busy with loading new data.
     * 
     * @param {Boolean}
     */
    isBuffering : false,

    /**
     * If a request for new data was made and the user scrolls to a new position
     * that lays not within the requested range of the new data, the queue will
     * hold the latest requested position. If the buffering succeeds and the
     * value of requestQueue is not within the range of the current buffer, data
     * may be re-requested.
     * 
     * @param {Number}
     */
    requestQueue : -1,

    /**
     * An {@Ext.LoadMask} config that will be shown when a request to data was
     * made and there are no rows in the buffer left to render.
     * 
     * @param {Object}
     */
    loadMask : false,

    /**
     * A shortcut to indicate whether the loadMask is currently being displayed.
     * 
     * @type {Boolean}
     * @private
     */
    loadMaskDisplayed : false,

    /**
     * Set to <tt>true</tt> if a request for new data has been made while
     * there are still rows in the buffer that can be rendered before the
     * request finishes.
     * 
     * @param {Boolean}
     */
    isPrebuffering : false,

    /**
     * The dom node for which the node mask will be rendered.
     * 
     * @type {Ext.Element}
     * @private
     */
    _loadMaskAnchor : null,
    
    /**
     * used to know if you have to display Warning if too many rows
     */
    _displayWarningTooManyRows : true, 
    // }}}

    // {{{ --------------------------public API
    // methods-----------------------------

    /**
     * Resets the view to display the first row in the data model. This will
     * change the scrollTop property of the scroller and may trigger a request
     * to buffer new data, if the row index "0" is not within the buffer range
     * and forceReload is set to true.
     * 
     * @param {Boolean}
     *            forceReload <tt>true</tt> to reload the buffers contents,
     *            othwerwise <tt>false</tt>
     * 
     * @return {Boolean} Whether the store loads after reset(true); returns
     *         false if any of the attached beforeload listeners cancels the
     *         load-event
     */
    reset : function (forceReload) {
        if (forceReload === false) {
            this.ds.modified = [];
            // this.grid.selModel.clearSelections(true);
            this.rowIndex = 0;
            this.lastScrollPos = 0;
            this.lastRowIndex = 0;
            this.lastIndex = 0;
            this.adjustVisibleRows();
            this.adjustScrollerPos(-this.liveScroller.dom.scrollTop, true);
            this.showLoadMask(false);

            var _ofn = this.processRows;
            this.processRows = Ext.emptyFn;
            this.refresh(true);
            this.processRows = _ofn;
            this.processRows(0);

            this.fireEvent('cursormove', this, 0, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped),
                    this.ds.totalLength);
            return false;
        } else {

            
            var params = {
				colModel : Ext.util.JSON.encode(extColModelToSrv(this.cm))
            };
            var sInfo = this.ds.sortInfo;

            if (sInfo) {
                Ext.apply(params, {
                    dir : sInfo.direction,
                    sort : sInfo.field
                });
            }    
            return this.ds.load({
                params : params
            });
        }

    },

    // {{{ ------------adjusted methods for applying custom
    // behavior----------------

    // private
    render : function() {
        if (this.autoFill) {
            var ct = this.grid.ownerCt;

            if (ct && ct.getLayout()) {
                ct.on('afterlayout', function() {
                    this.fitColumns(true, true);
                    this.updateHeaders();
                    this.updateHeaderSortState();
                }, this, {single: true});
            }
        } else if (this.forceFit) {
            this.fitColumns(true, false);
        } else if (this.grid.autoExpandColumn) {
            this.autoExpand(true);
        }

        this.grid.getGridEl().dom.innerHTML = this.renderUI();

        this.afterRenderUI();
    },

    /**
     * Overwritten so the {@link Ext.ux.grid.livegrid.DragZone} can be used with
     * this view implementation.
     * 
     * Since detaching a previously created DragZone from a grid panel seems to
     * be impossible, a little workaround will tell the parent implementation
     * that drad/drop is not enabled for this view's grid, and right after that
     * the custom DragZone will be created, if neccessary.
     */
    renderUI : function () {
        var g = this.grid;
        var dEnabled = g.enableDragDrop || g.enableDrag;

        g.enableDragDrop = false;
        g.enableDrag = false;

        var m = this._gridViewSuperclass.renderUI.call(this);

        g = this.grid;

        g.enableDragDrop = dEnabled;
        g.enableDrag = dEnabled;

        if (dEnabled) {
            this.dragZone = new Ext.ux.grid.livegrid.DragZone(g, {
                ddGroup : g.ddGroup || 'GridDD'
            });
        }
        return m;
    },

    afterRenderUI : function()
    {
        this._gridViewSuperclass.afterRenderUI.call(this);
        

        if (this.loadMask) {
            this._loadMaskAnchor = Ext.get(this.mainBody.dom.parentNode.parentNode);
            Ext.apply(this.loadMask, {
                msgCls : 'x-mask-loading'
            });
            this._loadMaskAnchor.mask(this.loadMask.msg, this.loadMask.msgCls);
            var dom = this._loadMaskAnchor.dom;
            var data = Ext.Element.data;
            data(dom, 'mask').addClass('ext-ux-livegrid');
            data(dom, 'mask').setDisplayed(false);
            data(dom, 'maskMsg').setDisplayed(false);
        }
    },

    /**
     * The extended implementation attaches an listener to the beforeload event
     * of the store of the grid. It is guaranteed that the listener will only be
     * executed upon reloading of the store, sorting and initial loading of
     * data. When the store does "buffer", all events are suspended and the
     * beforeload event will not be triggered.
     * 
     * @param {Ext.grid.GridPanel}
     *            grid The grid panel this view is attached to
     */
    init : function (grid) {
        this._gridViewSuperclass.init.call(this, grid);

        grid.on('expand', this._onExpand, this);
    },

    initData : function (ds, cm) {
        if (this.ds) {
            this.ds.un('bulkremove', this.onBulkRemove, this);
            this.ds.un('beforeload', this.onBeforeLoad, this);
        }
        if (ds) {
            ds.on('bulkremove', this.onBulkRemove, this);
            ds.on('beforeload', this.onBeforeLoad, this);
        }

        this._gridViewSuperclass.initData.call(this, ds, cm);
    },

    /**
     * Only render the viewable rect of the table. The number of rows visible to
     * the user is defined in <tt>visibleRows</tt>. This implementation does
     * completely overwrite the parent's implementation.
     */
    // private
    renderBody : function () {
        var markup = this.renderRows(0, this.visibleRows - 1);
        return this.templates.body.apply({
            rows : markup
        });
    },

    /**
     * Overriden so the renderer of the specific cells gets the index of the row
     * as available in the view passed (row's rowIndex property)-
     * 
     */
    doRender : function (cs, rs, ds, startRow, colCount, stripe) {
        return this._gridViewSuperclass.doRender.call(this, cs, rs, ds, startRow + this.ds.bufferRange[0], colCount,
                stripe);

    },

    /**
     * Inits the DOM native elements for this component. The properties
     * <tt>liveScroller</tt> and <tt>liveScrollerInsets</tt> will be
     * respected as provided by the master template. The <tt>scroll</tt>
     * listener for the <tt>liverScroller</tt> will also be added here as the
     * <tt>mousewheel</tt> listener. This method overwrites the parents
     * implementation.
     */
    // private
    initElements : function () {
        var E = Ext.Element;

        var el = this.grid.getGridEl().dom.firstChild;
        var cs = el.childNodes;

        this.el = new E(el);

        this.mainWrap = new E(cs[1]);

        // liveScroller and liveScrollerInsets
        this.liveScroller = new E(cs[0]);
        var f = this.liveScroller.dom.firstChild;
        this.liveScrollerInsets = [ f ];
        var divSuivante = f.nextSibling;
        while (!Ext.isEmpty(divSuivante)) {
            this.liveScrollerInsets.push(divSuivante);
            divSuivante = divSuivante.nextSibling;
        }
        //this.liveScrollerInsets = [ f, f.nextSibling, f.nextSibling.nextSibling, f.nextSibling.nextSibling.nextSibling, f.nextSibling.nextSibling.nextSibling.nextSibling, f.nextSibling.nextSibling.nextSibling.nextSibling.nextSibling ];
        this.liveScroller.on('scroll', this.onLiveScroll, this, {
            buffer : this.scrollDelay
        });

        var thd = this.mainWrap.dom.firstChild;
        this.mainHd = new E(thd);

        this.hdHeight = thd.offsetHeight;

        this.innerHd = this.mainHd.dom.firstChild;
        this.scroller = new E(this.mainWrap.dom.childNodes[1]);
        if (this.forceFit) {
            this.scroller.setStyle('overflow-x', 'hidden');
        }
        this.mainBody = new E(this.scroller.dom.firstChild);

        // addd the mousewheel event to the table's body
        this.mainBody.on('mousewheel', this.handleWheel, this);

        this.focusEl = new E(this.scroller.dom.childNodes[1]);
        this.focusEl.swallowEvent("click", true);

        this.resizeMarker = new E(cs[2]);
        this.resizeProxy = new E(cs[3]);

    },

    /**
     * Layouts the grid's view taking the scroller into account. The height of
     * the scroller gets adjusted depending on the total width of the columns.
     * The width of the grid view will be adjusted so the header and the rows do
     * not overlap the scroller. This method will also compute the row-height
     * based on the first row this grid displays and will adjust the number of
     * visible rows if a resize of the grid component happened. This method
     * overwrites the parents implementation.
     */
    // private
    layout : function () {
        if (!this.mainBody) {
            return; // not rendered
        }
        var g = this.grid;
        var c = g.getGridEl(), cm = this.cm, expandCol = g.autoExpandColumn, gv = this;

        var csize = c.getSize(true);

        // set vw to 19 to take scrollbar width into account!
        var vw = csize.width;

        if (!g.hideHeaders && vw < 20 || csize.height < 20) { // display:
                                                                // none?
            return;
        }

        if (g.autoHeight) {
            this.scroller.dom.style.overflow = 'visible';
            if (Ext.isWebKit) {
                this.scroller.dom.style.position = 'static';
            }
        } else {
            this.el.setSize(csize.width, csize.height);

            var hdHeight = this.mainHd.getHeight();
            var vh = csize.height - (hdHeight);

            this.scroller.setSize(vw, vh);
            if (this.innerHd) {
                this.innerHd.style.width = (vw) + 'px';
            }
        }

        this.liveScroller.dom.style.top = this.hdHeight + "px";

        if (this.forceFit) {
            if (this.lastViewWidth != vw) {
                this.fitColumns(false, false);
                this.lastViewWidth = vw;
            }
        } else {
            this.autoExpand();
        }

        // adjust the number of visible rows and the height of the scroller.
        this.adjustVisibleRows();
        this.adjustBufferInset();

        this.onLayout(vw, vh);
    },

    /**
     * Overriden for Ext 2.2 to prevent call to focus Row.
     * 
     */
    removeRow : function (row) {
        Ext.removeNode(this.getRow(row));
    },

    /**
     * Overriden for Ext 2.2 to prevent call to focus Row. This method i s here
     * for dom operations only - the passed arguments are the index of the nodes
     * in the dom, not in the model.
     * 
     */
    removeRows : function (firstRow, lastRow) {
        var bd = this.mainBody.dom;
        for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {
            Ext.removeNode(bd.childNodes[firstRow]);
        }
    },

    // {{{ ----------------------dom/mouse
    // listeners--------------------------------

    /**
     * Tells the view to recalculate the number of rows displayable and the
     * buffer inset, when it gets expanded after it has been collapsed.
     * 
     */
    _onExpand : function (panel) {
        this.adjustVisibleRows();
        this.adjustBufferInset();
        this.adjustScrollerPos(this.rowHeight * this.rowIndex, true);
    },

    // private
    onColumnMove : function (cm, oldIndex, newIndex) {
        this.indexMap = null;
        this.replaceLiveRows(this.rowIndex, true);
        this.updateHeaders();
        this.updateHeaderSortState();
        this.afterMove(newIndex);
        this.grid.fireEvent('columnmove', oldIndex, newIndex);
    },

    /**
     * Called when a column width has been updated. Adjusts the scroller height
     * and the number of visible rows wether the horizontal scrollbar is shown
     * or not.
     */
    onColumnWidthUpdated : function (col, w, tw) {
        this.adjustVisibleRows();
        this.adjustBufferInset();
    },

    /**
     * Called when the width of all columns has been updated. Adjusts the
     * scroller height and the number of visible rows wether the horizontal
     * scrollbar is shown or not.
     */
    onAllColumnWidthsUpdated : function (ws, tw) {
        this.adjustVisibleRows();
        this.adjustBufferInset();
    },

    /**
     * Callback for selecting a row. The index of the row is the absolute index
     * in the datamodel. If the row is not rendered, this method will do
     * nothing.
     */
    // private
    onRowSelect : function (row) {
        if (row < this.rowIndex || row > this.rowIndex+this.visibleRows) {
            return;
        }

        this.addRowClass(row, this.selectedRowClass);
    },

    /**
     * Callback for deselecting a row. The index of the row is the absolute
     * index in the datamodel. If the row is not currently rendered in the view,
     * this method will do nothing.
     */
    // private
    onRowDeselect : function (row) {
        if (row < this.rowIndex || row > this.rowIndex+this.visibleRows) {
            return;
        }

        this.removeRowClass(row, this.selectedRowClass);
    },

    // {{{ ----------------------data
    // listeners-------------------------------------
    /**
     * Called when the buffer gets cleared. Simply calls the updateLiveRows
     * method with the adjusted index and should force the store to reload
     */
    // private
    onClear : function () {
        this.reset(false);
    },

    /**
     * Callback for the "bulkremove" event of the attached datastore.
     * 
     * @param {Ext.ux.grid.livegrid.Store}
     *            store
     * @param {Array}
     *            removedData
     * 
     */
    onBulkRemove : function (store, removedData) {
        var record = null;
        var index = 0;
        var viewIndex = 0;
        var len = removedData.length;

        var removedInView = false;
        var removedAfterView = false;
        var scrollerAdjust = 0;

        if (len === 0) {
            return;
        }

        var tmpRowIndex = this.rowIndex;
        var removedBefore = 0;
        var removedAfter = 0;
        var removedIn = 0;

        for (var i = 0; i < len; i++) {
            record = removedData[i][0];
            index = removedData[i][1];

            viewIndex = (index != Number.MIN_VALUE && index != Number.MAX_VALUE) ? index + this.ds.bufferRange[0] : index;

            if (viewIndex < this.rowIndex) {
                removedBefore++;
            } else if (viewIndex >= this.rowIndex && viewIndex <= this.rowIndex + (this.visibleRows - 1)) {
                removedIn++;
            } else if (viewIndex >= this.rowIndex + this.visibleRows) {
                removedAfter++;
            }

            this.fireEvent("beforerowremoved", this, viewIndex, record);
            this.fireEvent("rowremoved", this, viewIndex, record);
        }

        var totalLength = this.ds.totalLength;
        this.rowIndex = Math.max(0, Math.min(this.rowIndex - removedBefore, totalLength - (this.visibleRows - 1)));

        this.lastRowIndex = this.rowIndex;

        this.adjustScrollerPos(-(removedBefore * this.rowHeight), true);
        this.updateLiveRows(this.rowIndex, true);
        this.adjustBufferInset();
        this.processRows(0, undefined, false);

    },

    /**
     * Callback for the underlying store's remove method. The current
     * implementation does only remove the selected row which record is in the
     * current store.
     * 
     * @see onBulkRemove()
     */
    // private
    onRemove : function (ds, record, index) {
        this.onBulkRemove(ds, [ [ record, index ] ]);
    },

    /**
     * The callback for the underlying data store when new data was added. If
     * <tt>index</tt> equals to <tt>Number.MIN_VALUE</tt> or
     * <tt>Number.MAX_VALUE</tt>, the method can't tell at which position in
     * the underlying data model the records where added. However, if
     * <tt>index</tt> equals to <tt>Number.MIN_VALUE</tt>, the
     * <tt>rowIndex</tt> property will be adjusted to
     * <tt>rowIndex+records.length</tt>, and the <tt>liveScroller</tt>'s
     * properties get adjusted so it matches the new total number of records of
     * the underlying data model. The same will happen to any records that get
     * added at the store index which is currently represented by the first
     * visible row in the view. Any other value will cause the method to compute
     * the number of rows that have to be (re-)painted and calling the
     * <tt>insertRows</tt> method, if neccessary.
     * 
     * This method triggers the <tt>beforerowsinserted</tt> and
     * <tt>rowsinserted</tt> event, passing the indexes of the records as they
     * may default to the positions in the underlying data model. However, due
     * to the fact that any sort algorithm may have computed the indexes of the
     * records, it is not guaranteed that the computed indexes equal to the
     * indexes of the underlying data model.
     * 
     * @param {Ext.ux.grid.livegrid.Store}
     *            ds The datastore that buffers records from the underlying data
     *            model
     * @param {Array}
     *            records An array containing the newly added
     *            {@link Ext.data.Record}s
     * @param {Number}
     *            index The index of the position in the underlying
     *            {@link Ext.ux.grid.livegrid.Store} where the rows were added.
     */
    // private
    onAdd : function (ds, records, index) {
        if (this._checkEmptyBody) {
            if (this.mainBody.dom.innerHTML == '&nbsp;') {
                this.mainBody.dom.innerHTML = '';
            }
            this._checkEmptyBody = false;
        }

        var recordLen = records.length;

        // values of index which equal to Number.MIN_VALUE or Number.MAX_VALUE
        // indicate that the records were not added to the store. The component
        // does not know which index those records do have in the underlying
        // data model
        if (index == Number.MAX_VALUE || index == Number.MIN_VALUE) {
            this.fireEvent("beforerowsinserted", this, index, index);

            // if index equals to Number.MIN_VALUE, shift rows!
            if (index == Number.MIN_VALUE) {

                this.rowIndex = this.rowIndex + recordLen;
                this.lastRowIndex = this.rowIndex;

                this.adjustBufferInset();
                this.adjustScrollerPos(this.rowHeight * recordLen, true);

                this.fireEvent("rowsinserted", this, index, index, recordLen);
                this.processRows(0, undefined, false);
                // the cursor did virtually move
                this.fireEvent('cursormove', this, this.rowIndex, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength);

                return;
            }

            this.adjustBufferInset();
            this.fireEvent("rowsinserted", this, index, index, recordLen);
            return;
        }

        // only insert the rows which affect the current view.
        var start = index + this.ds.bufferRange[0];
        var end = start + (recordLen - 1);
        var len = this.getRows().length;

        var firstRow = 0;
        var lastRow = 0;

        // rows would be added at the end of the rows which are currently
        // displayed, so fire the event, resize buffer and adjust visible
        // rows and return
        if (start > this.rowIndex + (this.visibleRows - 1)) {
            this.fireEvent("beforerowsinserted", this, start, end);
            this.fireEvent("rowsinserted", this, start, end, recordLen);

            this.adjustVisibleRows();
            this.adjustBufferInset();

        }

        // rows get added somewhere in the current view.
        else if (start >= this.rowIndex && start <= this.rowIndex + (this.visibleRows - 1)) {
            firstRow = index;
            // compute the last row that would be affected of an insert
            // operation
            lastRow = index + (recordLen - 1);
            this.lastRowIndex = this.rowIndex;
            this.rowIndex = (start > this.rowIndex) ? this.rowIndex : start;

            this.insertRows(ds, firstRow, lastRow);

            if (this.lastRowIndex != this.rowIndex) {
                this.fireEvent('cursormove', this, this.rowIndex, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength);
            }

            this.adjustVisibleRows();
            this.adjustBufferInset();
        }

        // rows get added before the first visible row, which would not affect
        // any
        // rows to be re-rendered
        else if (start < this.rowIndex) {
            this.fireEvent("beforerowsinserted", this, start, end);

            this.rowIndex = this.rowIndex + recordLen;
            this.lastRowIndex = this.rowIndex;

            this.adjustVisibleRows();
            this.adjustBufferInset();

            this.adjustScrollerPos(this.rowHeight * recordLen, true);

            this.fireEvent("rowsinserted", this, start, end, recordLen);
            this.processRows(0, undefined, true);

            this.fireEvent('cursormove', this, this.rowIndex, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength);
        }

    },

    // {{{ ----------------------store
    // listeners------------------------------------
    /**
     * This callback for the store's "beforeload" event will adjust the start
     * position and the limit of the data in the model to fetch. It is
     * guaranteed that this method will only be called when the store initially
     * loads, remeote-sorts or reloads. All other load events will be suspended
     * when the view requests buffer data. See {updateLiveRows}. Note: If you
     * are using a custom proxy, such as {Ext.data.DirectProxy}, you should
     * listen to the 'abortrequest'-event, which will tell that an ongoing
     * "read" request should be aborted, since the grid's store gets refreshed.
     * If the store is using an instance of {Ext.data.HttpProxy}, the method
     * will still be fired, but the request made through this proxy will be
     * aborted automatically.
     * 
     * 
     * @param {Ext.data.Store}
     *            store The store the Grid Panel uses
     * @param {Object}
     *            options The configuration object for the proxy that loads data
     *            from the server
     */
    onBeforeLoad : function (store, options) {
        var proxy = store.proxy;
        if (proxy.activeRequest && proxy.activeRequest[Ext.data.Api.actions.read]) {
            proxy.getConnection().abort(proxy.activeRequest[Ext.data.Api.actions.read]);
        }
        this.fireEvent('abortrequest', store, options);

        this.isBuffering = false;
        this.isPreBuffering = false;

        options.params = options.params || {};

        var apply = Ext.apply;

        apply(options, {
            scope : this,
            callback : function () {
                this.reset(false);
            },
            suspendLoadEvent : false
        });

        apply(options.params, {
            start : 0,
            limit : this.ds.bufferSize
        });

        return true;
    },

    /**
     * Method is used as a callback for the load-event of the attached data
     * store. Adjusts the buffer inset based upon the <tt>totalCount</tt>
     * property returned by the response. Overwrites the parent's
     * implementation.
     */
    onLoad : function (o1, o2, options) {
        this.adjustBufferInset();
    },

    /**
     * This will be called when the data in the store has changed, i.e. a
     * re-buffer has occured. If the table was not rendered yet, a call to
     * <tt>refresh</tt> will initially render the table, which DOM elements
     * will then be used to re-render the table upon scrolling.
     * 
     */
    // private
    onDataChange : function (store) {
        this.updateHeaderSortState();
    },

    /**
     * A callback for the store when new data has been buffered successfully. If
     * the current row index is not within the range of the newly created data
     * buffer or another request to new data has been made while the store was
     * loading, new data will be re-requested.
     * 
     * Additionally, if there are any rows that have been selected which were
     * not in the data store, the method will request the pending selections
     * from the grid's selection model and add them to the selections if
     * available. This is because the component assumes that a user who scrolls
     * through the rows and updates the view's buffer during scrolling, can
     * check the selected rows which come into the view for integrity. It is up
     * to the user to deselect those rows not matchuing the selection.
     * Additionally, if the version of the store changes during various requests
     * and selections are still pending, the versionchange event of the store
     * can delete the pending selections after a re-bufer happened and before
     * this method was called.
     * 
     */
    // private
    liveBufferUpdate : function (records, options, success) {
        if (success === true) {
            this.adjustBufferInset();

            this.fireEvent('buffer', this, this.ds, this.rowIndex, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength, options);

            // this is needed since references to records which have been
            // unloaded
            // get lost when the store gets loaded with new data.
            // from the store
            this.grid.selModel.replaceSelections(records);

            this.isBuffering = false;
            this.isPrebuffering = false;
            this.showLoadMask(false);

            if (this.requestQueue >= 0) {
                var offset = this.requestQueue;
                this.requestQueue = -1;
                this.updateLiveRows(offset);
                return;
            }

            if (this.isInRange(this.rowIndex)) {
                this.replaceLiveRows(this.rowIndex, options.forceRepaint);
            } else {
                this.updateLiveRows(this.rowIndex);
            }

            return;
        } else {
            this.fireEvent('bufferfailure', this, this.ds, options);
        }

        this.requestQueue = -1;
        this.isBuffering = false;
        this.isPrebuffering = false;
        this.showLoadMask(false);
    },

    // {{{ ----------------------scroll
    // listeners------------------------------------
    /**
     * Handles mousewheel event on the table's body. This is neccessary since
     * the <tt>liveScroller</tt> element is completely detached from the
     * table's body.
     * 
     * @param {Ext.EventObject}
     *            e The event object
     */
    handleWheel : function (e) {
        if (this.rowHeight == -1) {
            e.stopEvent();
            return;
        }
        var d = e.getWheelDelta();

        this.adjustScrollerPos(-(d * this.rowHeight));

        e.stopEvent();
    },

    /**
     * Handles scrolling through the grid. Since the grid is fixed and rows get
     * removed/ added subsequently, the only way to determine the actual row in
     * view is to measure the <tt>scrollTop</tt> property of the
     * <tt>liveScroller</tt>'s DOM element.
     * 
     */
    onLiveScroll : function () {
        var scrollTop = this.liveScroller.dom.scrollTop;

        var cursor = Math.floor((scrollTop) / this.rowHeight);

        this.rowIndex = cursor;
        // the lastRowIndex will be set when refreshing the view has finished
        if (cursor == this.lastRowIndex) {
            return;
        }

        this.updateLiveRows(cursor);

        this.lastScrollPos = this.liveScroller.dom.scrollTop;
    },

    // {{{
    // --------------------------helpers----------------------------------------

    // private
    refreshRow : function (record) {
        var ds = this.ds, index;
        if (typeof record == 'number') {
            index = record;
            record = ds.getAt(index);
        } else {
            index = ds.indexOf(record);
        }

        var viewIndex = index + this.ds.bufferRange[0];

        if (viewIndex < this.rowIndex || viewIndex >= this.rowIndex + this.visibleRows) {
            this.fireEvent("rowupdated", this, viewIndex, record);
            return;
        }

        this.insertRows(ds, index, index, true);
        this.fireEvent("rowupdated", this, viewIndex, record);
    },

    /**
     * Overwritten so the rowIndex can be changed to the absolute index.
     * 
     * If the third parameter equals to <tt>true</tt>, the method will also
     * repaint the selections.
     */
    // private
    processRows : function (startRow, skipStripe, paintSelections) {
        if (!this.ds || this.ds.getCount() < 1) {
            return;
        }

        skipStripe = skipStripe || !this.grid.stripeRows;

        var cursor = this.rowIndex;
        var rows = this.getRows();
        var index = 0;

        var row = null;
        for (var idx = 0, len = rows.length; idx < len; idx++) {
            row = rows[idx];

            row.rowIndex = index = cursor + idx;
            row.className = row.className.replace(this.rowClsRe, ' ');
            if (!skipStripe && (index + 1) % 2 === 0) {
                row.className += ' x-grid3-row-alt';
            }

            if (paintSelections !== false) {
                if (this.grid.selModel.isSelected(this.ds.getAt(index)) === true) {
                    this.addRowClass(index, this.selectedRowClass);
                } else {
                    this.removeRowClass(index, this.selectedRowClass);
                }
                this.fly(row).removeClass("x-grid3-row-over");
            }
        }

        // add first/last-row classes
        if (cursor === 0) {
            Ext.fly(rows[0]).addClass(this.firstRowCls);
        } else if (cursor + rows.length == this.ds.totalLength) {
            Ext.fly(rows[rows.length - 1]).addClass(this.lastRowCls);
        }
    },

    /**
     * API only, since the passed arguments are the indexes in the buffer store.
     * However, the method will try to compute the indexes so they might match
     * the indexes of the records in the underlying data model.
     * 
     */
    // private
    insertRows : function (dm, firstRow, lastRow, isUpdate) {
        var viewIndexFirst = firstRow + this.ds.bufferRange[0];
        var viewIndexLast = lastRow + this.ds.bufferRange[0];

        if (!isUpdate) {
            this.fireEvent("beforerowsinserted", this, viewIndexFirst, viewIndexLast);
        }

        // first off, remove the rows at the bottom of the view to match the
        // visibleRows value and to not cause any spill in the DOM
        if (isUpdate !== true && (this.getRows().length + (lastRow - firstRow)) >= this.visibleRows) {
            this.removeRows((this.visibleRows - 1) - (lastRow - firstRow), this.visibleRows - 1);
        } else if (isUpdate) {
            this.removeRows(viewIndexFirst - this.rowIndex, viewIndexLast - this.rowIndex);
        }

        // compute the range of possible records which could be drawn into the
        // view without
        // causing any spill
        var lastRenderRow = (firstRow == lastRow) ? lastRow : Math.min(lastRow,
                (this.rowIndex - this.ds.bufferRange[0]) + (this.visibleRows - 1));

        var html = this.renderRows(firstRow, lastRenderRow);

        var before = this.getRow(viewIndexFirst);

        if (before) {
            Ext.DomHelper.insertHtml('beforeBegin', before, html);
        } else {
            Ext.DomHelper.insertHtml('beforeEnd', this.mainBody.dom, html);
        }

        // if a row is replaced, we need to set the row index for this
        // row
        if (isUpdate === true) {
            var rows = this.getRows();
            var cursor = this.rowIndex;
            for (var i = 0, max_i = rows.length; i < max_i; i++) {
                rows[i].rowIndex = cursor + i;
            }
        }

        if (!isUpdate) {
            this.fireEvent("rowsinserted", this, viewIndexFirst, viewIndexLast, (viewIndexLast - viewIndexFirst) + 1);
            this.processRows(0, undefined, true);
        }
    },

    /**
     * Return the
     * <TR> HtmlElement which represents a Grid row for the specified index. The
     * passed argument is assumed to be the absolute index and will get
     * translated to the index of the row that represents the data in the view.
     * 
     * @param {Number}
     *            index The row index
     * 
     * @return {null|HtmlElement} The
     *         <TR> element, or null if the row is not rendered in the view.
     */
    getRow : function (row) {
        if (row - this.rowIndex < 0) {
            return null;
        }

        return this.getRows()[row - this.rowIndex];
    },

    /**
     * Returns the grid's
     * <TD> HtmlElement at the specified coordinates. Returns null if the
     * specified row is not currently rendered.
     * 
     * @param {Number}
     *            row The row index in which to find the cell.
     * @param {Number}
     *            col The column index of the cell.
     * @return {HtmlElement} The &lt;TD> at the specified coordinates.
     */
    getCell : function (row, col) {
        var arow = this.getRow(row);

        return arow ? arow.getElementsByTagName('td')[col] : null;
    },

    /**
     * Focuses the specified cell.
     * 
     * @param {Number}
     *            row The row index
     * @param {Number}
     *            col The column index
     */
    focusCell : function (row, col, hscroll) {
        var xy = this.ensureVisible(row, col, hscroll);

        if (!xy) {
            return;
        }

        this.focusEl.setXY(xy);

        if (Ext.isGecko) {
            this.focusEl.focus();
        } else {
            this.focusEl.focus.defer(1, this.focusEl);
        }

    },

    /**
     * Makes sure that the requested /row/col is visible in the viewport. The
     * method may invoke a request for new buffer data and triggers the
     * scroll-event of the <tt>liveScroller</tt> element.
     * 
     */
    // private
    ensureVisible : function (row, col, hscroll) {
        if (typeof row != "number") {
            row = row.rowIndex;
        }

        if (row < 0 || row >= this.ds.totalLength) {
            return;
        }

        col = (col !== undefined ? col : 0);

        var rowInd = row - this.rowIndex;

        if (this.rowClipped && row == this.rowIndex + this.visibleRows - 1) {
            this.adjustScrollerPos(this.rowHeight);
        } else if (row >= this.rowIndex + this.visibleRows) {
            this.adjustScrollerPos(((row - (this.rowIndex + this.visibleRows)) + 1) * this.rowHeight);
        } else if (row <= this.rowIndex) {
            this.adjustScrollerPos((rowInd) * this.rowHeight);
        }

        var rowEl = this.getRow(row), cellEl;

        if (!rowEl) {
            return;
        }

        if (!(hscroll === false && col === 0)) {
            while (this.cm.isHidden(col)) {
                col++;
            }
            cellEl = this.getCell(row, col);
        }

        var c = this.scroller.dom;

        if (hscroll !== false) {
            var cleft = parseInt(cellEl.offsetLeft, 10);
            var cright = cleft + cellEl.offsetWidth;

            var sleft = parseInt(c.scrollLeft, 10);
            var sright = sleft + c.clientWidth;
            if (cleft < sleft) {
                c.scrollLeft = cleft;
            } else if (cright > sright) {
                c.scrollLeft = cright - c.clientWidth;
            }
        }

        return cellEl ? Ext.fly(cellEl).getXY() : [ c.scrollLeft + this.el.getX(), Ext.fly(rowEl).getY() ];
    },

    /**
     * Return strue if the passed record is in the visible rect of this view.
     * 
     * @param {Ext.data.Record}
     *            record
     * 
     * @return {Boolean} true if the record is rendered in the view, otherwise
     *         false.
     */
    isRecordRendered : function (record) {
        var ind = this.ds.indexOf(record);

        if (ind >= this.rowIndex && ind < this.rowIndex + this.visibleRows) {
            return true;
        }

        return false;
    },

    /**
     * Checks if the passed argument <tt>cursor</tt> lays within a renderable
     * area. The area is renderable, if the sum of cursor and the visibleRows
     * property does not exceed the current upper buffer limit.
     * 
     * If this method returns <tt>true</tt>, it's basically save to re-render
     * the view with <tt>cursor</tt> as the absolute position in the model as
     * the first visible row.
     * 
     * @param {Number}
     *            cursor The absolute position of the row in the data model.
     * 
     * @return {Boolean} <tt>true</tt>, if the row can be rendered, otherwise
     *         <tt>false</tt>
     * 
     */
    isInRange : function (rowIndex) {
        var lastRowIndex = Math.min(this.ds.totalLength - 1, rowIndex + (this.visibleRows - 1));

        return (rowIndex >= this.ds.bufferRange[0]) && (lastRowIndex <= this.ds.bufferRange[1]);
    },

    /**
     * Calculates the bufferRange start index for a buffer request
     * 
     * @param {Boolean}
     *            inRange If the index is within the current buffer range
     * @param {Number}
     *            index The index to use as a reference for the calculations
     * @param {Boolean}
     *            down Wether the calculation was requested when the user
     *            scrolls down
     */
    getPredictedBufferIndex : function (index, inRange, down) {
        if (!inRange) {
            if (index + this.ds.bufferSize >= this.ds.totalLength) {
                return this.ds.totalLength - this.ds.bufferSize;
            }
            // we need at last to render the index + the visible Rows
            return Math.max(0, (index + this.visibleRows) - Math.round(this.ds.bufferSize / 2));
        }
        if (!down) {
            return Math.max(0, (index - this.ds.bufferSize) + this.visibleRows);
        }

        if (down) {
            return Math.max(0, Math.min(index, this.ds.totalLength - this.ds.bufferSize));
        }
    },

    /**
     * Updates the table view. Removes/appends rows as needed and fetches the
     * cells content out of the available store. If the needed rows are not
     * within the buffer, the method will advise the store to update it's
     * contents.
     * 
     * The method puts the requested cursor into the queue if a previously
     * called buffering is in process.
     * 
     * @param {Number}
     *            cursor The row's position, absolute to it's position in the
     *            data model
     * 
     */
    updateLiveRows : function (index, forceRepaint, forceReload) {
        var inRange = this.isInRange(index);

        if (this.isBuffering) {
            if (this.isPrebuffering) {
                if (inRange) {
                    this.replaceLiveRows(index, forceRepaint);
                } else {
                    this.showLoadMask(true);
                }
            }

            this.fireEvent('cursormove', this, index,
                    Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength);

            this.requestQueue = index;
            return;
        }

        var lastIndex = this.lastIndex;
        this.lastIndex = index;
        inRange = this.isInRange(index);

        var down = false;

        if (inRange && forceReload !== true) {

            // repaint the table's view
            this.replaceLiveRows(index, forceRepaint);
            // has to be called AFTER the rowIndex was recalculated
            this.fireEvent('cursormove', this, index,
                    Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength);
            // lets decide if we can void this method or stay in here for
            // requesting a buffer update
            if (index > lastIndex) { // scrolling down

                down = true;
                var totalCount = this.ds.totalLength;

                // while scrolling, we have not yet reached the row index
                // that would trigger a re-buffer
                if (index + this.visibleRows + this.nearLimit <= this.ds.bufferRange[1]) {
                    return;
                }

                // If we have already buffered the last range we can ever get
                // by the queried data repository, we don't need to buffer
                // again.
                // This basically means that a re-buffer would only occur again
                // if we are scrolling up.
                if (this.ds.bufferRange[1] + 1 >= totalCount) {
                    return;
                }
            } else if (index < lastIndex) { // scrolling up

                down = false;
                // We are scrolling up in the first buffer range we can ever get
                // Re-buffering would only occur upon scrolling down.
                if (this.ds.bufferRange[0] <= 0) {
                    return;
                }

                // if we are scrolling up and we are moving in an acceptable
                // buffer range, lets return.
                if (index - this.nearLimit > this.ds.bufferRange[0]) {
                    return;
                }
            } else {
                return;
            }

            this.isPrebuffering = true;
        }

        // prepare for rebuffering
        this.isBuffering = true;

        var bufferOffset = this.getPredictedBufferIndex(index, inRange, down);

        if (!inRange) {
            this.showLoadMask(true);
        }

        this.ds.suspendEvents();
        var sInfo = this.ds.sortInfo;

        var params = {};
        if (this.ds.lastOptions) {
            Ext.apply(params, this.ds.lastOptions.params);
        }

        params.start = bufferOffset;
        params.limit = this.ds.bufferSize;
        
       // if(this.ds.doCount){
        params.nocount = true;
        /*}else{
            params.nocount = false;
        }*/

        if (sInfo) {
            params.dir = sInfo.direction;
            params.sort = sInfo.field;
        }

        var opts = {
            forceRepaint : forceRepaint,
            callback : this.liveBufferUpdate,
            scope : this,
            params : params,
            suspendLoadEvent : true
        };

        this.fireEvent('beforebuffer', this, this.ds, index, Math.min(this.ds.totalLength, this.visibleRows - this.rowClipped), this.ds.totalLength, opts);
        
        this.ds.load(opts);
        this.ds.resumeEvents();
    },

    /**
     * Shows this' view own load mask to indicate that a large amount of buffer
     * data was requested by the store.
     * 
     * @param {Boolean}
     *            show <tt>true</tt> to show the load mask, otherwise
     *            <tt>false</tt>
     */
    showLoadMask : function (show) {
        if (!this.loadMask || show == this.loadMaskDisplayed) {
            return;
        }

        var dom = this._loadMaskAnchor.dom;
        var data = Ext.Element.data;

        var mask = data(dom, 'mask');
        var maskMsg = data(dom, 'maskMsg');

        if (show) {
            mask.setDisplayed(true);
            maskMsg.setDisplayed(true);
            maskMsg.center(this._loadMaskAnchor);
            // this lines will help IE8 to re-calculate the height of the
            // loadmask
            if (Ext.isIE && !(Ext.isIE7 && Ext.isStrict) && this._loadMaskAnchor.getStyle('height') == 'auto') {
                mask.setSize(undefined, this._loadMaskAnchor.getHeight());
            }
        } else {
            mask.setDisplayed(false);
            maskMsg.setDisplayed(false);
        }

        this.loadMaskDisplayed = show;
    },

    /**
     * Renders the table body with the contents of the model. The method will
     * prepend/ append rows after removing from either the end or the beginning
     * of the table DOM to reduce expensive DOM calls. It will also take care of
     * rendering the rows selected, taking the property
     * <tt>bufferedSelections</tt> of the {@link BufferedRowSelectionModel}
     * into account. Instead of calling this method directly, the
     * <tt>updateLiveRows</tt> method should be called which takes care of
     * rebuffering if needed, since this method will behave erroneous if data of
     * the buffer is requested which may not be available.
     * 
     * @param {Number}
     *            cursor The position of the data in the model to start
     *            rendering.
     * 
     * @param {Boolean}
     *            forceReplace <tt>true</tt> for recomputing the DOM in the
     *            view, otherwise <tt>false</tt>.
     */
    // private
    replaceLiveRows : function (cursor, forceReplace, processRows) {
        var spill = cursor - this.lastRowIndex;

        if (spill === 0 && forceReplace !== true) {
            return;
        }

        // decide wether to prepend or append rows
        // if spill is negative, we are scrolling up. Thus we have to prepend
        // rows. If spill is positive, we have to append the buffers data.
        var append = spill > 0;

        // abs spill for simplyfiying append/prepend calculations
        spill = Math.abs(spill);

        // adjust cursor to the buffered model index
        var bufferRange = this.ds.bufferRange;
        var cursorBuffer = cursor - bufferRange[0];

        // compute the last possible renderindex
        var lpIndex = Math.min(cursorBuffer + this.visibleRows - 1, bufferRange[1] - bufferRange[0]);
        // we can skip checking for append or prepend if the spill is larger
        // than
        // visibleRows. We can paint the whole rows new then-
        if (spill >= this.visibleRows || spill === 0) {
            this.mainBody.update(this.renderRows(cursorBuffer, lpIndex));
        } else {
            if (append) {

                this.removeRows(0, spill - 1);

                if (cursorBuffer + this.visibleRows - spill <= bufferRange[1] - bufferRange[0]) {
                    var html = this.renderRows(cursorBuffer + this.visibleRows - spill, lpIndex);
                    Ext.DomHelper.insertHtml('beforeEnd', this.mainBody.dom, html);

                }

            } else {
                this.removeRows(this.visibleRows - spill, this.visibleRows - 1);
                html = this.renderRows(cursorBuffer, cursorBuffer + spill - 1);
                Ext.DomHelper.insertHtml('beforeBegin', this.mainBody.dom.firstChild, html);

            }
        }

        if (processRows !== false) {
            this.processRows(0, undefined, true);
        }
        this.lastRowIndex = cursor;
    },

    /**
     * Adjusts the scroller height to make sure each row in the dataset will be
     * can be displayed, no matter which value the current height of the grid
     * component equals to.
     */
    // protected
    adjustBufferInset : function () {
        var liveScrollerDom = this.liveScroller.dom;
        var g = this.grid, ds = g.store;
        var c = g.getGridEl();
        var elWidth = c.getSize().width;

        // hidden rows is the number of rows which cannot be
        // displayed and for which a scrollbar needs to be
        // rendered. This does also take clipped rows into account
        var hiddenRows = (ds.totalLength == this.visibleRows - this.rowClipped) ? 0 : Math.max(0, ds.totalLength - (this.visibleRows - this.rowClipped));

        if (hiddenRows === 0) {
            this.scroller.setWidth(elWidth);
            liveScrollerDom.style.display = 'none';
            return;
        } else {
            this.scroller.setWidth(elWidth - this.getScrollOffset());
            liveScrollerDom.style.display = '';
        }

        var scrollbar = this.cm.getTotalWidth() + this.getScrollOffset() > elWidth;

        // adjust the height of the scrollbar
        var contHeight = liveScrollerDom.parentNode.offsetHeight + ((ds.totalLength > 0 && scrollbar) ? -this.horizontalScrollOffset : 0) - this.hdHeight;

        liveScrollerDom.style.height = Math.max(contHeight, this.horizontalScrollOffset * 2) + "px";
		this.liveScroller.dom.style.width = (this.getScrollOffset() + 2) + "px";
		
        if (this.rowHeight == -1) {
            return;
        }

        var cm = this.cm;
        
        var vw = elWidth - this.getScrollOffset();
        var hso = 0, hh = 0;
        // horizontal scrollbar shown?
        if (cm.getTotalWidth() > vw) {
            // yes!
            hso = this.horizontalScrollOffset;
        }
        hh = this.mainHd.getHeight();
        

        var h = (hiddenRows === 0 ? 0 : ds.totalLength * this.rowHeight + hso + hh);//contHeight + (hiddenRows * this.rowHeight));
        //DA : Ajouter une limitation a la taille de la div générée. Générer un message pour l'utilisateur en cas de dépassement. 
        if (h > 35791380) {
            h = 35000000;
            var nbRecords = Math.floor(h / this.rowHeight);
            if (this._displayWarningTooManyRows) {
                Ext.Msg.alert(i18n.get('label.warning'), String.format(i18n.get("label.tooManyRecords"), nbRecords, this.visibleRows + hiddenRows));
                this._displayWarningTooManyRows = false;
            }
            
        }
        var oh = h;
        var len = this.liveScrollerInsets.length;

        if (h === 0) {
            h = 0;
        } else {
            h = Math.round(h / len);
        }

        for (var i = 0; i < len; i++) {
            if (i == len - 1 && h !== 0) {
                h = oh - (h * i);
            }
            this.liveScrollerInsets[i].style.height = h + "px";
        }
    },

    /**
     * Recomputes the number of visible rows in the table based upon the height
     * of the component. The method adjusts the <tt>rowIndex</tt> property as
     * needed, if the sum of visible rows and the current row index exceeds the
     * number of total data available.
     */
    // protected
    adjustVisibleRows : function () {
        if (this.rowHeight == -1) {
            if (this.getRows()[0]) {
                this.rowHeight = this.getRows()[0].offsetHeight;

                if (this.rowHeight <= 0) {
                    this.rowHeight = -1;
                    return;
                }

            } else {
                return;
            }
        }

        var g = this.grid, ds = g.store;

        var c = g.getGridEl();
        var cm = this.cm;
        var size = c.getSize();
        var width = size.width;
        var vh = size.height;

        var vw = width - this.getScrollOffset();
        // horizontal scrollbar shown?
        if (cm.getTotalWidth() > vw) {
            // yes!
            vh -= this.horizontalScrollOffset;
        }

        vh -= this.mainHd.getHeight();

        var totalLength = ds.totalLength || 0;

        var visibleRows = Math.max(1, Math.floor(vh / this.rowHeight));

        this.rowClipped = 0;
        // only compute the clipped row if the total length of records
        // exceeds the number of visible rows displayable
        if (totalLength > visibleRows && this.rowHeight / 3 < (vh - (visibleRows * this.rowHeight))) {
            visibleRows = Math.min(visibleRows + 1, totalLength);
            this.rowClipped = 1;
        }

        // if visibleRows didn't change, simply void and return.
        if (this.visibleRows == visibleRows) {
            return;
        }

        this.visibleRows = visibleRows;

        // skip recalculating the row index if we are currently buffering, but
        // not if we
        // are just pre-buffering
        if (this.isBuffering && !this.isPrebuffering) {
            return;
        }

        // when re-rendering, doe not take the clipped row into account
        if (this.rowIndex + (visibleRows - this.rowClipped) > totalLength) {
            this.rowIndex = Math.max(0, totalLength - (visibleRows - this.rowClipped));
            this.lastRowIndex = this.rowIndex;
        }

        this.updateLiveRows(this.rowIndex, true);
    },

    adjustScrollerPos : function (pixels, suspendEvent) {
        if (pixels === 0) {
            return;
        }
        var liveScroller = this.liveScroller;
        var scrollDom = liveScroller.dom;

        if (suspendEvent === true) {
            liveScroller.un('scroll', this.onLiveScroll, this);
        }
        this.lastScrollPos = scrollDom.scrollTop;
        scrollDom.scrollTop += pixels;

        if (suspendEvent === true) {
            scrollDom.scrollTop = scrollDom.scrollTop;
            liveScroller.on('scroll', this.onLiveScroll, this, {
                buffer : this.scrollDelay
            });
        }

    }

});
/**
 * Ext.ux.grid.livegrid.JsonReader Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.JsonReader is licensed under the terms of the GNU Open
 * Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.JsonReader
 * @extends Ext.data.JsonReader
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.JsonReader = function (meta, recordType) {

    Ext.ux.grid.livegrid.JsonReader.superclass.constructor.call(this, meta, recordType);
};

Ext.extend(Ext.ux.grid.livegrid.JsonReader, Ext.data.JsonReader, {

    /**
     * @cfg {String} versionProperty Name of the property from which to retrieve
     *      the version of the data repository this reader parses the reponse
     *      from
     */

    buildExtractors : function () {
        if (this.ef) {
            return;
        }

        var s = this.meta;

        if (s.versionProperty) {
            this.getVersion = this.createAccessor(s.versionProperty);
        }

        Ext.ux.grid.livegrid.JsonReader.superclass.buildExtractors.call(this);
    },

    /**
     * Create a data block containing Ext.data.Records from a JSON object.
     * 
     * @param {Object}
     *            o An object which contains an Array of row objects in the
     *            property specified in the config as 'root, and optionally a
     *            property, specified in the config as 'totalProperty' which
     *            contains the total size of the dataset.
     * @return {Object} data A data block which is used by an Ext.data.Store
     *         object as a cache of Ext.data.Records.
     */
    readRecords : function (o) {
        // shorten for future calls
        if (!this.__readRecords) {
            this.__readRecords = Ext.ux.grid.livegrid.JsonReader.superclass.readRecords;
        }
        var intercept = this.__readRecords.call(this, o);

        if (this.meta.versionProperty) {
            var v = this.getVersion(o);
            intercept.version = (v === undefined || v === "") ? null : v;
        }
        //TODO
        if (Ext.isEmpty(o.total)) {
            intercept.totalRecords = this.totalRecordsSitools;
        } else {
            this.totalRecordsSitools = o.total;
        }

        return intercept;
    }

});
/**
 * Ext.ux.grid.livegrid.RowSelectionModel Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.RowSelectionModel is licensed under the terms of the GNU
 * Open Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.RowSelectionModel
 * @extends Ext.grid.RowSelectionModel
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.RowSelectionModel = function (config) {
    
    this.addEvents({
        /**
         * The selection dirty event will be triggered in case records were
         * inserted/ removed at view indexes that may affect the current
         * selection ranges which are only represented by view indexes, but not
         * current record-ids
         */
        'selectiondirty' : true,
        
        //SITOOLS, MG, nouvel event pour gérer les selections
        'handleMouseDown' : true
    });

    Ext.apply(this, config);

    this.pendingSelections = {};

    Ext.ux.grid.livegrid.RowSelectionModel.superclass.constructor.call(this);

};

Ext.extend(Ext.ux.grid.livegrid.RowSelectionModel, Ext.grid.RowSelectionModel, {

    // private
    initEvents : function () {
        Ext.ux.grid.livegrid.RowSelectionModel.superclass.initEvents.call(this);

        this.grid.view.on('rowsinserted', this.onAdd, this);
        this.grid.store.on('selectionsload', this.onSelectionsLoad, this);
    },

    // private : DA : supprimer le view.focusRow (celui ci provoque un probleme
    // lorsque le scroll horizontal est important
    //SITOOLS, MG, nouvel event pour gérer les selections

    handleMouseDown : function (g, rowIndex, e) {
        if (e.button !== 0 || this.isLocked()) {
            return;
        }
        var view = this.grid.getView();
        if (e.shiftKey && !this.singleSelect && this.last !== false) {
            var last = this.last;
            this.selectRange(last, rowIndex, e.ctrlKey);
            this.last = last;
            // view.focusRow(rowIndex);
            this.fireEvent('handleMouseDown', this);
        } else {
            var isSelected = this.isSelected(rowIndex);
            if (e.ctrlKey && isSelected) {
                this.deselectRow(rowIndex);
                this.fireEvent('handleMouseDown', this);
            } else if (!isSelected || this.getCount() > 1) {
                this.selectRow(rowIndex, e.ctrlKey || e.shiftKey);
                this.fireEvent('handleMouseDown', this);
                // view.focusRow(rowIndex);
            }
        }
        
    },

    /**
     * Callback is called when a row gets removed in the view. The process to
     * invoke this method is as follows:
     * 
     * <ul>
     * <li>1. store.remove(record);</li>
     * <li>2. view.onRemove(store, record, indexInStore, isUpdate)<br />
     * [view triggers rowremoved event]</li>
     * <li>3. this.onRemove(view, indexInStore, record)</li>
     * </ul>
     * 
     * If r defaults to <tt>null</tt> and index is within the pending
     * selections range, the selectionchange event will be called, too.
     * Additionally, the method will shift all selections and trigger the
     * selectiondirty event if any selections are pending.
     * 
     */
    onRemove : function (v, index, r) {
        var ranges = this.getPendingSelections();
        var rangesLength = ranges.length;
        var selectionChanged = false;

        // if index equals to Number.MIN_VALUE or Number.MAX_VALUE, mark current
        // pending selections as dirty
        if (index == Number.MIN_VALUE || index == Number.MAX_VALUE) {

            if (r) {
                // if the record is part of the current selection, shift the
                // selection down by 1
                // if the index equals to Number.MIN_VALUE
                if (this.isIdSelected(r.id) && index == Number.MIN_VALUE) {
                    // bufferRange already counted down when this method gets
                    // called
                    this.shiftSelections(this.grid.store.bufferRange[1], -1);
                }
                this.selections.remove(r);
                selectionChanged = true;
            }

            // clear all pending selections that are behind the first
            // bufferrange, and shift all pending Selections that lay in front
            // front of the second bufferRange down by 1!
            if (index == Number.MIN_VALUE) {
                this.clearPendingSelections(0, this.grid.store.bufferRange[0]);
            } else {
                // clear pending selections that are in front of bufferRange[1]
                this.clearPendingSelections(this.grid.store.bufferRange[1]);
            }

            // only fire the selectiondirty event if there were pendning ranges
            if (rangesLength !== 0) {
                this.fireEvent('selectiondirty', this, index, 1);
            }

        } else {

            selectionChanged = this.isIdSelected(r.id);

            // if the record was not part of the selection, return
            if (!selectionChanged) {
                return;
            }

            this.selections.remove(r);
            // this.last = false;
            // if there are currently pending selections, look up the interval
            // to tell whether removing the record would mark the selection
            // dirty
            if (rangesLength !== 0) {

                var startRange = ranges[0];
                var endRange = ranges[rangesLength - 1];
                if (index <= endRange || index <= startRange) {
                    this.shiftSelections(index, -1);
                    this.fireEvent('selectiondirty', this, index, 1);
                }
            }

        }

        if (selectionChanged) {
            this.fireEvent('selectionchange', this);
        }
    },

    /**
     * If records where added to the store, this method will work as a callback,
     * called by the views' rowsinserted event. Selections will be shifted down
     * if, and only if, the listeners for the selectiondirty event will return
     * <tt>true</tt>.
     * 
     */
    onAdd : function (store, index, endIndex, recordLength) {
        var ranges = this.getPendingSelections();
        var rangesLength = ranges.length;

        // if index equals to Number.MIN_VALUE or Number.MAX_VALUE, mark current
        // pending selections as dirty
        if ((index == Number.MIN_VALUE || index == Number.MAX_VALUE)) {

            if (index == Number.MIN_VALUE) {
                // bufferRange already counted down when this method gets
                // called
                this.clearPendingSelections(0, this.grid.store.bufferRange[0]);
                this.shiftSelections(this.grid.store.bufferRange[1], recordLength);
            } else {
                this.clearPendingSelections(this.grid.store.bufferRange[1]);
            }

            // only fire the selectiondirty event if there were pendning ranges
            if (rangesLength !== 0) {
                this.fireEvent('selectiondirty', this, index, r);
            }

            return;
        }

        // it is safe to say that the selection is dirty when the inserted index
        // is less or equal to the first selection range index or less or equal
        // to the last selection range index
        var startRange = ranges[0];
        var endRange = ranges[rangesLength - 1];
        var viewIndex = index;
        if (viewIndex <= endRange || viewIndex <= startRange) {
            this.fireEvent('selectiondirty', this, viewIndex, recordLength);
            this.shiftSelections(viewIndex, recordLength);
        }
    },

    /**
     * Shifts current/pending selections. This method can be used when rows
     * where inserted/removed and the selection model has to synchronize itself.
     */
    shiftSelections : function (startRow, length) {
        var index = 0;
        var newIndex = 0;
        var newRequests = {};

        var ds = this.grid.store;
        var storeIndex = startRow - ds.bufferRange[0];
        var newStoreIndex = 0;
        var totalLength = this.grid.store.totalLength;
        var rec = null;

        // this.last = false;

        var ranges = this.getPendingSelections();
        var rangesLength = ranges.length;

        if (rangesLength === 0) {
            return;
        }

        for (var i = 0; i < rangesLength; i++) {
            index = ranges[i];

            if (index < startRow) {
                continue;
            }

            newIndex = index + length;
            newStoreIndex = storeIndex + length;
            if (newIndex >= totalLength) {
                break;
            }

            rec = ds.getAt(newStoreIndex);
            if (rec) {
                this.selections.add(rec);
            } else {
                newRequests[newIndex] = true;
            }
            //DA : Ajout de l'objet allSelections
            this.allSelections[newIndex] = true;
        }

        this.pendingSelections = newRequests;
    },

    /**
     * 
     * @param {Array}
     *            records The records that have been loaded
     * @param {Array}
     *            ranges An array representing the model index ranges the reords
     *            have been loaded for.
     */
    onSelectionsLoad : function (store, records, ranges) {
        this.replaceSelections(records);
    },

    /**
     * Returns true if there is a next record to select
     * 
     * @return {Boolean}
     */
    hasNext : function () {
        return this.last !== false && (this.last + 1) < this.grid.store.getTotalCount();
    },

    /**
     * Gets the number of selected rows.
     * 
     * @return {Number}
     */
    getCount : function () {
        return this.selections.length + this.getPendingSelections().length;
    },

    /**
     * Returns True if the specified row is selected.
     * 
     * @param {Number/Record}
     *            record The record or index of the record to check
     * @return {Boolean}
     */
    isSelected : function (index) {
        if (typeof index == "number") {
            var orgInd = index;
            index = this.grid.store.getAt(orgInd);
            if (!index) {
                var ind = this.getPendingSelections().indexOf(orgInd);
                if (ind != -1) {
                    return true;
                }

                return false;
            }
        }

        var r = index;
        return (r && this.selections.key(r.id) ? true : false);
    },

    /**
     * Deselects a record. The emthod assumes that the record is physically
     * available, i.e. pendingSelections will not be taken into account
     */
    deselectRecord : function (record, preventViewNotify) {
        if (this.locked) {
            return;
        }

        var isSelected = this.selections.key(record.id);

        if (!isSelected) {
            return;
        }

        var store = this.grid.store;
        var index = store.indexOfId(record.id);

        if (index == -1) {
            index = store.findInsertIndex(record);
            if (index != Number.MIN_VALUE && index != Number.MAX_VALUE) {
                index += store.bufferRange[0];
            }
        } else {
            // just to make sure, though this should not be
            // set if the record was availablein the selections
            delete this.pendingSelections[index];
        }

        if (this.last == index) {
            this.last = false;
        }

        if (this.lastActive == index) {
            this.lastActive = false;
        }
		
		//DA : suppression de l'item ds allSelections
		delete this.allSelections[index];
        this.selections.remove(record);

        if (!preventViewNotify) {
            this.grid.getView().onRowDeselect(index);
        }
        this.fireEvent("rowdeselect", this, index, record);
        this.fireEvent("selectionchange", this);
    },

    /**
     * Deselects a row.
     * 
     * @param {Number}
     *            row The index of the row to deselect
     */
    deselectRow : function (index, preventViewNotify) {
        if (this.locked) {
            return;
        }
        if (this.last == index) {
            this.last = false;
        }

        if (this.lastActive == index) {
            this.lastActive = false;
        }
        var r = this.grid.store.getAt(index);

        //DA : gestion de l'objet allSelections
        delete this.allSelections[index];
        delete this.pendingSelections[index];

        if (r) {
            this.selections.remove(r);
        }
        // SITOOLS 
        this.last = this.lastActive = index;
        
        if (!preventViewNotify) {
            this.grid.getView().onRowDeselect(index);
        }
        
        if (!this.silent) {
            this.fireEvent("rowdeselect", this, index, r);
            this.fireEvent("selectionchange", this);
        }
    },

    /**
     * Selects a row.
     * 
     * @param {Number}
     *            row The index of the row to select
     * @param {Boolean}
     *            keepExisting (optional) True to keep existing selections
     */
    selectRow : function (index, keepExisting, preventViewNotify) {
        if (// this.last === index
        // ||
        this.locked || index < 0 || index >= this.grid.store.getTotalCount()) {
            return;
        }

        var r = this.grid.store.getAt(index);

        if (this.fireEvent("beforerowselect", this, index, keepExisting, r) !== false) {
            if (!keepExisting || this.singleSelect) {
                this.clearSelections();
            }

            if (r) {
                this.selections.add(r);
                delete this.pendingSelections[index];
            } else {
                this.pendingSelections[index] = true;
            }
			//DA : gestion de l'objet allSelections
			this.allSelections[index] = true;
			
            this.last = this.lastActive = index;

            if (!preventViewNotify) {
                this.grid.getView().onRowSelect(index);
            }
            

            if (!this.silent) {
                this.fireEvent("rowselect", this, index, r);
                this.fireEvent("selectionchange", this);
            }

        }
    },

    clearPendingSelections : function (startIndex, endIndex) {
        if (endIndex === undefined) {
            endIndex = Number.MAX_VALUE;
        }

        var newSelections = {};

        var ranges = this.getPendingSelections();
        var rangesLength = ranges.length;

        var index = 0;

        for (var i = 0; i < rangesLength; i++) {
            index = ranges[i];
            if (index <= endIndex && index >= startIndex) {
                continue;
            }

            newSelections[index] = true;
        }

        this.pendingSelections = newSelections;
    },

    /**
     * Replaces already set data with new data from the store if those records
     * can be found within this.selections or this.pendingSelections
     * 
     * @param {Array}
     *            An array with records buffered by the store
     */
    replaceSelections : function (records) {
        if (!records || records.length === 0) {
            return;
        }

        var ds = this.grid.store;
        var rec = null;

        var assigned = [];
        var ranges = this.getPendingSelections();
        var rangesLength = ranges.length;

        var selections = this.selections;
        var index = 0;

        for (var i = 0; i < rangesLength; i++) {
            index = ranges[i];
            rec = ds.getAt(index);
            if (rec) {
                selections.add(rec);
                assigned.push(rec.id);
                delete this.pendingSelections[index];
            }
        }

        var id = null;
        var len = null;
        for (i = 0, len = records.length; i < len; i++) {
            rec = records[i];
            id = rec.id;
            if (assigned.indexOf(id) == -1 && selections.containsKey(id)) {
                selections.add(rec);
            }
        }

    },

    getPendingSelections : function (asRange) {
        var index = 1;
        var ranges = [];
        var currentRange = 0;
        var tmpArray = [];

        for (var i in this.pendingSelections) {
            tmpArray.push(parseInt(i));
        }

        tmpArray.sort(function (o1, o2) {
            if (o1 > o2) {
                return 1;
            } else if (o1 < o2) {
                return -1;
            } else {
                return 0;
            }
        });

        if (!asRange) {
            return tmpArray;
        }

        var max_i = tmpArray.length;

        if (max_i === 0) {
            return [];
        }

        ranges[currentRange] = [ tmpArray[0], tmpArray[0] ];
        for (var i = 0, max_i = max_i - 1; i < max_i; i++) {
            if (tmpArray[i + 1] - tmpArray[i] == 1) {
                ranges[currentRange][1] = tmpArray[i + 1];
            } else {
                currentRange++;
                ranges[currentRange] = [ tmpArray[i + 1], tmpArray[i + 1] ];
            }
        }

        return ranges;
    },

    getAllSelections : function (asRange) {
        var index = 1;
        var ranges = [];
        var currentRange = 0;
        var tmpArray = [];

        for (var i in this.allSelections) {
            tmpArray.push(parseInt(i));
        }

        tmpArray.sort(function (o1, o2) {
            if (o1 > o2) {
                return 1;
            } else if (o1 < o2) {
                return -1;
            } else {
                return 0;
            }
        });

        if (!asRange) {
            return tmpArray;
        }

        var max_i = tmpArray.length;

        if (max_i === 0) {
            return [];
        }

        ranges[currentRange] = [ tmpArray[0], tmpArray[0] ];
        for (var i = 0, max_i = max_i - 1; i < max_i; i++) {
            if (tmpArray[i + 1] - tmpArray[i] == 1) {
                ranges[currentRange][1] = tmpArray[i + 1];
            } else {
                currentRange++;
                ranges[currentRange] = [ tmpArray[i + 1], tmpArray[i + 1] ];
            }
        }

        return ranges;
    },

    /**
     * Clears all selections.
     */
    clearSelections : function (fast) {
        if (this.locked) {
            return;
        }
        //SITOOLS MG, clear all selections, not only the ones in the store
        if (fast !== true) {
            var s = this.getAllSelections();
            this.silent = true;
            s.each(function (ind) {
                if (ind != -1) {
                    this.deselectRow(ind);
                }
            }, this);
            s.clear();
            this.silent = false;
            this.deselectRow(0);

            this.pendingSelections = {};

        } else {
            this.selections.clear();
            this.pendingSelections = {};
        }
        this.allSelections = {};
        this.last = false;
    },

    /**
     * Selects a range of rows. All rows in between startRow and endRow are also
     * selected.
     * 
     * @param {Number}
     *            startRow The index of the first row in the range
     * @param {Number}
     *            endRow The index of the last row in the range
     * @param {Boolean}
     *            keepExisting (optional) True to retain existing selections
     */
    selectRange : function (startRow, endRow, keepExisting) {
        if (this.locked) {
            return;
        }

        if (!keepExisting) {
            this.clearSelections();
        }

        if (startRow <= endRow) {
            this.silent = true;
            for (var i = startRow; i < endRow; i++) {
                this.selectRow(i, true);
            }
            this.silent = false;
            this.selectRow(endRow, true);
        } else {
            this.silent = true;
            for (var i = startRow; i > endRow; i--) {
                this.selectRow(i, true);
            }
            this.silent = false;
            this.selectRow(endRow, true);
        }

    },
    
    /**
     * Deselects a range of rows if the selection model
     * {@link Ext.grid.AbstractSelectionModel#isLocked is not locked}.  
     * All rows in between startRow and endRow are also deselected.
     * @param {Number} startRow The index of the first row in the range
     * @param {Number} endRow The index of the last row in the range
     */
    deselectRange : function (startRow, endRow, preventViewNotify) {
        if(this.isLocked()){
            return;
        }
        this.silent = true;
        for(var i = startRow; i < endRow; i++){
            this.deselectRow(i, preventViewNotify);
        }
        this.silent = false;
        this.deselectRow(endRow, preventViewNotify);

    },
    
    /**
     * Selects all rows if the selection model
     * {@link Ext.grid.AbstractSelectionModel#isLocked is not locked}. 
     */
    selectAll : function (keepExisting) {
        if(this.isLocked()){
            return
        }
        this.selections.clear();
        var store = this.grid.store;
        this.selectRange(store.bufferRange[0],store.bufferRange[1] , (Ext.isEmpty(keepExisting)?false:keepExisting));
    }

});

/**
 * Ext.ux.grid.livegrid.Store Copyright (c) 2007-2008, http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.Store is licensed under the terms of the GNU Open Source
 * GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.Store
 * @extends Ext.data.Store
 * 
 * The BufferedGridSore is a special implementation of a Ext.data.Store. It is
 * used for loading chunks of data from the underlying data repository as
 * requested by the Ext.ux.BufferedGridView. It's size is limited to the config
 * parameter bufferSize and is thereby guaranteed to never hold more than this
 * amount of records in the store.
 * 
 * Requesting selection ranges: ---------------------------- This store
 * implementation has 2 Http-proxies: A data proxy for requesting data from the
 * server for displaying and another proxy to request pending selections:
 * Pending selections are represented by row indexes which have been selected
 * but which records have not yet been available in the store. The
 * loadSelections method will initiate a request to the data repository (same
 * url as specified in the url config parameter for the store) to fetch the
 * pending selections. The additional parameter send to the server is the
 * "ranges" parameter, which will hold a json encoded string representing ranges
 * of row indexes to load from the data repository. As an example, pending
 * selections with the indexes 1,2,3,4,5,9,10,11,16 would have to be translated
 * to [1,5],[9,11],[16]. Please note, that by indexes we do not understand
 * (primary) keys of the data, but indexes as represented by the view. To get
 * the ranges of pending selections, you can use the getPendingSelections method
 * of the BufferedRowSelectionModel, which should be used as the default
 * selection model of the grid.
 * 
 * Version-property: ----------------- This implementation does also introduce a
 * new member called "version". The version property will help you in
 * determining if any pending selections indexes are still valid or may have
 * changed. This is needed to reduce the danger of data inconsitence when you
 * are requesting data from the server: As an example, a range of indexes must
 * be read from the server but may have been become invalid when the row
 * represented by the index is no longer available in teh underlying data store,
 * caused by a delete or insert operation. Thus, you have to take care of the
 * version property by yourself (server side) and change this value whenever a
 * row was deleted or inserted. You can specify the path to the version property
 * in the BufferedJsonReader, which should be used as the default reader for
 * this store. If the store recognizes a version change, it will fire the
 * versionchange event. It is up to the user to remove all selections which are
 * pending, or use them anyway.
 * 
 * Inserting data: --------------- Another thing to notice is the way a user
 * inserts records into the data store. A user should always provide a sortInfo
 * for the grid, so the findInsertIndex method can return a value that comes
 * close to the value as it would have been computed by the underlying store's
 * sort algorithm. Whenever a record should be added to the store, the insert
 * index should be calculated and the used as the parameter for the insert
 * method. The findInsertIndex method will return a value that equals to
 * Number.MIN_VALUE or Number.MAX_VALUE if the added record would not change the
 * current state of the store. If that happens, this data is not available in
 * the store, and may be requested later on when a new request for new data is
 * made.
 * 
 * Sorting: -------- remoteSort will always be set to true, no matter what value
 * the user provides using the config object.
 * 
 * @constructor Creates a new Store.
 * @param {Object}
 *            config A config object containing the objects needed for the Store
 *            to access data, and read the data into Records.
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.Store = function (config) {

    config = config || {};

    // remoteSort will always be set to true.
    config.remoteSort = true;

    // we will intercept the autoLoad property and set it to false so we do not
    // load any contents of the store before the View has not fully initialized
    // itself. if autoLoad was set to true, the Ext.ux.grid.livegrid.GridPanel
    // will take care of loading the store once it has been rendered
    this._autoLoad = config.autoLoad ? true : false;
    config.autoLoad = false;

    this.addEvents(
    /**
     * @event bulkremove Fires when a bulk remove operation was finished.
     * @param {Ext.ux.BufferedGridStore}
     *            this
     * @param {Array}
     *            An array with the records that have been removed. The values
     *            for each array index are record - the record that was removed
     *            index - the index of the removed record in the store
     */
    'bulkremove',
    /**
     * @event versionchange Fires when the version property has changed.
     * @param {Ext.ux.BufferedGridStore}
     *            this
     * @param {String}
     *            oldValue
     * @param {String}
     *            newValue
     */
    'versionchange',
    /**
     * @event beforeselectionsload Fires before the store sends a request for
     *        ranges of records to the server.
     * @param {Ext.ux.BufferedGridStore}
     *            this
     * @param {Array}
     *            ranges
     */
    'beforeselectionsload',
    /**
     * @event selectionsload Fires when selections have been loaded.
     * @param {Ext.ux.BufferedGridStore}
     *            this
     * @param {Array}
     *            records An array containing the loaded records from the
     *            server.
     * @param {Array}
     *            ranges An array containing the ranges of indexes this records
     *            may represent.
     */
    'selectionsload');

    Ext.ux.grid.livegrid.Store.superclass.constructor.call(this, config);

    this.totalLength = 0;

    /**
     * The array represents the range of rows available in the buffer absolute
     * to the indexes of the data model. Initialized with [-1, -1] which tells
     * that no records are currrently buffered
     * 
     * @param {Array}
     */
    this.bufferRange = [ -1, -1 ];

    this.on('clear', function () {
        this.bufferRange = [ -1, -1 ];
    }, this);

    if (this.url && !this.selectionsProxy) {
        this.selectionsProxy = new Ext.data.HttpProxy({
            url : this.url
        });
    }

};

Ext.extend(Ext.ux.grid.livegrid.Store, Ext.data.Store, {

    /**
     * The version of the data in the store. This value is represented by the
     * versionProperty-property of the BufferedJsonReader.
     * 
     * @property
     */
    version : null,

    /**
     * Inserts a record at the position as specified in index. If the index
     * equals to Number.MIN_VALUE or Number.MAX_VALUE, the record will not be
     * added to the store, but still fire the add-event to indicate that the set
     * of data in the underlying store has been changed. If the index equals to
     * 0 and the length of data in the store equals to bufferSize, the add-event
     * will be triggered with Number.MIN_VALUE to indicate that a record has
     * been prepended. If the index equals to bufferSize, the method will assume
     * that the record has been appended and trigger the add event with index
     * set to Number.MAX_VALUE.
     * 
     * Note: ----- The index parameter is not a view index, but a value in the
     * range of [0, this.bufferSize].
     * 
     * You are strongly advised to not use this method directly. Instead, call
     * findInsertIndex wirst and use the return-value as the first parameter for
     * for this method.
     */
    insert : function (index, records) {
        // hooray for haskell!
        records = [].concat(records);

        index = index >= this.bufferSize ? Number.MAX_VALUE : index;

        if (index == Number.MIN_VALUE || index == Number.MAX_VALUE) {
            var l = records.length;
            if (index == Number.MIN_VALUE) {
                this.bufferRange[0] += l;
                this.bufferRange[1] += l;
            }

            this.totalLength += l;
            this.fireEvent("add", this, records, index);
            return;
        }

        var split = false;
        var insertRecords = records;
        if (records.length + index >= this.bufferSize) {
            split = true;
            insertRecords = records.splice(0, this.bufferSize - index);
        }
        this.totalLength += insertRecords.length;

        // if the store was loaded without data and the bufferRange
        // has to be filled first
        if (this.bufferRange[0] <= -1) {
            this.bufferRange[0] = 0;
        }
        if (this.bufferRange[1] < (this.bufferSize - 1)) {
            this.bufferRange[1] = Math.min(this.bufferRange[1] + insertRecords.length, this.bufferSize - 1);
        }

        for (var i = 0, len = insertRecords.length; i < len; i++) {
            this.data.insert(index, insertRecords[i]);
            insertRecords[i].join(this);
        }

        while (this.getCount() > this.bufferSize) {
            this.data.remove(this.data.last());
        }

        this.fireEvent("add", this, insertRecords, index);

        if (split === true) {
            this.fireEvent("add", this, records, Number.MAX_VALUE);
        }
    },

    /**
     * Remove a Record from the Store and fires the remove event.
     * 
     * This implementation will check for the appearance of the record id in the
     * store. The record to be removed does not neccesarily be bound to the
     * instance of this store. If the record is not within the store, the method
     * will try to guess it's index by calling findInsertIndex.
     * 
     * Please note that this method assumes that the records that's about to be
     * removed from the store does belong to the data within the store or the
     * underlying data store, thus the remove event will always be fired. This
     * may lead to inconsitency if you have to stores up at once. Let A be the
     * store that reads from the data repository C, and B the other store that
     * only represents a subset of data of the data repository C. If you now
     * remove a record X from A, which has not been in the store, but is assumed
     * to be available in the data repository, and would like to sync the
     * available data of B, then you have to check first if X may have apperead
     * in the subset of data C represented by B before calling remove from the B
     * store (because the remove operation will always trigger the "remove"
     * event, no matter what). (Common use case: you have selected a range of
     * records which are then stored in the row selection model. User scrolls
     * through the data and the store's buffer gets refreshed with new data for
     * displaying. Now you want to remove all records which are within the
     * rowselection model, but not anymore within the store.) One possible
     * workaround is to only remove the record X from B if, and only if the
     * return value of a call to [object instance of store B].data.indexOf(X)
     * does not return a value less than 0. Though not removing the record from
     * B may not update the view of an attached BufferedGridView immediately.
     * 
     * @param {Ext.data.Record}
     *            record
     * @param {Boolean}
     *            suspendEvent true to suspend the "remove"-event
     * 
     * @return Number the index of the record removed.
     */
    remove : function (record, suspendEvent) {
        // check wether the record.id can be found in this store
        var index = this._getIndex(record);

        if (index < 0) {
            this.totalLength -= 1;
            if (this.pruneModifiedRecords) {
                this.modified.remove(record);
            }
            // adjust the buffer range if a record was removed
            // in the range that is actually behind the bufferRange
            this.bufferRange[0] = Math.max(-1, this.bufferRange[0] - 1);
            this.bufferRange[1] = Math.max(-1, this.bufferRange[1] - 1);

            if (suspendEvent !== true) {
                this.fireEvent("remove", this, record, index);
            }
            return index;
        }

        this.bufferRange[1] = Math.max(-1, this.bufferRange[1] - 1);
        this.data.removeAt(index);

        if (this.pruneModifiedRecords) {
            this.modified.remove(record);
        }

        this.totalLength -= 1;
        if (suspendEvent !== true) {
            this.fireEvent("remove", this, record, index);
        }

        return index;
    },

    _getIndex : function (record) {
        var index = this.indexOfId(record.id);

        if (index < 0) {
            index = this.findInsertIndex(record);
        }

        return index;
    },

    /**
     * Removes a larger amount of records from the store and fires the
     * "bulkremove" event. This helps listeners to determine whether the remove
     * operation of multiple records is still pending.
     * 
     * @param {Array}
     *            records
     */
    bulkRemove : function (records) {
        var rec = null;
        var recs = [];
        var ind = 0;
        var len = records.length;

        var orgIndexes = [];
        for (var i = 0; i < len; i++) {
            rec = records[i];

            orgIndexes[rec.id] = this._getIndex(rec);
        }

        for (var i = 0; i < len; i++) {
            rec = records[i];
            this.remove(rec, true);
            recs.push([ rec, orgIndexes[rec.id] ]);
        }

        this.fireEvent("bulkremove", this, recs);
    },

    /**
     * Remove all Records from the Store and fires the clear event. The method
     * assumes that there will be no data available anymore in the underlying
     * data store.
     */
    removeAll : function () {
        this.totalLength = 0;
        this.bufferRange = [ -1, -1 ];
        this.data.clear();

        if (this.pruneModifiedRecords) {
            this.modified = [];
        }
        this.fireEvent("clear", this);
    },

    /**
     * Requests a range of data from the underlying data store. Similiar to the
     * start and limit parameter usually send to the server, the method needs an
     * array of ranges of indexes. Example: To load all records at the positions
     * 1,2,3,4,9,12,13,14, the supplied parameter should equal to
     * [[1,4],[9],[12,14]]. The request will only be done if the
     * beforeselectionsloaded events return value does not equal to false.
     */
    loadRanges : function (ranges) {
        var max_i = ranges.length;

        if (max_i > 0 && !this.selectionsProxy.activeRequest[Ext.data.Api.actions.read] && this.fireEvent("beforeselectionsload", this, ranges) !== false) {

            var lParams = this.lastOptions.params;

            var params = {};
            params.ranges = Ext.encode(ranges);

            if (lParams) {
                if (lParams.sort) {
                    params.sort = lParams.sort;
                }
                if (lParams.dir) {
                    params.dir = lParams.dir;
                }
            }

            var options = {};
            for (var i in this.lastOptions) {
                options.i = this.lastOptions.i;
            }

            options.ranges = params.ranges;

            this.selectionsProxy.doRequest(Ext.data.Api.actions.read, null, options, this.reader,
                    this.selectionsLoaded, this, options);
        }
    },

    /**
     * Alias for loadRanges.
     */
    loadSelections : function (ranges) {
        if (ranges.length === 0) {
            return;
        }
        this.loadRanges(ranges);
    },

    /**
     * Called as a callback by the proxy which loads pending selections. Will
     * fire the selectionsload event with the loaded records if, and only if the
     * return value of the checkVersionChange event does not equal to false.
     */
    selectionsLoaded : function (o, options, success) {
        if (this.checkVersionChange(o, options, success) !== false) {

            var r = o.records;
            for (var i = 0, len = r.length; i < len; i++) {
                r[i].join(this);
            }

            this.fireEvent("selectionsload", this, o.records, Ext.decode(options.ranges));
        } else {
            this.fireEvent("selectionsload", this, [], Ext.decode(options.ranges));
        }
    },

    /**
     * Checks if the version supplied in <tt>o</tt> differs from the version
     * property of the current instance of this object and fires the
     * versionchange event if it does.
     */
    // private
    checkVersionChange : function (o, options, success) {
        if (o && success !== false) {
            if (o.version !== undefined) {
                var old = this.version;
                this.version = o.version;
                if (this.version !== old) {
                    return this.fireEvent('versionchange', this, old, this.version);
                }
            }
        }
    },

    /**
     * The sort procedure tries to respect the current data in the buffer. If
     * the found index would not be within the bufferRange, Number.MIN_VALUE is
     * returned to indicate that the record would be sorted below the first
     * record in the buffer range, while Number.MAX_VALUE would indicate that
     * the record would be added after the last record in the buffer range.
     * 
     * The method is not guaranteed to return the relative index of the record
     * in the data model as returned by the underlying domain model.
     */
    findInsertIndex : function (record) {
        this.remoteSort = false;
        var index = Ext.ux.grid.livegrid.Store.superclass.findInsertIndex.call(this, record);
        this.remoteSort = true;

        // special case... index is 0 and we are at the very first record
        // buffered
        if (this.bufferRange[0] <= 0 && index === 0) {
            return index;
        } else if (this.bufferRange[0] > 0 && index === 0) {
            return Number.MIN_VALUE;
        } else if (index >= this.bufferSize) {
            return Number.MAX_VALUE;
        }

        return index;
    },

    /**
     * Removed snapshot check
     */
    // private
    sortData : function (f, direction) {
        direction = direction || 'ASC';
        var st = this.fields.get(f).sortType;
        var fn = function (r1, r2) {
            var v1 = st(r1.data[f]), v2 = st(r2.data[f]);
            return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
        };
        this.data.sort(direction, fn);
    },

    /**
     * @cfg {Number} bufferSize The number of records that will at least always
     *      be available in the store for rendering. This value will be send to
     *      the server as the <tt>limit</tt> parameter and should not change
     *      during the lifetime of a grid component. Note: In a paging grid,
     *      this number would indicate the page size. The value should be set
     *      high enough to make a userfirendly scrolling possible and should be
     *      greater than the sum of {nearLimit} and {visibleRows}. Usually, a
     *      value in between 150 and 200 is good enough. A lesser value will
     *      more often make the store re-request new data, while a larger number
     *      will make loading times higher.
     */

    // private
    onMetaChange : function (meta, rtype, o) {
        this.version = null;
        Ext.ux.grid.livegrid.Store.superclass.onMetaChange.call(this, meta, rtype, o);
    },

    /**
     * Will fire the versionchange event if the version of incoming data has
     * changed.
     */
    // private
    loadRecords : function (o, options, success) {
        this.checkVersionChange(o, options, success);

        // we have to stay in sync with rows that may have been skipped while
        // the request was loading.
        // if the response didn't make it through, set buffer range to -1,-1
        if (!o) {
            this.bufferRange = [ -1, -1 ];
        } else {
            this.bufferRange = [ options.params.start,
                    Math.max(0, Math.min((options.params.start + options.params.limit) - 1, o.totalRecords - 1)) ];
        }

        if (options.suspendLoadEvent === true) {
            this.suspendEvents();
        }
        Ext.ux.grid.livegrid.Store.superclass.loadRecords.call(this, o, options, success);
        if (options.suspendLoadEvent === true) {
            this.resumeEvents();
        }
    },

    /**
     * Get the Record at the specified index. The function will take the
     * bufferRange into account and translate the passed argument to the index
     * of the record in the current buffer.
     * 
     * @param {Number}
     *            index The index of the Record to find.
     * @return {Ext.data.Record} The Record at the passed index. Returns
     *         undefined if not found.
     */
    getAt : function (index) {
        // anything buffered yet?
        if (this.bufferRange[0] == -1) {
            return undefined;
        }
        
        var modelIndex = index - this.bufferRange[0];
        return this.data.itemAt(modelIndex);
    },

    // --------------------------------------EMPTY-----------------------------------
    // no interface concept, so simply overwrite and leave them empty as for now
    clearFilter : function () {
    },
    isFiltered : function () {
    },
    collect : function () {
    },
    createFilterFn : function () {
    },
    sum : function () {
    },
    filter : function () {
    },
    filterBy : function () {
    },
    query : function () {
    },
    queryBy : function () {
    },
    find : function () {
    },
    findBy : function () {
    }

});
/**
 * Ext.ux.grid.livegrid.Toolbar Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.Toolbar is licensed under the terms of the GNU Open
 * Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * toolbar that is bound to a {@link Ext.ux.grid.livegrid.GridView} and provides
 * information about the indexes of the requested data and the buffer state.
 * 
 * @class Ext.ux.grid.livegrid.Toolbar
 * @extends Ext.Toolbar
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.Toolbar = Ext.extend(Ext.Toolbar, {

    /**
     * @cfg {Ext.grid.GridPanel} grid The grid the toolbar is bound to. If
     *      ommited, use the cfg property "view"
     */

    /**
     * @cfg {Ext.grid.GridView} view The view the toolbar is bound to The grid
     *      the toolbar is bound to. If ommited, use the cfg property "grid"
     */

    /**
     * @cfg {Boolean} displayInfo True to display the displayMsg (defaults to
     *      false)
     */

    /**
     * @cfg {String} displayMsg The paging status message to display (defaults
     *      to "Displaying {start} - {end} of {total}")
     */
    displayMsg : "",

    /**
     * @cfg {String} emptyMsg The message to display when no records are found
     *      (defaults to "No data to display")
     */
    emptyMsg : 'No data to display',

    /**
     * Value to display as the tooltip text for the refresh button. Defaults to
     * "Refresh"
     * 
     * @param {String}
     */
    refreshText : "Refresh",

    initComponent : function () {
        this.displayMsg = i18n.get('paging.display');
        Ext.ux.grid.livegrid.Toolbar.superclass.initComponent.call(this);

        if (this.grid) {
            this.view = this.grid.getView();
        }

        var me = this;
        this.view.init = this.view.init.createSequence(function () {
            me.bind(this);
        }, this.view);
    },

    // private
    updateInfo : function (rowIndex, visibleRows, totalCount) {
        if (this.displayEl) {
            var msg = totalCount === 0 ? this.emptyMsg : String.format(this.displayMsg, rowIndex + 1, Math.min(rowIndex + 1 + visibleRows, totalCount), totalCount);
            this.displayEl.update(msg);
        }
    },

    /**
     * Unbinds the toolbar.
     * 
     * @param {Ext.grid.GridView|Ext.gid.GridPanel}
     *            view Either The view to unbind or the grid
     */
    unbind : function (view) {
        var st;
        var vw;

        if (view instanceof Ext.grid.GridView) {
            vw = view;
        } else {
            // assuming parameter is of type Ext.grid.GridPanel
            vw = view.getView();
        }

        st = view.ds;

        st.un('loadexception', this.enableLoading, this);
        st.un('beforeload', this.disableLoading, this);
        st.un('load', this.enableLoading, this);
        vw.un('rowremoved', this.onRowRemoved, this);
        vw.un('rowsinserted', this.onRowsInserted, this);
        vw.un('beforebuffer', this.beforeBuffer, this);
        vw.un('cursormove', this.onCursorMove, this);
        vw.un('buffer', this.onBuffer, this);
        vw.un('bufferfailure', this.enableLoading, this);

        this.view = undefined;
    },

    /**
     * Binds the toolbar to the specified {@link Ext.ux.grid.Livegrid}
     * 
     * @param {Ext.grird.GridView}
     *            view The view to bind
     */
    bind : function (view) {
        this.view = view;
        var st = view.ds;

        st.on('loadexception', this.enableLoading, this);
        st.on('beforeload', this.disableLoading, this);
        st.on('load', this.enableLoading, this);
        view.on('rowremoved', this.onRowRemoved, this);
        view.on('rowsinserted', this.onRowsInserted, this);
        view.on('beforebuffer', this.beforeBuffer, this);
        view.on('cursormove', this.onCursorMove, this);
        view.on('buffer', this.onBuffer, this);
        view.on('bufferfailure', this.enableLoading, this);
    },

    // ----------------------------------- Listeners
    // -------------------------------
    enableLoading : function () {
        this.loading.setDisabled(false);
    },

    disableLoading : function () {
        this.loading.setDisabled(true);
    },

    onCursorMove : function (view, rowIndex, visibleRows, totalCount) {
        this.updateInfo(rowIndex, visibleRows, totalCount);
    },

    // private
    onRowsInserted : function (view, start, end) {
        this.updateInfo(view.rowIndex, Math.min(view.ds.totalLength, view.visibleRows - view.rowClipped),
                view.ds.totalLength);
    },

    // private
    onRowRemoved : function (view, index, record) {
        this.updateInfo(view.rowIndex, Math.min(view.ds.totalLength, view.visibleRows - view.rowClipped),
                view.ds.totalLength);
    },

    // private
    beforeBuffer : function (view, store, rowIndex, visibleRows, totalCount, options) {
        this.loading.disable();
        this.updateInfo(rowIndex, visibleRows, totalCount);
    },

    // private
    onBuffer : function (view, store, rowIndex, visibleRows, totalCount) {
        this.loading.enable();
        this.updateInfo(rowIndex, visibleRows, totalCount);
        //plot refresh when data is buffered
        var plotComp = Ext.getCmp("plot" + this.ownerCt.datasetId);
        if (plotComp) {
            var rightPanel = plotComp.findById('plot-right-panel');
            var success = rightPanel.fireEvent('buffer', store, rowIndex, visibleRows, totalCount);
        }
    },

    // private
    onClick : function (type) {
        switch (type) {
        case 'refresh':
            if (this.view.reset(true)) {
                this.loading.disable();
            } else {
                this.loading.enable();
            }
            break;

        }
    },

    // private
    onRender : function (ct, position) {
        Ext.PagingToolbar.superclass.onRender.call(this, ct, position);

        this.loading = new Ext.Toolbar.Button({
            tooltip : this.refreshText,
            iconCls : "x-tbar-loading",
            handler : this.onClick.createDelegate(this, [ "refresh" ])
        });

        this.addButton(this.loading);

        this.addSeparator();

        if (this.displayInfo) {
            this.displayEl = Ext.fly(this.el.dom).createChild({
                cls : 'x-paging-info'
            });
        }
    }
});
/**
 * Ext.ux.grid.livegrid.DragZone Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.DragZone is licensed under the terms of the GNU Open
 * Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.DragZone
 * @extends Ext.dd.DragZone
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.DragZone = function (grid, config) {

    Ext.ux.grid.livegrid.DragZone.superclass.constructor.call(this, grid, config);

    this.view.ds.on('beforeselectionsload', this._onBeforeSelectionsLoad, this);
    this.view.ds.on('selectionsload', this._onSelectionsLoad, this);
};

Ext.extend(Ext.ux.grid.livegrid.DragZone, Ext.grid.GridDragZone, {

    /**
     * Tells whether a drop is valid. Used inetrnally to determine if pending
     * selections need to be loaded/ have been loaded.
     * 
     * @type {Boolean}
     */
    isDropValid : true,

    /**
     * Overriden for loading pending selections if needed.
     */
    onInitDrag : function (e) {
        this.view.ds.loadSelections(this.grid.selModel.getPendingSelections(true));

        Ext.ux.grid.livegrid.DragZone.superclass.onInitDrag.call(this, e);
    },

    /**
     * Gets called before pending selections are loaded. Any drop operations are
     * invalid/get paused if the component needs to wait for selections to load
     * from the server.
     * 
     */
    _onBeforeSelectionsLoad : function () {
        this.isDropValid = false;
        Ext.fly(this.proxy.el.dom.firstChild).addClass('ext-ux-livegrid-drop-waiting');
    },

    /**
     * Gets called after pending selections have been loaded. Any paused drop
     * operation will be resumed.
     * 
     */
    _onSelectionsLoad : function () {
        this.isDropValid = true;
        this.ddel.innerHTML = this.grid.getDragDropText();
        Ext.fly(this.proxy.el.dom.firstChild).removeClass('ext-ux-livegrid-drop-waiting');
    }
});
/**
 * Ext.ux.grid.livegrid.EditorGridPanel Copyright (c) 2007-2008,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.EditorGridPanel is licensed under the terms of the GNU
 * Open Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://www.siteartwork.de/livegrid> if
 * you need to obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */

Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.EditorGridPanel
 * @extends Ext.grid.EditorGridPanel
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.EditorGridPanel = Ext.extend(Ext.grid.EditorGridPanel, {

    /**
     * Overriden so the panel listens to the "cursormove" event for cancelling
     * any edit that is in progress.
     * 
     * @private
     */
    initEvents : function () {
        Ext.ux.grid.livegrid.EditorGridPanel.superclass.initEvents.call(this);

        this.view.on("cursormove", this.stopEditing, this, [ true ]);
    },

    /**
     * Starts editing the specified for the specified row/column Will be
     * cancelled if the requested row index to edit is not represented by data
     * due to out of range regarding the view's store buffer.
     * 
     * @param {Number}
     *            rowIndex
     * @param {Number}
     *            colIndex
     */
    startEditing : function (row, col) {
        this.stopEditing();
        if (this.colModel.isCellEditable(col, row)) {
            this.view.ensureVisible(row, col, true);
            if (!this.store.getAt(row)) {
                return;
            }
        }

        return Ext.ux.grid.livegrid.EditorGridPanel.superclass.startEditing.call(this, row, col);
    },

    // Since we do not have multiple inheritance, we need to override the
    // same methods in this class we have overriden for
    // Ext.ux.grid.livegrid.GridPanel
    walkCells : function (row, col, step, fn, scope) {
        return Ext.ux.grid.livegrid.GridPanel.prototype.walkCells.call(this, row, col, step, fn, scope);
    },

    onRender : function (ct, position) {
        return Ext.ux.grid.livegrid.GridPanel.prototype.onRender.call(this, ct, position);
    },

    initComponent : function () {
        if (this.cls) {
            this.cls += ' ext-ux-livegrid';
        } else {
            this.cls = 'ext-ux-livegrid';
        }

        return Ext.ux.grid.livegrid.EditorGridPanel.superclass.initComponent.call(this);
    }

});
/**
 * Ext.ux.grid.livegrid.CheckboxSelectionModel Copyright (c) 2007-2012,
 * http://www.siteartwork.de
 * 
 * Ext.ux.grid.livegrid.CheckboxSelectionModel is licensed under the terms of
 * the GNU Open Source GPL 3.0 license.
 * 
 * Commercial use is prohibited. Visit <http://ext-livegrid.com> if you need to
 * obtain a commercial license.
 * 
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 * 
 */
/*global Ext, sitools, i18n, sql2ext, extColModelToSrv, window, 
 extColModelToJsonColModel, DEFAULT_NEAR_LIMIT_SIZE,
 DEFAULT_LIVEGRID_BUFFER_SIZE, SITOOLS_DEFAULT_IHM_DATE_FORMAT,
 DEFAULT_PREFERENCES_FOLDER, SitoolsDesk, getDesktop, userLogin, projectGlobal, getColumnModel, loadUrl, getApp
*/
Ext.namespace('Ext.ux.grid.livegrid');

/**
 * @class Ext.ux.grid.livegrid.CheckboxSelectionModel
 * @extends Ext.ux.grid.livegrid.RowSelectionModel
 * @constructor
 * @param {Object}
 *            config
 * 
 * @author Thorsten Suckow-Homberg <ts@siteartwork.de>
 */
Ext.ux.grid.livegrid.CheckboxSelectionModel = Ext.extend(Ext.ux.grid.livegrid.RowSelectionModel, {

    /**
     * @cfg {Boolean} checkOnly <tt>true</tt> if rows can only be selected by
     *      clicking on the checkbox column (defaults to <tt>false</tt>).
     */
    /**
     * @cfg {Number} width The default width in pixels of the checkbox column
     *      (defaults to <tt>20</tt>).
     */
    width : 20,

    // private
    menuDisabled : true,
    sortable : false,
    fixed : true,
    dataIndex : '',
    id : 'checker',
    headerCheckbox : null,
    markAll : false,
    
    ready : false,

    isColumn : true, // So that ColumnModel doesn't feed this through the
                        // Column constructor

    constructor : function (config) {
        Ext.apply(this, config);
        
        this.addEvents(
                /**
                 * @event selectionmodelready
                 * Fires when the selectionmodel is ready to be selected
                 * @param {SelectionModel} this
                 */
                'selectionmodelready'
        );
        
        
        
        this.headerChecked = '<div id="qtip-checker" ext:qtip="' + i18n.get('label.deselectAll') + '" class="x-grid3-hd-checker">&#160;</div>';
        this.headerUnchecked = '<div id="qtip-checker" ext:qtip="' + i18n.get('label.selectAll') + '" class="x-grid3-hd-checker">&#160;</div>';

        if (!this.header) {
            this.header = this.headerUnchecked;
           //this.header = Ext.grid.CheckboxSelectionModel.prototype.header;
        }

        if (this.checkOnly) {
            this.handleMouseDown = Ext.emptyFn;
        }

        this.sortable = false;

        Ext.ux.grid.livegrid.CheckboxSelectionModel.superclass.constructor.call(this);

    },

    // private
    initEvents : function () {
        Ext.ux.grid.livegrid.CheckboxSelectionModel.superclass.initEvents.call(this);

        this.grid.view.on('reset', function (gridView, forceReload) {
            this.headerCheckbox = new Ext.Element(gridView.getHeaderCell(this.grid.getColumnModel().getIndexById(this.id)).firstChild);
            if (this.markAll && forceReload === false) {
                this.headerCheckbox.addClass('x-grid3-hd-checker-on');
            }
        }, this);
        
        
        this.grid.view.addListener('buffer', function() {
            if(this.markAll){
                this.selectAll();
            }
        }, this);

        // this.grid.on('render', function(){
        // Ext.fly(this.grid.getView().innerHd).on('mousedown',
        // this.onHdMouseDown, this);
        // }, this);

        Ext.grid.CheckboxSelectionModel.prototype.initEvents.call(this);
    },

    /**
     * @private Process and refire events routed from the GridView's
     *          processEvent method.
     */
    processEvent : function (name, e, grid, rowIndex, colIndex) {
        if (name == 'mousedown') {
            this.onMouseDown(e, e.getTarget());
            return false;
        } else {
            return Ext.grid.Column.prototype.processEvent.apply(this, arguments);
        }
    },

    // private
    onMouseDown : function (e, t) {
        if (e.button === 0 && t.className == 'x-grid3-row-checker') {
            e.stopEvent();
            var row = e.getTarget('.x-grid3-row');
            if (row) {
                var index = row.rowIndex;
                if (this.isSelected(index)) {
                    if (this.markAll) {
                        // Show a dialog using config options:
                        this.selectRow(index, false);
                    } else {
                        if (e.shiftKey && !this.singleSelect && this.last !== false) {
                            var last = this.last;
                            this.deselectRange(last, index);
                            this.last = last;
                            // view.focusRow(rowIndex);
                            // this.fireEvent('handleMouseDown', this);
                        } else {
                            this.deselectRow(index);
                        }
                    }
                } else {
                    if (e.shiftKey && !this.singleSelect && this.last !== false) {
                        var last = this.last;
                        this.selectRange(last, index, true);
                        this.last = last;
                        // view.focusRow(rowIndex);
                        // this.fireEvent('handleMouseDown', this);
                    } else {
                        this.selectRow(index, true);
                    }
                    // this.grid.getView().focusRow(index);
                }
                if (this.headerCheckbox) {
                    this.markAll = false;
                    this.headerCheckbox.removeClass('x-grid3-hd-checker-on');
                }
            }
        }
    },

    // private
    onHdMouseDown : function (e, t) {
        if (t.className == 'x-grid3-hd-checker' && !this.headerCheckbox) {
            this.headerCheckbox = new Ext.Element(t.parentNode);
        }

        if (t.className == 'x-grid3-hd-checker') {
            e.stopEvent();
            var hd = Ext.fly(t.parentNode);
            var isChecked = hd.hasClass('x-grid3-hd-checker-on');
            if (isChecked) {
                hd.removeClass('x-grid3-hd-checker-on');
                hd.child('div').dom.outerHTML = this.headerUnchecked;
                this.clearSelections();
            } else {
                hd.addClass('x-grid3-hd-checker-on');
                hd.child('div').dom.outerHTML = this.headerChecked;
                this.selectAll();
            }
        }

    },

    // private
    renderer : function (v, p, record) {
        return Ext.grid.CheckboxSelectionModel.prototype.renderer.call(this, v, p, record);
    },

    // -------- overrides

    /**
     * Overriden to prevent selections by shift-clicking
     */
    handleMouseDown : function (g, rowIndex, e) {
        // if (e.shiftKey) {
        // return;
        // }

//        this.markAll = false;

        if (this.headerCheckbox) {
            this.headerCheckbox.removeClass('x-grid3-hd-checker-on');
        }

        Ext.ux.grid.livegrid.CheckboxSelectionModel.superclass.handleMouseDown.call(this, g, rowIndex, e);
    },

    /**
     * Overriden to clear header sort state
     */
    clearSelections : function (fast) {
        if (this.isLocked()) {
            return;
        }

        this.markAll = false;

        if (this.headerCheckbox) {
            this.headerCheckbox.removeClass('x-grid3-hd-checker-on');
        }

        //always clearSelections in fast mode
        Ext.ux.grid.livegrid.CheckboxSelectionModel.superclass.clearSelections.call(this, true);
        
        if (!fast) {
            //done only on user change selection, not at livegrid startup
            this.fireEvent("selectionchange", this);
            this.grid.getView().refresh();
            this.grid.getView().processRows(0, false);
        }
    },

    /**
     * Selects all rows if the selection model
     * {@link Ext.grid.AbstractSelectionModel#isLocked is not locked}.
     */
    selectAll : function () {
        this.clearSelections();
        this.markAll = true;

        if (this.headerCheckbox) {
            this.headerCheckbox.addClass('x-grid3-hd-checker-on');
        }
        Ext.ux.grid.livegrid.CheckboxSelectionModel.superclass.selectAll.call(this, true);
    },
    
    onRefresh : function () {
        Ext.ux.grid.livegrid.CheckboxSelectionModel.superclass.onRefresh.call(this);
        if (!this.ready) {
            this.ready = true;
            this.fireEvent('selectionmodelready', this);
        }
    },
    
    isReady : function () {
        return this.ready;
    }

});/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, i18n, sql2ext, extColModelToSrv, window,
 extColModelToJsonColModel, DEFAULT_NEAR_LIMIT_SIZE,
 DEFAULT_LIVEGRID_BUFFER_SIZE, SITOOLS_DEFAULT_IHM_DATE_FORMAT,
 DEFAULT_PREFERENCES_FOLDER, SitoolsDesk, getDesktop, userLogin, projectGlobal, ColumnRendererEnum, SITOOLS_DATE_FORMAT
*/
Ext.namespace('sitools.user.component.dataviews');

/**
 * A Simple Object to publish common methods to use dataviews in Sitools2.
 * @type 
 */
sitools.user.component.dataviews.dataviewUtils = {
//sitools.user.component.liveGrid.dataviewUtils = {
    /**
     * build the param that will represent the active selection.
     * @param [Ext.data.Record] recSelected the selected records
     * @returns {} this object contains the param that will use FORM API 
     */
    getFormParamsFromRecsSelected : function (recSelected) {
        var rec = recSelected[0], result = {};
        var primaryKeyName = "";
        Ext.each(rec.fields.items, function (field) {
            if (field.primaryKey) {
                primaryKeyName = field.name;
            }
        });
        if (Ext.isEmpty(primaryKeyName)) {
            Ext.Msg.alert(i18n.get('label.error'), i18n.get('label.noPrimaryKey'));
            return;
        }
        // build the primaryKey Value
        var primaryKeyValues = [];
        Ext.each(recSelected, function (record) {
            primaryKeyValues.push(record.get(primaryKeyName));
        });

        // use the form API to request the selected records
        result["p[0]"] = "LISTBOXMULTIPLE|" + primaryKeyName + "|" + primaryKeyValues.join("|");
        return result;
    },
    

    /**
     * Get the renderer for a column from its featureType for the DataView
     * @param {Object} item col the Column definition
     * @param {Object} dataviewConfig the specific dataview Configuration.
     * @return {function} the renderer for a column
     */
    getRendererLiveGrid : function (item, dataviewConfig) {
        var renderer;
        if (!Ext.isEmpty(item.columnRenderer)) {
            renderer = function (value, metadata, record, rowIndex, colIndex,
                    store) {
                if (!Ext.isEmpty(value)) {
                    if (!Ext.isEmpty(item.columnRenderer.toolTip)){
                        metadata.attr = 'ext:qtip="' + item.columnRenderer.toolTip + '"';
                    }
                    
                    var imageStyle = "max-width:" + (item.width - 10) + "px;";
                    if (!Ext.isEmpty(dataviewConfig) && !Ext.isEmpty(dataviewConfig.lineHeight)) {
                        imageStyle += "max-height: " + (dataviewConfig.lineHeight - 10) + "px;";
                    }
                    var html = sitools.user.component.dataviews.dataviewUtils.getRendererHTML(item, imageStyle );
                    var str;
                    if (!Ext.isEmpty(html)) {
                        if (item.columnRenderer.behavior == ColumnRendererEnum.IMAGE_FROM_SQL) {
                            var imageUrl = record.get(item.columnRenderer.columnAlias);                     
                            str = String.format(html, value, imageUrl);
                        } else {
                            str = String.format(html, value);
                        }
                    }
                    return str;
                } else {
                    return value;
                }                
            };
        } else {
            renderer = function (value) {
                var valueFormat = value;
                if (sql2ext.get(item.sqlColumnType) == 'dateAsString') {
                    valueFormat = sitools.user.component.dataviews.dataviewUtils.formatDate(
                            value, item);
                }
                if (sql2ext.get(item.sqlColumnType) == 'boolean') {
                    valueFormat = value ? i18n.get('label.true') : i18n
                            .get('label.false');
                }
                return valueFormat;
            };
        }
        return renderer;
    },
    

    
    /**
     * Get the template to render a column from its featureType for the DataView
     * @param {Object} col the Column definition
     * @param {String} style the style to add to the label part
     * @param {Object} dataviewConfig the specific dataview Configuration.
     * @return {String} a template to render a column from its featureType for the DataView
     */
    getRendererDataView : function (col, style, dataviewConfig) {
            var tplString = "", value, behavior, label, valueDisplayed;
            var columnRenderer = col.columnRenderer;
            if (!Ext.isEmpty(columnRenderer)) {
                behavior = columnRenderer.behavior;
                var html = sitools.user.component.dataviews.dataviewUtils.getRendererHTML(col, dataviewConfig);
                switch (behavior) {
                case ColumnRendererEnum.URL_LOCAL :
                case ColumnRendererEnum.URL_EXT_NEW_TAB :
                case ColumnRendererEnum.URL_EXT_DESKTOP :
               
                case ColumnRendererEnum.DATASET_ICON_LINK :
                    if (!Ext.isEmpty(columnRenderer.linkText)) {
                        tplString += String.format("<tpl if=\"this.isNotEmpty({0})\">", col.columnAlias);              
                        value = String.format(html, "{" + col.columnAlias + "}");
                        tplString += String.format('<span class="dataview_columnValue"><div class=x-view-entete style="{2}">{0} </div> {1}</span>', col.header, value, style);
                        tplString += "</tpl>";            
                        tplString += String.format("<tpl if=\"this.isEmpty({0})\">", col.columnAlias);
                        value = "";
                        tplString += String.format('<span class="dataview_columnValue"><div class=x-view-entete style="{2}">{0} </div> {1}</span>', col.header, value, style);
                        tplString += "</tpl>";
                    } else if (!Ext.isEmpty(columnRenderer.image)) {
                        tplString += String.format("<tpl if=\"this.isNotEmpty({0})\">", col.columnAlias);
                        tplString += String.format('<li  class="img-link" ext:qtip="{0}">', col.header);
                        tplString += String.format(html, "{" + col.columnAlias + "}");
                        tplString += '</li></tpl>';
                    }
                    break;
                case ColumnRendererEnum.IMAGE_THUMB_FROM_IMAGE :
                    tplString += String.format("<tpl if=\"this.isNotEmpty({0})\">", col.columnAlias);
                    tplString += String.format('<li  class="img-link" ext:qtip="{0}">', col.header);
                    tplString += String.format(html, "{" + col.columnAlias + "}");
                    tplString += '</li></tpl>';
                    break;
                case ColumnRendererEnum.IMAGE_FROM_SQL :
                    var imageUrl = "";
                    if (!Ext.isEmpty(columnRenderer.url)) {
                        imageUrl = columnRenderer.url;
                    } else if (!Ext.isEmpty(columnRenderer.columnAlias)) {
                        imageUrl = "{" + columnRenderer.columnAlias + "}";            
                    }
                    tplString += String.format("<tpl if=\"this.isNotEmpty({0})\">", col.columnAlias);
                    tplString += String.format('<li  class="img-link" ext:qtip="{0}">', col.header, imageUrl);
                    tplString += String.format(html, "{" + col.columnAlias + "}", imageUrl);
                    tplString += '</li></tpl>';
                    break;
                default :                                 
                    tplString += String.format("<tpl if=\"this.isNotEmpty({0})\">", col.columnAlias);
                    value = String.format(html, "{" + col.columnAlias + "}");
                    tplString += String.format('<span class="dataview_columnValue"><div class=x-view-entete style="{2}">{0} </div> {1}</span>', col.header, value, style);
                    tplString += "</tpl>";            
                    tplString += String.format("<tpl if=\"this.isEmpty({0})\">", col.columnAlias);
                    value = "";
                    tplString += String.format('<span class="dataview_columnValue"><div class=x-view-entete style="{2}">{0} </div> {1}</span>', col.header, value, style);
                    tplString += "</tpl>";                    
                    break;
                }
            } else {
                if (sql2ext.get(col.sqlColumnType) == 'dateAsString') {
                    tplString += String.format('<span class="dataview_columnValue"><div class=x-view-entete style="{2}">{0} </div> <tpl if=\"this.isValidDate({1})\">{[Date.parseDate(values.{1}, SITOOLS_DATE_FORMAT).format("{3}")]}</tpl></span>', 
                        col.header, 
                        col.columnAlias, 
                        style, 
                        Ext.isEmpty(col.format) ? SITOOLS_DEFAULT_IHM_DATE_FORMAT : col.format);
                }
                else {
                    tplString += String.format('<span class="dataview_columnValue"><div class=x-view-entete style="{2}">{0} </div> {{1}}</span>', col.header, col.columnAlias, style);
                }
            }
            return tplString;
        },
    
    /**
     * Get the HTML specific part to render a column corresponding to its featureType (columnRenderer)
     * It is a formated date where {0} must be replaced by the column value and {1} by the imageUrl to display in big only for ColumnRendererEnum.IMAGE_FROM_SQL
     * @param {Object} item the column definition
     * @param {Object} dataviewConfig the specific dataview Configuration.
     * @return {String} a formated HTML String 
     */
    getRendererHTML : function (item, imageStyle) {
        var renderer, valueDisplayed, imageUrl;
        var html;
        if (!Ext.isEmpty(item.columnRenderer) && !Ext.isEmpty(item.columnRenderer.behavior)) {
            
            var columnRenderer = item.columnRenderer;
            switch (columnRenderer.behavior) {
            case ColumnRendererEnum.URL_LOCAL :
            case ColumnRendererEnum.URL_EXT_NEW_TAB :
            case ColumnRendererEnum.URL_EXT_DESKTOP :
                if (!Ext.isEmpty(columnRenderer.linkText)) {
                    html = "<span class='link featureType' sitools:column='"+item.columnAlias+"'>" + columnRenderer.linkText + "</span>";
                } else if (!Ext.isEmpty(columnRenderer.image)) {
                    html = "<div class='image-link featureType' sitools:column='"+item.columnAlias+"'><img src=\"" + columnRenderer.image.url + "\" class='sitools-display-image' style ='" + imageStyle + "' ></img></div>";
                }
                break;
            case ColumnRendererEnum.IMAGE_NO_THUMB :
                html = "<span class='link featureType' sitools:column='"+item.columnAlias+"'>" + columnRenderer.linkText + "</span>"; 
                break;
            case ColumnRendererEnum.IMAGE_THUMB_FROM_IMAGE :
                html = "<div class='image-link featureType' sitools:column='"+item.columnAlias+"'><img class='sitools-display-image' src='{0}' style ='" + imageStyle + "'></img></div>";  
                break;
            case ColumnRendererEnum.IMAGE_FROM_SQL :
                html = "<div class='image-link featureType' sitools:column='"+item.columnAlias+"'><img class='sitools-display-image image-link' src='{1}' style ='" + imageStyle + "'></div>"; 
                break;
            case ColumnRendererEnum.DATASET_LINK :
                html = "<span class='link featureType' sitools:column='"+item.columnAlias+"'>{0}</span>"; 
                break;
            case ColumnRendererEnum.DATASET_ICON_LINK :
                if (!Ext.isEmpty(columnRenderer.image)) {
                    imageUrl = columnRenderer.image.url;                    
                }
                html = "<div class='image-link featureType' sitools:column='"+item.columnAlias+"'><img style ='" + imageStyle + "' class='sitools-display-image' src='" + imageUrl + "'></div>";
                break;
            default : 
                html = "{0}"; 
                break;
            }
        } 

        return html;
    },
    
    getRendererViewDataDetails : function (item) {
        
        
    },
    

    /**
     * Execute the action on a featureType column. It can be either a
     * Gui_Service action if one is configured, or a classic featureType
     * action
     * 
     * @param column
     *            {Object} the column
     * @param record
     *            {Ext.data.Record} the record
     * @param controller
     *            {sitools.user.component.dataviews.services.GuiServiceController}
     *            the current Gui_Service controller
     */
    featureTypeAction : function (column, record, controller) {
        var service = controller.getService(column.columnAlias);
        if (!Ext.isEmpty(service)) {
            controller.callGuiService(service.id, record, column.columnAlias);
        }
        else {
            this.executeFeatureType(column, record);
        }
    },
    /**
     * Execute the featureType action depending on the given column and record
     * 
     * @param column
     *            {Object} the column
     * @param record
     *            {Ext.data.Record} the record
     */
    executeFeatureType : function (column, record) {
        if (!Ext.isEmpty(column.columnRenderer) && !Ext.isEmpty(column.columnRenderer.behavior)) {
            var value = record.get(column.columnAlias);
            var columnRenderer = column.columnRenderer;
            switch (columnRenderer.behavior) {
            case ColumnRendererEnum.URL_LOCAL :
                sitools.user.component.dataviews.dataviewUtils.downloadData(value);
                break;
            case ColumnRendererEnum.URL_EXT_NEW_TAB :
                window.open(value); 
                break;
            case ColumnRendererEnum.URL_EXT_DESKTOP :
                sitools.user.component.dataviews.dataviewUtils.showDisplayableUrl(value, columnRenderer.displayable); 
                break;
            case ColumnRendererEnum.IMAGE_NO_THUMB :
                sitools.user.component.dataviews.dataviewUtils.showPreview(value, columnRenderer.linkText); 
                break;
            case ColumnRendererEnum.IMAGE_THUMB_FROM_IMAGE :
            case ColumnRendererEnum.IMAGE_FROM_SQL :
                sitools.user.component.dataviews.dataviewUtils.showPreview(value, column.header); 
                break;
            case ColumnRendererEnum.DATASET_LINK :
            case ColumnRendererEnum.DATASET_ICON_LINK :
                sitools.user.component.dataviews.dataviewUtils.showDetailsData(value, columnRenderer.columnAlias, columnRenderer.datasetLinkUrl); 
                break;
            default : 
                break;
            }
        } 
    },
    
    
    
    formatDate : function (value, item) {
        var valueFormat;
        var result = Date.parseDate(value, SITOOLS_DATE_FORMAT, true);                
        // try to build Date with "Y-m-d" format
        if (Ext.isEmpty(result)) {
            valueFormat = "";
        }
        else {
            if (Ext.isEmpty(item.format)) {
                valueFormat = result.format(SITOOLS_DEFAULT_IHM_DATE_FORMAT);
            }
            else {
                try {
                    valueFormat = result.format(item.format);
                }
                catch (err) {
                    valueFormat = "unable to format Date";
                }
            }
        }
        return valueFormat;    
    }, 
    /**
     * @static
     * Execute a REST OPTION request to the value url. 
     * Switch on Content-Type value to determine if we open a new iframe, or a window. 
     * @param {} value the url to request 
     */
    downloadData : function (value) {
    //    value = encodeURIComponent(value);
       //build first request to get the headers
        Ext.Ajax.request({
            url : value,
            method : 'HEAD',
            scope : this,
            success : function (ret) {
                try {
                    var headerFile = ret.getResponseHeader("Content-Type")
                            .split(";")[0].split("/")[0];
                    if (headerFile == "text") {
                        Ext.Ajax.request({
                            url : value,
                            method : 'GET',
                            scope : this,
                            success : function (ret) {
                                var windowConfig = {
                                    id : "winPreferenceDetailId",
                                    title : value, 
                                    iconCls : "version"
                                };
                                var jsObj = Ext.Panel;
                                var componentCfg = {
                                    layout : 'fit',
                                    autoScroll : true,
                                    html : ret.responseText
                                };
                                SitoolsDesk.addDesktopWindow(
                                        windowConfig, componentCfg,
                                        jsObj);
                            }
                        });
                    } else if (headerFile == "image") {
                        sitools.user.component.dataviews.dataviewUtils.showPreview(value, item.header);
                    } else {
                        sitools.user.component.dataviews.dataviewUtils.downloadFile(value);         
                    }
                } catch (err) {
                    Ext.Msg.alert(i18n.get('label.error'), err);
                }
            },
            failure : function (ret) {
                return null;
            }
        });
    }, 
    /**
     * @static Build a MIF panel with a given url and load it into the desktop
     * @param {}
     *            value the url to request
     * @param {boolean}
     *            true if the url is displayable in a window, false otherwise
     */
    showDisplayableUrl : function (value, isDisplayable, customConfig) {
        if (isDisplayable) {
            
            if (customConfig) {
                var windowConfig = customConfig;
            }
            else {
                var windowConfig = {
                    title : value,
                    id : value, 
                    iconCls : "version"
                };
            }
            
            var jsObj = Ext.ux.ManagedIFrame.Panel;
            var componentCfg = {
                defaults : {
                    padding : 10
                },
                layout : 'fit',
                region : 'center',
                defaultSrc : value,
                listeners : {
                    documentloaded : function (iframe){
                        this.ownerCt.syncSize();
                    }
                }
            };
            
        SitoolsDesk.addDesktopWindow(
                windowConfig, componentCfg,
                jsObj);
        } else {             
            sitools.user.component.dataviews.dataviewUtils.downloadFile(value);                
        }
        
    }, 
    /**
     * Use a spcialized MIF to download datas...
     * @param {String} url the url to request.
     */
    downloadFile : function (url) {
        if (Ext.getCmp("mifToDownload")) {
            Ext.getCmp("mifToDownload").destroy();
        }
        
        var forceDlParam = "forceDownload=true";
        var defaultSrc = url + ((url.indexOf("?") === -1) ? "?" : "&") + forceDlParam;
        
        var mifToDownload = new Ext.ux.ManagedIFrame.Panel({
            layout : 'fit',
            id : "mifToDownload", 
            region : 'center',
            defaultSrc : defaultSrc, 
            renderTo : Ext.getBody(), 
            cls : 'x-hidden'
        });
        
    }, 
    /**
     * @static 
     * Definition of the showDetailData method used by the columnRenderer. Calls the
     * Livegrid corresponding to the dataset linked to the column. To filter the
     * data : use the form API : ["RADIO|" + columnAlias + "|'" + value + "'"]
     * @param {string} value
     * @param {string} columnAlias
     * @param {string} datasetUrl
     */
    showDetailsData : function (value, columnAlias, datasetUrl) {
        var desktop = getDesktop();
    
        // récupération des données du dataset
        Ext.Ajax.request({
            scope : this,
            method : 'GET',
            url : datasetUrl,
            success : function (response, opts) {
                try {
                    var json = Ext.decode(response.responseText);
                    if (!json.success) {
                        Ext.Msg.alert(i18n.get('label.error'), json.message);
                        return;
                    }
                    var formParams = [ "RADIO|" + columnAlias + "|" + value ];
                    var dataset = json.dataset;
                    var jsObj = eval(dataset.datasetView.jsObject);
                    var componentCfg = {
                        dataUrl : dataset.sitoolsAttachementForUsers,
                        datasetId : dataset.id,
                        datasetCm : dataset.columnModel,
                        formParams : formParams, 
                        datasetName : dataset.name, 
                        dictionaryMappings : dataset.dictionaryMappings, 
                        datasetViewConfig : dataset.datasetViewConfig, 
                        preferencesPath : "/" + dataset.name, 
                        preferencesFileName : "datasetView"
                        
                    };
                    
                    var windowConfig = {
                        id : "wind" + dataset.id + columnAlias + value,
                        title : i18n.get('label.dataTitle') + " : " + dataset.name,
                        datasetName : dataset.name,
                        type : "data",
                        saveToolbar : true, 
                        iconCls : "dataDetail"
                    };
                    SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
    
                } catch (err) {                
                }
            }
        });

    }, 
    /**
     * @static 
     * Definition of the showPreview method used by the columnRenderer.
     * @param {string} value The img src
     */
    showPreview : function (value, title) {
        var previewWin = new sitools.widget.WindowImageViewer({            
            title : title,
            src : value,
            hideAction : 'close',
            resizeImage : false
        });
        
        previewWin.show();
        previewWin.toFront();
    }, 
    /**
     * Return true if the column is NoClientAccess
     * @param {Object} column the column object
     * @return {boolean} true if the column should not be used in client
     */
    isNoClientAccess : function (column) {
        return !Ext.isEmpty(column.columnRenderer) &&  ColumnRendererEnum.NO_CLIENT_ACCESS == column.columnRenderer.behavior;
    }, 
    /**
     * @param {Array} listeColonnes
     *            ColumnModel of the grid
     * @param {Array} activeFilters
     *            Definition of the filters used to build the grid
     * 
     * @returns {Array} The filters configuration for the grid
     */
    getFilters : function (listeColonnes, activeFilters) {

        var filters = [];
        var i = 0;
        if (!Ext.isEmpty(listeColonnes)) {
            // First loop on all the columns
            Ext.each(listeColonnes, function (item, index, totalItems) {
                if (item.filter) {
                    var boolActiveFilter = false, activeFilterValue = "", activeComparison = "";
                    // loop on active filters to determine if there is an active
                    // filter on the column
                    Ext.each(activeFilters, function (activeFilter) {
                        if (item.columnAlias == activeFilter.columnAlias) {
                            boolActiveFilter = true;
                            // construct the value for the specific filter
                            if (activeFilter.data.type == 'numeric') {
                                if (!Ext.isObject(activeFilterValue)) {
                                    activeFilterValue = {};
                                }
                                activeFilterValue[activeFilter.data.comparison] = activeFilter.data.value;
                            } else if (activeFilter.data.type == 'date') {
                                var date = new Date();
                                var tmp = activeFilter.data.value.split('-');
                                date.setFullYear(tmp[0], tmp[1] - 1, tmp[2]);

                                if (!Ext.isObject(activeFilterValue)) {
                                    activeFilterValue = {};
                                }
                                if (activeFilter.data.comparison == 'eq') {
                                    activeFilterValue.on = date;
                                }
                                if (activeFilter.data.comparison == 'gt') {
                                    activeFilterValue.after = date;
                                }
                                if (activeFilter.data.comparison == 'lt') {
                                    activeFilterValue.before = date;
                                }
                            } else {
                                activeFilterValue = activeFilter.data.value;
                            }
                        }
                    });
                    var filter = {
                        type : sql2ext.get(item.sqlColumnType),
                        active : boolActiveFilter,
                        dataIndex : item.columnAlias,
                        columnAlias : item.columnAlias,
                        value : activeFilterValue
                    };

                    filters.push(filter);
                }
                i++;

            }, this);
        }
        return filters;

    },
    
    createColMenu : function (view, columnModel) {
        var colCount = columnModel.getColumnCount();
        var menu = new Ext.menu.Menu();
        
        for (var i = 0; i < colCount; i++) {
            if (columnModel.config[i].hideable !== false && !columnModel.config[i].isSelectionModel) {
                menu.add(new Ext.menu.CheckItem({
                    itemId : 'col-' + columnModel.getColumnId(i),
                    text : columnModel.getColumnHeader(i),
                    checked : !columnModel.isHidden(i),
                    hideOnClick : false,
                    disabled : columnModel.config[i].hideable === false,
                    listeners : {
                        scope : view,
                        checkchange : function (ci, checked) {
                            if (checked) {
                                var colModel = extColModelToSrv(columnModel);
                                view.grid.getStore().load({
                                    params : {
                                        colModel : Ext.util.JSON.encode(colModel)
                                    }
                                });
                            }
                        }
                    }
                }));
            }
        }
        menu.on('itemclick', view.handleHdMenuClick, view);
        
        return menu;
    },
    
    copyImageToClipboard : function CopyToClip(img) {
       
    }
};/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, i18n, sql2ext, extColModelToSrv, window,
 extColModelToJsonColModel, DEFAULT_NEAR_LIMIT_SIZE,
 DEFAULT_LIVEGRID_BUFFER_SIZE, SITOOLS_DEFAULT_IHM_DATE_FORMAT,
 DEFAULT_PREFERENCES_FOLDER, SitoolsDesk, getDesktop, userLogin, projectGlobal, ColumnRendererEnum, SITOOLS_DATE_FORMAT
*/
Ext.namespace('sitools.user.component.dataviews');

/**
 * A Simple Object to publish common methods to use stores dataviews in Sitools2.
 * @type 
 */
sitools.user.component.dataviews.storeUtils = {
    /**
	 * @param {Array}
	 *            ColumnModel of the grid
	 * 
	 * @returns {Array} The fields used to build the grid
	 */
	getFields : function (listeColonnes) {
        var fields = [];
        var i = 0;
        if (!Ext.isEmpty(listeColonnes)) {
            Ext.each(listeColonnes, function (item, index, totalItems) {
                fields[i] = new Ext.data.Field({
                    name : item.columnAlias,
                    primaryKey : item.primaryKey,
                    type : sql2ext.get(item.sqlColumnType)
                });
                if (sql2ext.get(item.sqlColumnType) === 'boolean') {
					Ext.apply(fields[i], {
						convert : function (value, record) {
							if (value == "f" || value == "false" || value === 0) {
								return 0;
							}
							if (value == "t" || value == "true" || value == 1) {
								return 1;
							}
							return value;
						}
					});
                }
                i++;

            }, this);
        }
        return fields;
    }, 
    /**
	 * @param {Array}
	 *            ColumnModel of the grid
	 * 
	 * @returns {String} The columnAlias of the primaryKey
	 */
    getPrimaryKey : function (listeColonnes) {
        var i = 0, primaryKey = "";
        if (!Ext.isEmpty(listeColonnes)) {
            Ext.each(listeColonnes, function (item, index, totalItems) {
                if (!Ext.isEmpty(item.primaryKey)) {
                    if (item.primaryKey) {
                        primaryKey = item.columnAlias;
                    }
                }
            }, this);
        }
        return primaryKey;
    },
    getFormParams : function (store) {
        return store.formParams;
    },
    /**
     * Build a string using a form param Value. 
     * @param {} paramValue An object with attributes : at least type, code, value and optionnal userDimension, userUnit
     * @return {string} something like "TEXTFIELD|ColumnAlias|value"
     */
    paramValueToApi : function (paramValue) {
		var stringParam = paramValue.type + "|" + paramValue.code + "|" + paramValue.value;
        if (!Ext.isEmpty(paramValue.userDimension) && !Ext.isEmpty(paramValue.userUnit)) {
			stringParam += "|" + paramValue.userDimension + "|" + paramValue.userUnit.unitName; 
        }  
        return stringParam;
    }

};/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, extColModelToStorage, projectId, userStorage, window,   
extColModelToSrv, userLogin, alertFailure, DEFAULT_LIVEGRID_BUFFER_SIZE, projectGlobal, SitoolsDesk, DEFAULT_ORDER_FOLDER, DEFAULT_PREFERENCES_FOLDER, getColumnModel */
/*
 * @include "../../../env.js"
 * @include "Ext.ux.livegrid/Ext.ux.livegrid-all-debug.js"
 * @include "../../../def.js"
 */ 
Ext.namespace('sitools.user.component.dataviews.livegrid');

// Surcharge de l'objet Store de la liveGrid pour gestion du multiSort.
Ext.override(Ext.ux.grid.livegrid.Store, {
    /**
	 * Sort by multiple fields in the specified order.
	 * 
	 * @param {Array}
	 *            An Array of field sort specifications, or, if ascending sort
	 *            is required on all columns, an Array of field names. A field
	 *            specification looks like:
	 * 
	 * <pre><code>
	 * {
	 *     ordersList : [ {
	 *         field : firstname,
	 *         direction : ASC
	 *     }, {
	 *         field : name
	 *         direction : DESC
	 *     } ]
	 * }
	 * 
	 * </code>
	 * 
	 */
    multiSort : function (sorters, direction) {
        this.hasMultiSort = true;
        direction = direction || "ASC";

        if (this.multiSortInfo && direction == this.multiSortInfo.direction) {
            direction = direction.toggle("ASC", "DESC");
        }

        this.multiSortInfo = {
            sorters : sorters,
            direction : direction
        };

        if (this.remoteSort) {
            // this.singleSort(sorters[0].field, sorters[0].direction);
            this.load(this.lastOptions);

        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
    },
    getSortState : function () {
        return this.hasMultiSort ? this.multiSortInfo : this.sortInfo;
    },

    // application du tri multiple sur le store
    load : function (options) {
        options = Ext.apply({}, options);
        this.storeOptions(options);
        if ((this.sortInfo || this.multiSortInfo) && this.remoteSort) {
            var pn = this.paramNames;
            options.params = Ext.apply({}, options.params);
            this.isInSort = true;
            var root = pn.sort;
            if (this.hasMultiSort) {
                options.params[pn.sort] = Ext.encode({
                    "ordersList" : this.multiSortInfo.sorters
                });
            } else {
                options.params[pn.sort] = Ext.encode({
                    "ordersList" : [ this.sortInfo ]
                });
            }

        }

        try {
            return this.execute('read', null, options);
        } catch (e) {
            this.handleException(e);
            return false;
        }
    }

});

/**
 * @class sitools.user.component.dataviews.livegrid.StoreLiveGrid
 * @extends Ext.ux.grid.livegrid.Store
 * @cfg [] datasetCm The Dataset columnModel,
 * @cfg {string} urlRecords The url to request the API
 * @cfg {string} sitoolsAttachementForUsers the dataset Attachement
 * @cfg {} userPreference Object containing all userPreference for this dataset
 * @cfg {numeric} bufferSize the buffer Size of the store
 * @cfg [] formParams an array of all formParams to apply to the store
 * @cfg [] formMultiDsParams an array of all formParams to apply to the store
 * @cfg {} mainView the View of the grid 
 * @cfg {string} datasetId the DatasetId
 * @requires Ext.ux.grid.livegrid.JsonReader
 * @requires sql2ext
 * @return {Boolean}
 */
sitools.user.component.dataviews.livegrid.StoreLiveGrid = function (config) {
	this.storeUtils = sitools.user.component.dataviews.storeUtils;
    if (Ext.isEmpty(config)) {
		return false;
    }
	/**
	 * Construction of the column Model : user preferences have priority on the
	 * initial definition of the model column in the dataset
	 */
    var colModel;
    if (!Ext.isEmpty(config.userPreference) && config.userPreference.datasetView == "Ext.ux.livegrid" && !Ext.isEmpty(config.userPreference.colModel)) {
		colModel = Ext.applyIf(config.userPreference.colModel, config.datasetCm);
    }
    else {
		colModel = config.datasetCm; 
    }
    var cm = getColumnModel(colModel);
    /**
	 * the fields of the store
	 */
    var map = this.storeUtils.getFields(config.datasetCm);
    var primaryKey = this.storeUtils.getPrimaryKey(config.datasetCm);
    /*
	 * JSON Reader : BufferedJsonReader derives from Ext.data.JsonReader and
	 * allows to pass a version value representing the current state of the
	 * underlying data repository. Version handling on server side is totally up
	 * to the user. The version property should change whenever a record gets
	 * added or deleted on the server side, so the store can be notified of
	 * changes between the previous and current request. If the store notices a
	 * version change, it will fire the version change event. Speaking of data
	 * integrity: If there are any selections pending, the user can react to
	 * this event and cancel all pending selections.
	 */
    var bufferedReaderSimple = new Ext.ux.grid.livegrid.JsonReader({
        idProperty : primaryKey,
        root : 'data',
        versionProperty : 'version',
        totalProperty : 'total'
    }, map);

    /*
	 * Building the params used to request the data :
	 */
    var params;
    // sending the columnModel to the server
    if (this.userPreference) {
        colModel = extColModelToSrv(cm);
        params = {
            colModel : Ext.util.JSON.encode(colModel)
        };
    } else {
        params = {};
    }
    

    var i = 0;
    // sending the formParams to the server
    this.formParams = {};
    if (!Ext.isEmpty(config.formParams)) {
        Ext.each(config.formParams, function (param) {
            this.formParams["p[" + i + "]"] = param;
            i += 1;
        }, this);
        Ext.apply(params, this.formParams);
    }
    // sending the formParams to the server
    i = 0;
    if (!Ext.isEmpty(config.formMultiDsParams)) {
        Ext.each(config.formMultiDsParams, function (param) {
            this.formParams["c[" + i + "]"] = param;
            i += 1;
        }, this);
        Ext.apply(params, this.formParams);
    }

    Ext.apply(config, {
        autoLoad : true,
        bufferSize : DEFAULT_LIVEGRID_BUFFER_SIZE,
        restful : true,
        reader : bufferedReaderSimple,
        storeUtils : sitools.user.component.dataviews.storeUtils, 
        url : config.urlRecords,
        dataUrl : config.sitoolsAttachementForUsers,
        baseParams : params,
        listeners : {
            scope : this,
            exception : function (dp, type, action, options, response, arg) {
                // load the alert & close the window.
                this.removeAll();

                Ext.Msg.show({
                    title : i18n.get('label.error'),
                    msg : response.responseText,
                    buttons : Ext.Msg.OK,
                    width : 400
                });
                this.fireEvent("load", this, []);
            }
        }
    });
    sitools.user.component.dataviews.livegrid.StoreLiveGrid.superclass.constructor.call(this, config);
};
Ext.extend(sitools.user.component.dataviews.livegrid.StoreLiveGrid, Ext.ux.grid.livegrid.Store, {
    
    paramPrefix : "filter",
    
    getFormParams : function () {
		return this.storeUtils.getFormParams(this);
	},

	buildQuery : function (filters) {
        if (Ext.isEmpty(filters)) {
            return;
        }
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;

        for (i = 0; i < len; i++) {
            f = filters[i];
            root = [this.paramPrefix, '[', i, ']'].join('');
            p[root + '[columnAlias]'] = f.columnAlias;

            dataPrefix = root + '[data]';
            for (key in f.data) {
                p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
            }
        }
        return p;
    }

});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, extColModelToStorage, projectId, userStorage, window,   
GeoExt, userLogin, alertFailure, DEFAULT_LIVEGRID_BUFFER_SIZE, projectGlobal, SitoolsDesk, DEFAULT_ORDER_FOLDER, DEFAULT_PREFERENCES_FOLDER, getColumnModel */

Ext.namespace('sitools.user.component.dataviews.cartoView');



/**
 */
sitools.user.component.dataviews.cartoView.featureSelectionModel = function (config) {
    this.width = 20;

    // private
    this.menuDisabled = true;
    this.sortable = false;
    this.fixed = true;
    this.dataIndex = '';
    this.id = 'checker';
    this.headerCheckbox = null;
    this.markAll = false;
   
    this.isColumn = true; // So that ColumnModel doesn't feed this through the
                        // Column constructor
    
    Ext.apply(this, config);
    
    if (!this.header) {
        this.header = Ext.grid.CheckboxSelectionModel.prototype.header;
    }

    if (this.checkOnly) {
        this.handleMouseDown = Ext.emptyFn;
    }
    
    this.sortable = false;
    
    sitools.user.component.dataviews.cartoView.featureSelectionModel.superclass.constructor.call(this, config);
    this.addEvents('gridFeatureSelected', 'selectionmodelready');
    
};

Ext.extend(sitools.user.component.dataviews.cartoView.featureSelectionModel, GeoExt.grid.FeatureSelectionModel, {
    
    //private
    initEvents : function () {
        sitools.user.component.dataviews.cartoView.featureSelectionModel.superclass.initEvents.call(this);
    
        this.grid.view.on('refresh', function (gridView, forceReload) {
            this.headerCheckbox = new Ext.Element(gridView.getHeaderCell(this.grid.getColumnModel().getIndexById(this.id)).firstChild);
            if (this.markAll && forceReload === false) {
                this.headerCheckbox.addClass('x-grid3-hd-checker-on');
            }
            this.fireEvent('selectionmodelready');
        }, this);
        
        
    
        // this.grid.on('render', function(){
        // Ext.fly(this.grid.getView().innerHd).on('mousedown',
        // this.onHdMouseDown, this);
        // }, this);
        

        this.grid.getBottomToolbar().on('change', function (tb, pageData) {
            this.locked = false;
            if (this.markAll) {
                this.selectAll();
            }            
        }, this);
        
        this.grid.getBottomToolbar().on('beforechange', function (tb, pageData) {
            this.locked = true;
        }, this);
        
        Ext.grid.CheckboxSelectionModel.prototype.initEvents.call(this);
    },
    
    /**
     * @private Process and refire events routed from the GridView's
     *          processEvent method.
     */
    processEvent : function (name, e, grid, rowIndex, colIndex) {
        if (name == 'mousedown') {
            this.onMouseDown(e, e.getTarget());
            return false;
        } else {
            return Ext.grid.Column.prototype.processEvent.apply(this, arguments);
        }
    },
    
    // private
    onMouseDown : function (e, t) {
        if (e.button === 0 && t.className == 'x-grid3-row-checker') {
            e.stopEvent();
            var row = e.getTarget('.x-grid3-row');
            if (row) {
                var index = row.rowIndex;
                var isSelected = this.isSelected(index);
                var shiftKey = e.shiftKey;
                
                
                if (isSelected) {
                    if (this.markAll) {
                        // Show a dialog using config options:
                        this.selectRow(index, false);
                    }
                    else {
                        if (shiftKey && !this.singleSelect && this.last !== false) {
                            var last = this.last;
                            this.deselectRange(last, index);
                            this.last = last;
                            // view.focusRow(rowIndex);
                            // this.fireEvent('handleMouseDown', this);
                        } else {
                            this.deselectRow(index);
                        }
                    }
                } else {
                    if (shiftKey && !this.singleSelect && this.last !== false) {
                        var last = this.last;
                        this.selectRange(last, index, true);
                        this.last = last;
                        // view.focusRow(rowIndex);
                        // this.fireEvent('handleMouseDown', this);
                    } else {
                        this.selectRow(index, true);
                    }
                    // this.grid.getView().focusRow(index);
                }
                
                if (this.headerCheckbox) {
                    this.markAll = false;
                    this.headerCheckbox.removeClass('x-grid3-hd-checker-on');
                }
                
            }
        }
    },
    
    
    // private
    onHdMouseDown : function (e, t) {

        if (t.className === 'x-grid3-hd-checker' && !this.headerCheckbox) {
            this.headerCheckbox = new Ext.Element(t.parentNode);
        }
    
        if (t.className === 'x-grid3-hd-checker') {
            e.stopEvent();
            var hd = Ext.fly(t.parentNode);
            var isChecked = hd.hasClass('x-grid3-hd-checker-on');
            if (isChecked) {
                hd.removeClass('x-grid3-hd-checker-on');
                this.clearSelections();
            } else {
                hd.addClass('x-grid3-hd-checker-on');
                this.selectAll();
            }
        }
    
    },
    
    // private
    renderer : function (v, p, record) {
        return Ext.grid.CheckboxSelectionModel.prototype.renderer.call(this, v, p, record);
    },
    
    // -------- overrides
    
    /**
     * Overriden to prevent selections by shift-clicking
     */
    handleMouseDown : function (g, rowIndex, e) {
        this.markAll = false;
    
        if (this.headerCheckbox) {
            this.headerCheckbox.removeClass('x-grid3-hd-checker-on');
        }
    
        sitools.user.component.dataviews.cartoView.featureSelectionModel.superclass.handleMouseDown.call(this, g, rowIndex, e);
        this.fireEvent("gridFeatureSelected", g, rowIndex, e);
    },
    
    

    /**
     * Clears all selections.
     */
    clearSelections : function (fast) {
        if (this.isLocked()) {
            return;
        }

        this.markAll = false;

        if (this.headerCheckbox) {
            this.headerCheckbox.removeClass('x-grid3-hd-checker-on');
        }
        
        if (fast !== true) {
            var ds = this.grid.store, s = this.selections;
            this.silent = true;
            s.each(function (r) {
                this.deselectRow(ds.indexOfId(r.id));
            }, this);
            s.clear();
            this.silent = false;
            this.deselectRow(0);
        } else {
            this.selections.clear();
        }
        this.last = false;
    },
    
    getAllSelections : function (asRange) {
        var index = 1;
        var ranges = [];
        var currentRange = 0;
        var tmpArray =  [];
        
        this.selections.each(function (rec) {
            var index = this.grid.getStore().indexOf(rec);
            tmpArray.push(index);
        }, this);

        tmpArray.sort(function (o1, o2) {
            if (o1 > o2) {
                return 1;
            } else if (o1 < o2) {
                return -1;
            } else {
                return 0;
            }
        });

        if (!asRange) {
            return tmpArray;
        }

        var max_i = tmpArray.length;

        if (max_i === 0) {
            return [];
        }

        ranges[currentRange] = [ tmpArray[0], tmpArray[0] ];
        for (var i = 0, max_i = max_i - 1; i < max_i; i++) {
            if (tmpArray[i + 1] - tmpArray[i] == 1) {
                ranges[currentRange][1] = tmpArray[i + 1];
            } else {
                currentRange++;
                ranges[currentRange] = [ tmpArray[i + 1], tmpArray[i + 1] ];
            }
        }

        return ranges;
    },
    
    /**
     * Selects all rows if the selection model
     * {@link Ext.grid.AbstractSelectionModel#isLocked is not locked}.
     */
    selectAll : function () {
        if (this.isLocked()) {
            return;
        }
        this.selections.clear();
        
        this.markAll = true;

        this.silent = true;
        for (var i = 0, len = this.grid.store.getCount(); i < len - 1; i++) {
            this.selectRow(i, true);
        }
        this.silent = false;
        this.selectRow(len-1, true);
        
    
        if (this.headerCheckbox) {
            this.headerCheckbox.addClass('x-grid3-hd-checker-on');
        }
    },
    
    /**
     * Selects a range of rows if the selection model
     * {@link Ext.grid.AbstractSelectionModel#isLocked is not locked}.
     * All rows in between startRow and endRow are also selected.
     * @param {Number} startRow The index of the first row in the range
     * @param {Number} endRow The index of the last row in the range
     * @param {Boolean} keepExisting (optional) True to retain existing selections
     */
    selectRange : function(startRow, endRow, keepExisting){
        var i;
        if (this.locked) {
            return;
        }

        if (!keepExisting) {
            this.clearSelections();
        }

        if (startRow <= endRow) {
            this.silent = true;
            for (i = startRow; i < endRow; i++) {
                this.selectRow(i, true);
            }
            this.silent = false;
            this.selectRow(endRow, true);
        } else {
            this.silent = true;
            for (i = startRow; i > endRow; i--) {
                this.selectRow(i, true);
            }
            this.silent = false;
            this.selectRow(endRow, true);
        }
    },
    
    
    //SITOOLS MG, overide deselect row to prevent event calls when the SelectionModel is silent
    /**
     * Deselects a row.  Before deselecting a row, checks if the selection model
     * {@link Ext.grid.AbstractSelectionModel#isLocked is locked}.
     * If this check is satisfied the row will be deselected and followed up by
     * firing the {@link #rowdeselect} and {@link #selectionchange} events.
     * @param {Number} row The index of the row to deselect
     * @param {Boolean} preventViewNotify (optional) Specify <tt>true</tt> to
     * prevent notifying the view (disables updating the selected appearance)
     */
    deselectRow : function (index, preventViewNotify) {
        if (this.isLocked()) {
            return;
        }
        if (this.last == index) {
            this.last = false;
        }
        if (this.lastActive === index) {
            this.lastActive = false;
        }
        var r = this.grid.store.getAt(index);
        if (r) {
            this.selections.remove(r);
            if (!preventViewNotify) {
                this.grid.getView().onRowDeselect(index);
            }
            if (!this.silent) {
                this.fireEvent('rowdeselect', this, index, r);
                this.fireEvent('selectionchange', this);
            }
        }
    },

});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, i18n, sql2ext, extColModelToSrv, window, sitoolsUtils, 
 extColModelToJsonColModel, DEFAULT_NEAR_LIMIT_SIZE, GeoExt, 
 DEFAULT_LIVEGRID_BUFFER_SIZE, SITOOLS_DEFAULT_IHM_DATE_FORMAT, OpenLayers, 
 DEFAULT_PREFERENCES_FOLDER, SitoolsDesk, getDesktop, userLogin, projectGlobal, getColumnModel, loadUrl, getApp
*/

Ext.ns("sitools.user.component.dataviews.cartoView");

/**
 * The LiveGrid used to show Dataset Datas.
 * 
 * @cfg {string} dataUrl (Required) The datasetAttachment to request to load the datas 
 * @cfg {string} datasetId (Required)  The DatasetId, 
 * @cfg {Ext.grid.ColumnModel} datasetCm (Required) A definition of a ColumnModel 
 * @cfg {} userPreference {}  {
 *            componentSettings {Array} : Array of the Columns as saved by the user 
 *            windowSettings {Object} : { 
 *            moduleId : String 
 *                position : [xpos, ypos] 
 *                size : { 
 *                    width : w 
 *                    height : h 
 *                } 
 *                specificType : String 
 *            } 
 *      }
 * @cfg {Array} formParams list of the form params used to search thrue
 * the grid ["TEXTFIELD|AliasColumn1|X", "TEXTFIELD|AliasColumn2|Y"] 
 * @cfg {Array} filters Array of Ext.ux.Filter : [{ 
 *          columnAlias : Alias1, 
 *          data : {
 *            comparison : "LIKE", 
 *            type : "string", 
 *            value : "01" 
 *          } 
 *      }, {
 *            columnAlias : Alias2, 
 *            data : { 
 *              comparison : "gt", 
 *              type : "date",
 *              value : "199-11-04" 
 *            } 
 *      }] 
 *      
 * @requires sitools.user.component.columnsDefinition
 * @requires sitools.user.component.viewDataDetail
 * @requires Ext.ux.grid.GridFiltersSpe
 * @requires sitools.user.component.dataPlotter
 * @class sitools.user.component.dataviews.cartoView.cartoView
 * @extends Ext.ux.grid.livegrid.EditorGridPanel
 * 
 * 
 */
sitools.user.component.dataviews.cartoView.mapPanel = function (config) {
	this.map = new OpenLayers.Map();
	var layer;

    var dataviewConfig = sitoolsUtils.arrayProperties2Object(config.datasetViewConfig);

    var layersDef = Ext.decode(dataviewConfig.layers), mapLayers = [], baseLayer;
    
    //Définir le column Model.
    var colModel = config.datasetCm; 
    var cm = getColumnModel(colModel, config.dictionaryMappings, dataviewConfig);

    
    Ext.each(layersDef, function (layerDef) {
		layer = new OpenLayers.Layer.WMS(
			layerDef.layerName,
			layerDef.url, 
	        {
				layers: layerDef.layerName, 
				format : "image/png"
			},
	        {
				isBaseLayer: layerDef.baseLayer ? true : false,
				opacity : layerDef.baseLayer ? 1 : 0.5
	        }
	    );
	    this.map.addLayer(layer);
	}, this);
    
    // create vector layer
    this.featureLayer = new OpenLayers.Layer.Vector(config.datasetName);
    
    this.featureLayer.events.register("featuresadded", this, function () {
       this.fireEvent('selectionmodelready'); 
    });
    
    var selectCtrl = new OpenLayers.Control.SelectFeature(this.featureLayer, {
    	id : "selectCtrl", 
    	onSelect : function (feature) {
    	}
    });
    
    //Ajout d'un controle pour choisir les layers
    this.map.addControl(new OpenLayers.Control.LayerSwitcher());
    //Ajout d'un controle pour la souris
    this.map.addControl(new OpenLayers.Control.MousePosition());

    this.featureLayer.events.on({
		featureselected: function (e) {
			var feature = e.feature;
			var selectCtrl = this.map.getControlsByClass("OpenLayers.Control.SelectFeature");
			if (!Ext.isEmpty(selectCtrl)) {
				selectCtrl = selectCtrl[0];
			}
			
//			var popup = new GeoExt.Popup({
//		        title: 'My Popup',
//		        location: feature,
//		        manager : getDesktop().getManager(), 
//		        width: 200,
//		        html: "toto",
//		        maximizable: true,
//		        collapsible: true, 
//		        layer : feature.layer, 
//		        feature : feature, 
//		        selectCtrl : selectCtrl
//		    });
		    // unselect feature when the popup
		    // is closed
//		    popup.on({
//		        close: function () {
//		            if (OpenLayers.Util.indexOf(this.layer.selectedFeatures, this.feature) > -1) {
//		                this.selectCtrl.unselect(this.feature);
//	                }
//	            }
//	        });
//	        popup.show();
        }, 
        scope : this
    });
    
    this.map.addLayers([this.featureLayer]);
    
    // -- CONSTRUCTOR --
    sitools.user.component.dataviews.cartoView.mapPanel.superclass.constructor.call(Ext.apply(this, {
        region: "center",
        map: this.map,
        center: new OpenLayers.LonLat(5, 45),
        zoom: 6,
        listeners : {
            scope : this,
            beforedestroy : function (panel) {
                this.map.layers.clear();
            }
        }
	}));    

};

Ext.extend(sitools.user.component.dataviews.cartoView.mapPanel, GeoExt.MapPanel, {
	getFeaturesLayer : function () {
		return this.featureLayer;
	}, 
	getMap : function () {
		return this.map;
	}
});/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, userLogin, DEFAULT_ORDER_FOLDER, document, alertFailure, SITOOLS_DATE_FORMAT, SITOOLS_DEFAULT_IHM_DATE_FORMAT, sql2ext, 
getDesktop, getColumnModel, extColModelToStorage, SitoolsDesk, projectGlobal, DEFAULT_PREFERENCES_FOLDER, DEFAULT_LIVEGRID_BUFFER_SIZE, loadUrl, ColumnRendererEnum*/

Ext.namespace('sitools.user.component.dataviews.tplView');

/**
 * Defines a toolbar for the specific view {sitools.user.component.dataviews.tplView.TplView}
 * Redefine method doLoad
 * @class sitools.user.component.dataviews.tplView.dataViewPagingToolbar
 * @extends Ext.PagingToolbar
 */
sitools.user.component.dataviews.tplView.dataViewPagingToolbar = Ext.extend(Ext.PagingToolbar, {
//sitools.user.component.dataViewPagingToolbar = Ext.extend(Ext.PagingToolbar, {
	doLoad : function (start) {
        var lastOptions = this.store.lastOptions || {};
        var o = lastOptions.params, pn = this.getParams();
        o[pn.start] = start;
        o[pn.limit] = this.pageSize;
        if (this.fireEvent('beforechange', this, o) !== false) {
            this.store.load({params : o});
        }
        //Fire Event on plot window if opened ! 
        var plotComp = Ext.getCmp("plot" + this.ownerCt.datasetId);
        if (plotComp) {
            var rightPanel = plotComp.findById('plot-right-panel');
            var success = rightPanel.fireEvent('buffer', this.store);
        }
        
	}
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, userLogin, DEFAULT_ORDER_FOLDER, document, alertFailure, SITOOLS_DATE_FORMAT, SITOOLS_DEFAULT_IHM_DATE_FORMAT, sql2ext, 
getDesktop, getColumnModel, extColModelToStorage, SitoolsDesk, projectGlobal, DEFAULT_PREFERENCES_FOLDER, DEFAULT_LIVEGRID_BUFFER_SIZE, loadUrl, ColumnRendererEnum*/
/*
 * @include "contextMenu.js"
 * @include "../../viewDataDetail/viewDataDetail.js"
 * @include "../../plot/dataPlotter.js"
 * @include "contextMenu.js"
 * @include "storeLiveGrid.js"
 */
Ext.namespace('sitools.user.component.dataviews.tplView');

/**
 * Define the store for the dataview. 
 * Redefine the getAt function.
 * @class sitools.user.component.dataviews.tplView.StoreTplView
 * @extends sitools.user.component.dataviews.livegrid.StoreLiveGrid
 * @requires sitools.user.component.columnsDefinition
 */
sitools.user.component.dataviews.tplView.StoreTplView = Ext.extend(sitools.user.component.dataviews.livegrid.StoreLiveGrid, {
//sitools.user.component.dataViewStore = Ext.extend(sitools.user.component.dataviews.livegrid.StoreLiveGrid, {
	
    getAt : function (index) {
		return this.data.itemAt(index);
    } 
    
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, extColModelToStorage, projectId, userStorage, window,   
extColModelToSrv, userLogin, alertFailure, DEFAULT_LIVEGRID_BUFFER_SIZE, projectGlobal, SitoolsDesk, DEFAULT_ORDER_FOLDER, DEFAULT_PREFERENCES_FOLDER, getColumnModel */
/*
 * @include "../../../env.js"
 * @include "Ext.ux.livegrid/Ext.ux.livegrid-all-debug.js"
 * @include "../../../def.js"
 */ 
Ext.namespace('sitools.user.component.dataviews.cartoView');

/**
 * @class sitools.user.component.dataviews.cartoView.featureStore
 * @extends Ext.ux.grid.livegrid.Store
 * @cfg [] datasetCm The Dataset columnModel,
 * @cfg {string} urlRecords The url to request the API
 * @cfg {string} sitoolsAttachementForUsers the dataset Attachement
 * @cfg {} userPreference Object containing all userPreference for this dataset
 * @cfg {numeric} bufferSize the buffer Size of the store
 * @cfg [] formParams an array of all formParams to apply to the store
 * @cfg [] formMultiDsParams an array of all formParams to apply to the store
 * @cfg {} mainView the View of the grid 
 * @cfg {string} datasetId the DatasetId
 * @requires Ext.ux.grid.livegrid.JsonReader
 * @requires sql2ext
 * @return {Boolean}
 */
sitools.user.component.dataviews.cartoView.featureStore = function (config) {
	this.storeUtils = sitools.user.component.dataviews.storeUtils;
    if (Ext.isEmpty(config)) {
		return false;
    }

    /*
	 * Building the params used to request the data :
	 */
    var params;
    // sending the columnModel to the server
    if (this.userPreference) {
        colModel = extColModelToSrv(config.datasetCm);
        params = {
            colModel : Ext.util.JSON.encode(colModel)
        };
    } else {
        params = {};
    }
    

    var i = 0;
    // sending the formParams to the server
    this.formParams = {};
    if (!Ext.isEmpty(config.formParams)) {
        Ext.each(config.formParams, function (param) {
            this.formParams["p[" + i + "]"] = param;
            i += 1;
        }, this);
        Ext.apply(params, this.formParams);
    }
    // sending the formParams to the server
    i = 0;
    if (!Ext.isEmpty(config.formMultiDsParams)) {
        Ext.each(config.formMultiDsParams, function (param) {
            this.formParams["c[" + i + "]"] = param;
            i += 1;
        }, this);
        Ext.apply(params, this.formParams);
    }

    var reader = config.reader || new sitools.user.data.featureReader({
        totalProperty : "totalResults"
    }, config.fields);

    Ext.apply(config, {
        bufferSize : DEFAULT_LIVEGRID_BUFFER_SIZE,
        restful : true,
        reader : reader, 
        totalProperty : "totalResults", 
        storeUtils : sitools.user.component.dataviews.storeUtils, 
        url : config.urlRecords,
        dataUrl : config.urlRecords,
        baseParams : params
    });
    
    sitools.user.component.dataviews.cartoView.featureStore.superclass.constructor.call(this, config);
	var sIndex;
	(config.startIndex) ? sIndex = config.startIndex : sIndex = 0;
	this.load({
		params : {
			start : sIndex, 
			limit : DEFAULT_LIVEGRID_BUFFER_SIZE
		}
	});
};

Ext.extend(sitools.user.component.dataviews.cartoView.featureStore, GeoExt.data.FeatureStore, {
    
    paramPrefix : "filter",
    
    getFormParams : function () {
		return this.storeUtils.getFormParams(this);
	}, 
	loadRecords : function (o, options, success) {
		this.bufferRange = [ -1, -1 ];
		if (o && options && options.params) {
        	this.bufferRange = [ options.params.start,
                    Math.max(0, Math.min((options.params.start + options.params.limit) - 1, o.totalRecords - 1)) ];
		}
        sitools.user.component.dataviews.cartoView.featureStore.superclass.loadRecords.call(this, o, options, success);
	}, 
//	load : function (options) {
//		sitools.user.component.dataviews.cartoView.featureStore.superclass.load.call(this, options);
//	}, 
    /**
     * Override
     */
	singleSort: function(fieldName, dir) {
        var field = this.fields.get(fieldName);
        if (!field) {
            return false;
        }

        var name       = field.name,
            sortInfo   = this.sortInfo || null,
            sortToggle = this.sortToggle ? this.sortToggle[name] : null;

        if (!dir) {
            if (sortInfo && sortInfo.field == name) { 
                dir = (this.sortToggle[name] || 'ASC').toggle('ASC', 'DESC');
            } else {
                dir = field.sortDir;
            }
        }

        this.sortToggle[name] = dir;
        this.sortInfo = {field: name, direction: dir};
        this.hasMultiSort = false;

        if (this.remoteSort) {
        	//DA : disable this
        	this.load(this.lastOptions);
//        	if (!this.load(this.lastOptions)) {
//                if (sortToggle) {
//                    this.sortToggle[name] = sortToggle;
//                }
//                if (sortInfo) {
//                    this.sortInfo = sortInfo;
//            }
        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
        return true;
    },
    
    /**
     * Sort by multiple fields in the specified order.
     * 
     * @param {Array}
     *            An Array of field sort specifications, or, if ascending sort
     *            is required on all columns, an Array of field names. A field
     *            specification looks like:
     * 
     * <pre><code>
     * {
     *     ordersList : [ {
     *         field : firstname,
     *         direction : ASC
     *     }, {
     *         field : name
     *         direction : DESC
     *     } ]
     * }
     * 
     * </code>
     * 
     */
    multiSort : function (sorters, direction) {
        this.hasMultiSort = true;
        direction = direction || "ASC";

        if (this.multiSortInfo && direction == this.multiSortInfo.direction) {
            direction = direction.toggle("ASC", "DESC");
        }

        this.multiSortInfo = {
            sorters : sorters,
            direction : direction
        };

        if (this.remoteSort) {
            // this.singleSort(sorters[0].field, sorters[0].direction);
            this.load(this.lastOptions);

        } else {
            this.applySort();
            this.fireEvent('datachanged', this);
        }
    },
    getSortState : function () {
        return this.hasMultiSort ? this.multiSortInfo : this.sortInfo;
    },

    // application du tri multiple sur le store
    load : function (options) {
        options = Ext.apply({}, options);
        this.storeOptions(options);
        if ((this.sortInfo || this.multiSortInfo) && this.remoteSort) {
            var pn = this.paramNames;
            options.params = Ext.apply({}, options.params);
            this.isInSort = true;
            var root = pn.sort;
            if (this.hasMultiSort) {
                options.params[pn.sort] = Ext.encode({
                    "ordersList" : this.multiSortInfo.sorters
                });
            } else {
                options.params[pn.sort] = Ext.encode({
                    "ordersList" : [ this.sortInfo ]
                });
            }

        }

        try {
            return this.execute('read', null, options);
        } catch (e) {
            this.handleException(e);
            return false;
        }
    },
    
    buildQuery : function (filters) {
        if (Ext.isEmpty(filters)) {
            return;
        }
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;

        for (i = 0; i < len; i++) {
            f = filters[i];
            root = [this.paramPrefix, '[', i, ']'].join('');
            p[root + '[columnAlias]'] = f.columnAlias;

            dataPrefix = root + '[data]';
            for (key in f.data) {
                p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
            }
        }
        return p;
    }


});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global Ext, sitools, i18n, SitoolsDesk */

Ext.namespace('sitools.user.component.dataviews');
/**
 * @cfg {Ext.menu.menu} contextMenu the contextMenu that call the plugin and will execute onResourceCallClick method
 * @cfg {Ext.data.Record} resource the resource record
 * @cfg {string} url the base url of the resource
 * @cfg {string} methods the methods allowed with the format method1|method2|...|methodN
 * @cfg {string} runType the runTypeUserInput defined in the resource
 * @cfg {boolean} withSelection true if there was a selection, false otherwise
 * @cfg {Array} parameters the parameters
 * @class sitools.user.component.dataviews.resourcePluginParamsPanel
 * @extends Ext.Window
 */
sitools.user.component.dataviews.resourcePluginParamsPanel = Ext.extend(Ext.Panel, {
//sitools.user.component.livegrid.resourcePluginParamsWindow = Ext.extend(Ext.Window, {
    width : "450",
    
    showMethod : false, 
    defaultMethod : "",
    showRunType : false, 
    initComponent : function () {
        var methodsArray = this.methods.split("|");
        this.showMethod = methodsArray.length > 1;
        this.defaultMethod = methodsArray[0];
        
        this.methodsStore = new Ext.data.ArrayStore({
            fields: ["method"],
            idIndex: 0
        });
    
        Ext.each(methodsArray, function (item, index) {
            this.methodsStore.add(new Ext.data.Record({
                method : item
            }));
        }, this);
        
        var formCommonParametersFields = [];
        var comboMethod = new Ext.form.ComboBox({                
            xtype : 'combo',
            mode : 'local',
            triggerAction : 'all',
            editable : false,
            name : 'method',
            fieldLabel : i18n.get('label.method'),
            width : 100,
            store : this.methodsStore,
            valueField : 'method',
            displayField : 'method',
            anchor : "100%",
            value : this.defaultMethod,
            forceSelection : true
        });
        this.items = [];
        if (this.showMethod) {
			formCommonParametersFields.push(comboMethod);
			this.formParams = new Ext.form.FormPanel({
	            padding: 5,
	//            title : "Request parameters",
	            items : [{
	                xtype : 'fieldset',
	                title : i18n.get("label.commonParameters"),
	                items : formCommonParametersFields
	            }]
	        });
	        
	        this.items.push(this.formParams);			
        }
        
        var userInputParams = [];
        Ext.each(this.resource.parameters, function (value, index) {
            if (value.type == "PARAMETER_USER_INPUT" && value.userUpdatable) {
                var item = this.buildFormItemFromParam(value);
                userInputParams.push(item);
		        if (value.name == "runTypeUserInput") {
					this.showRunType = true;
				}
            }
        }, this);

        if (!Ext.isEmpty(userInputParams)) {
            this.formParamsUserInput = new Ext.form.FormPanel({
                padding: 5,
                labelWidth : 150, 
                items : {
                    xtype : 'fieldset',
                    title : i18n.get("label.specificParameter"),
                    items : userInputParams
                }
            });  
            this.items.push(this.formParamsUserInput);
        }
        
        this.buttons = [{
            text : i18n.get('label.submit'),
            scope : this,
            handler : this.onCall            
        }, {
            text : i18n.get('label.cancel'),
            scope : this,
            handler : function () {
                this.ownerCt.close();
                this.callback.call(undefined, false);
            }
        }];
        sitools.user.component.dataviews.resourcePluginParamsPanel.superclass.initComponent.call(this);
    },
    
    onCall : function () {        
        var method;
        if (this.showMethod) {
	        var form = this.formParams.getForm();
	        method = form.findField("method").getValue();
        }
        else {
			method = this.defaultMethod;	
        }
		
        var runTypeUserInput;
        if (this.showRunType) {
			runTypeUserInput = this.formParamsUserInput.getForm().findField("runTypeUserInput").getValue();
        }
        else {
			runTypeUserInput = this.runType;
        }
        var limit;

        var userParameters = {};
        if (!Ext.isEmpty(this.formParamsUserInput)) {
            var formParams = this.formParamsUserInput.getForm();
            Ext.iterate(formParams.getValues(), function (key, value) {
                userParameters[key] = value;                
            });
        }
        
        Ext.each(this.parameters, function (param) {
            if (param.type == "PARAMETER_IN_QUERY") {
                userParameters[param.name] = param.value;
            }
        });
        
        this.contextMenu.onResourceCallClick(this.resource, this.url, method, runTypeUserInput, limit, userParameters, this.postParameter, this.callback);
        this.ownerCt.close();
    }, 
    buildFormItemFromParam : function (value, userInputParams) {
		var valueType = value.valueType;
        var item = {};
        //specific case for boolean
        if (valueType.indexOf("xs:boolean") != -1) {
            valueType = "xs:enum[true,false]";
        }
        if (valueType.indexOf("xs:enum") != -1) {
	        var enumeration = valueType.split("[");
	        enumeration = enumeration[1].split("]");
	        enumeration = enumeration[0].split(",");

			var multiple = false;
			if (valueType.indexOf("xs:enum-multiple") >= 0 || valueType.indexOf("xs:enum-editable-multiple") >= 0) {
				multiple = true;
			}
			
			var storeItems = [];
			for (var i = 0; i < enumeration.length; i++) {
				var tmp = enumeration[i].trim();
				storeItems.push([ tmp, tmp]);
			}
			var store = new Ext.data.ArrayStore({
                fields : ['value', 'text'],
                data : storeItems, 
                valueField : 'value', 
                displayField : 'text'
            });
			
			if (multiple) {
				item = {
					store : store,
					name : value.name, 
					xtype : "multiselect", 
					values : value.value, 
					delimiter : '|', 
					fieldLabel : value.name, 
					width : 235, 
					tooltip : value.description
				};
			}
			else {
				item = {
					store : store,
					name : value.name, 
					xtype : "combo", 
					value : value.value, 
					valueField : "value", 
					displayField : "text", 
					mode: 'local', 
					fieldLabel : value.name, 
					triggerAction : 'all',
					selectOnFocus : true,
					editable : false, 
					anchor : "100%", 
					tooltip : value.description
				};
			}
        }
        else {
			item = {
                name : value.name,
                xtype : 'textfield',
                value : value.value,
                fieldLabel : value.name,
                anchor : "100%", 
				tooltip : value.description
            };
        }
        return item;
    }, 
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }

});/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global Ext, sitools, i18n, SitoolsDesk, alertFailure, window, loadUrl */

Ext.namespace('sitools.user.component.dataviews');

/**
 * A simple window that displays result of Resource Tasks.
 * @class sitools.user.component.dataviews.goToTaskPanel
 * @extends Ext.Panel
 */
sitools.user.component.dataviews.goToTaskPanel = Ext.extend(Ext.Panel, {
//sitools.user.component.livegrid.goToTaskPanel = Ext.extend(Ext.Window, {
//    modal : true,
    width : "500", 
    buttonAlign : 'left',
    layout : 'fit',
    initComponent : function () {
        
        
        
        this.mainPanel = this.createNewFormComponent(this.task);
 
        this.buttons = ["->",  {
            text : i18n.get('label.goToTask'),
            scope : this,
            handler : this.goToTask
        }, {
            text : i18n.get('label.close'),
            scope : this,
            handler : function () {
                this.ownerCt.close();
            }
        } ];
        
        
        this.items = [this.mainPanel];
        
        sitools.user.component.dataviews.goToTaskPanel.superclass.initComponent.call(this);

    },
    
    refreshTask : function () {
//        var form = this.mainPanel;
        var url = this.task.statusUrl;
        Ext.Ajax.request({
            url : url,
            method : "GET",
            scope : this,
            success : function (ret) {
                var data = Ext.decode(ret.responseText);
                if (!data.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), data.message);
                    return false;
                }
                this.task = data.TaskModel;
                this.mainPanel = this.createNewFormComponent(this.task);
                this.removeAll();
                this.add(this.mainPanel);
                this.doLayout();
            },
            failure : alertFailure
        });
    },
    
    createNewFormComponent : function (task) {
      
        var html = String.format(i18n.get("label.taskLaunched"), task.status);
        html += String.format("<a href='#'>{0}</a><br>", i18n.get("label.detail"));
        
        if (!Ext.isEmpty(task.urlResult)) {
			html += "<br>" + String.format(i18n.get("label.taskResult"), task.urlResult);	
			html += String.format("<a href='#'>{0}</a><br>", i18n.get("label.result"));
        }
        else {
			html += "<br>" + i18n.get("label.refreshTaskWindow");	
			html += String.format("<a href='#'>{0}</a><br>", i18n.get("label.refresh"));
        }
        
        var panel = new Ext.Panel({
			padding: 5,
			layout : "fit", 
			html : html, 
			listeners : {
				scope : this, 
				afterrender : function (panel) {
					panel.getEl().child('a').on("click", function () {
						this.showTaskDetail(task);
					}, this);
					var resultOrRefreshLink = panel.getEl().child('a').next('a');
					if (!Ext.isEmpty(task.urlResult)) {
						resultOrRefreshLink.on("click", function () {
							this.showTaskResults(task);
						}, this);
					}
					else {
						resultOrRefreshLink.on("click", function () {
							this.refreshTask();
						}, this);
					}
				}
			}
        });
        return panel;
        
//        var formPanel = new Ext.form.FormPanel({
//            title : i18n.get("label.taskDetails"),
//            padding: 5,
//            items : [ {
//                name : 'statusUrl',
//                xtype : 'textfield',
//                value : task.statusUrl,
//                hidden : true
//            }, {
//                name : 'status',
//                fieldLabel : i18n.get('label.status'),
//                anchor : "100%",
//                xtype : 'textfield',
//                value : task.status
//            }, {
//                name : 'id',
//                fieldLabel : i18n.get('label.id'),
//                anchor : "100%",
//                xtype : 'textfield',
//                value : task.id
//            }, {
//                itemValue : task.statusUrl,
//                fieldLabel : i18n.get('label.url'),
//                xtype : 'box',
//                html : "<a href='#'> " + task.statusUrl + "</a>"
//                ,
//                listeners : {
//                    scope : this,
//                    render : function (cmp) {
//                        cmp.getEl().on('click', function () {
//                            var jsObj = sitools.user.modules.userSpaceDependencies.svaTasksDetails;
//                            var componentCfg = {
//                                sva : task    
//                            };
//                            var windowConfig = {
//                                id : "taskStatusDetails", 
//                                title : i18n.get("label.taskDetails") + ":" + task.id
//                            };
//                            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
//                        });
//                    }
//                }
//            }
//            ]
//        });
//        
//        if (!Ext.isEmpty(task.urlResult)) {
//            var item = new Ext.BoxComponent({
//                itemValue : task.urlResult,
//                fieldLabel : i18n.get('label.result'),
//                html : "<a href='#'> " + task.urlResult + "</a>",
//                listeners : {
//                    scope : this,
//                    render : function (cmp) {
//                        cmp.getEl().on('click', function () {
//                            var orderUrl = loadUrl.get('APP_URL') + loadUrl.get('APP_ORDERS_USER_URL');
//                            if (cmp.itemValue.indexOf(orderUrl) != -1) {
//                                this._showOrderDetails(cmp.itemValue);
//                            } else if (cmp.itemValue.indexOf("/records") != -1) {
//                                this._showDatasetDetails(cmp.itemValue);
//                            } 
//                            else {
//                                window.open(cmp.itemValue);
//                            }
//                        }, this);
//                    }
//                }
//            });
//            formPanel.add(item);
//        }
//        
//        return formPanel;
        
    },
    
    /**
     * Handler of the button goToTask. 
     * Open the home Module Window with the taskPanel opened.
     */
    goToTask : function () {
        this.ownerCt.close();
		var jsObj = sitools.user.component.entete.userProfile.tasks;
        var windowConfig = {
            title : i18n.get('label.Tasks'),
            saveToolbar : false, 
            iconCls : "tasks"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, {}, jsObj, true);

    },
    /**
     * Open a sitools.user.component.entete.userProfile.orderProp window. 
     * @param {String} url the Url to request the task. 
     */
    _showOrderDetails : function (url) {
        Ext.Ajax.request({
            url : url,
            method : 'GET',
            scope : this,
            success : function (ret) {
                var data = Ext.decode(ret.responseText);
                if (!data.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), data.message);
                    return false;
                }
                var rec = new Ext.data.Record(data.order);
                var jsObj = sitools.user.component.entete.userProfile.orderProp;
                var componentCfg = {
                    action : 'detail',
                    orderRec : rec
                };
                var title = i18n.get('label.details') + " : ";
                title += rec.data.userId;
                title += " " + i18n.get('label.the');
                title += " " + rec.data.dateOrder;

                var windowConfig = {
                    id : "showDataDetailId", 
                    title : title,  
                    specificType : "dataDetail", 
                    iconCls : "dataDetail"
                };
                SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
            },
            failure : alertFailure
        });
        
    },
    /**
     * Only in NoSql, open a dataset view 
     * @param {} url
     */
    _showDatasetDetails : function (url) {
        var urlDataset = url.substring(0, url.indexOf("/records"));
        Ext.Ajax.request({
            url : urlDataset,
            method : 'GET',
            scope : this,
            success : function (ret) {
                var data = Ext.decode(ret.responseText);
                if (!data.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), data.message);
                    return false;
                }
                var dataset = new Ext.data.Record(data.dataset).data;
                
                var windowConfig = {
                        title : i18n.get('label.dataTitle') + " : " + dataset.name,
                        datasetName : dataset.name, 
                        datasetDescription : dataset.description,
                        type : "data", 
                        saveToolbar : true, 
                        toolbarItems : [], 
                        iconCls : "dataDetail"
                    };
                
                //open the dataView according to the dataset Configuration.
                var javascriptObject = eval(dataset.datasetView.jsObject);
                //add the toolbarItems configuration
                Ext.apply(windowConfig, {
                    id : "data" + dataset.datasetId
                });
                var componentCfg = {
                    dataUrl : dataset.sitoolsAttachementForUsers,
                    datasetId : dataset.id,
                    datasetCm : dataset.columnModel, 
                    datasetName : dataset.name,
                    dictionaryMappings : dataset.dictionaryMappings, 
	                datasetViewConfig : dataset.datasetViewConfig, 
                    preferencesPath : "/" + dataset.name, 
                    preferencesFileName : "datasetView"
                };
                
                SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, javascriptObject);
                
            },
            failure : alertFailure
        });
        
    }, 
    /**
     * Opens a sitools.user.modules.userSpaceDependencies.svaTasksDetails window to see the task Details. 
     * @param {} task
     */
    showTaskDetail : function (task) {
	    var jsObj = sitools.user.component.entete.userProfile.tasksDetails;
	    var componentCfg = {
	        sva : task    
	    };
	    var windowConfig = {
	        id : "taskStatusDetails", 
	        title : i18n.get("label.taskDetails") + ":" + task.id, 
	        iconCls : "dataDetail"
	    };
	    SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
	}, 
	/**
	 * parse the task.urlResult to see if this is an Specialized resource (noSQl or Order). 
	 * If not, open a new Window to get the result of the resource. 
	 * @param {} task
	 */
	showTaskResults : function (task) {
		var orderUrl = loadUrl.get('APP_URL') + loadUrl.get('APP_ORDERS_USER_URL');
        if (task.urlResult.indexOf(orderUrl) != -1) {
            this._showOrderDetails(task.urlResult);
        } else if (task.urlResult.indexOf("/records") != -1) {
            this._showDatasetDetails(task.urlResult);
        } 
        else {
            window.open(task.urlResult);
        }
	}, 
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }
    

});

/***************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global Ext, sitools, i18n, extColModelToStorage, projectId, userStorage, window, extColModelToSrv, userLogin, alertFailure, DEFAULT_LIVEGRID_BUFFER_SIZE, projectGlobal, SitoolsDesk, DEFAULT_ORDER_FOLDER, DEFAULT_PREFERENCES_FOLDER, loadUrl */

/*
 * @include "resourcePluginParamsPanel.js"
 * @include "goToTaskPanel.js"
 * @include "../../../env.js"
 * @include "../../../def.js"
 */
Ext.namespace('sitools.user.component.dataviews.services');

/**
 * Define an object to call server service resources
 * 
 * @extends Ext.util.Observable
 * @cfg {} grid The object that calls ContextMenu 
 * @cfg {string} datasetUrl The url Attachement of the dataset
 * @cfg {string} datasetName Dataset Name
 * @cfg {string} origin name of the dataview which call this object
 * @requires sitools.user.component.dataviews.resourcePluginParamsPanel
 * @requires sitools.user.component.dataviews.goToTaskPanel
 */
sitools.user.component.dataviews.services.serverServicesUtil =  Ext.extend(Ext.util.Observable, {

    constructor : function (config) {
        /** apply datasetUrl, grid, origin **/
        Ext.apply(this, config);
        
        this.urlDatasetServiceServer = this.datasetUrl + "/services" + '/server/{idService}';
    },
    
    callServerService : function (idService, selections) {
        this.setSelections(selections);
        Ext.Ajax.request({
            url : this.urlDatasetServiceServer.replace('{idService}', idService),
            method : 'GET',
            scope : this,
            success : function (ret) {
                var json = Ext.decode(ret.responseText);
                if (!json.success) {
                    Ext.Msg.alert(i18n.get("label.warning"), i18n.get("label.resource.not.found"));
                    return;
                }
                
                var resource = json.resourcePlugin;
                var parameters = resource.parameters;
                var url = null, runTypeUserInput = null, methods = null;
                parameters.each(function (param) {
                    switch (param.name) {
                    case "methods":
                        methods = param.value;
                        break;
                    case "runTypeUserInput":
                        runTypeUserInput = param.value;
                        break;
                    case "url":
                        url = this.datasetUrl + param.value;
                        break;                    
                    }
                }, this);
                
                this.resourceClick(resource, url, methods, runTypeUserInput, parameters);
            }
        });
        
    },
    
    
    /**
     * Get the number of selected records
     * @return {number}
     */
    getNbRowsSelected : function () {
        if (this.grid.getNbRowsSelected()) {
            return this.grid.getNbRowsSelected();
        }
        else {
            return null;
        }
    },
    /**
     * Get the number of grid records
     * @return {number}
     */
    getNbGridRecords : function () {
        return this.grid.getStore().totalLength;
    }, 
    /**
     * Sets the grid attribute
     * @param {} cmp
     */
    setGrid : function (cmp) {
        this.grid = cmp;
    },
    /**
     * sets the selections attribute
     * @param {} selections
     */
    setSelections : function (selections) {
        this.selections = selections;
    },
    /**
     * Method called when a resource item is clicked.
     * 
     * @param {} resource The resource description
     * @param {string} url the url to call to execute query
     * @param {Array} methods A list of permissed methods. 
     * @param {} runType The runType of the resource.
     * @param {Array} parameters An array of parameters.
     */
    resourceClick : function (resource, url, methods, runType, parameters, postParameter, callback) {
        this.checkResourceParameters(resource, url, methods, runType, parameters, postParameter, callback);
    },
    
    /**
     * handle the click on a Resource after the parameters have been checked
     * 
     * @param {} resource The resource description
     * @param {string} url the url to call to execute query
     * @param {Array} methods A list of permissed methods. 
     * @param {} runType The runType of the resource.
     * @param {Array} parameters An array of parameters.
     */
    handleResourceClick : function (resource, url, methods, runType, parameters, postParameter, callback) {
        //check that the number of records allowed is not reached
        var showParameterBox = false;
        var params = {};
        Ext.each(parameters, function (parameter) {
            if (parameter.type === "PARAMETER_USER_INPUT" && parameter.userUpdatable) {
                showParameterBox = true;
            } 
            if (parameter.type == "PARAMETER_IN_QUERY") {
                params[parameter.name] = parameter.value;   
            }
        });
        if (methods.split("|") && methods.split("|").length > 1) {
            showParameterBox = true;
        }
        var componentCfg = null, windowConfig = null, jsObj = null;
        if (showParameterBox && this.origin !== "sitools.user.modules.projectServices") {
            windowConfig = {
                title : i18n.get("label.resourceReqParam"), 
                iconCls : "datasetRessource"
            };
            jsObj = sitools.user.component.dataviews.resourcePluginParamsPanel;
            componentCfg = {
                resource : resource,
                url : url,
                methods : methods,
                runType : runType,
                parameters : parameters,
                contextMenu : this,
                postParameter : postParameter,
                callback : callback,
                withSelection : (this.getNbRowsSelected() !== 0)
            };
            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
        }
        else if (showParameterBox) {
            windowConfig = {
                title : i18n.get("label.resourceReqParam"), 
                iconCls : "datasetRessource"
            };
            jsObj = sitools.user.component.dataviews.resourcePluginParamsPanel;
            componentCfg = {
                resource : resource,
                url : url,
                methods : methods,
                runType : runType,
                parameters : parameters,
                contextMenu : this,
                withSelection : false,
                postParameter : postParameter,
                callback : callback
            };
            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
        }
        else {
            this.onResourceCallClick(resource, url, methods, runType, null, params, postParameter, callback);
        }
    },

    /**
     * the action used when click on a Resource menu. Request Resource tasks to the URL
     * datasetUrlAttachment + "/sva/" + sva.id + "/tasks If there is no selected
     * record : Build the request with the actual params of the grid : sort,
     * filters, formParams, ColModel else Build the request with a list of
     * records primaryKeyValue by using the formRequest API LISTBOXMULTIPLE|
     * 
     * @param {} resource the resource object.  
     * @param url :
     *            the Url to request the data
     * @param method :
     *            the method used to request the data
     * @param grid :
     *            the liveGrid
     * @param method :
     *            the method for the resource : POST or GET
     * @param userSyncChoice :
     *            the user choice : "sync" || "async"
     * @param limit :
     *            the request limit
     * @param userParameters :
     *            a list of key/value object
     * 
     */
    onResourceCallClick : function (resource, url, method, userSyncChoice, limit, userParameters, postParameter, callback) {
        if ((method === "POST" || method === "PUT" || method === "DELETE") && userSyncChoice === "TASK_RUN_SYNC") {
            Ext.Msg.alert(i18n.get('label.error'), String.format(i18n.get("error.invalidMethodOrSyncRessourceCall"), method, userSyncChoice));
            return;
        }

        var request = "";
        if (this.origin !== "sitools.user.modules.projectServices") {
            try {
                request = this.grid.getRequestParam();
            }
            catch (err) {
                Ext.Msg.alert(i18n.get('label.error'), String.format(i18n.get('label.notImplementedService'), err));
                return false;
            }
        }

        url += "?1=1" + request;
        if (!Ext.isEmpty(limit)) {
            url += "&limit=" + limit;
        }
        if (! Ext.isEmpty(userParameters)) {
            Ext.iterate(userParameters, function (key, value) {
                url += "&" + key + "=" + value; 
            });
        }

        if (method === "GET") {
            switch (resource.behavior) {
            case "DISPLAY_IN_NEW_TAB" :
                if (!Ext.isEmpty(callback)) {
                    callback.call();
                }
                window.open(url);
                Ext.getBody().unmask();
                break;
            case "DISPLAY_IN_DESKTOP" :
                var windowConfig = {
                    title : i18n.get('downloadedResource'), 
                    iconCls : "datasetRessource"
                };
                var jsObj = Ext.ux.ManagedIFrame.Panel;
                var componentCfg = {
                    layout : 'fit',
                    defaultSrc: url, 
                    autoScroll : true
                };
                Ext.Ajax.request({
                    method : "HEAD", 
                    url : url, 
                    success : function (ret) {
                        var headerFile = "";
                        try {
                            headerFile = ret.getResponseHeader("Content-Type").split(";")[0].split("/")[0];
                        }
                        catch (err) {
                            headerFile = "";    
                        }
                        var contentDisp = ret.getResponseHeader("Content-Disposition");
                        
                        if (headerFile === "text" && Ext.isEmpty(contentDisp)) {
                            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
                        }
                        else {
                            if (!Ext.isEmpty(callback)) {
                                callback.call();
                            }
                            var iFrame = Ext.getCmp("tempMifDownload");
                            if (Ext.isEmpty(iFrame)) {
                                iFrame  = new Ext.ux.ManagedIFrame.Panel({
                                    layout : 'fit',
                                    defaultSrc: url, 
                                    autoScroll : true, 
                                    renderTo : Ext.getBody(), 
                                    id : "tempMifDownload",
                                    listeners : {
                                        activate : function () {
                                            
                                        }
                                    }
                                });
                            }
                            else {
                                iFrame.setSrc(url); 
                            }
                        }
                    }, 
                    failure : alertFailure
                });
                break;
            case "DOWNLOAD" :
                if (!Ext.isEmpty(callback)) {
                    callback.call();
                }
                //générer un panel caché
                var iFrame = Ext.getCmp("tempMifDownload");
                if (Ext.isEmpty(iFrame)) {
                    iFrame  = new Ext.ux.ManagedIFrame.Panel({
                        layout : 'fit',
                        defaultSrc: url, 
                        autoScroll : true, 
                        renderTo : Ext.getBody(), 
                        id : "tempMifDownload",
                        listeners : {
                            afterrender : function () {
//                              callback.call();
//                              console.log('afterrender 2');
                          }
                        }
                    });
                }
                else {
                    iFrame.setSrc(url); 
                }
                
                break;
            }
            return;
        } else {
            this._executeRequestForResource(url, method, postParameter, callback);
        }
    },
    /**
     * Execute the resource.
     * @param {string} url the url to request
     * @param {string} method The method (GET, POST, PUT, DELETE)
     * @param {} postObject The object that will be passed with the request.
     */
    _executeRequestForResource : function (url, method, postObject, callback) {
        var config = {
            method : method,
            url : url,
            scope : this,
            success : function (response, opts) {
                // try {
                
                var json = Ext.decode(response.responseText);
                if (!json.success) {
                    Ext.Msg.show({
                        title : i18n.get('label.error'),
                        msg : json.message,
                        width : 300,
                        buttons : Ext.MessageBox.OK
                    });
                    return;
                }
                var task = json.TaskModel;
                if (!Ext.isEmpty(task.urlResult)) {
                    window.open(task.urlResult);
                } else {
                    var componentCfg = {
                        task : task
                    };
                    var jsObj = sitools.user.component.dataviews.goToTaskPanel;
        
                    var windowConfig = {
                        title : i18n.get('label.info'),
                        saveToolbar : false,
                        iconCls : "datasetRessource"
                    };
                    SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj, true);
                    
                }
                

            },
            failure : function (response, opts) {
                this.grid.getEl().unmask();
                Ext.Msg.show({
                        title : i18n.get('label.error'),
                        msg : response.responseText,
                        width : 300,
                        buttons : Ext.MessageBox.OK
                    });
            },
            callback : function () {
                
                if (Ext.getBody().isMasked()) {
                    Ext.getBody().unmask();
                }
                callback.call();
            }

        };
        if (!Ext.isEmpty(postObject)) {
            Ext.apply(config, postObject);
        }
        Ext.Ajax.request(config);
    },
    /**
     * check that the request is compatible with the resource parameters.
     * If the parameters are ok, call the method handleResourceClick to handle the resource call
     * @param {} resource The resource description
     * @param {string} url the url to call to execute query
     * @param {Array} methods A list of permissed methods. 
     * @param {} runType The runType of the resource.
     * @param {Array} parameters An array of parameters.
     * 
     */
    checkResourceParameters : function (resource, url, methods, runType, parameters, postParameter, callback) {
        //in the case of a OrderResource, let's check that the number of records is not superior to too_many_selected_threshold => stop the resource execution
        var maxThreshold = this.getParameterFromName(parameters, "too_many_selected_threshold");
        var nbRows;
        if (!Ext.isEmpty(maxThreshold)) {
            var maxThresholdTextParam, maxTresholdText;
            //get the number of rows either from a selection or all the rows
            nbRows = (Ext.isEmpty(this.getNbRowsSelected()) || this.getNbRowsSelected() === 0) ? this.getNbGridRecords() : this.getNbRowsSelected();
            if (!Ext.isEmpty(maxThreshold.value) && parseInt(maxThreshold.value) !== -1 && nbRows > parseInt(maxThreshold.value)) {
                maxThresholdTextParam = this.getParameterFromName(parameters, "too_many_selected_threshold_text");
                maxTresholdText = i18n.get("label.defaultMaxThresholdText");
                if (!Ext.isEmpty(maxThresholdTextParam)) {
                    maxTresholdText = maxThresholdTextParam.value;
                }
                Ext.Msg.alert(i18n.get("label.error"), maxTresholdText);
                return;
            }
        }
        //in the case of a OrderResource, let's check that the number of records is not superior to max_warning_threshold => ask the user to continue or stop the resource execution
        var warningThreshold = this.getParameterFromName(parameters, "max_warning_threshold");
        if (!Ext.isEmpty(warningThreshold)) {
            //get the number of rows either from a selection or all the rows
            nbRows = (Ext.isEmpty(this.getNbRowsSelected()) || this.getNbRowsSelected() === 0) ? this.getNbGridRecords() : this.getNbRowsSelected();
            if (!Ext.isEmpty(warningThreshold.value) &&  parseInt(warningThreshold.value) !== -1 && nbRows >  parseInt(warningThreshold.value)) {
                var warningThresholdTextParam = this.getParameterFromName(parameters, "max_warning_threshold_text");
                var warningTresholdText = i18n.get("label.defaultWarningThresholdText");
                if (!Ext.isEmpty(warningThresholdTextParam)) {
                    warningTresholdText = warningThresholdTextParam.value;
                } 
                Ext.Msg.show({
                    title : i18n.get('label.warning'),
                    buttons : {
                        yes : i18n.get('label.yes'),
                        no : i18n.get('label.no')
                    },
                    msg : warningTresholdText,
                    scope : this,
                    fn : function (btn, text) {
                        if (btn === 'yes') {
                            this.handleResourceClick(resource, url, methods, runType, parameters, postParameter, callback);
                        }
                    }
                }); 
                return;     
            }
        }
        this.handleResourceClick(resource, url, methods, runType, parameters, postParameter, callback);
    },
    /**
     * get the parameter with the given name from the given list of parameter
     * @param {Array} parameters the Array of parameters
     * @param {string} name the name of the Parameter to search
     * @return {Object} a Parameter with the given name or null if the parameter is not found 
     */
    getParameterFromName : function (parameters, name) {
        var paramOut = null;
        for (var index = 0; index < parameters.length && paramOut === null; index++) {
            if (parameters[index].name === name) {
                paramOut = parameters[index];
            }
        }
        return paramOut;

    }
    
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, LOCALE, ImageChooser, 
 showHelp, ann, mainPanel, helpUrl:true, loadUrl, SHOW_HELP*/

Ext.namespace('sitools.user.component.dataviews.services');

/**
 * Create A Toolbar from the currents dataset services
 * @required datasetId
 * @required datasetUrl
 * @required dataview
 * @required origin
 * @required columnModel
 * @cfg {String} datasetUrl the url of the dataset
 * @cfg {String} datasetId the id of the dataset
 * @cfg {Object} dataview the dataview
 * @cfg {String} origin the name of the dataview
 * @cfg {Array} columnModel the dataset columnModel
 * @class sitools.user.component.dataviews.services.menuServicesToolbar
 * @extends Ext.Toolbar
 */
sitools.user.component.dataviews.services.menuServicesToolbar = Ext.extend(Ext.Toolbar, {
    enableOverflow: true,
    initComponent : function () {
        this.cls = "services-toolbar"; 
        
        this.addEvents("allServicesLoaded");
        
        this.urlDatasetServiceIHM = this.datasetUrl + "/services" + '/gui/{idService}';

        this.store = new Ext.data.JsonStore({
            url : this.datasetUrl + "/services",
            idProperty : 'id',
            root : 'ServiceCollectionModel.services',
            autoload : true,
            fields : [ 'id', 'type', 'name', 'description', 'icon', 'label', 'category', 'visible', 'position', 'dataSetSelection' ],
//            listeners : {
//                scope : this,
//                load : this.createMenuServices
//            }
        });
        this.store.load();
        
        this.serverServiceUtil = new sitools.user.component.dataviews.services.serverServicesUtil({
            datasetUrl : this.datasetUrl,
            grid : this.dataview,
            origin : this.origin
        });
        
        this.guiServiceController = new sitools.user.component.dataviews.services.GuiServiceController({
            datasetUrl : this.datasetUrl,
            columnModel : this.columnModel,
            dataview : this.dataview,
            origin : this.origin,
            listeners : {
                scope : this,
                guiservicesloaded : function () {
                    this.fireEvent("allServicesLoaded");
                }
            }
        });
        
        
        sitools.user.component.dataviews.services.menuServicesToolbar.superclass.initComponent.call(this);
    },

    afterRender : function () {
        
//        if (this.origin === "sitools.user.component.dataviews.cartoView.cartoView"){
//            
//            this.dataview.gridPanel.selModel.addListener('selectionchange', function () {
//                this.updateContextToolbar();
//            }, this);
//            sitools.user.component.dataviews.services.menuServicesToolbar.superclass.afterRender.apply(this, arguments);
//        }
        
        this.dataview.getSelectionModel().addListener('selectionchange', function () {
                this.updateContextToolbar();
            }, this);
        sitools.user.component.dataviews.services.menuServicesToolbar.superclass.afterRender.apply(this, arguments);
    },
    
    /**
     * Update the toolbar according to the dataview selection 
     */
    updateContextToolbar : function () {
        if (this.store.getTotalCount() === 0) {
            return;
        }
        
        var records = [];
        this.removeAll();
        
        this.store.each(function (rec) {
            records.push(rec); 
        });
        this.createMenuServices(this.store, records, null);
    },

    
    createMenuServices : function (store, records, opts) {
        
        records = this.sortServices(records);
        
        var icon, category, menu = this, btn = {};
        Ext.each(records, function (item) {
            menu = this;
            
            if (item instanceof Ext.Toolbar.Item || !this.isService(item)) {
                menu.add(item);
                return;
            }
            
            if (!item.get('visible')) {
                return;
            }
            
            if (!this.isSelectionOK(item.get('dataSetSelection'))) {
                return;
            }
            
            if (!Ext.isEmpty(category = item.get('category'))) {
                menu = this.getMenu(category);
            }
            
            
            if (!Ext.isEmpty(icon = item.get('icon'))) {
                Ext.apply(btn, {
                    iconCls : 'btn-format-icon',
                    icon : icon
                });
            }
            
            Ext.apply(btn, {
                idService : item.get('id'),
                typeService : item.get('type'),
                text : i18n.get(item.get('label')),
                cls : 'services-toolbar-btn',
                icon : icon,
                scope : this,
                handler : this.callService
            });
            
            menu.add(btn);
            
            if (this.id === menu.id) {
                this.add(' ');
            }
            
        }, this);
        this.doLayout();
    },
    
    isService : function (item) {
        return item instanceof Ext.data.Record;
    },

    /**
     * Return a array with the column filter button
     */
    addAdditionalButton : function () {
        return this.dataview.getCustomToolbarButtons();
    },
    

    /**
     * Execute the service when the button service is clicked
     * @param button
     * @param e
     */
    callService : function (button, e) {
        if (button.typeService === 'SERVER') {
            this.serverServiceUtil.callServerService(button.idService, this.dataview.getSelections());
        } else {
            this.callGUIService(button.idService);
        }
    },
    
    callGUIService : function (idService) {
        this.guiServiceController.callGuiService(idService);
    },
    
    getMenu : function (category) {
        var buttonSearch = this.find('category', category);
        var button;
        if (Ext.isEmpty(buttonSearch)) {
            button = new Ext.Button({
                category : category,
                text : category,
                cls : 'services-toolbar-btn',
                menu : new Ext.menu.Menu({
                    showSeparator : false
                }),
                iconAlign : "right",
                clickEvent : 'mousedown'
            });
            this.add(button);
            this.add(' ');
        } else {
            button = buttonSearch[0];
        }
        return button.menu;
    },
    
    /**
     * Sort all services in the right order before being displayed
     * @param records
     *          
     * @returns Tab of records
     */
    sortServices : function (records) {
        var tbRight = [], tb = [];
        tb.push(this.addAdditionalButton());
        Ext.each(records, function (item) {
            if (item.get('position') === 'left' || Ext.isEmpty(item.get('position'))) {
                tb.push(item);
            } else {
                tbRight.push(item);
            }
        });
        tb.push(new Ext.Toolbar.Fill());
        
        return tb.concat(tbRight);
    },
    
    
    /**
     * Return true if the datasetSelection match the dataview selection
     * 
     * @param selectionString
     *          the datasetSelection string (NONE, SINGLE, MULTIPLE, ALL)
     * @returns {Boolean}
     */
    isSelectionOK : function (selectionString) {
        var selectionOK = false;
        var nbRowsSelected = this.dataview.getNbRowsSelected();
        switch (selectionString) {

        case "NONE":
            selectionOK = true;            
            break;
            
        case "SINGLE":
            if (!Ext.isEmpty(nbRowsSelected) && nbRowsSelected === 1) {
                selectionOK = true;
            }
            break;
            
        case "MULTIPLE":
            if (!Ext.isEmpty(nbRowsSelected) && nbRowsSelected >= 1) {
                selectionOK = true;
            }
            break;
            
        case "ALL":
            if (!Ext.isEmpty(nbRowsSelected) && this.dataview.isAllSelected()) {
                selectionOK = true;
            }
            break;
        }
        return selectionOK;
    }
    
});/***************************************

* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, LOCALE, ImageChooser, 
 showHelp, ann, mainPanel, helpUrl:true, loadUrl, SHOW_HELP*/

Ext.namespace('sitools.user.component.dataviews.services');

/**
 * GuiServiceController to organize GuiServices on the dataset columns
 * 
 * @required datasetId
 * @required datasetUrl
 * @required dataview
 * @required origin
 * @required columnModel
 * 
 * @cfg {Array} columnModel the dataset columnModel
 * @cfg datasetUrl {String} the url attachment of the dataset
 * @cfg dataview {Object} the dataview object
 * @cfg origin {String} the name of the dataview
 * 
 * @class sitools.user.component.dataviews.services.GuiServiceController
 * @extends Ext.util.Observable
 */
sitools.user.component.dataviews.services.GuiServiceController =  function (config) {
    
    Ext.apply(this, config);
    
    this.addEvents("guiServicesLoaded");
    
    //Map<Colonne, Service> with colonne = columnAlias and Service = the service object
    this.guiServiceMap = new Ext.util.MixedCollection();
    
    this.guiServiceStore = new sitools.user.component.dataviews.services.GuiServicesStore({
        datasetUrl : this.datasetUrl,
        autoLoad : true,
        listeners : {
            scope : this,
            load : function (store, services, options) {
                
                this.createMapParamServices(services);
                //For each column, find the Gui_Service configured, if exists
                Ext.each(this.columnModel, function (column) {
                    if (!Ext.isEmpty(column.columnRenderer)) {
                        var featureTypeColumn = sitools.admin.datasets.columnRenderer.behaviorEnum.getColumnRendererCategoryFromBehavior(column.columnRenderer.behavior);
                        
                        var guiServiceWithColumn = null;
                        var guiServiceWithoutColumn = null;
                        
                        
                        Ext.each(services, function (service) {
                            var parameters = service.get("parametersMap");
                            if (!Ext.isEmpty(parameters)) {
                                var featureTypeService = parameters.get("featureType");
                                if (!Ext.isEmpty(featureTypeService) && featureTypeService === featureTypeColumn) {
                                    var columnAlias = parameters.get("columnAlias");
                                    if (columnAlias === column.columnAlias) {
                                        guiServiceWithColumn = service;
                                    } else if (Ext.isEmpty(columnAlias)) {
                                        guiServiceWithoutColumn = service;
                                    }
                                }
                            }
                        }, this);
                        
                        if (!Ext.isEmpty(guiServiceWithColumn)) {
                            this.guiServiceMap.add(column.columnAlias, guiServiceWithColumn);
                        } else if (!Ext.isEmpty(guiServiceWithoutColumn)) {
                            this.guiServiceMap.add(column.columnAlias, guiServiceWithoutColumn);
                        }
                    }
                }, this);
                
                this.fireEvent("guiServicesLoaded");
                                    
            }
            
        }
        
    });
    sitools.user.component.dataviews.services.GuiServiceController.superclass.constructor.call(this);
};

Ext.extend(sitools.user.component.dataviews.services.GuiServiceController, Ext.util.Observable, {
    

    /**
     * Get the service if exists configured on the given column identified
     * by its columnAlias
     * 
     * @param columnAlias
     *            {String} the columnAlias
     * @returns the service if exists configured on the given column
     *          identified by its columnAlias
     */
    getService : function (columnAlias) {
        return this.guiServiceMap.get(columnAlias);
    },
    

    /**
     * Call a GuiService
     * 
     * @param idService
     *            {String} the id of the service
     * @param record
     *            {Ext.data.Record} the record to execute the guiservice
     * @param columnAlias
     *            {String} the columnAlias
     */
    callGuiService : function (idService, record, columnAlias) {
        var service = this.guiServiceStore.getById(idService);
        if (Ext.isEmpty(service)) {
            new Ext.ux.Notification({
                iconCls : 'x-icon-information',
                title : i18n.get('label.warning'),
                html : i18n.get("label.cannot-find-guiservice"),
                autoDestroy : true,
                hideDelay : 1000
            }).show(document);
            return;
        }
        
        var guiServicePlugin = {};
        Ext.apply(guiServicePlugin, service.data);
        
        var JsObj = eval(guiServicePlugin.xtype);
        
        var config = Ext.apply(guiServicePlugin, {
            columnModel : this.dataview.getColumnModel(),
            store : this.dataview.getStore(),
            dataview : this.dataview,
            origin : this.origin,
            record : record,
            columnAlias : columnAlias
        });

        JsObj.executeAsService(config);            
    },
    

    /**
     * Create a collection of parameters for each services with parameter
     * and add it to the service record
     * 
     * @param services
     *            {Array} the list of services
     */
    createMapParamServices : function (services) {
      //  create a map of parameters for each guiservice
        Ext.each(services, function (service) {
            var parameters = service.get("parameters");
            //if the parameters are empty, try to get the defaultParameters
            if (Ext.isEmpty(parameters)) {
                var JsObj = eval(service.get("xtype"));
                if (Ext.isFunction(JsObj.getDefaultParameters)) {
                    parameters = JsObj.getDefaultParameters();
                }
            }
            if (!Ext.isEmpty(parameters)) {
                var collection = new Ext.util.MixedCollection();
                Ext.each(parameters, function (param) {
                    collection.add(param.name, param.value);
                });
                service.set("parametersMap", collection);
            }
        });
    }
    
    
});
    
    
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, LOCALE, ImageChooser, 
 showHelp, ann, mainPanel, helpUrl:true, loadUrl, SHOW_HELP*/

Ext.namespace('sitools.user.component.dataviews.services');


sitools.user.component.dataviews.services.GuiServicesStore = Ext.extend(Ext.data.JsonStore, {
    
    
 constructor : function (config) {
        
        Ext.apply(config, {
            root : 'data',
            restful : true,
            proxy : new Ext.data.HttpProxy({
                url : config.datasetUrl + "/services/gui",
                restful : true,
                method : 'GET'
            }),
            idProperty : 'id',
            fields : [ {
                name : 'id',
                type : 'string'
            }, {
                name : 'name',
                type : 'string'
            }, {
                name : 'description',
                type : 'string'
            }, {
                name : 'label',
                type : 'string'
            }, {
                name : 'xtype',
                type : 'string'
            }, {
                name : 'author',
                type : 'string'
            }, {
                name : 'version',
                type : 'string'
            }, {
                name : 'icon',
                type : 'string'
            }, {
                name : 'parameters'                    
            }, {
                name : 'priority',
                type : 'int'
            }, {
                name : 'dataSetSelection'
            }, {
                name : 'dependencies'
            }, {
                name : 'defaultVisibility'
            }, {
                name : 'parametersMap'
            }]
        });
        
        sitools.user.component.dataviews.services.GuiServicesStore.superclass.constructor.call(this, config);
     }
});
    
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, sitools, showResponse, i18n, extColModelToJsonColModel, loadUrl */

Ext.namespace('sitools.user.component');

// sitools.component.users.datasets.columnsDefinition = function (config) {
/**
 * A Panel that displays a grid with columns definition.
 * 
 * @cfg {string} datasetId The datasetId
 * @cfg {Ext.grid.ColumnModel} datasetCm The dataset Column Model
 * @cfg {string} datasetName The dataset Name
 * @cfg {Array} dictionnaryMappings The dataset Dictionnary Mapping
 * @class sitools.user.component.columnsDefinition
 * @extends Ext.Panel
 */
sitools.user.component.columnsDefinition = function(config) {

	Ext.apply(this, config);
	this.dictionaryMappings = config.dictionaryMappings[0];

	var fields = [{
				name : 'columnAlias',
				type : 'string'
			}, {
				name : 'unit',
				type : 'string'
			}];

	var columns = [{
				header : i18n.get('label.columnAlias'),
				dataIndex : 'columnAlias',
				width : 100,
				sortable : true
			}, {
				header : i18n.get('label.unit'),
				dataIndex : 'unit',
				width : 100,
				sortable : true
			}];

	if (!Ext.isEmpty(this.dictionaryMappings)
			&& !Ext.isEmpty(this.dictionaryMappings.mapping)
			&& !Ext.isEmpty(this.dictionaryMappings.mapping[0])) {

		var conceptAsTemplate = this.dictionaryMappings.mapping[0].concept;
		// columns
		columns.push({
					header : i18n.get("headers.name"),
					dataIndex : 'name',
					width : 100
				});
		columns.push({
					header : i18n.get("headers.description"),
					dataIndex : 'description',
					width : 120
				});

		// fields
		fields.push({
					name : 'name',
					type : 'string'
				});
		fields.push({
					name : 'description',
					type : 'string'
				});

		for (var i = 0; i < conceptAsTemplate.properties.length; i++) {
			var property = conceptAsTemplate.properties[i];
			columns.push({
						header : property.name,
						dataIndex : property.name,
						width : 80
					});

			fields.push({
						name : property.name,
						type : 'string'
					});
		}
	}

	var reader = new Ext.data.JsonReader({
				fields : fields,
				idProperty : 'columnAlias'
			});

	this.grid = new Ext.grid.GridPanel({
		store : new Ext.data.GroupingStore({
					idProperty : 'id',
					fields : fields,
					autoload : false,
					groupField : false,
					reader : reader,
					sortInfo : {
						field : 'columnAlias',
						direction : 'ASC'
					},
					remoteSort : false
				}),
		cm : new Ext.grid.ColumnModel({
					columns : columns
				}),
		view : new Ext.grid.GroupingView({
			groupTextTpl : '{text} ({[values.rs.length]} {[values.rs.length > 1 ? "Items" : "Item"]})',
			autoFill : true,
			forceFit : true

		}),
		layout : 'fit'
	});

	this.layout = "fit";
	this.items = [this.grid];

	sitools.user.component.columnsDefinition.superclass.constructor.call(this);
};

Ext.extend(sitools.user.component.columnsDefinition, Ext.Panel, {
	componentType : "defi",
	_getSettings : function() {
		var colModel = [];
		return {
			colModel : extColModelToJsonColModel(this.grid.getColumnModel().config),
			datasetName : this.datasetName,
			preferencesPath : this.preferencesPath,
			preferencesFileName : this.preferencesFileName
		};
	},

	/**
	 * overrides onRender method : Adds records in the store for each columns.
	 */
	onRender : function() {
		sitools.user.component.columnsDefinition.superclass.onRender.apply(
				this, arguments);

		var store = this.grid.getStore();
		var concepts, record;
		Ext.each(this.datasetCm, function(column) {
			concepts = this.getConcepts(column);
			if (!Ext.isEmpty(concepts)) {
				Ext.each(concepts, function(concept) {
							var rec = {
								columnAlias : column.columnAlias,
								unit : column.unit && column.unit.label
							};
							rec = Ext.apply(rec, {
										id : concept.id,
										name : concept.name,
										description : concept.description
									});

							for (var j = 0; j < concept.properties.length; j++) {
								var property = concept.properties[j];
								rec[property.name] = property.value;
							}
							record = new Ext.data.Record(rec);
							store.add(record);
						});
			} else {
				var rec = {
					columnAlias : column.columnAlias
				};
				record = new Ext.data.Record(rec);
				store.add(record);
			}

		}, this);
	},

	/**
	 * @param {Ext.grid.Column}
	 *            column
	 * @return {Array} the concepts of the column
	 */
	getConcepts : function(column) {
		if (Ext.isEmpty(this.dictionaryMappings)) {
			return;

		}
		var mapping = this.dictionaryMappings.mapping;
		var concepts = [], map;
		for (var i = 0; i < mapping.length; i++) {
			map = mapping[i];
			if (column.columnAlias == map.columnAlias) {
				concepts.push(map.concept);
			}
		}
		return concepts;
	},
	/**
	 * Enable or disable grouping View
	 */
	toggleGroup : function() {
		var store = this.grid.getStore();
		if (store.groupField === false) {
			store.groupBy("columnAlias");
			var indexColumnAlias = this.grid.getColumnModel()
					.findColumnIndex("columnAlias");
			this.grid.getColumnModel().setHidden(indexColumnAlias, true);
			this.grid.getView().enableGrouping = true;
			this.grid.getView().refresh();
		} else {
			store.clearGrouping();
			this.grid.getColumnModel().setHidden(0, false);
		}
	},
	/**
	 * Method called when trying to show this component with fixed navigation
	 * 
	 * @param {sitools.user.component.columnsDefinition}
	 *            me the semantic view
	 * @param {}
	 *            config config options
	 * @returns
	 */
	showMeInFixedNav : function(me, config) {
		Ext.apply(config.windowSettings, {
					width : 400,
					height : 400
				});
		SitoolsDesk.openModalWindow(me, config);
	}

});

Ext.reg('sitools.user.component.columnsDefinition',
		sitools.user.component.columnsDefinition);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * global Ext, sitools, showResponse, i18n, extColModelToJsonColModel, loadUrl,
 * alertFailure
 */

Ext.namespace('sitools.user.component');

// sitools.component.users.datasets.columnsDefinition = function (config) {
/**
 * A Panel that displays a grid with columns definition.
 * 
 * @cfg {string} datasetId The datasetId
 * @class sitools.user.component.DatasetOverview
 * @extends Ext.Panel
 */
sitools.user.component.DatasetOverview = function(config) {
	this.DEFAULT_HEIGHT = 600;
	this.DEFAULT_WIDTH = 800;
	this.DEFAULT_WIDTH_FORMS_PANEL = 400;
	this.DEFAULT_HEIGHT_SEMANTIC_PANEL = 200;
	this.DEFAULT_WIDTH_EAST_PANEL = 200;

	Ext.apply(this, config);

	this.formsTabPanel = new Ext.TabPanel({
				items : []
			});

	this.formsContainerPanel = new Ext.Panel({
				title : "forms",
				layout : "fit",
				region : "west",
				collapsible : true,
				split : true,
				// customFormWidth existe quand des préférences utilisateur sont
				// sauvegardés
				width : (this.customFormWidth)
						? this.customFormWidth
						: this.DEFAULT_WIDTH_FORMS_PANEL,
				items : [this.formsTabPanel]
			});

	this.semanticPanel = new Ext.Panel({
				title : i18n.get('label.semantic'),
				layout : "fit",
				region : "south",
				html : " ",
				collapsible : true,
				split : true,
				hidden : true,
				height : this.DEFAULT_HEIGHT_SEMANTIC_PANEL
			});

	this.descriptionPanel = new Ext.Panel({
				title : i18n.get('label.description'),
				autoScroll : true,
				layout : "fit",
				region : "center",
				html : " "
			});

	this.mainPanel = new Ext.Panel({
				layout : "fit",
				region : "center",
				border : false,
				items : [{
							layout : "border",
							items : [this.descriptionPanel, this.semanticPanel]
						}]
			});

	this.eastPanel = new Ext.Panel({
				layout : "fit",
				region : "east",
				hidden : true,
				collapsible : true,
				split : true,
				items : [],
				width : this.DEFAULT_WIDTH_EAST_PANEL
			});

	sitools.user.component.DatasetOverview.superclass.constructor.call(this, {
				layout : "border",
				items : [this.formsContainerPanel, this.mainPanel,
						this.eastPanel],
				listeners : {
					scope : this,
					beforerender : function() {
						this.loadDataset();
						return true;
					},
					datasetLoaded : function() {
						this.loadForms();
					},
					formsLoaded : function() {
						this.loadSemantic();
					},
					semanticLoaded : function() {
						this.loadDescription();
					},
					descriptionLoaded : function() {
						// this.unMask();
						return;
					}
				}
			});
};

Ext.extend(sitools.user.component.DatasetOverview, Ext.Panel, {
	componentType : "datasetOverview",
	_getSettings : function() {
		var colModel = {};
		var globalSettings = {};

		if (this.formsTabPanel.items.length > 0) {
			globalSettings.formsActivePanel = this.formsTabPanel.items
					.findIndex('id', this.formsTabPanel.activeTab.id);
			globalSettings.formsPanelWidth = this.formsTabPanel.getWidth();

			globalSettings = Ext.apply(globalSettings,
					this.formsTabPanel.activeTab._getSettings());
		} else if (this.dataview) {
			globalSettings = Ext.apply(globalSettings, this.dataview
							._getSettings());
		}

		return Ext.apply(globalSettings, {
			sitoolsAttachementForUsers : this.sitoolsAttachementForUsers,
			datasetUrl : this.sitoolsAttachementForUsers,
			datasetName : this.dataset.name,
			datasetId : this.dataset.id,
			// formsPanelWidth : 50,
			formsPanelCollapsed : true
				// formsActivePanel : 1
			});
	},
	loadDataset : function() {
		Ext.Ajax.request({
					method : "GET",
					scope : this,
					url : this.sitoolsAttachementForUsers,
					success : function(response) {
						var json = Ext.decode(response.responseText);
						if (!json.success) {
							Ext.Msg
									.alert(
											i18n.get('label.error'),
											i18n
													.get('warning.datasetRequestError'));
							return false;
						} else {
							this.dataset = json.dataset;
							this.fireEvent("datasetLoaded");
						}

					},
					failure : alertFailure
				});
	},
	loadForms : function() {
		Ext.Ajax.request({
			method : "GET",
			scope : this,
			url : this.dataset.sitoolsAttachementForUsers + '/forms',
			success : function(response) {
				var json = Ext.decode(response.responseText);
				var eventToFire = 'formsLoaded';

				if (!json.success) {
					Ext.Msg.alert(i18n.get('label.error'), i18n
									.get('warning.datasetRequestError'));
					return false;
				} else {
					this.forms = json.data;
					if (!Ext.isEmpty(this.forms)) {
						// If forms exist : fire loadSemantic event
						var eventToFire = 'semanticLoaded';
						var activeFormExists = false;
						Ext.each(this.forms, function(form) {
							if (form.id == this.formId) {
								activeFormExists = true;
							}
							var panel = new sitools.user.component.forms.mainContainer(
									{
										title : form.name,
										dataUrl : this.dataset.sitoolsAttachementForUsers,
										dataset : this.dataset,
										formId : form.id,
										id : form.id,
										formName : form.name,
										formParameters : form.parameters,
										formZones : form.zones,
										formWidth : form.width,
										formHeight : form.height,
										formCss : form.css,
										preferencesPath : "/"
												+ this.dataset.name + "/forms",
										preferencesFileName : form.name,
										searchAction : this.searchAction,
										scope : this
									});
							this.formsTabPanel.add(panel);
						}, this);
						this.formsTabPanel.doLayout();
						if (this.formId) {
							if (activeFormExists) {
								this.formsTabPanel.setActiveTab(this.formId);
							} else {
								Ext.Msg.show({
									buttons : Ext.MessageBox.OK,
									icon : Ext.MessageBox.INFO,
									modal : true,
									closable : false,
									title : i18n.get('label.info'),
									msg : i18n
											.get('label.cannotFindFormIdDisplayFirstOne')
								});
								this.formsTabPanel.setActiveTab(0);
							}
						} else {
							this.formsTabPanel.setActiveTab(0);
						}
					} else {
						this.semanticPanel.show();

						var jsObj = eval(this.dataset.datasetView.jsObject);
						var componentCfg = {
							dataUrl : this.dataset.sitoolsAttachementForUsers,
							datasetId : this.dataset.id,
							datasetCm : this.dataset.columnModel,
							datasetName : this.dataset.name,
							dictionaryMappings : this.dataset.dictionaryMappings,
							datasetViewConfig : this.dataset.datasetViewConfig,
							preferencesPath : "/" + this.dataset.name,
							preferencesFileName : "datasetView"
						};
						this.dataview = new jsObj(componentCfg);
						this.formsContainerPanel.removeAll();
						this.formsContainerPanel.hide();
						this.eastPanel.setVisible(true);
						this.eastPanel.add(this.mainPanel.items.items);

						this.mainPanel.removeAll();
						this.mainPanel.add(this.dataview);
						this.doLayout();

					}
					this.mainPanel.doLayout();
					this.fireEvent(eventToFire);
				}
			},
			failure : alertFailure
		});
	},
	loadSemantic : function() {
		var panel = new sitools.user.component.columnsDefinition({
					datasetId : this.dataset.id,
					datasetCm : this.dataset.columnModel,
					datasetName : this.dataset.name,
					dictionaryMappings : this.dataset.dictionaryMappings
				});
		this.semanticPanel.removeAll();
		this.semanticPanel.add(panel);
		this.semanticPanel.doLayout();
		this.fireEvent('semanticLoaded');
	},
	loadDescription : function() {
		var contentTarget = this.descriptionPanel.getContentTarget();
		if (!Ext.isEmpty(this.dataset.descriptionHTML)) {
			contentTarget.update(Ext.DomHelper
					.markup(this.dataset.descriptionHTML));
		}
		this.fireEvent("descriptionLoaded");
	},
	searchAction : function(formParams, dataset, scope) {
		var jsObj = eval(dataset.datasetView.jsObject);
		var componentCfg = {
			dataUrl : dataset.sitoolsAttachementForUsers,
			datasetId : dataset.id,
			datasetCm : dataset.columnModel,
			datasetName : dataset.name,
			formParams : formParams,
			dictionaryMappings : dataset.dictionaryMappings,
			datasetViewConfig : dataset.datasetViewConfig,
			preferencesPath : "/" + dataset.name,
			preferencesFileName : "datasetView",
			userPreference : {
				datasetName : this.dataset.name,
				colModel : extColModelToJsonColModel(this.dataset.columnModel),
				datasetView : "datasetOverview",
				datasetUrl : this.sitoolsAttachementForUsers,
				dictionaryMappings : this.dataset.dictionaryMappings
			}
		};
		scope.dataview = new jsObj(componentCfg);
		// scope.formsContainerPanel.collapse();
		// scope.semanticPanel.collapse();
		scope.mainPanel.removeAll();
		scope.mainPanel.add(scope.dataview);
		scope.doLayout();

	}
});

Ext.reg('sitools.user.component.DatasetOverview',
		sitools.user.component.DatasetOverview);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, alert, showResponse, alertFailure, SitoolsDesk, window, userLogin, loadUrl, DEFAULT_WIN_WIDTH, DEFAULT_WIN_HEIGHT */

Ext.namespace('sitools.user.component.entete.userProfile');

/**
 * @class sitools.user.component.entete.userProfile.tasksDetails
 * @extends Ext.FormPanel
 */
sitools.user.component.entete.userProfile.tasksDetails = Ext.extend(Ext.FormPanel, {

    
    labelWidth : 120,
    frame : true,
    autoScroll : true,
	initComponent : function () {
		//this.svaIntern = this.sva;
        
        var itemsForm = [];
        
        Ext.iterate(this.sva, function (key, value) {
            if (value != undefined && value != ""){
                itemsForm.push({
                    xtype : 'textfield',
                    name : key,
                    fieldLabel : i18n.get('label.' + key),
                    disabled : true,
                    disabledClass : 'x-item-disabled-custom',
                    labelStyle : 'font-weight:bold;',
                    anchor : '100%',
                    value : value                
                });
            }
        });
        
		this.items = itemsForm;
            
        sitools.user.component.entete.userProfile.tasksDetails.superclass.initComponent.call(this);

	},
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, userLogin, document, alertFailure, SitoolsDesk, userLogin, DEFAULT_ORDER_FOLDER, loadUrl, viewFileContent, Reference*/

Ext.namespace('sitools.user.component.entete.userProfile');

/**
 * @class sitools.user.component.entete.userProfile.diskSpace
 * @extends Ext.tree.TreePanel
 */
sitools.user.component.entete.userProfile.diskSpace = Ext.extend(Ext.tree.TreePanel, {
    autoScroll : true, 
    

    initComponent : function () {
        this.AppUserStorage = loadUrl.get('APP_USERSTORAGE_USER_URL').replace('{identifier}', userLogin) + "/files";

        
        this.tbar = new Ext.ux.StatusBar({
            statusAlign: 'right'              
        });
        
        this.buttons = [ {
                text : i18n.get('label.refreshResource'),
                scope : this,
                handler : this._onRefresh
            }, {
                text : i18n.get('label.deleteResource'),
                scope : this,
                handler : this._onDelete
            }, {
                text : i18n.get('label.close'),
                scope : this,
                handler : function () {
                    this.ownerCt.destroy();
                }
            } ];

        sitools.user.component.entete.userProfile.diskSpace.superclass.initComponent.call(Ext.apply(this, {
            expanded : true,
            useArrows : true,
            autoScroll : true,
            layout : 'fit', 
            animate : true,
            enableDD : false,
            containerScroll : true,
            //frame : true,
            loader : new Ext.tree.TreeLoader(),
            rootVisible : true,
            root : {
                text : userLogin,
                children : [],
                nodeType : 'async',
                url : loadUrl.get('APP_URL') + this.AppUserStorage + "/"
            },

            // auto create TreeLoader
            listeners : {
                scope : this,
                beforeload : function (node) {
                    return node.isRoot || Ext.isDefined(node.attributes.children);
                },
                beforeexpandnode : function (node) {
                    node.removeAll();
                    var reference = new Reference(node.attributes.url);
                    var url = reference.getFile();
                    Ext.Ajax.request({
                        url : url,
                        method : 'GET',
                        scope : this,
                        success : function (ret) {
                            try {
                                var Json = Ext.decode(ret.responseText);
                                Ext.each(Json, function (child) {
                                    var text = child.text;
                                    if (child.leaf) {
                                        text += "<span style='font-style:italic'> (" + Ext.util.Format.fileSize(child.size) + ")</span>";
                                    }
                                    var reference = new Reference(child.url);
                                    var url = reference.getFile();
                                    node.appendChild({
                                        cls : child.cls,
                                        text : decodeURIComponent(text),
                                        url : url,
                                        leaf : child.leaf,
                                        children : [],
                                        checked : child.checked
                                    });
                                });
                                return true;
                            } catch (err) {
                                Ext.Msg.alert(i18n.get('warning'), err);
                                return false;
                            }
                        },
                        failure : function (ret) {
                            return null;
                        }
                    });
                    return true;
                }, 
                click : function (n) {
                    if (n.attributes.leaf) {
                        var url = n.attributes.url;
                        viewFileContent(url, n.attributes.text);
                    }
                }
            }
        }));

    },
    onRender : function () {
        sitools.user.component.entete.userProfile.diskSpace.superclass.onRender.apply(this, arguments);
        this.setUserStorageSize();
    },
    
    setUserStorageSize : function () {
        Ext.Ajax.request({
            method : "GET",
            scope : this,
            url : loadUrl.get('APP_URL') + loadUrl.get('APP_USERSTORAGE_USER_URL').replace("{identifier}", userLogin) + "/status", 
            success : function (ret) {
                var json = Ext.decode(ret.responseText);
                if (!json.success) {
                    return;
                }
                var storage = json.userstorage.storage;
                var totalSpace = storage.quota;
                var usedSpace = storage.busyUserSpace;
                var pourcentage = usedSpace / totalSpace * 100;
                var cls = null; 
                
                if (pourcentage >= 90 && pourcentage < 100) {
                    cls = "x-status-warning";
                }
                else if (pourcentage > 100) {
                    cls = "x-status-error";
                }
                var str = String.format(i18n.get('label.diskSpaceLong'), Ext.util.Format.round(pourcentage, 0), Ext.util.Format.fileSize(totalSpace));
                
                this.getTopToolbar().setText(str);
                this.getTopToolbar().setIcon(cls);
                this.doLayout();
            }
        });
    },
    
    _onRefresh : function () {
        this.getRootNode().collapse();
        this.setUserStorageSize();
        // this.treePanel.getLoader().load(this.treePanel.getRootNode());
    },

    _onDelete : function () {
        var selNodes = this.getChecked();
        if (selNodes.length === 0) {
            return;
        }

        Ext.each(selNodes, function (node) {
            Ext.Ajax.request({
                method : 'DELETE',
                url : node.attributes.url + "?recursive=true",                
                scope : this,
                success : function (response, opts) {
                    var notify = new Ext.ux.Notification({
                        iconCls : 'x-icon-information',
                        title : i18n.get('label.information'),
                        html : i18n.get('label.resourceDeleted'),
                        autoDestroy : true,
                        hideDelay : 1000
                    });
                    notify.show(document);
                    node.destroy();
                },
                failure : alertFailure
            }, this);
        });
    }

});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, alert, showResponse, alertFailure, SitoolsDesk, window, userLogin, loadUrl*/

Ext.namespace('sitools.user.component.entete.userProfile');

sitools.user.component.entete.userProfile.tasks = Ext.extend(Ext.grid.GridPanel, {
    border : false,
    sm : new Ext.grid.RowSelectionModel(),
    layout : {
        type : 'vbox',
        // flex : 1,
        align : 'stretch'
    },
    height : 430,
    pageSize : 10,
    // loadMask: true,

    initComponent : function () {
        this.url = loadUrl.get('APP_URL') + loadUrl.get('APP_USERRESOURCE_ROOT_URL') + '/' + userLogin + '/tasks';
        this.store = new Ext.data.JsonStore({
            root : 'data',
            restful : true,
            url : this.url,
            remoteSort : true,
            idProperty : 'id',
            fields : [ {
                name : 'id',
                type : 'string'
            }, {
                name : 'status',
                type : 'string'
            }, {
                name : 'modelId',
                type : 'string'
            }, {
                name : 'customStatus',
                type : 'string'
            }, {
                name : 'timestamp',
                type : 'string'
            }, {
                name : 'statusUrl',
                type : 'string'
            }, {
                name : 'urlResult',
                type : 'string'
            }, {
                name : 'userId',
                type : 'string'
            }, {
                name : 'startDate',
                type : 'string'
            }, {
                name : 'endDate',
                type : 'string'
            }, {
                name : 'runType',
                type : 'string'
            }, {
                name : 'modelName',
                type : 'string'
            }]

        });

        this.cm = new Ext.grid.ColumnModel({
            // specify any defaults for each column
            defaults : {
                sortable : true
            },
            columns : [ {
                header : i18n.get('label.taskId'),
                dataIndex : 'id',
                width : 220,
                hidden : true
            }, {
                header : i18n.get('label.startDate'),
                dataIndex : 'startDate',
                width : 170
            }, {
                header : i18n.get('label.endDate'),
                dataIndex : 'endDate',
                width : 170
            },  {
                header : i18n.get('label.status'),
                dataIndex : 'status',
                width : 180
            }, {
                header : i18n.get('label.customStatus'),
                dataIndex : 'customStatus',
                width : 100
            } ]
        });

        this.bbar = {
            xtype : 'paging',
            pageSize : this.pageSize,
            store : this.store,
            displayInfo : true,
            displayMsg : i18n.get('paging.display'),
            emptyMsg : i18n.get('paging.empty')
        };

        this.tbar = {
            xtype : 'toolbar',
            cls : 'services-toolbar',
            defaults : {
                scope : this,
                cls : 'services-toolbar-btn'
            },
            items : [ {
                text : i18n.get('label.delete'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/toolbar_delete.png',
                handler : this._onDelete,
                xtype : 's-menuButton'
            }, {
                text : i18n.get('label.clean'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/toolbar_clean.png',
                handler : this._onClean,
                xtype : 's-menuButton'
            }, {
                text : i18n.get('label.viewResult'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/view_result.png',
                handler : this._onViewResult,
                xtype : 's-menuButton'
            }, {
                text : i18n.get('label.viewStatusDetails'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/toolbar_details.png',
                handler : this._onViewStatusDetails,
                xtype : 's-menuButton'
            }, {
                text : i18n.get('label.setFinish'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/set_finish.png',
                handler : this._onFinish,
                xtype : 's-menuButton'
            } ]
        };

        sitools.user.component.entete.userProfile.tasks.superclass.initComponent.call(Ext.apply(this, {
			viewConfig : {
				forceFit : true
			}
        }));
    },

    onRender : function () {
        sitools.user.component.entete.userProfile.tasks.superclass.onRender.apply(this, arguments);
        this.store.load({
            params : {
                start : 0,
                limit : this.pageSize
            }
        });

    },

    _onDelete : function () {
        var rec = this.getSelectionModel().getSelected();
        if (!rec) {
            return false;
        }
        var tot = Ext.Msg.show({
            title : i18n.get('label.delete'),
            buttons : {
                yes : i18n.get('label.yes'),
                no : i18n.get('label.no')
            },
            msg : i18n.get('tasks.delete'),
            scope : this,
            fn : function (btn, text) {
                if (btn == 'yes') {
                    this.doDelete(rec);
                }
            }

        });

    },
    doDelete : function (rec) {
        // var rec = this.getSelectionModel().getSelected();
        // if (!rec) return false;
        Ext.Ajax.request({
            url : this.url + "/" + rec.data.id,
            method : 'DELETE',
            scope : this,
            success : function (ret) {
                if (showResponse(ret)) {
                    this.store.reload();
                }
            },
            failure : alertFailure
        });
    },
    _onViewResult : function () {
        var rec = this.getSelectionModel().getSelected();
        if (!rec) {
            return false;
        }
        if (!Ext.isEmpty(rec.data.urlResult)) {
            var orderUrl = loadUrl.get('APP_URL') + loadUrl.get('APP_ORDERS_USER_URL');
            if (rec.data.urlResult.indexOf(orderUrl) != -1) {
                this._showOrderDetails(rec.data.urlResult);
            } else {
                var pathUrl = window.location.protocol + "//" + window.location.host;
                if (rec.data.urlResult.indexOf("http://") != -1) {
					window.open(rec.data.urlResult);
				} else {
					window.open(pathUrl + rec.data.urlResult);
				}
                
            }
        }
    },
    _onFinish : function () {
        var rec = this.getSelectionModel().getSelected();
        if (!rec) {
            return false;
        }
        Ext.Ajax.request({
            url : this.url + "/" + rec.data.id + "?action=finish",
            method : 'PUT',
            scope : this,
            success : function (ret) {
                if (showResponse(ret)) {
                    this.store.reload();
                }
            },
            failure : alertFailure
        });
    },

    _onClean : function () {
        var tot = Ext.Msg.show({
            title : i18n.get('label.delete'),
            buttons : {
                yes : i18n.get('label.yes'),
                no : i18n.get('label.no')
            },
            msg : i18n.get('tasks.delete.all'),
            scope : this,
            fn : function (btn, text) {
                if (btn == 'yes') {
                    this._doClean();
                }
            }
        });
    },

    _doClean : function () {
        Ext.Ajax.request({
            url : this.url,
            method : 'DELETE',
            scope : this,
            success : function (ret) {
                if (showResponse(ret)) {
                    this.store.reload();
                }
            },
            failure : alertFailure
        });
    },
    
    _onViewStatusDetails : function () {
        
        var rec = this.getSelectionModel().getSelected();
        if (!rec) {
            return Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.noselection'));
        }
        
        var jsObj = sitools.user.component.entete.userProfile.tasksDetails;
        var componentCfg = {
            sva : rec.data    
        };
        var windowConfig = {
            id : "taskStatusDetails", 
            title : i18n.get("label.taskDetails") + ":" + rec.data.id, 
            iconCls : "dataDetail"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);        
        
    },
    _showOrderDetails : function (url) {
        Ext.Ajax.request({
            url : url,
            method : 'GET',
            scope : this,
            success : function (ret) {
                var data = Ext.decode(ret.responseText);
                if (!data.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), data.message);
                    return false;
                }
                var rec = new Ext.data.Record(data.order);
                var jsObj = sitools.user.component.entete.userProfile.orderProp;
                var componentCfg = {
                    action : 'detail',
                    orderRec : rec
                };
                var title = i18n.get('label.details') + " : ";
                title += rec.data.userId;
                title += " " + i18n.get('label.the');
                title += " " + rec.data.dateOrder;

                var windowConfig = {
                    id : "showDataDetailId", 
                    title : title,  
                    specificType : "dataDetail", 
                    iconCls : "dataDetail"
                };
                SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
            },
            failure : alertFailure
        });
        
    }

});
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global Ext, sitools, i18n, SitoolsDesk, alertFailure, window, loadUrl, DEFAULT_WIN_WIDTH, DEFAULT_WIN_HEIGHT */

Ext.namespace('sitools.user.component.entete.viewTextPanel');

/**
 * A simple panel that displays text
 * 
 * @cfg {String} text The text to display 
 * @cfg {Boolean} formatJson true to format the text as json, false otherwise
 * @class sitools.user.component.entete.userProfile.viewTextPanel
 * @extends Ext.Panel
 */
sitools.user.component.entete.userProfile.viewTextPanel = Ext.extend(Ext.Panel, {
    layout : 'fit', 
    autoScroll : true,
    initComponent : function () {
        if (this.formatJson) {
            try {
                if (Ext.isFunction(JSON.parse) && Ext.isFunction(JSON.stringify)) {
                    var obj = JSON.parse(this.text);
                    this.html = JSON.stringify(obj, null, 4);
                    this.style = "white-space: pre";
                }
            } catch (err) {
                this.html = this.text;
            }
        }
        else {
            if (this.isOpenable(this.url)) {
                this.items = [{
                    xtype : 'textarea',
                    readOnly : true,
                    value : this.text
                    
                }];
            } else {
                this.html = this.text;            
            }
            
        }
        
        sitools.user.component.entete.userProfile.viewTextPanel.superclass.initComponent.call(this);
    },
    
    isOpenable : function (text) {
        var textRegex = /\.(txt|json|css|xml)$/;
        return text.match(textRegex);            
    },

    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, alert, showResponse, alertFailure, SitoolsDesk, loadUrl*/

Ext.namespace('sitools.user.component.entete.userProfile');

sitools.user.component.entete.userProfile.viewOrderPanel = Ext.extend(Ext.grid.GridPanel, {
    border : false,
    sm : new Ext.grid.RowSelectionModel(),

    layout : {
        type : 'vbox',
        // flex : 1,
        align : 'stretch'
    },
    height : 430,
    pageSize : 10,
    // loadMask: true,

    initComponent : function () {
    	
    	this.viewConfig = {
            autoFill : true,
            forceFit : true,
            listeners : {
                scope : this,
                refresh : function (view) {
                    this.getEl().unmask();
                }
            }
        };
    	
        this.url = loadUrl.get('APP_URL') + loadUrl.get('APP_ORDERS_USER_URL');
        this.store = new Ext.data.JsonStore({
            root : 'data',
            restful : true,
            url : this.url,
            remoteSort : true,
            idProperty : 'id',
            fields : [ {
                name : 'id',
                type : 'string'
            }, {
                name : 'userId',
                type : 'string'
            }, {
                name : 'description',
                type : 'string'
            }, {
                name : 'resourceCollection'
            }, {
                name : 'resourceDescriptor',
                type : 'string'
            }, {
                name : 'status',
                type : 'string'
            }, {
                name : 'dateOrder',
                type : 'string'
            }, {
                name : 'events'
            } ]

        });

        this.cm = new Ext.grid.ColumnModel({
            // specify any defaults for each column
            defaults : {
                sortable : true
            // columns are not sortable by default
            },
            columns : [ {
                header : i18n.get('label.orderNumber'),
                dataIndex : 'id',
                width : 200
            }, {
                header : i18n.get('label.orderDate'),
                dataIndex : 'dateOrder',
                width : 200
            }, {
                header : i18n.get('label.status'),
                dataIndex : 'status',
                width : 80
            } ]
        });

        this.bbar = {
            xtype : 'paging',
            pageSize : this.pageSize,
            store : this.store,
            displayInfo : true,
            displayMsg : i18n.get('paging.display'),
            emptyMsg : i18n.get('paging.empty')
        };

        this.tbar = {
            xtype : 'toolbar',
            cls : 'services-toolbar',
            defaults : {
                scope : this,
                cls : 'services-toolbar-btn'
            },
            items : [ {
                text : i18n.get('label.details'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : '/sitools/common/res/images/icons/toolbar_details.png',
                handler : this._onDetail,
                xtype : 's-menuButton'
            }, {
                text : i18n.get('label.delete'),
                // icon: 'res/images/icons/toolbar_project_add.png',
                icon : loadUrl.get('APP_URL') + '/common/res/images/icons/toolbar_delete.png',
                handler : this._onDelete,
                xtype : 's-menuButton'
            } ]
        };

        sitools.user.component.entete.userProfile.viewOrderPanel.superclass.initComponent.call(this);
    },

    onRender : function () {
        sitools.user.component.entete.userProfile.viewOrderPanel.superclass.onRender.apply(this, arguments);
        this.store.load({
            params : {
                start : 0,
                limit : this.pageSize
            }
        });

    },

    _onDetail : function () {
        var rec = this.getSelectionModel().getSelected();
        if (!rec) {
            return Ext.Msg.alert(i18n.get('label.warning'), i18n.get('warning.noselection'));
        }
        var jsObj = sitools.user.component.entete.userProfile.orderProp;
        var componentCfg = {
            // url:this.url,
            action : 'detail',
            // store: this.getStore(),
            orderRec : rec
        };
        var title = i18n.get('label.details') + " : ";
        title += rec.data.userId;
        title += " " + i18n.get('label.the');
        title += " " + rec.data.dateOrder;

        var windowConfig = {
            id : "showDataDetailId", 
            title : title,
            iconCls : "orders",
//            size : {
//                width : 700,
//                height : 480
//            },
            specificType : "dataDetail"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
    },

    _onDelete : function () {
        var rec = this.getSelectionModel().getSelected();
        if (!rec) {
            return false;
        }
        var tot = Ext.Msg.show({
            title : i18n.get('label.delete'),
            buttons : {
                yes : i18n.get('label.yes'),
                no : i18n.get('label.no')
            },
            msg : i18n.get('orderCrud.delete'),
            scope : this,
            fn : function (btn, text) {
                if (btn == 'yes') {
                    this.doDelete(rec);
                }
            }

        });

    },
    doDelete : function (rec) {
        // var rec = this.getSelectionModel().getSelected();
        // if (!rec) return false;
        Ext.Ajax.request({
            url : this.url + "/" + rec.id,
            method : 'DELETE',
            scope : this,
            success : function (ret) {
                if (showResponse(ret)) {
                    this.store.reload();
                }
            },
            failure : alertFailure
        });
    }

});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, userLogin, DEFAULT_ORDER_FOLDER, SitoolsDesk, projectGlobal, DEFAULT_PREFERENCES_FOLDER, loadUrl, viewFileContent*/

Ext.namespace('sitools.user.component.entete.userProfile');

sitools.user.component.entete.userProfile.orderProp = Ext.extend(Ext.Panel, {
    pageSize : 10,
    dataSets : "",
    autoScroll : true, 
	layout : 'fit',
	
    initComponent : function () {
        var eventsStore = new Ext.data.JsonStore({
            fields : [ {
                name : 'eventDate',
                type : 'string'
            }, {
                name : 'description',
                type : 'string'
            }, {
                name : 'message',
                type : 'string'
            } ],
            data : this.orderRec.data.events
        });

        var eventsCm = new Ext.grid.ColumnModel({
            columns : [ {
                header : i18n.get("headers.date"),
                dataIndex : 'eventDate',
                width : 150
            },
            // {header : i18n.get("headers.order"), dataIndex: 'order', width :
            // 100},
            {
                header : i18n.get("headers.description"),
                dataIndex : 'description',
                width : 250
            }, {
                header : i18n.get("headers.message"),
                dataIndex : 'message',
                width : 150
            } ]
        });
        var eventsGrid = new Ext.grid.GridPanel({
            layout : 'fit', 
            flex : 0.5, 
            title : i18n.get('label.events'),
            store : eventsStore,
            cm : eventsCm,
            rowSelectionModel : new Ext.grid.RowSelectionModel(),
            autoScroll : true,
            collapsible : false, 
            viewConfig : {
				forceFit : true
            }
            
        });

        var resourceCollectionStore = new Ext.data.JsonStore({
            fields : [ {
                name : 'resourceCollection',
                type : 'string'
            } ]
        });
        if (!Ext.isEmpty(this.orderRec.data.resourceCollection)) {
            Ext.each(this.orderRec.data.resourceCollection, function (resource) {
                var rec = new resourceCollectionStore.recordType({
                    resourceCollection : resource
                });
                resourceCollectionStore.add(rec);
            });
        }

        var resourceCollectionCm = new Ext.grid.ColumnModel({
            columns : [ {
                header : i18n.get("headers.resource"),
                dataIndex : 'resourceCollection',
                width : 500
            } ]
        });
        var resourceCollectionGrid = new Ext.grid.GridPanel({
            layout : 'fit', 
            flex : 0.5, 
            title : i18n.get('label.resourceCollection'),
            store : resourceCollectionStore,
            cm : resourceCollectionCm,
            rowSelectionModel : new Ext.grid.RowSelectionModel(),
            autoScroll : true, 
            viewConfig : {
				forceFit : true
            }, 
            collapsible : false, 
            listeners : {
                scope : this, 
                rowclick : function (grid, rowIndex) {
                    var rec = grid.getStore().getAt(rowIndex);
                    if (Ext.isEmpty(rec)) {
                        Ext.Msg.alert(i18n.get('label.warning'), i18n.get('label.noSelection'));
                        return;
                    }
                    var tabTmp = rec.data.resourceCollection.split('/');
                    var nomFichier = tabTmp[tabTmp.length - 1];
                    tabTmp = nomFichier.split('.');
                    var extension = tabTmp[tabTmp.length - 1];
                    
                    
                    if (extension != "json") {
                        var url = rec.data.resourceCollection;
                        viewFileContent(url, nomFichier);
                    } else {
                        Ext.Ajax.request({
                            url : rec.data.resourceCollection,
                            method : 'GET',
                            scope : this,
                            success : function (ret) {
                                var Json;
                                if (extension == "json") {
                                    //If it is a Json file, try to decode it and use it into a specific grid
                                    try {
                                        Json = Ext.decode(ret.responseText);
                                        if (!Ext.isEmpty(Json.orderRequest)) {
                                            this.orderRequest(Json.orderRequest, nomFichier);
                                        }
                                        else if (!Ext.isEmpty(Json.orderRecord)) {
                                            this.orderRecord(Json.orderRecord, nomFichier);
                                        }
                                        else {
                                            var windowConfig = {
                                                id : "winPreferenceDetailId", 
                                                title : nomFichier
                                            };
                                            var jsObj = Ext.Panel;
                                            var componentCfg = {
                                                layout : 'fit', 
                                                autoScroll : true, 
                                                html : ret.responseText
                                            };
                                            SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
                                        }
                                    } catch (err) {
                                        Ext.Msg.alert(err);
                                    }
                                }                            
                            },
                            failure : function (ret) {
                                Ext.Msg.alert(i18n.get('label.error'), ret.responseText);
                            }
                        });
                    }
                }
            }
        });

        this.items = [ {
            xtype : 'panel',
            layout : 'vbox', 
            layoutConfig : {
				align : 'stretch', 
				flex : 'ratio'
            }, 
            items : [ {
                xtype : 'form',
                border : false,
                padding : 10,
                items : [ {
                    xtype : 'hidden',
                    name : 'orderId',
                    id : 'userValueFieldId'
                }, {
                    xtype : 'textfield',
                    name : 'userId',
                    fieldLabel : i18n.get('label.userLogin'),
                    anchor : '100%',
                    maxLength : 100,
                    readOnly : true
                }, {
                    xtype : 'textfield',
                    name : 'description',
                    fieldLabel : i18n.get('label.description'),
                    anchor : '100%',
                    maxLength : 100,
                    readOnly : true
                }, {
                    xtype : 'textfield',
                    name : 'resourceDescriptor',
                    fieldLabel : i18n.get('label.url'),
                    anchor : '100%',
                    maxLength : 30,
                    readOnly : true
                }, {
                    xtype : 'textfield',
                    name : 'dateOrder',
                    fieldLabel : i18n.get('label.dateOrder'),
                    anchor : '100%',
                    maxLength : 100,
                    readOnly : true
                } ]
            }, resourceCollectionGrid, eventsGrid ],
            buttons : [ {
                text : i18n.get('label.close'),
                scope : this,
                handler : function () {
                    this.ownerCt.close();
                }
            } ]

        } ];
        sitools.user.component.entete.userProfile.orderProp.superclass.initComponent.call(this);
    },

    onRender : function () {
        sitools.user.component.entete.userProfile.orderProp.superclass.onRender.apply(this, arguments);
        var f = this.findByType('form')[0].getForm();
        f.loadRecord(this.orderRec);
    }, 
    orderRequest : function (orderRequest, nomFichier) {
        Ext.Ajax.request({
            scope : this,
            method : 'GET',
            url : orderRequest.datasetUrl,
            success : function (response, opts) {
                try {
                    var json = Ext.decode(response.responseText);
                    if (!json.success) {
                        throw (json.message);
                    }

                    var componentCfg = {
                        dataUrl : json.dataset.sitoolsAttachementForUsers,
                        datasetId : orderRequest.datasetId,
                        datasetCm : Ext.decode(orderRequest.colModel),
                        filters : orderRequest.filters, 
						dictionaryMappings : json.dataset.dictionaryMappings, 
	                    datasetViewConfig : json.dataset.datasetViewConfig, 
	                    preferencesPath : "/" + json.dataset.name, 
	                    preferencesFileName : "datasetView"
                    // ,
                    // sorters : orderRequest.sort.sorters
                    };
                    if (!Ext.isEmpty(orderRequest.formParams)) {
                        componentCfg.formParams = orderRequest.formParams;
                    }

                    var jsObj = eval(json.dataset.datasetView.jsObject);
                    
                    var windowConfig = {
                        id : "winOrderId" + json.dataset.id, 
                        title : nomFichier, 
                        datasetName : json.dataset.name, 
                        saveToolbar : true, 
                        type : "data"
                    };
                    SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);

                } catch (err) {
                    Ext.Msg.alert(i18n.get('label.error'), err);
                }
            },
            failure : function (response, opts) {
                Ext.Msg.alert(response);
            }
        });
    },
    orderRecord : function (orderRecord, nomFichier) {
        var winOrderDetail = new sitools.user.component.entete.userProfile.viewRecordSelectionDetail({
            orderRecord : orderRecord,
            nomFichier : nomFichier
        });
        winOrderDetail.show();
    }

});

Ext.reg('s-orderprop', sitools.user.component.entete.userProfile.orderProp);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global Ext, sitools, i18n, loadUrl */

Ext.namespace('sitools.user.component');
/**
 * Help Component
 * @class sitools.user.component.help
 * @extends Ext.Panel
 */
sitools.user.component.help = Ext.extend(Ext.Panel, {
    /**
	 * the node to activate
	 * @type Ext.tree.TreeNode
	 */
    activeNode : null,
    initComponent : function () {
//        this.url = loadUrl.get('APP_URL') + "/client-user/res/help/fr/Client-userUG.html";
        this.url = loadUrl.get('APP_URL') + "/client-user/res/help/fr/User_Guide.html";
        this.layout = "border";
        var htmlReaderCfg = {
            defaults : {
                padding : 10
            },
            layout : 'fit',
            region : 'center'
        };

        if (!Ext.isEmpty(this.cfgCmp) && !Ext.isEmpty(this.cfgCmp.activeNode)) {
            this.activeNode = this.cfgCmp.activeNode;
        } else {
            htmlReaderCfg.defaultSrc = this.url;
        }

        this.tree = new Ext.tree.TreePanel({
            region : 'west',
            animate : true,
            width : 200,
            rootVisible : false,
            useArrows : true,
            autoScroll : true,
            split : true,
            collapsible : true,
            collapsed : false,
            title : "menu",
            root : {
                nodeType : 'async',
                text : "rootHelp"
            },
            loader : new Ext.tree.TreeLoader({
                requestMethod : 'GET',
                url : loadUrl.get('APP_URL') + "/client-user/tmp/help.json",
                listeners : {
                    scope : this,
                    load : function () {
                        if (!Ext.isEmpty(this.activeNode)) {
                            var node = this.tree.getNodeById(this.activeNode);
                            if (!Ext.isEmpty(node)) {
                                this.tree.selectPath(node.getPath());
                                this.treeAction(node);
                            } else {
                                Ext.Msg.alert(i18n.get('label.warning'), i18n.get('msg.nodeundefined'));
                            }
                        }
                    }
                }
            }),
            listeners : {
                scope : this,
                click : function (node, e) {
                    this.treeAction(node);
                }
            }

        });

        this.htmlReader = new Ext.ux.ManagedIFrame.Panel(htmlReaderCfg);

        this.items = [ this.tree, this.htmlReader ];
        
        this.tbar = {
                xtype : 'toolbar',
                cls : 'services-toolbar',
                height : 15,
                defaults : {
                    scope : this,
                    cls : 'services-toolbar-btn'
                },
                items : [ ]
            };

        // tree.getRootNode().expand(true);
        sitools.user.component.help.superclass.initComponent.call(this);
    },

    onRender : function () {
        sitools.user.component.help.superclass.onRender.apply(this, arguments);
        this.tree.getRootNode().expand(true);

    },

    /**
     * Action executed ; 'this' refers to this component
     * 
     * @param node
     * @returns
     */
    treeAction : function (node) {
        // Getting node urlArticle
        var nodeAnchor = node.attributes.nodeAnchor;

        if (!Ext.isDefined(nodeAnchor)) {
            Ext.Msg.alert(i18n.get('label.warning'), i18n.get('msg.nodeundefined'));
            return;
        }
        this.htmlReader.setSrc(this.url + "#" + nodeAnchor);
    }

});

Ext.reg('sitools.user.component.help', sitools.user.component.help);


/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, showResponse, i18n, SitoolsDesk, extColModelToJsonColModel, loadUrl, projectGlobal*/

Ext.namespace('sitools.user.component.entete');

/**
 * Populate the div x-headers of the sitools Desktop. 
 * @cfg {String} htmlContent html content of the headers, 
 * @cfg {Array} modules the modules list
 * @class sitools.user.component.entete.Entete
 * @extends Ext.Panel
 */
sitools.user.component.entete.Entete = Ext.extend(Ext.Panel, {
    heightNormalMode : 0, 
    heightMaximizeDesktopMode : 0, 
	
	initComponent : function () {

		this.navBarModule = new sitools.user.component.entete.NavBar({
			modules : this.modules, 
			observer : this
		});
		
		this.navToolbarButtons = new sitools.user.component.entete.NavBarButtons({
            observer : this,
            width: '162px' // width without save button
        });

		this.NavBarsPanel = new Ext.Panel({
		    border : false, 
		    layout : 'hbox',
		    height : 35,
		    listeners : {
                scope : this, 
                maximizeDesktop : this.onMaximizeDesktopNavbar, 
                minimizeDesktop : this.onMinimizeDesktopNavbar 
            },
		    items : [ this.navBarModule, this.navToolbarButtons ]
		});

		this.entetePanel = new Ext.Panel({
			html : this.htmlContent, 
			border : false, 
			layout : "fit",
			flex : 1, 
			listeners : {
				scope : this, 
				desktopReady : this.showUserContainer
			}
		});
		
		sitools.user.component.entete.Entete.superclass.initComponent.call(Ext.apply(this,  {
			items : [this.entetePanel, this.NavBarsPanel], 
			border : false, 
			layout : "vbox", 
			layoutConfig : {
				align : "stretch"
			}, 
			listeners : {
				scope : this, 
				afterRender : function (me) {
					var enteteEl = SitoolsDesk.getEnteteEl();
					me.setHeight(enteteEl.getHeight());
					me.doLayout();
					
					me.heightNormalMode = enteteEl.getHeight();
					me.heightMaximizeDesktopMode = this.NavBarsPanel.getHeight();
				}, 
				
				maximizeDesktop : this.onMaximizeDesktop, 
				minimizeDesktop : this.onMinimizeDesktop, 
//				navBarRendered : function (navBar) {
//					this.entetePanel.fireEvent("navBarRendered", navBar);
//				}, 
				windowResize : function (me) {
				    if (!Ext.isEmpty(this.userContainer) && this.userContainer.isVisible()) {
				        this.userContainer.hide();
				    }
				}, 
				desktopReady : function (me) {
					this.entetePanel.fireEvent("desktopReady", this.navToolbarButtons);
				}
			}
		}));
	}, 
	/**
	 * listeners of maximizeDesktop event : 
	 */
	onMaximizeDesktop : function () {
		this.entetePanel.hide();
		this.container.setHeight(this.heightMaximizeDesktopMode);
		this.setHeight(this.heightMaximizeDesktopMode);
		this.NavBarsPanel.fireEvent("maximizeDesktop");
//		this.userContainer.setVisible(! SitoolsDesk.desktopMaximizeMode);
		if (this.userContainer) {
			this.userContainer.fireEvent("maximizeDesktop", this.userContainer, this.navToolbarButtons);
			this.userContainer = null;
		}
		this.doLayout();
	}, 
	/**
	 * listeners of minimizeDesktop event : 
	 */
	onMinimizeDesktop : function () {
		this.entetePanel.setVisible(true);
		this.container.dom.style.height = "";
		this.setHeight(this.heightNormalMode);
		this.NavBarsPanel.fireEvent("minimizeDesktop");
//		this.userContainer.setVisible(! SitoolsDesk.desktopMaximizeMode);
		if (this.userContainer) {
			this.userContainer.fireEvent("minimizeDesktop", this.userContainer, this.navToolbarButtons);
			this.userContainer = null;
		}
		this.doLayout();
		
	}, 
	
	showUserContainer : function (navBar) {
		var tpl, textToDisplay = i18n.get("label.welcome"), userContainerHeight, userContainerWidth;
		if (projectGlobal.user) {
			textToDisplay += " " + projectGlobal.user.firstName + " " + projectGlobal.user.lastName;
			userContainerHeight = 30;
			userContainerWidth = 250;
		}
		else {
			textToDisplay += " " + i18n.get('label.guest') + "<br>" + i18n.get("label.clickToConnect");
			userContainerHeight = 50;
			userContainerWidth = 250;
		}
		
		if (SitoolsDesk.desktopMaximizeMode) {
			tpl = new Ext.XTemplate("<div style='left:{width - 60}px;' class='sitools-userContainer-arrow-border-up'></div>", 
				"<div style='left:{width - 60}px;' class='sitools-userContainer-arrow-up'></div>", 
				"<div><img class='sitools-userContainer-icon' src='/sitools/cots/extjs/resources/images/default/window/icon-info.gif'>{text}</div>");
		}
		else {
			tpl = new Ext.XTemplate("<div><img class='sitools-userContainer-icon' src='/sitools/cots/extjs/resources/images/default/window/icon-info.gif'>{text}</div>", 
					"<div style='left:{width - 60}px;' class='sitools-userContainer-arrow-border-down'></div>", 
					"<div style='left:{width - 60}px;' class='sitools-userContainer-arrow-down'></div>");
		}
		this.userContainer = new Ext.BoxComponent({
			data : {
				text : textToDisplay, 
				height : userContainerHeight, 
				width : userContainerWidth
			}, 
			cls : "sitools-userContainer", 
			width : userContainerWidth, 
			height : userContainerHeight, 
			renderTo : SitoolsDesk.getEnteteEl(), 
			tpl : tpl, 
			listeners : {
				scope : this, 
				afterRender : function (me) {
					var el = Ext.get(me.id);
					el.on("click", function (e, t, o) {
							this.getEl().fadeOut({
							    easing: 'easeOut',
							    duration: 1,
							    endOpacity : 0,
							    useDisplay: false
							});
					    }, me);
				}, 
				maximizeDesktop : function (me, navBar) {
//					me.setPosition(me.getPosition()[0], this.calcUserContainerYPos(navBar));
					if (me.isVisible()) {
					    me.setVisible(false);
						me.destroy();
//						this.showUserContainer(navBar);
					}
				}, 
				minimizeDesktop : function (me, navBar) {
					if (me.isVisible()) {
					    me.setVisible(false);
						me.destroy();
//						this.showUserContainer(navBar);
					}
				}
			}
		});
		
		var enteteEl = SitoolsDesk.getEnteteEl();
		var userContEl = this.userContainer.getEl();
		var x, y;
		x = Ext.getBody().getWidth() - this.userContainer.getWidth();
		
		y = this.calcUserContainerYPos(navBar);
		
		this.userContainer.setPosition([x, y]);
		userContEl.highlight("948B8B", { 
			attr: 'background-color', 
			duration: 1
		});
		userContEl.fadeOut({
		    easing: 'easeOut',
		    duration: 1,
		    endOpacity : 0,
		    useDisplay: false
		});
//		this.userContainer.setVisible(! SitoolsDesk.desktopMaximizeMode);
	}, 
	/**
	 * Calculates the y position of the userContainer.
	 * @param navBar (the navBar component
	 * @returns {integer} the yPosition
	 */
	calcUserContainerYPos : function (navBar) {
		var enteteEl = SitoolsDesk.getEnteteEl();
		var userContEl = this.userContainer.getEl();
		var y;
		if (SitoolsDesk.desktopMaximizeMode) {
			y = navBar.getHeight();
		}
		else {
			y = enteteEl.getHeight() - navBar.getHeight() - this.userContainer.getHeight();
			if (!Ext.isEmpty(userContEl.getMargins())) {
				y -= userContEl.getMargins().bottom;
				y -= userContEl.getMargins().top;
			}
		}
		return y;

	},
	
	/**
	 * Return the Navbar Buttons
	 */
	getNavbarButtons : function () {
	    return this.navToolbarButtons;
	},
	
	/**
     * Return the Navbar Modules
     */
	getNavbarModules : function () {
	    return this.navBarModule;
	},
	/**
     * listeners of maximizeDesktop event
     */
    onMaximizeDesktopNavbar : function () {
        this.navBarModule.fireEvent("maximizeDesktop");
        this.navToolbarButtons.fireEvent("maximizeDesktop");
    },
    
    /**
     * listeners of minimizeDesktop event
     */
    onMinimizeDesktopNavbar : function () {
        this.navBarModule.fireEvent("minimizeDesktop");
        this.navToolbarButtons.fireEvent("minimizeDesktop");
    }
	
    
});

Ext.reg('sitools.user.component.entete.Entete', sitools.user.component.entete.Entete);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, window, showVersion, publicStorage, userLogin, projectGlobal, SitoolsDesk, showResponse, i18n, extColModelToJsonColModel, loadUrl*/

Ext.namespace('sitools.user.component.entete');
/**
 * @cfg {Array} modules la liste des modules
 * @class sitools.user.component.entete.NavBar
 * @extends Ext.Toolbar
 */
sitools.user.component.entete.NavBar = Ext.extend(Ext.Toolbar, {
	
	initComponent : function () {
		var items = [];
		var categories = this.categorizeModules();
		
		var homeButton = new Ext.Button({
            handler : function () {
                projectGlobal.getPreferences(function () {
                    SitoolsDesk.removeActivePanel();
                    SitoolsDesk.removeAllWindows();
                    SitoolsDesk.loadPreferences();
                });
            }, 
            scale : "medium", 
            icon : "/sitools/common/res/images/icons/button-home.png",
            iconCls : 'navBarButtons-icon',
            tooltip : {
                html : i18n.get("label.homeButton"), 
                anchor : 'bottom', 
                trackMouse : false
            },
            template : new Ext.Template('<table cellspacing="0" class="x-btn {3}" style="padding-left:5px;"><tbody><tr>',
                    '<td><i>&#160;</i></td>',
                    '<td><em class="{5} unselectable="on">',
                    '<button type="{1}" style="height:28px; width:28px;">{0}</button>', '</em></td>',
                    '<td><i>&#160;</i></td>', "</tr></tbody></table>")
        });
        items.push(homeButton);
		items.push('|');
        
		Ext.each(categories, function (category) {
			var modules = category.modules;
			
			//Le module n'appartient pas à une catégorie: inclusion en tant que bouton dans le menu.
			if (Ext.isEmpty(category.category)) {
				var module = modules[0];
				var xtype = module.xtype;
				try {
					if (Ext.isEmpty(module.divIdToDisplay)) {
						var handler = null;
						var item = {
							text : i18n.get(module.label),
							iconCls : module.icon,
			                scope : module,
			                tooltip : {
								html : i18n.get(module.description), 
								anchor : 'bottom', 
								trackMouse : false
							}, 
			                cls : "x-navBar-items", 
			                clickEvent : 'mousedown',
						    template : new Ext.Template('<table cellspacing="0" class="x-btn {3}"><tbody><tr>',
						            '<td class="ux-taskbutton-left"><i>&#160;</i></td>',
						            '<td class="ux-taskbutton-center"><em class="{5} unselectable="on">',
						            '<button class="x-btn-text {2}" type="{1}" style="height:28px;">{0}</button>', '</em></td>',
						            '<td class="ux-taskbutton-right"><i>&#160;</i></td>', "</tr></tbody></table>")
						
						};
						var xtype = module.xtype;
						var func = xtype + ".openModule";
						if (!Ext.isEmpty(xtype) && Ext.isFunction(eval(func))) {
							handler = eval(func);
						}
						else {
							handler = module.openModule;
						}
						Ext.apply(item, {
							handler : handler
						});
						items.push(item);
						items.push('|');
					}
				}
				catch(err) {
					//Nothing to do
					var tmp = null;
				}
			}
			//Le module est dans une catégorie : On crée un menu contenant tous les modules de la catégorie
			else {
				var menuItems = [];
				Ext.each(category.modules, function (moduleInCategory) {
					try {
						if (Ext.isEmpty(moduleInCategory)) {
							return;
						}
						
						if (Ext.isEmpty(moduleInCategory.divIdToDisplay)) {
							var item = {
								text : i18n.get(moduleInCategory.label),
								
								iconCls : moduleInCategory.icon,
				                scope : this
							};

							//Test spécifique pour savoir si on doit inclure un sous menu : 
							var xtype = moduleInCategory.xtype;
							if (Ext.isEmpty(xtype)) {
								return;
							}
							var Func = eval(xtype + ".getStaticParameters");
							if (Ext.isFunction(Func)) {
								var staticParameters = Func();	
								if (staticParameters && staticParameters.showAsMenu) {
									Ext.apply(item, {
										menu : {
											xtype : moduleInCategory.xtype, 
											cls : "sitools-navbar-menu"
										}
									});
								}
								else {
									Ext.apply(item, {
										handler : moduleInCategory.openModule
									});
								}
							}
							
							
							func = xtype + ".openModule";
							if (Ext.isFunction(eval(func))) {
								handler = eval(func);
							}
							else {
								handler = moduleInCategory.openModule
							}
							Ext.apply(item, {
								handler : handler
							});
								
							menuItems.push(item);
							
							
						}
					}
					catch (err) {
						//nothing to do 
						var tmp = null;
					}
					
				});
			    if (!Ext.isEmpty(menuItems)) {
		            var menu = new Ext.menu.Menu({
                        items : menuItems, 
                        cls : "sitools-navbar-menu"
                    });
                    items.push({
                        text : category.category,
                        menu : menu,
                        icon : "/sitools/common/res/images/icons/white_arrow.gif",
                        iconAlign : "left",
                        clickEvent : 'mousedown',
                        cls : "x-navBar-items",
                        template : new Ext.Template('<table cellspacing="0" class="x-btn {3}"><tbody><tr>',
                                '<td class="ux-taskbutton-center"><em class="{2} unselectable="on">',
                                '<button class="x-btn-text {2}" type="{1}" style="height:28px;">{0}</button>', '</em></td>',
                                "</tr></tbody></table>")

                    });
                    items.push('|');
			    }
			}
			
		});

		sitools.user.component.entete.NavBar.superclass.initComponent.call(Ext.apply(this,  {
			id : "navBarId", 
			enableOverflow: true,
			defaults : {
				overCls : "x-navBar-items-over", 
				ctCls : "x-navBar-items-ct"
			}, 
			items : items, 
			cls : "x-navBar", 
			overCls : "x-navBar-over", 
			ctCls : "x-navBar-ct", 
			flex : 1,
			listeners : {
				scope : this, 
				afterRender : function (me) {
					this.observer.fireEvent("navBarRendered", me);
				}
			}, 
			border : false
		}));
	}, 
	/**
	 * From the modules attribute, return an array of categories. 
	 * Each items of the array could be either 
	 *  - {
	 *      modules : [module]
	 *    }
	 *  - {
	 *      category : categoryName, 
	 *      modules : [modules]
	 *    }
	 * @returns {Array}
	 */
	categorizeModules : function () {
		function getCategoryIndex(category, categoryList) {
			var idx = -1;
			for (var i = 0; i < categoryList.length; i++) {
				if (categoryList[i].category === category) {
					return i;
				}
			}
			return idx;
		}
		var categoryModules = [];
		Ext.each(this.modules, function (module) {
			if (Ext.isEmpty(module.categoryModule)) {
				categoryModules.push({
					modules : [module]
				});
			}
			else {
				var idx = getCategoryIndex(module.categoryModule, categoryModules);
				if (idx >= 0) {
					categoryModules[idx].modules.push(module);
				}
				else {
					categoryModules.push({
						category : module.categoryModule,
						modules : [module]
					});
				}
			}
			
		});
		return categoryModules;
	}
});

Ext.reg('sitools.user.component.entete.NavBar', sitools.user.component.entete.NavBar);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, window, showVersion, publicStorage, userLogin, projectGlobal, SitoolsDesk, showResponse, i18n, extColModelToJsonColModel, loadUrl*/

Ext.namespace('sitools.user.component.entete');
/**
 * @cfg {Array} modules la liste des modules
 * @class sitools.user.component.entete.NavBarButtons
 * @extends Ext.Toolbar
 */
sitools.user.component.entete.NavBarButtons = Ext.extend(Ext.Toolbar, {
    /**
     * The id of the button to open the profile window
     */
    profileButtonId : "profileButtonId", 
    
    initComponent : function () {
        
        var itemsButtons = [];
        
        if (!Ext.isEmpty(userLogin)) {
            // width with save button
            this.width = '204px';
        }
        
        
        /**
         * The btn to open profileWindow
         */
        this.profilButton = new Ext.Button({
            scope : this, 
            handler : this.showProfil, 
            iconCls : 'navBarButtons-icon',
            cls : 'navBarTransition',
//            scale : "medium", 
            icon : "/sitools/common/res/images/icons/navBarButtons/user-icon.png", 
            tooltip : {
                html : i18n.get('label.profil'), 
                anchor : 'bottom', 
                trackMouse : false
            }, 
            id : this.profileButtonId
        });
        itemsButtons.push(this.profilButton);
        
        this.versionButton = new Ext.Button({
            iconCls : 'navBarButtons-icon',
//            scale : "medium", 
            id : "versionBtnId",
            icon : "/sitools/common/res/images/icons/navBarButtons/version-icon.png", 
            handler : function () {
                showVersion();
            }, 
            tooltip : {
                html : i18n.get('label.version'), 
                anchor : 'bottom', 
                trackMouse : false
            }
        });
        itemsButtons.push(this.versionButton);
        
        if (!Ext.isEmpty(userLogin)) {
            this.saveButton = new Ext.Button({
                scope : this, 
                iconCls : 'navBarButtons-icon',
                handler : this.saveAction, 
//                scale : "medium", 
                icon : "/sitools/common/res/images/icons/navBarButtons/save-icon.png", 
                tooltip : {
                    html : i18n.get('label.save'), 
                    anchor : 'bottom', 
                    trackMouse : false
                }, 
                id : "saveBtnId"
            });
            itemsButtons.push(this.saveButton);
        }
        
        this.helpButton = new Ext.Button({
            iconCls : 'navBarButtons-icon',
//            scale : "medium", 
            scope : this, 
            icon : "/sitools/common/res/images/icons/navBarButtons/help-icon.png", 
            handler : SitoolsDesk.showHelp, 
            tooltip : {
                html : i18n.get('label.help'), 
                anchor : 'bottom', 
                trackMouse : false
            }
        });
        itemsButtons.push(this.helpButton);
        
        /**A specialized btn to switch between normal and maximize mode */
        this.maximizeButton = new Ext.Button({
//            scope : this, 
            iconCls : 'navBarButtons-icon',
            handler : function () {
                if (SitoolsDesk.desktopMaximizeMode) {
                    SitoolsDesk.getDesktop().minimize(); 
                }
                else {
                    SitoolsDesk.getDesktop().maximize();    
                }
            }, 
            icon : SitoolsDesk.desktopMaximizeMode ? "/sitools/common/res/images/icons/navBarButtons/mini-icon.png" : "/sitools/common/res/images/icons/navBarButtons/maxi-icon.png",  
            tooltip : {
            	id : 'tooltipId',
                html : SitoolsDesk.desktopMaximizeMode ? i18n.get('label.maximize') : i18n.get('label.minimize'), 
                anchor : 'bottom',
                trackMouse : false,
                listeners : {
                	show : function (tooltip){
		                if (SitoolsDesk.desktopMaximizeMode) {
                			tooltip.update(i18n.get('label.minimize'));
		                }
		                else {
	                		tooltip.update(i18n.get('label.maximize'));
		                }
                	}
                }
            }
        });
        itemsButtons.push(this.maximizeButton);
        
        sitools.user.component.entete.NavBarButtons.superclass.initComponent.call(Ext.apply(this,  {
            id : 'navBarButtonsId',
            enableOverflow: true,
            defaults : {
                overCls : "x-navBar-items-over", 
                ctCls : "x-navBar-items-ct"
            }, 
            items : itemsButtons, 
            cls : "x-navBar-buttons", 
            overCls : "x-navBar-over", 
            ctCls : "x-navBar-ct", 
            width : this.width,
            listeners : {
                scope : this, 
                maximizeDesktop : this.onMaximizeDesktop, 
                minimizeDesktop : this.onMinimizeDesktop 
            }, 
            border : false
        }));
    }, 
    
    /**
     * listeners of maximizeDesktop event
     */
    onMaximizeDesktop : function () {
        this.maximizeButton.setIcon("/sitools/common/res/images/icons/navBarButtons/mini-icon.png");
        SitoolsDesk.desktopMaximizeMode = true;
        this.maximizeButton.tooltip.html = i18n.get('label.minimize');
    },
    
    /**
     * listeners of minimizeDesktop event
     */
    onMinimizeDesktop : function () {
        this.maximizeButton.setIcon("/sitools/common/res/images/icons/navBarButtons/maxi-icon.png");
        SitoolsDesk.desktopMaximizeMode = false;
        this.maximizeButton.tooltip.html = i18n.get('label.maximize');
    },
    
    /**
     * Returns the maximizeBtn
     * @returns {Ext.Button}
     */
    getMaximizeButton : function () {
        return this.maximizeButton;
    }, 
    
    /**
     * Handler of profileBtn : Open the sitools.user.component.entete.UserProfile window
     * @param {Ext.Button} b The pressed btn
     * @param {Ext.event} e the click Event. 
     * @returns
     */
    showProfil : function (b, e) {
        var win = new sitools.user.component.entete.UserProfile({
            buttonId : this.profileButtonId
        });
        win.show();
    }, 

    /**
     * Handler of Save Btn. If admin Role : open a menu, else save desktop. 
     * @param {Ext.Button} btn The pressed btn
     * @param {Ext.event} event the click Event. 
     * @returns
     */
    saveAction : function (btn, event) {
        if (!Ext.isEmpty(userLogin) && projectGlobal && projectGlobal.isAdmin) {
            var ctxMenu = new Ext.menu.Menu({
                items: ['<b class="menu-title">' + i18n.get('label.chooseSaveType') + '</b>', '-',
                {
                    text: i18n.get("label.myself"),
                    handler : function () {
                        SitoolsDesk.app.saveWindowSettings();
                    }
                }, {
                    text: i18n.get("label.publicUser"),
                    handler : function () {
                        SitoolsDesk.app.saveWindowSettings(true);
                    }
                }, {
                    text : i18n.get('label.deletePublicPref'),
                    handler : function () {
                        publicStorage.remove();
                    }
                }] 
            });
            ctxMenu.showAt([event.getXY()[0], SitoolsDesk.getEnteteEl().getHeight()]);
        }
        else {
            SitoolsDesk.app.saveWindowSettings();
        }
    }
    
});

Ext.reg('sitools.user.component.entete.NavBarButtons', sitools.user.component.entete.NavBarButtons);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, utils_logout, sitools, SitoolsDesk, window, userLogin, showResponse, projectGlobal, 
  userStorage, DEFAULT_PREFERENCES_FOLDER, i18n, extColModelToJsonColModel, loadUrl*/

Ext.namespace('sitools.user.component.entete');

/**
 * @cfg {String} buttonId the id of the button that displays the window
 * @class sitools.user.component.entete.UserProfile
 * @extends Ext.Window
 */
sitools.user.component.entete.UserProfile = Ext.extend(Ext.Window, {
	
	width : 450,
	
	initComponent : function () {
	    
		this.header = false;
		
		this.user = projectGlobal.user || {
			firstName : "public", 
			identifier : "public", 
			email : "&nbsp;"
		};
		this.userPublic = this.user.identifier === "public";
		var userLanguage = SitoolsDesk.app.language, userLargeIcon;
		
		Ext.each(projectGlobal.languages, function (language) {
			if (userLanguage === language.localName) {
				userLargeIcon = language.largeIcon;
			}
		});
		var freeDisk = 0;
		var totalDisk = 0;
		var userTasksRunning = 0;
		var userTotalTasks = 0;
		var data = [{
			identifier : "language", 
			name: i18n.get("label.langues"), 
			url : userLargeIcon, 
			action : "changeLanguage"
		}];
		
		this.height =  this.user.identifier === "public" ? 140 : 220; 
		
		if (this.user.identifier !== "public") {
			data.push({
				identifier : "editProfile", 
				name: i18n.get("label.editProfile"), 
				url : '/sitools/common/res/images/icons/menu/regcrud.png', 
				action : "editProfile",
				comment : ""
			}, {
				identifier : "userDiskSpace", 
				name: i18n.get('label.userDiskSpace'), 
				url : '/sitools/common/res/images/icons/menu/dataAccess.png', 
				action : "showDisk", 
				comment : String.format(i18n.get("label.userDiskUse"), freeDisk, totalDisk)
			}, {
				identifier : "tasks", 
				name: i18n.get("label.Tasks"), 
				url : "/sitools/common/res/images/icons/menu/applications2.png", 
				action : "showTasks", 
				comment : String.format(i18n.get("label.taskRunning"), userTasksRunning, userTotalTasks)
			}, {
				identifier : "orders", 
				name: i18n.get("label.orders"), 
				url : "/sitools/common/res/images/icons/menu/order.png", 
				action : "showOrders"
			});
			
		}

		var store = new Ext.data.JsonStore({
			fields : ['name', 'url', 'action', 'comment', 'identifier'],
			data : data
		});
		var tpl = new Ext.XTemplate('<tpl for=".">',
		        '<div class="userButtons" id="{identifier}">',
		        '<div class="userButtons-thumb"><img src="{url}" title="{name}"></div>',
		        '<span class="userButtons-name">{name}</span>', 
		        '<span class="userButtons-comment">{comment}</span></div>',
		    '</tpl>',
		    '<div class="x-clear"></div>'
		);
		
		var buttonsDataView = new Ext.DataView({
	        store: store,
	        cls : "userButtonsDataview", 
	        tpl: tpl,
	        autoHeight : true,
	        width : this.userPublic ? 100 : this.width, 
	        multiSelect: true,
	        overClass: 'x-view-over',
	        overCls : 'userButtonsPointer',
	        emptyText: 'No images to display', 
	        itemSelector: 'div.userButtons',
	        listeners : {
				scope : this, 
				click : this.actionItemClick, 
				afterRender : function () {
					this.fillDiskInformations();
					this.fillTaskInformations();
				}
			}
	    });
		
		
		var userInfoStore = new Ext.data.JsonStore({
			fields : ['firstName', 'lastName', 'image', 'email', 'identifier'],
			data : [Ext.apply(this.user, {
				"image" : "/sitools/common/res/images/icons/menu/usersGroups.png"
			})]
		});
		var logout = new Ext.Button({
			scope : this, 
			text  : i18n.get('label.logout'), 
			handler : function () {
			    sitools.userProfile.LoginUtils.logout();
			}
		});
		var login = new Ext.Button({
			scope : this, 
			cls : "userProfileBtn", 
			text  : i18n.get('label.login'), 
			handler : function () {
			    sitools.userProfile.LoginUtils.connect({
			        closable : true,
                    url : loadUrl.get('APP_URL') + '/login',
                    register : loadUrl.get('APP_URL') + '/inscriptions/user',
                    reset : loadUrl.get('APP_URL') + '/resetPassword'
                });			    
			}
		});
		
		var register = new Ext.Button({
			scope : this, 
			cls : "userProfileBtn",
			text  : i18n.get('label.register'), 
			handler : function () {
				var register = new sitools.userProfile.Register({
	                closable : true,
	                url : "/sitools/inscriptions/user",
	                login : "/sitools/login"
	            });
	            register.show();
			}
		});
		var closeBtn = new Ext.Button({
			scope : this,
			icon : "/sitools/common/res/images/icons/close-icon.png",
			cls : 'button-transition',
			handler : function () {
				this.destroy();
			}, 
			x : this.width - 30, 
			y : this.height * -1 + 1, 
			style : {
				"position" : "relative", 
				"height" : 16,
				"width" : 16,
				"z-index" : 200
			}
		});
		
		var displayInfo = new Ext.DataView({
			flex : 1, 
			logoutBtn : logout, 
			loginBtn : login, 
			closeBtn : closeBtn, 
			registerBtn : register, 
			cls : "x-panel-body", 
			tpl : new Ext.XTemplate('<tpl for=".">',
			        '<div class="userProfileItem" id="{identifier}">',
			        '<div class="userProfile userProfileItem-thumb"><img style="height:60px;" src="{image}" title="{name}"></div>',
			        '<div class="userProfile"><span class="userProfileName">{firstName} {lastName}</span>', 
			        '<span class="userProfileEmail">{email}</span>',
			        '<div id="logBtn"></div>', 
		            '</div>', 
			    '</tpl>',
			    '<div class="x-clear"></div>'
			), 
			store : userInfoStore, 
			listeners : {
				scope : this, 
				afterRender : function (me) {
					if (this.user.identifier !== "public") {
						me.logoutBtn.render("logBtn");
					}
					else {
						me.loginBtn.render("logBtn");
						me.registerBtn.render("logBtn");
					}
					me.closeBtn.render(this.id);
				}
			}
		});
		sitools.user.component.entete.UserProfile.superclass.initComponent.call(Ext.apply(this, {
			id : "userProfileWindow", 
			header : false,
			stateful : false, 
			shadow : false, 
			layout : this.user.identifier === "public" ? 'hbox' : 'vbox',
			layoutConfig : {
				align : "stretch"
			},
			border : false, 
			hideBorders : true, 
			closable : false, 
			x : Ext.getBody().getWidth() - this.width, 
			y : SitoolsDesk.getEnteteEl().getHeight(), 
			resizable : false, 
			bodyBorder : false, 
			listeners : {
				scope : this, 
				beforeRender : function () {
					Ext.getBody().on("click", this.interceptOnClick, this);
				}, 
				beforeDestroy : function (me) {
					Ext.getBody().un("click", this.interceptOnClick, this);
					Ext.getCmp(this.buttonId).enable();
				}
			}, 
			items : [displayInfo, {
				xtype : "panel", 
				items : [buttonsDataView]
			}]
		}));
		
	}, 
	/**
	 * while this window is active, checked if any click is done on this window, or somewhere Else. 
	 * 
	 * @param {Ext.event} evt the clic Event. 
	 * @param {HtmlElement} target the Html target element. 
	 * @returns
	 */
	interceptOnClick : function (evt, target) {
		//le click est sur le bouton pour ouvrir la fenêtre : Désactiver le bouton... et fin de l'action.
		if (Ext.DomQuery.select("table[id=" + this.buttonId + "] button[id=" + target.id + "]").length === 1) {
			Ext.getCmp(this.buttonId).disable();
			return;
		}
		
		//Le clic est sur un élément de la fenêtre : rien à faire. 
		if (this.isDescendant(Ext.DomQuery.select("div[id=userProfileWindow]")[0], target)) {
			if (evt.shiftKey && evt.ctrlKey) {
				breakout().getBackToDesktop();
			}
			return;
		}
		
		//Le clic est quelque part en dehors de la fenêtre, on détruit la fenêtre (-> beforeDestroy est exécuté)
		this.destroy();
	}, 
	/**
	 * Handler of any click on the dataview used to display actions btn : 
	 * Execute the method specified in each store.action attribute. 
	 * 
	 * @param {Ext.DataView} dataView the clicked Dataview
	 * @param {numeric} index the index of the clicked node
	 * @param {Html Element} node the clicked html element 
	 * @param {Ext.event} e The click event
	 * @returns
	 */
	actionItemClick : function (dataView, index, node, e) {
		try {
			var data = dataView.getSelectedRecords()[0].data;	
			eval("this." + data.action).call(this, dataView, index, node, e);
		}
		catch (err) {
			return;
		}
		
	}, 
	isDescendant : function (parent, child) {
		var node = child.parentNode;
		while (node !== null) {
		    if (node === parent) {
		        return true;
		    }
		    node = node.parentNode;
		}
		return false;
	}, 
	/**
	 * Open a Ext.Menu.menu containing all projectGlobal.languages options. 
	 * @param {Ext.DataView} dataView the clicked Dataview
	 * @param {numeric} index the index of the clicked node
	 * @param {Html Element} node the clicked html element 
	 * @param {Ext.event} e The click event
	 */
	changeLanguage : function (dataView, index, node, e) {
	    var menuLangues = new Ext.menu.Menu({
	        plain : true
	    });
	    Ext.each(projectGlobal.languages, function (language) {
	        menuLangues.add({
	            text : language.displayName,
	            scope : this,
	            handler : function () {
	                var callback = function () {
	                    Ext.util.Cookies.set('language', language.localName);
	                    window.location.reload();
	                };
	                var date = new Date();
	                Ext.util.Cookies.set('language', language.localName, date.add(Date.MINUTE, 20));
	                var userPreferences = {};
	                userPreferences.language = language.localName;
	                if (!Ext.isEmpty(userLogin)) {
	                    userStorage.set(loadUrl.get('APP_PORTAL_URL'),  "/" + DEFAULT_PREFERENCES_FOLDER + loadUrl.get('APP_PORTAL_URL'), userPreferences, callback);
	                } else {
	                    window.location.reload();
	                }

	            },
	            icon : language.image
	        });
	    }, this);
	    menuLangues.showAt([Ext.get(node.id).getLeft(), Ext.get(node.id).getBottom()]);
		
	}, 
	/**
	 * Edit the profile of the user depending on the server configuration
	* @param {Ext.DataView} dataView the clicked Dataview
     * @param {numeric} index the index of the clicked node
     * @param {Html Element} node the clicked html element 
     * @param {Ext.event} e The click event
	 */
	editProfile : function (dataView, index, node, e) {
		if (this.user.identifier === "public") {
			return;
		}
		
        var callback = Ext.createDelegate(this.onEditProfile, this);		
		sitools.userProfile.LoginUtils.editProfile(callback);
		
	}, 
	
	/**
     * Open a window in the desktop with the sitools.userProfile.editProfile object. 
     */
	onEditProfile : function () {
	    var componentCfg = {
            identifier : this.user.identifier,
            url : '/sitools/editProfile/' + this.user.identifier,
            handler : function (user) {
                projectGlobal.user = user;
            }
        };
        var jsObj = sitools.userProfile.editProfile;

        var windowConfig = {
            title : i18n.get('label.editProfile'),
            saveToolbar : false,
            iconCls : "editProfile"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj, true);
        this.destroy();
	},
	
	/**
	 * Open a window in the desktop with the sitools.user.component.entete.userProfile.tasks object. 
	 * @param {Ext.DataView} dataView the clicked Dataview
	 * @param {numeric} index the index of the clicked node
	 * @param {Html Element} node the clicked html element 
	 * @param {Ext.event} e The click event
	 */
	showTasks : function () {
		var jsObj = sitools.user.component.entete.userProfile.tasks;
        var windowConfig = {
            title : i18n.get('label.Tasks'),
            saveToolbar : false, 
            iconCls : 'tasks'
        };
        SitoolsDesk.addDesktopWindow(windowConfig, {}, jsObj, true);
		this.destroy();
		
	}, 
	/**
	 * Open a window in the desktop with the sitools.user.component.entete.userProfile.diskSpace object. 
	 * @param {Ext.DataView} dataView the clicked Dataview
	 * @param {numeric} index the index of the clicked node
	 * @param {Html Element} node the clicked html element 
	 * @param {Ext.event} e The click event
	 */
	showDisk : function () {
		var jsObj = sitools.user.component.entete.userProfile.diskSpace;
		var windowConfig = {
            title : i18n.get('label.userSpace'),
            saveToolbar : false, 
            iconCls : "diskSpace"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, {}, jsObj, true);
		this.destroy();
	}, 
	
	/**
	 * Open a window in the desktop with the sitools.user.component.entete.userProfile.diskSpace object. 
	 * @param {Ext.DataView} dataView the clicked Dataview
	 * @param {numeric} index the index of the clicked node
	 * @param {Html Element} node the clicked html element 
	 * @param {Ext.event} e The click event
	 */
	showOrders : function () {
		var jsObj = sitools.user.component.entete.userProfile.viewOrderPanel;
		var windowConfig = {
            title : i18n.get('label.ordersHistory'),
            saveToolbar : false, 
//            iconCls : "orders"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, {}, jsObj, true);
		this.destroy();
	}, 
	/**
	 * Send a request on user task resource to determine how many tasks are launched and finished.
	 * Update the task comment div with the formated result. 
	 */
	fillDiskInformations : function () {
		var el = Ext.DomQuery.select("div[id='userDiskSpace'] span[class='userButtons-comment']")[0];
		if (Ext.isEmpty(el)) {
			return;
		}
		Ext.Ajax.request({
			method : "GET",

			url : loadUrl.get('APP_URL') + loadUrl.get('APP_USERSTORAGE_USER_URL').replace("{identifier}", this.user.identifier) + "/status", 
			success : function (ret) {
				var json = Ext.decode(ret.responseText);
				if (!json.success) {
					return;
				}
				var storage = json.userstorage.storage;
				var totalSpace = storage.quota;
				var usedSpace = storage.busyUserSpace;
				var pourcentage = usedSpace / totalSpace * 100;
				var cls = null; 
			    if (pourcentage >= 90 && pourcentage < 100) {
				    Ext.get("userDiskSpace").addClass("sitools-userProfile-warning-icon");
				    cls = "sitools-userProfile-warning-text";
				}
			    else if (pourcentage > 100) {
                    Ext.get("userDiskSpace").addClass("sitools-userProfile-error-icon");
                    cls = "sitools-userProfile-error-text";
                }
			    var str = "";
			    if (!Ext.isEmpty(cls)) {
                    str += "<span class='" + cls + "'>";
                }
			    str += String.format(i18n.get('label.diskSpace'), Ext.util.Format.round(pourcentage, 0), Ext.util.Format.fileSize(totalSpace));
			    if (!Ext.isEmpty(cls)) {
                    str += "</span>";
                }
				el.update(str);
			}
		});
	}, 
	/**
	 * Send a request on user userstorage resource to determine the space allowed and consumed. 
	 * Update the diskSpace comment div with the formated result. 
	 */
	fillTaskInformations : function () {
		var el = Ext.DomQuery.select("div[id='tasks'] span[class='userButtons-comment']")[0];
		if (Ext.isEmpty(el)) {
			return;
		}
		Ext.Ajax.request({
			method : "GET",
			url : loadUrl.get('APP_URL') + loadUrl.get('APP_USERRESOURCE_ROOT_URL') +  "/" + this.user.identifier + "/tasks", 
			success : function (ret) {
				var json = Ext.decode(ret.responseText);
				if (!json.success) {
					return;
				}
				var runningTasks = 0, totalTasks = 0;
				Ext.each(json.data, function (task) {
					if (task.status === "TASK_STATUS_RUNNING" || task.status === "TASK_STATUS_PENDING") {
						runningTasks++;
					}
					totalTasks++;
				});
                if (runningTasks > 0) {
				    el.update(String.format(i18n.get('label.taskRunning'), runningTasks));
                } else {
                    el.update("");
                }
			}
		});
		
	}
	
});/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * global Ext, sitools, showResponse, i18n, extColModelToJsonColModel, loadUrl,
 * projectGlobal, SitoolsDesk
 */

Ext.namespace('sitools.user.component.bottom');

// sitools.component.users.datasets.columnsDefinition = function (config) {
/**
 * Create the desktop footer component with the sitools footer by default or
 * with the template footer of the project (if it's not empty)
 * 
 * @cfg {String} htmlContent html content of the headers,
 * @cfg {Array} modules the modules list
 * @class sitools.user.component.bottom.Bottom
 * @extends Ext.Panel
 */
sitools.user.component.bottom.Bottom = Ext.extend(Ext.Panel, {
	heightNormalMode : 0,
	heightMaximizeDesktopMode : 0,
	forceLayout : true,
	layout : "hbox",
	border : false,
	layoutConfig : {
		align : 'stretch',
		pack : 'start'
	},
	bodyCssClass : 'sitools_footer',
	initComponent : function() {

		this.versionUrl = loadUrl.get('APP_URL') + '/version';

		this.defaultBottom = Ext.get('x-bottom').dom.children.length === 0;

		if (this.defaultBottom) {

			this.renderTo = 'x-bottom';

			this.panelLeft = new Ext.Panel({
				border : false,
				flex : 0.5,
				html : "<img id='sitools_logo' src='"
						+ loadUrl.get("APP_URL")
						+ "/res/images/logo_01_petiteTaille.png' alt='sitools_logo'/>",
				bodyCssClass : 'no-background',
				listeners : {
					scope : this,
					afterRender : function() {
						Ext.get("sitools_logo").on('load', function() {
							Ext.get("sitools_logo").alignTo(
									this.panelLeft.getEl(), "c-c", [-60, 2]);
						}, this);
					}
				}
			});

			this.credits = new Ext.form.Label({
						style : 'color:white'
					});

			this.panelMiddle = new Ext.Panel({
						border : false,
						flex : 1,
						bodyCssClass : 'no-background',
						items : [{
									xtype : "panel",
									id : 'sitools_build_by',
									cls : "sitools_footer_build_by",
									bodyCssClass : 'no-background',
									items : [this.credits]

								}]
					});

			this.linkStore = new Ext.data.Store({
						fields : ['name', 'url']
					});

			var linkDataview = new Ext.DataView({
				store : this.linkStore,
				tpl : new Ext.XTemplate(
						'<div class="sitools_footer_right" id="sitools_footer_right">',
						'<tpl for=".">',
						'<a rel="contents" href="#" onclick="sitools.user.component.bottom.Bottom.showFooterLink(\'{url}\',\'{name}\');">',
						'{[this.getLabel(values.name)]}', '</a>',
						'<tpl if="(xindex < xcount)">', ' | ', '</tpl>',
						'</tpl>', '</div>', {
							compiled : true,
							disableFormats : true,
							getLabel : function(labelName) {
								return i18n.get(labelName);
							}
						})
			});

			this.panelRight = new Ext.Panel({
						border : false,
						flex : 0.5,
						bodyCssClass : 'no-background',
						items : [linkDataview]
					});

			this.items = [this.panelLeft, this.panelMiddle, this.panelRight];
		} else {
			var el = Ext.get('x-bottom').createChild({
						tag : 'div'
					});
			this.renderTo = el;
		}

		sitools.user.component.bottom.Bottom.superclass.initComponent.call(Ext
				.apply(this, {

					// html : this.htmlContent,
					listeners : {
						scope : this,
						afterRender : function(me) {

							if (!this.defaultBottom) {
								me.setHeight(0);
							} else {
								Ext.Ajax.request({
									url : this.versionUrl,
									method : 'GET',
									scope : this,
									success : function(ret) {
										var json = Ext.decode(ret.responseText);
										if (!json.success) {
											Ext.Msg.alert(
													i18n.get('label.warning'),
													json.message);
											return false;
										}
										var info = json.info;

										var copyright = info.copyright;

										this.credits
												.setText(
														String
																.format(
																		i18n
																				.get("label.build_by_sitools2"),
																		copyright),
														false);

										var bottomEl = SitoolsDesk
												.getBottomEl();
										me.fillLinks();
										me.setHeight(bottomEl.getHeight());
										me.heightNormalMode = bottomEl
												.getHeight();
										me.doLayout();
										Ext.get("sitools_build_by").alignTo(
												this.panelMiddle.getEl(),
												"bl-bl");

										var fr = Ext
												.get("sitools_footer_right");
										if (Ext.isDefined(fr)
												&& !Ext.isEmpty(fr)) {
											fr.alignTo(this.panelRight.getEl(),
													"c-c");
										}
									}
								});
							}

						},
						resize : function(me) {
							if (!this.defaultBottom) {
								me.setHeight(0);
							} else {
								me.setSize(SitoolsDesk.getBottomEl().getSize());
								me.doLayout();
								Ext.get("sitools_logo").alignTo(
										this.panelLeft.getEl(), "c-c");
								Ext.get("sitools_build_by").alignTo(
										this.panelMiddle.getEl(), "bl-bl");

								var fr = Ext.get("sitools_footer_right");
								if (Ext.isDefined(fr) && !Ext.isEmpty(fr)) {
									fr.alignTo(this.panelRight.getEl(), "c-c");
								}
							}
						},

						maximizeDesktop : this.onMaximizeDesktop,
						minimizeDesktop : this.onMinimizeDesktop
					}

				}));
	},
	onMaximizeDesktop : function() {
		this.container.setHeight(0);
		this.hide();
		this.doLayout();
	},
	onMinimizeDesktop : function() {
		this.container.dom.style.height = "";
		this.setSize(SitoolsDesk.getBottomEl().getSize());
		this.show();
		this.doLayout();
	},
	fillLinks : function() {
		var projectLinks = projectGlobal.links;
		Ext.each(projectLinks, function(value) {
					this.linkStore.add(new Ext.data.Record(value));
				}, this);
	}

});

/**
 * @static
 */
sitools.user.component.bottom.Bottom.showFooterLink = function(url, linkName) {
	var windowConfig = {
		title : i18n.get(linkName),
		id : linkName,
		iconCls : "version"
	};

	var jsObj = Ext.ux.ManagedIFrame.Panel;
	var componentCfg = {
		defaults : {
			padding : 10
		},
		layout : 'fit',
		region : 'center',
		defaultSrc : url
	};

	SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);

};

Ext.reg('sitools.user.component.bottom.Bottom',
		sitools.user.component.bottom.Bottom);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, MULTIDS_TIME_DELAY, sitools, i18n, commonTreeUtils, projectGlobal, showResponse, document, SitoolsDesk, alertFailure, loadUrl*/
/*
 * @include "../../components/forms/forms.js"  
 */

Ext.namespace('sitools.user.component.forms');

/**
 * Displays The result of a multiDatasets Reasearch. 
 * @cfg {string} urlTask The url to request 
 * @cfg {string} formId The form Id
 * @cfg {string} formName The form Name
 * @cfg {Array} formMultiDsParams an array of formParams (represent concepts selection)
 * @cfg {Array} datasets Array of Datasets Ids
 * @class sitools.user.component.forms.resultsProjectForm
 * @extends Ext.grid.GridPanel
 */
sitools.user.component.forms.resultsProjectForm = Ext.extend(Ext.grid.GridPanel, {
    initComponent : function () {
        var params = {};
        params.datasetsList = this.datasets.join("|");

	    var i = 0;
	    
	    if (!Ext.isEmpty(this.formMultiDsParams)) {
	        Ext.each(this.formMultiDsParams, function (param) {
	            params["c[" + i + "]"] = param;
	            i += 1;
	        }, this);
	    }
        var task = new Ext.util.DelayedTask(function () {
			return;
		});
        var store = new Ext.data.JsonStore({
            url : this.urlTask,
            baseParams : params,
            restful : true, 
            root : 'TaskModel.properties',
			fields :  [{
				name : "id", 
				type : "string"
			}, {
				name : "name", 
				type : "string"
			}, {
				name : "description", 
				type : "string"
			}, {
				name : "image"
			}, {
				name : "nbRecord"
			}, {
				name : "url", 
				type : "string"
			}, {
				name : "status", 
				type : "string"
			}, {
				name : "errorMessage", 
				type : "string"
			}], 
			autoLoad : true, 
			listeners : {
				scope : this, 
				load : function (store, recs, options) {
					task.cancel();
					if (store.reader.jsonData.TaskModel.status == "TASK_STATUS_RUNNING" ||
						store.reader.jsonData.TaskModel.status == "TASK_STATUS_PENDING") {
						this.getBottomToolbar().setStatus({
		                    // text: ret.error ? ret.error :
		                    // i18n.get('warning.serverUnreachable'),
		                    text : i18n.get('label.loading'),
		                    iconCls : 'x-status-busy'
		                });
                    
		                task.delay(MULTIDS_TIME_DELAY, function () {
							store.load();
						});
					}
					else {
						Ext.Ajax.request({
							scope : this, 
							url : this.urlTask, 
							method : "DELETE", 
							success : function (ret) {
								var callerCmp = Ext.getCmp(this.callerId);
								callerCmp.fireEvent("multiDsSearchDone");
							},
							failure : alertFailure
						});
						if (store.reader.jsonData.TaskModel.status == "TASK_STATUS_FAILURE") {
							this.getBottomToolbar().setStatus({
			                    text : store.reader.jsonData.TaskModel.customStatus,
			                    iconCls : 'x-status-error'
			                });
						}
						else {
						    this.getBottomToolbar().setStatus({
								text : i18n.get("label.requestDone"),
			                    iconCls : 'x-status-valid'
			                });
						}
					}
                    store.each(function (record) {
                        var error = record.get("errorMessage");
                        if (!Ext.isEmpty(error)) {
                            var index = store.indexOf(record);
                            var htmlLineEl = this.getView().getRow(index);
                            var el = Ext.get(htmlLineEl);
                            
                            var cls = "x-form-invalid-tip";
                            
                            var ttConfig = {
                                html : error,
                                dismissDelay : 0,
                                target : el,
                                cls : cls
                            };
    
                            var ttip = new Ext.ToolTip(ttConfig);
                        }
                    }, this);					

				}
			}
        
        });
        
        var cm = new Ext.grid.ColumnModel({
			columns : [{
				width : 25, 
				dataIndex : 'image', 
				header : "", 
				renderer : function (value) {
					return ! Ext.isEmpty(value) && ! Ext.isEmpty(value.url) ? String.format("<img src='{0}' width=20 height=20>", value.url) : "";
				}
			}, {
				width : 100, 
				dataIndex : 'name', 
				header : i18n.get('label.name')
			}, {
				width : 100, 
				dataIndex : 'nbRecord', 
				header : i18n.get('label.nbRecords')
			}, {
                width : 150, 
                dataIndex : 'description', 
                header : i18n.get('label.description'),
                renderer : function (value, metaData, record, rowIndex, colIndex, store) {
					metaData.attr = "ext:qtip='" + value + "'";
					return value;

				}
            }, {
		        xtype: 'actioncolumn',
                header : i18n.get('label.showData'),
		        width: 100,
                
		        items: [{
	                getClass : function (value, meta, rec) {
						if (rec.get('status') == "REQUEST_ERROR") {
							return "multids-error";
						}
	                }, 
	                icon   : loadUrl.get('APP_URL') + '/common/res/images/icons/tree_datasets.png',                // Use a URL in the icon config
	                tooltip: i18n.get('label.showData'),
	                scope : this, 
	                handler: SitoolsDesk.navProfile.multiDataset.showDataset
	            }]
			}, {
		        xtype: 'actioncolumn',
                header : i18n.get('label.showDefinition'),
		        width: 100,
		        items: [{
	                icon   : loadUrl.get('APP_URL') + '/common/res/images/icons/tree_dictionary.png',
	                tooltip: i18n.get('label.showDefinition'),
	                scope : this, 
	                handler: function (grid, rowIndex, colIndex) {
	                    var rec = grid.getStore().getAt(rowIndex);
	                    if (Ext.isEmpty(rec)) {
							return;
	                    }
	                    sitools.user.clickDatasetIcone(rec.get("url"), "defi", {
							formMultiDsParams : this.formMultiDsParams
	                    });
	                }
	            }]
			}]
        });
        var bbar = new Ext.ux.StatusBar({
            text : i18n.get('label.ready'),
            iconCls : 'x-status-valid'
        });

		Ext.apply(this, {
			cm : cm, 
			store : store, 
			layout : "fit", 
			bbar : bbar, 
			listeners : {
				scope : this, 
				viewready : function (grid) {
					var callerCmp = Ext.getCmp(this.callerId);
					callerCmp.fireEvent("multiDsSeachDone");
				}
			}, 
			viewConfig : {
				forceFit : true, 
				getRowClass : function (rec) {
					if (rec.get('status') == "REQUEST_ERROR") {
						return "red-row";
					}
					if (rec.get('status') == "UNAUTHORIZED") {
						return "orange-row";
					}
				}
			}
		});
		sitools.user.component.forms.resultsProjectForm.superclass.initComponent.call(this);
    } 
    

});

Ext.reg('sitools.user.component.forms.resultsProjectForm', sitools.user.component.forms.resultsProjectForm);

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, MULTIDS_TIME_DELAY, sitools, i18n, commonTreeUtils, projectGlobal, showResponse, document, SitoolsDesk, alertFailure, loadUrl*/
/*
 * @include "../../components/forms/forms.js"  
 */

Ext.namespace('sitools.user.component.forms');

/**
 * Displays The result of a multiDatasets Reasearch. 
 * @cfg {string} urlTask The url to request 
 * @cfg {string} formId The form Id
 * @cfg {string} formName The form Name
 * @cfg {Array} formMultiDsParams an array of formParams (represent concepts selection)
 * @cfg {Array} datasets Array of Datasets Ids
 * @class sitools.user.component.forms.overviewResultsProjectForm
 * @extends Ext.Panel
 */
sitools.user.component.forms.overviewResultsProjectForm = Ext.extend(Ext.Panel, {
    initComponent : function () {

		var results = new sitools.user.component.forms.resultsProjectForm(this);
		Ext.apply(results, {
			region : "center"
		});
		
		var description = i18n.get('label.descriptionMultiDS');
		
		this.southPanel = new Ext.TabPanel({
        	title : i18n.get('label.results'), 
			region : "south", 
        	height : 300, 
        	split : true, 
        	autoScroll : false, 
        	collapsible : false, 
        	collapsed : true
		});
		Ext.apply(this, {
			layout : "border", 
			items : [results, this.southPanel]
		});
		
		if (description !== "label.descriptionMultiDS") {
			this.items.unshift({
				xtype : 'panel',
				height : 100, 
				html : description, 
				padding : "10px", 
				region : "north", 
				collapsible : true, 
				split : true, 
				autoScroll : true, 
				title : i18n.get('label.description')
			});
		}

		sitools.user.component.forms.overviewResultsProjectForm.superclass.initComponent.call(this);
    } 
    

});

Ext.reg('sitools.user.component.forms.overviewResultsProjectForm', sitools.user.component.forms.overviewResultsProjectForm);

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, SITOOLS_DATE_FORMAT, SITOOLS_DEFAULT_IHM_DATE_FORMAT, i18n, userLogin, DEFAULT_WIN_HEIGHT, DEFAULT_WIN_WIDTH, getDesktop, projectGlobal, SitoolsDesk, DEFAULT_PREFERENCES_FOLDER, alertFailure*/
/*global loadUrl*/
/*
 * @include "formComponentsPanel.js"
 * @include "resultsProjectForm.js"
 */
Ext.namespace('sitools.user.component.forms');

/**
 * The global Panel. A panel with a formComponentsPanel and the buttons. 
 * @cfg {string} formId Id of the selected Form
 * @cfg {string} formName Name of the selected Form 
 * @cfg {Array} formParameters Array of all form Parameters
 * @cfg {number} formWidth Form Width 
 * @cfg {number} formHeight Form Height 
 * @cfg {string} formCss Name of a specific css class to apply to form 
 * @cfg {Array} properties An array of Properties. 
 * @cfg {string} urlServicePropertiesSearch The url to request properties
 * @cfg {string} urlServiceDatasetSearch the url to request for Multids Search
 * @cfg {string} dictionaryName the Name of the dictionary attached to the form
 * @class sitools.user.component.forms.projectForm
 * @extends Ext.Panel
 * @requires sitools.user.component.formComponentsPanel
 */
sitools.user.component.forms.projectForm = Ext.extend(Ext.Panel, {
    initComponent : function () {
        var config = this; 
        this.componentType = "formProject";
        
        var panelIdObject = {};
        
        // New Form model with zones
        if (!Ext.isEmpty(this.formZones)){
            Ext.each(this.formZones, function(formParam) { 
                var containerId = formParam.containerPanelId;
                if (Ext.isEmpty(panelIdObject[containerId])){
                    panelIdObject[containerId] = [];
                }
                panelIdObject[containerId].push(formParam);
            });
        } else { // old form model
            Ext.each(config.formParameters, function(formParam) { 
                var containerId = formParam.containerPanelId;
                if (Ext.isEmpty(panelIdObject[containerId])){
                    panelIdObject[containerId] = [];
                }
                panelIdObject[containerId].push(formParam);
            });
        }
        
        var items = [];
        var globalParams = {};
        
        Ext.iterate(panelIdObject, function(key, formParams){
            var componentList = new  sitools.user.component.formComponentsPanel({
                border: true,
                css : config.formCss, 
                formId : config.formId,
                id : key
            });

            if (!Ext.isEmpty(this.formZones)) {
                globalParams.formZones = formParams;
            } else {
                globalParams.oldParameters = formParams;
            }

//            componentList.datasetCm = config.dataset.columnModel;
            componentList.loadParameters(globalParams, config.dataUrl, "dataset");

            items.push(componentList);
        }, this);
        
        
        
        /**
         * The panel that displays all form components as defined by the administrator. 
         */
        this.zonesPanel = new Ext.Panel({
            width : config.formWidth,
            height : config.formHeight, 
            css : config.formCss, 
            formId : config.formId,
            items : [items]
        });
//        
//        if (!Ext.isEmpty(config.formParameters)) {
//            this.componentList.loadParameters(config.formParameters, config.dataUrl, "project");
//        }
    
        var displayComponentPanel = new Ext.Panel({
            title : i18n.get('label.formConcepts'), 
            region : "center", 
            flex : 2, 
            autoScroll : true,
            items : this.zonesPanel,
            layout : "absolute",
            listeners : {
                scope : this, 
                resize : function () {
                    if (!Ext.isEmpty(this.zonesPanel.getEl())) {
                        var cmpChildSize = this.zonesPanel.getSize();
                        var size = this.body.getSize();
                        var xpos = 0, ypos = 0;
                        if (size.height > cmpChildSize.height) {
                            ypos = (size.height - cmpChildSize.height) / 2;
                        }
                        if (size.width > cmpChildSize.width) {
                            xpos = (size.width - cmpChildSize.width) / 2;
                        }
                        this.zonesPanel.setPosition(xpos, ypos);
                        
                    }
                }
            }
        });
        
        /**
         * The panel that displays Property search
         * Each property adds a formField with the buildPropertyField method
         */
        this.propertyPanel = new Ext.form.FormPanel({
            title : i18n.get("label.defineProperties"), 
            padding : 10,
            labelWidth : 100, 
            flex : 2,
            autoScroll : true, 
            defaults : {
                labelSeparator : ""
            },
            buttons : [{
                text : i18n.get('label.refreshDatasets'), 
                scope : this, 
                handler : this.propertySearch
            }]
        });
        if (!Ext.isEmpty(this.properties)) {
            Ext.each(this.properties, function (prop) {
                var field = this.buildPropertyField(prop);
                this.propertyPanel.add(field);
            }, this);
        }
        
        var storeDatasets = new Ext.data.JsonStore({
            restful  : true, 
            fields : [{
                name : "id", 
                type : "string"
            }, {
                name : "name", 
                type : "string"
            }, {
                name : "visible", 
                type : "boolean"
            }], 
            url : projectGlobal.sitoolsAttachementForUsers + this.urlServicePropertiesSearch, 
            root : "collection.dataSets", 
            listeners : {
                load : function (store, recs) {
                    Ext.each(recs, function (rec) {
                        rec.set("visible", true);
                    });
                }
            }, 
            autoLoad : true
        });
        
        var visible = new Ext.grid.CheckColumn({
            header : i18n.get('headers.visible'),
            dataIndex : 'visible',
            width : 55
        });
        
        var cmDatasets = new Ext.grid.ColumnModel({
            columns : [ {
                header : i18n.get('headers.name'),
                dataIndex : 'name',
                width : 120
            }, visible]
        });
        
        var smDatasets = new Ext.grid.RowSelectionModel({
            singleSelect : true
        });
        
        /**
         * The dataset list. 
         * It is updated when user pressed on refresh dataset button.
         */
        this.datasetPanel = new Ext.grid.EditorGridPanel({
            title : i18n.get('label.defineDatasets'), 
            store : storeDatasets, 
            cm : cmDatasets, 
            sm : smDatasets, 
            flex : 1, 
            autoScroll : true, 
            viewConfig : {
                forceFit : true 
            }, 
            plugins : [visible]
        });
        
        var firstPanel = new Ext.Panel({
            height : 300, 
            items : [this.propertyPanel, this.datasetPanel], 
            layout : "hbox", 
            collapsedTitle : i18n.get('label.advancedSearch'),
            region : "north",
            collapsible : true, 
            collapsed : true, 
            flex : 2, 
            layoutConfig : {
                align : "stretch"   
            }
        });
        /**
         * A simple button to launch the main request on each selected dataset. 
         */
        this.searchButton = new Ext.Button({
            text : i18n.get('label.search'),
            scope : this,
            handler : function (button) {
                this.onSearch(button);
            }
        });
        
        Ext.apply(this, {
            height : config.formHeight,
            layout : "border", 
            layoutConfig : {
                align : "stretch"
            },
            items : [ firstPanel, displayComponentPanel ],
            buttons : [this.searchButton], 
            listeners : {
                scope : this, 
                propertyChanged : function () {
                    var properties = this.propertyPanel.items.items;
                    var params = {};
                    var j = 0;
                    var k = {};
                    for (var i = 0; i < properties.length; i++) {
                        var prop = properties[i];
                        if (!Ext.isEmpty(prop.getAPIValue())) {
                            params["k[" + j + "]"] = prop.getAPIValue();
                            j++;
                        }
                    }
                    this.datasetPanel.getStore().load({
                        params : params
                    });
                }, 
                multiDsSearchDone : function () {
                    this.searchButton.setDisabled(false);
                }

            },            
            bbar : new Ext.ux.StatusBar({
                text : i18n.get('label.ready'),
                iconCls : 'x-status-valid',
                hidden : true
            })
        });
        sitools.user.component.forms.projectForm.superclass.initComponent.call(this);
    }, 
    /**
     * Build the query for the multiDs search
     * @param {Ext.Button} button The button that launch the request (to be disabled)
     * @returns
     */
    onSearch : function (button) {
        button.setDisabled(true);
        var containers = this.find("stype", 'sitoolsFormContainer');
        var formMultiDsParams = [];
        var glue = "";
        var i = 0;
        var datasets = [];
        this.datasetPanel.getStore().each(function (rec) {
            if (rec.get("visible")) {
                datasets.push(rec.get('id'));
            }
        });
        if (datasets.length <= 0) {
            Ext.Msg.alert(i18n.get('label.error'), i18n.get('label.atLeastOneDataset'));
            button.setDisabled(false);
            return;
        }
        
        if (! Ext.isEmpty(this.nbDatasetsMax) && datasets.length > this.nbDatasetsMax) {          
            Ext.Msg.alert(i18n.get('label.error'), String.format(i18n.get('label.toManyDatasetsAllowed'), this.nbDatasetsMax));
            button.setDisabled(false);
            return;
        }
        var valid = true;
        
        this.zonesPanel.items.each(function(componentList){
            valid = valid && componentList.isComponentsValid();            
        },this);
        
        if (!valid) {
            this.getBottomToolbar().setStatus({
                text : i18n.get('label.checkformvalue'),
                iconCls : 'x-status-error'
            });
            this.getBottomToolbar().setVisible(true);    
            button.setDisabled(false);
            return;
        } else {
            this.getBottomToolbar().setVisible(false);
        }
        
        Ext.each(containers, function (container) {
            // var f = form.getForm();

            if (Ext.isFunction(container.getParameterValue)) {
                var param = container.getParameterValue();
                
                if (!Ext.isEmpty(param)) {
                    formMultiDsParams.push(this.paramValueToApi(param));
                }
            }
        }, this);
        
        var urlService = projectGlobal.sitoolsAttachementForUsers + this.urlServiceDatasetSearch;
        
        var params = {};
        params.datasetsList = datasets.join("|");

        i = 0;
        
        if (!Ext.isEmpty(formMultiDsParams)) {
            Ext.each(formMultiDsParams, function (param) {
                params["c[" + i + "]"] = param;
                i += 1;
            }, this);
        }

        //Launch the first POST Request on service: 
        Ext.Ajax.request({
            method : "POST", 
            params : params, 
            //Just to be sure that params are passed with the url request
            jsonData : {}, 
            scope : this, 
            url : urlService, 
            success : function (response) {
                try {
                    var json = Ext.decode(response.responseText);
                    if (! json.success) {
                        Ext.Msg.alert(i18n.get('label.error'), json.message);
                        return;
                    }
                    var jsObj = SitoolsDesk.navProfile.multiDataset.getObjectResults();
                    var componentCfg = {
                        urlTask : json.TaskModel.statusUrl,
                        formId : this.formId,
                        formMultiDsParams : formMultiDsParams,
                        datasets : datasets, 
                        formName : this.formName, 
                        callerId : this.id
                    };

                    var windowConfig = {
                        id : "windMultiDsResultForm" + this.formId, 
                        title : i18n.get('label.MultiDsResultForm') + " : " + this.formName, 
                        saveToolbar : false, 
                        iconCls : "dataviews"
                    };
                    SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
                    
                }
                catch (err) {
                    Ext.Msg.alert(i18n.get('label.error'), err);
                    return;
                }
            }, 
                
            failure : alertFailure
        });
        var desktop = getDesktop();
        var win = desktop.getWindow("windMultiDsResultForm" + this.formId);
        if (win) {
            win.close();
        }

    },
    /**
     * A method to save all the window settings to be abble to reload it when desktop is reloaded. 
     * @return {}
     */
    _getSettings : function () {
        return {
            objectName : "projectForm", 
        	formId : this.formId,
            formName : this.formName,
            formParameters : this.formParameters,
            formWidth : this.formWidth,
            formHeight : this.formHeight, 
            formCss : this.formCss, 
            properties : this.properties, 
            urlServicePropertiesSearch : this.urlServicePropertiesSearch, 
            urlServiceDatasetSearch : this.urlServiceDatasetSearch, 
            componentType : this.componentType, 
            dictionaryName : this.dictionaryName,
            preferencesPath : this.preferencesPath, 
            preferencesFileName : this.preferencesFileName,
            formZones : this.zones
            
        };
    }, 
    /**
     * Build a string using a form param Value. 
     * @param {} paramValue An object with attributes : at least type, code, value and optionnal userDimension, userUnit
     * @return {string} something like "TEXTFIELD|ColumnAlias|value"
     */
    paramValueToApi : function (paramValue) {
        var stringParam = paramValue.type + "|" + this.dictionaryName + "," + paramValue.code + "|" + paramValue.value;
        if (!Ext.isEmpty(paramValue.userDimension) && !Ext.isEmpty(paramValue.userUnit)) {
            stringParam += "|" + paramValue.userDimension + "|" + paramValue.userUnit.unitName; 
        }  
        return stringParam;
    }, 
    /**
     * Returns the search Button. 
     * @return {}
     */
    getSearchButton : function () {
        return this.searchButton;
    }, 
    /**
     * Build for a properties a new formField depending on property type. 
     * The property type could be one of : 
     *  - TEXTFIELD, 
     *  - NUMERIC_FIELD, 
     *  - NUMERIC_BETWEEN, 
     *  - DATE_BETWEEN
     * @param {} prop the Json definition of a property. 
     * @return {Ext.form.Field} a simple or composite field. 
     */
    buildPropertyField : function (prop) {
        var field;
        switch (prop.type) {
        case "TEXTFIELD" : 
            field = {
                xtype : "textfield", 
                name : prop.name, 
                anchor : '98%', 
                enableKeyEvents : true, 
                fieldLabel : prop.name, 
                getAPIValue : function () {
                    if (Ext.isEmpty(this.getValue())) {
                        return null;
                    }
                    return String.format("{0}|{1}|{2}", prop.type, prop.name, this.getValue());
                }
            };          
            break;
        case "NUMBER_FIELD" : 
            field = {
                xtype : "numberfield", 
                name : prop.name, 
                anchor : '98%', 
                enableKeyEvents : true, 
                fieldLabel : prop.name, 
                getAPIValue : function () {
                    if (Ext.isEmpty(this.getValue())) {
                        return null;
                    }
                    return String.format("{0}|{1}|{2}", prop.type, prop.name, this.getValue());
                }
            };          
            break;
        case "NUMERIC_BETWEEN" : 
            field = {
                xtype: 'compositefield',
                defaults: {
                    flex: 1
                },
                msgTarget: 'under',
                anchor : '98%', 
                items: [
                    {
                        xtype: 'numberfield',
                        name : prop.name + "deb", 
                        enableKeyEvents : true
                    },
                    {
                        xtype: 'numberfield',
                        name : prop.name + "fin"
                
                    }
                ],
                fieldLabel : prop.name, 
                getAPIValue : function () {
                    var deb = this.items.itemAt(0).getValue();
                    var fin = this.items.itemAt(1).getValue();
                    if (Ext.isEmpty(deb) || Ext.isEmpty(fin)) {
                        return null;
                    }
                    return String.format("{0}|{1}|{2}|{3}", prop.type, prop.name, deb, fin);
                }
            };          
            break;
        case "DATE_BETWEEN" : 
            field = {
                xtype: 'compositefield',
                defaults: {
                    flex: 1
                },
                msgTarget: 'under',
                anchor : '98%', 
                items: [
                    {
                        xtype: 'datefield',
                        name : prop.name + "deb", 
                        enableKeyEvents : true, 
                        format : SITOOLS_DEFAULT_IHM_DATE_FORMAT, 
                        showTime : true
                    },
                    {
                        xtype: 'datefield',
                        name : prop.name + "fin", 
                        format : SITOOLS_DEFAULT_IHM_DATE_FORMAT, 
                        showTime : true
                
                    }
                ],
                fieldLabel : prop.name, 
                getAPIValue : function () {
                    var deb, fin;
                    try {
                        deb = this.items.itemAt(0).getValue().format(SITOOLS_DATE_FORMAT);
                        fin = this.items.itemAt(1).getValue().format(SITOOLS_DATE_FORMAT);
                    
                    }
                    catch (err) {
                        return null;
                    }
                    if (Ext.isEmpty(deb) || Ext.isEmpty(fin)) {
                        return null;
                    }
                    return String.format("{0}|{1}|{2}|{3}", prop.type, prop.name, deb, fin);
                }
            };          
            break;
        }
        return field;
    }, 
    /**
     * Method called when user pressed on refresh Datasets button. 
     * Course properties and creates the parameters of the query to search the list of datasets
     */
    propertySearch : function () {
        var properties = this.propertyPanel.items.items;
        var params = {};
        var j = 0;
        var k = {};
        for (var i = 0; i < properties.length; i++) {
            var prop = properties[i];
            if (!Ext.isEmpty(prop.getAPIValue())) {
                params["k[" + j + "]"] = prop.getAPIValue();
                j++;
            }
        }
        this.datasetPanel.getStore().load({
            params : params
        });
        this.datasetPanel.getView().refresh();
    }
    
});

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, userLogin, DEFAULT_WIN_HEIGHT, DEFAULT_WIN_WIDTH, getDesktop, projectGlobal, SitoolsDesk, DEFAULT_PREFERENCES_FOLDER*/
/*global loadUrl*/
/*
 * @include "../../../../client-public/js/forms/formParameterToComponent.js"
 */
Ext.namespace('sitools.user.component');

/**
 * The container (absolute Layout) that contains all the containers with each parameter
 * @cfg {number} width The width Form
 * @cfg {number} height the Height Form
 * @cfg {string} css A specific Css Class
 * @cfg {string} formId the Form Id
 * @cfg {Ext.grid.ColumnModel} datasetCm The dataset ColumnModel
 * @class sitools.user.component.formComponentsPanel
 * @extends Ext.Panel
 */
sitools.user.component.formComponentsPanel = Ext.extend(Ext.Panel, {
//sitools.component.users.datasets.formsContainer = Ext.extend(Ext.Panel, {
    
    initComponent : function () {
//        this.indexes = new Array();
//        this.loadParameters (this.formParameters,
//        this.formParameters[0].code);

        Ext.apply(this, {
//            title: this.formName,
//            id : "panelResultForm" + this.formId, 
            bodyCssClass : this.css,
            height : this.height,
            width : this.width,
//            border : false,
//            bodyBorder : false,
//            collapsible: true,
            layout : "form",
            labelWidth : 100,
            autoHeight : true,
//            width:600,
            padding : 10,
            items : [],

            /** The parameters retrieved from server. * */
            parameters : []
        });
        this.addEvents(
        /**
         * @event added
         * Fires when a parameter changes the value
         * @param formContainer : this
         * @param componentChanged : the component that triggered the event
         */
            'componentChanged'
        );
        
        this.on('componentChanged', function (formContainer, componentChanged) {
            //look for all the childrens of the component 
            var childrens = formContainer.find("parentParam", componentChanged.parameterId);
            //For each children, add a query string on the componentChanged value and reset children Value. 
            //Also, fire the event ComponentChanged for the children to cascade changes. 
            Ext.each(childrens, function (children) {
                if (children.valueSelection == 'D') {
                    var store = children.find("stype",  "sitoolsFormItem")[0].store;
                
                    var baseParams = store.baseParams;
                    
                    if (!Ext.isEmpty(componentChanged.getSelectedValue())) {
                        var filter = componentChanged.getParameterValue();
                        baseParams["p[0]"] = this.paramToAPI(filter);
                    }
                    else {
                        baseParams["p[0]"] = null;
                    }
                    store.baseParams = baseParams;
                    children.setSelectedValue(null);
                    store.reload({
                        callback : function () {
                            formContainer.fireEvent('componentChanged', formContainer, children);    
                        }
                    });
                    
                    
                } 
            }, this);
        });
        this.listeners = {
            scope : this,
            afterrender : function () {
                try {
	                var cmpChildSize = this.getSize();
	                var size = this.ownerCt.ownerCt.body.getSize();
	                var xpos = 0, ypos = 0;
	                if (size.height > cmpChildSize.height) {
	                    ypos = (size.height - cmpChildSize.height) / 2;
	                }
	                if (size.width > cmpChildSize.width) {
	                    xpos = (size.width - cmpChildSize.width) / 2;
	                }
	                this.setPosition(xpos, ypos);
                }
                catch (err) {
                	return;
                }
                this.doLayout();
            }
        };
        sitools.user.component.formComponentsPanel.superclass.initComponent.apply(this, arguments);
    },
    /**
     * Construct a container for each parameter
     * @param {Array} parameters array of parameters
     * @param {string} dataUrl the Url to request the data
     * @param {string} context the context should be "dataset" or "project"
     */
    loadParameters : function (parameters, dataUrl, context) {
        
        if (!Ext.isEmpty(parameters.formZones)){
            Ext.each(parameters.formZones, function(zone){
                var zoneFieldset = new Ext.form.FieldSet({
                    title : (!Ext.isEmpty(zone.title) ? zone.title : zone.id),
                    itemId : zone.id,
                    height : zone.height,
                    position : zone.position,
                    style : 'background-color:#FCFCFC;',
                    cls : zone.css,
                    animCollapse : true,
                    collapsible: zone.collapsible,
                    isCollapsed : zone.collapsed,
                    formId : this.formId,
                    datasetCm : this.datasetCm,
                    layout : 'absolute',
                    listeners : {
                        render : function (fieldset) {
                            if (fieldset.isCollapsed){
                                fieldset.collapse(true);
                            }
                        }
                    }
                });
                
                Ext.each(zone.params, function (param){
                    var y = Ext.isEmpty(param.ypos) ? y + 50 : param.ypos;
                    var x = Ext.isEmpty(param.xpos) ? x : param.xpos;
                    var containerItems = [ sitools.common.forms.formParameterToComponent(param, dataUrl, this.formId, this.datasetCm, context, this).component];

                    var container = new Ext.Container({
                        width : param.width,
                        height : param.height,
                        x : x,
                        y : y,
                        bodyCssClass : "noborder",
                        cls : param.css,
                        items : containerItems
                    });
                    zoneFieldset.add(container);
                    
                }, this);
                
                this.add(zoneFieldset);
                
            }, this);
        } else {
//            this.layout = 'absolute';
            Ext.each(parameters.oldParameters, function (parameter) {
                var y = Ext.isEmpty(parameter.ypos) ? y + 50 : parameter.ypos;
                var x = Ext.isEmpty(parameter.xpos) ? x : parameter.xpos;
                
                var containerItems = [ sitools.common.forms.formParameterToComponent(parameter, dataUrl, this.formId, this.datasetCm, context, this).component];
                
                var container = new Ext.Container({
                    width : parameter.width,
                    height : parameter.height,
                    x : x,
                    y : y,
                    bodyCssClass : "noborder",
                    cls : parameter.css,
                    items : containerItems
                });
                this.add(container);
            }, this);
        }
    }, 
    paramToAPI : function (paramValue) {
		var stringParam = paramValue.type + "|" + paramValue.code + "|" + paramValue.value;
        if (!Ext.isEmpty(paramValue.userDimension) && !Ext.isEmpty(paramValue.userUnit)) {
			stringParam += "|" + paramValue.userDimension + "|" + paramValue.userUnit.unitName; 
        }  
        return stringParam;
    },
    /**
     * Check that all the components are valid
     * @return {boolean} true if all components are valid, false otherwise
     */
    isComponentsValid : function () {
        var valid = true;
        var containers = this.find("stype", 'sitoolsFormContainer');
        Ext.each(containers, function (container) {
            if(Ext.isFunction(container.isValid)) {
                if(!container.isValid()){
                    valid = false;
                    return;
                }
            }
        });
        return valid;
    }
});

Ext.reg('sitools.user.component.formComponentsPanel', sitools.user.component.formComponentsPanel);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, userLogin, DEFAULT_WIN_HEIGHT, DEFAULT_WIN_WIDTH, getDesktop, projectGlobal, SitoolsDesk, DEFAULT_PREFERENCES_FOLDER*/
/*global loadUrl*/
/*
 * @include "formComponentsPanel.js"
 */
Ext.namespace('sitools.user.component.forms');

/**
 * The global Panel. A panel with a formComponentsPanel and the buttons. 
 * @cfg {string} dataUrl Attachement Url of the dataset
 * @cfg {string} datasetId datasetId 
 * @cfg {string} datasetName Dataset Name
 * @cfg {Ext.grid.ColumnModel} datasetCm Column model of the dataset
 * @cfg {string} formId Form Id
 * @cfg {string} formName Form Name
 * @cfg {Array} formParameters Array of form parameters
 * @cfg {Array} formZones Array of form Zones containing parameters
 * @cfg {number} formWidth Form Width 
 * @cfg {number} formHeight Form Height 
 * @cfg {string} formCss Name of a specific css class to apply to form
 * @cfg {string} datasetView Name of the datasetView Object
 * @cfg {Array} dictionaryMappings the Mapping between dataset column Model and concepts
 * @class sitools.user.component.forms.mainContainer
 * @extends Ext.Panel
 * @requires sitools.user.component.formComponentsPanel
 */
sitools.user.component.forms.mainContainer = function (config) {
//sitools.component.users.datasets.forms = function (config) {
    Ext.apply(this, config);
    this.componentType = "form";
    
    var panelIdObject = {};
    
    // New Form model with zones
    if (!Ext.isEmpty(this.formZones)){
        Ext.each(this.formZones, function(formParam) { 
            var containerId = formParam.containerPanelId;
            if (Ext.isEmpty(panelIdObject[containerId])){
                panelIdObject[containerId] = [];
            }
            panelIdObject[containerId].push(formParam);
        });
    } else { // old form model
        Ext.each(config.formParameters, function(formParam) { 
            var containerId = formParam.containerPanelId;
            if (Ext.isEmpty(panelIdObject[containerId])){
                panelIdObject[containerId] = [];
            }
            panelIdObject[containerId].push(formParam);
        });
    }
    
    var items = [];
    var globalParams = {};
    
    Ext.iterate(panelIdObject, function(key, formParams){
    	var componentList = new  sitools.user.component.formComponentsPanel({
            border: true,
            css : config.formCss, 
            formId : config.formId,
            id : key
    	});

        if (!Ext.isEmpty(this.formZones)) {
            globalParams.formZones = formParams;
        } else {
            globalParams.oldParameters = formParams;
        }

        componentList.datasetCm = config.dataset.columnModel;
        componentList.loadParameters(globalParams, config.dataUrl, "dataset");

		items.push(componentList);
    }, this);
    
    this.zonesPanel = new Ext.Panel({
        width : config.formWidth,
        height : config.formHeight,
        css : config.formCss, 
        formId : config.formId,
        items : [items]
    });
    
    if (Ext.isEmpty(config.dataset)) {
	    Ext.Ajax.request({
			url : config.dataUrl, 
			method : "GET", 
			scope : this, 
			success : function (ret) {
				if (showResponse(ret)) {
	                var json = Ext.decode(ret.responseText);
//	                this.componentList.datasetCm = json.dataset.columnModel;
//					this.componentList.loadParameters(config.formParameters, config.dataUrl, "dataset");
					this.datasetId = json.dataset.id;
					this.datasetName = json.dataset.name;
					this.datasetCm = json.dataset.columnModel;
		            this.datasetView = json.dataset.datasetView;
					this.dictionaryMappings = json.dataset.dictionaryMappings;
	            }
			}
		});
    }
    else {
//		this.componentList.datasetCm = config.dataset.columnModel;
//		this.componentList.loadParameters(config.formParameters, config.dataUrl, "dataset");
		this.datasetId = config.dataset.id;
		this.datasetName = config.dataset.name;
		this.datasetCm = config.dataset.columnModel;
        this.datasetView = config.dataset.datasetView;
		this.dictionaryMappings = config.dataset.dictionaryMappings;
    }
    
    sitools.user.component.forms.mainContainer.superclass.constructor.call(this, Ext.apply({
        height : config.formHeight,
        width : config.formWidth,
        autoScroll : true,
        bodyBorder : false,
        border : false,
        items : [this.zonesPanel],
        buttons : [ {
            text : i18n.get('label.search'),
            scope : this,
            handler : function () {
                this.onSearch(config);
            }
        } ],
        listeners : {
			scope : this, 
			resize : function () {
				if (!Ext.isEmpty(this.zonesPanel.getEl())) {
					var cmpChildSize = this.zonesPanel.getSize();
					var size = this.body.getSize();
					var xpos = 0, ypos = 0;
					if (size.height > cmpChildSize.height) {
						ypos = (size.height - cmpChildSize.height) / 2;
					}
					if (size.width > cmpChildSize.width) {
						xpos = (size.width - cmpChildSize.width) / 2;
					}
					this.zonesPanel.setPosition(xpos, ypos);
				}
				
			}
        },          
        bbar : new Ext.ux.StatusBar({
            text : i18n.get('label.ready'),
            iconCls : 'x-status-valid',
            hidden : true
        })
    }));

};
Ext.extend(sitools.user.component.forms.mainContainer, Ext.Panel, {
    onSearch : function (config) {
        
        var valid = true;
        
        this.zonesPanel.items.each(function(componentList){
            valid = valid && componentList.isComponentsValid();            
        },this);
        
        if (!valid) {
            this.getBottomToolbar().setStatus({
                text : i18n.get('label.checkformvalue'),
                iconCls : 'x-status-error'
            });
            this.getBottomToolbar().setVisible(true);    
            return;
        } else {
            this.getBottomToolbar().setVisible(false);
        }
		//Execute a request to get the dataset config 
		Ext.Ajax.request({
			url : config.dataUrl, 
			method : "GET", 
			scope : this, 
			success : function (ret) {
                var Json = Ext.decode(ret.responseText);
                if (!Json.success) {
                    Ext.Msg.alert(i18n.get('label.warning'), Json.message);
                    return;
                } else {
					var dataset = Json.dataset;
					this.doSearch(config, dataset);
                }
			},
			failure : alertFailure
		});
    }, 
    
    /**
     * Build the query for the liveGrid and build the livegrid component
     * @param config
     * @returns
     */
    doSearch : function (config, dataset) {
        var containers = this.find("stype", 'sitoolsFormContainer');
        var formParams = [];
        var glue = "";
        var i = 0;
        Ext.each(containers, function (container) {
            // var f = form.getForm();

            if (Ext.isFunction(container.getParameterValue)) {
	            var param = container.getParameterValue();
	            if (!Ext.isEmpty(param)) {
	                formParams.push(this.paramValueToApi(param));
	            }
            }
        }, this);

        var desktop = getDesktop();
        var win = desktop.getWindow("windResultForm" + config.formId);
        if (win) {
            win.close();
        }
        if (Ext.isFunction(this.searchAction)) {
        	this.searchAction(formParams, dataset, this.scope);
        }
        else {
        	this.defaultSearchAction(formParams, dataset);
        }
        
    },
    
    defaultSearchAction : function (formParams, dataset) {
        var jsObj = eval(dataset.datasetView.jsObject);
        var componentCfg = {
            dataUrl : dataset.sitoolsAttachementForUsers,
            datasetId : dataset.id,
            datasetCm : dataset.columnModel,
            datasetName : dataset.name, 
            formParams : formParams, 
            dictionaryMappings : dataset.dictionaryMappings, 
			datasetViewConfig : dataset.datasetViewConfig, 
            preferencesPath : "/" + dataset.name, 
            preferencesFileName : "datasetView"
        };
        var windowConfig = {
//            id : "windResultForm" + config.formId, 
            title : i18n.get('label.dataTitle') + " : " + dataset.name, 
            datasetName : dataset.name, 
            type : "data", 
            saveToolbar : true, 
            iconCls : "dataviews"
        };
        SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj);
    }, 
    
    _getSettings : function () {
        return {
			objectName : "forms", 
			dataUrl : this.dataUrl,
			dataset : this.dataset,
            formId : this.formId,
            formName : this.formName,
            formParameters : this.formParameters,
            formWidth : this.formWidth,
            formHeight : this.formHeight, 
            formCss : this.formCss, 
            datasetView : this.datasetView,
            dictionaryMappings : this.dictionaryMappings, 
            preferencesPath : this.preferencesPath, 
            preferencesFileName : this.preferencesFileName
        };
    }, 
    /**
     * Build a string using a form param Value. 
     * @param {} paramValue An object with attributes : at least type, code, value and optionnal userDimension, userUnit
     * @return {string} something like "TEXTFIELD|ColumnAlias|value"
     */
    paramValueToApi : function (paramValue) {
		var stringParam = paramValue.type + "|" + paramValue.code + "|" + paramValue.value;
        if (!Ext.isEmpty(paramValue.userDimension) && !Ext.isEmpty(paramValue.userUnit)) {
			stringParam += "|" + paramValue.userDimension + "|" + paramValue.userUnit.unitName; 
        }  
        return stringParam;
    }
});

/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/* global Ext, i18n, sitools, formPanel, result, window, SitoolsDesk, loadUrl */
/*
 * @include "openSearchResultFeed.js"
 */
Ext.namespace('sitools.user.component');
// sitools.component.users.datasets.datasetOpensearch = function (config) {
/**
 * A Panel to display OpenSearch queries and result.
 * 
 * @cfg {string} datasetId DatasetId
 * @cfg {string} datasetUrl the attachementUrl of the dataset
 * @cfg {string} datasetName the dataset Name.
 * @class sitools.user.component.datasetOpensearch
 * @extends Ext.Panel
 * @requires sitools.user.component.openSearchResultFeed
 */
sitools.user.component.datasetOpensearch = function(config) {

	Ext.apply(this, config);
	// set the uri for the opensearch engine
	// exemple de requete avec pagination
	// http://localhost:8182/sitools/solr/db?q=fu*&start=10&rows=20
	var uri = config.dataUrl + "/opensearch/search";
	var uriSuggest = config.dataUrl + "/opensearch/suggest";

	/**
	 * click handler for the search button gets the search query and update the
	 * RSS feed URI to display the results
	 */
	function _clickOnSearch() {
		// create the opensearch url
		var searchQuery = formPanel.getForm().getValues().searchQuery;
		result.updateStore(uri + "?q=" + searchQuery);
	}

	var search;
	var ds = new Ext.data.JsonStore({
				url : uriSuggest,
				restful : true,
				root : 'data',
				fields : [{
							name : 'field',
							type : 'string'
						}, {
							name : 'name',
							type : 'string'
						}, {
							name : 'nb',
							type : 'string'
						}]
			});

	// Custom rendering Template
	var resultTpl = new Ext.XTemplate('<tpl for="."><div class="search-item">',
			'<h3>{name}<span> ({field} / {nb} results ) </span></h3>',
			'</div></tpl>');

	search = new Ext.form.ComboBox({
				store : ds,
				displayField : 'name',
				typeAhead : false,
				loadingText : i18n.get("label.searching"),
				hideTrigger : true,
				name : 'searchQuery',
				anchor : "90%",
				tpl : resultTpl,
				itemSelector : 'div.search-item',
				minChars : 2,
				queryParam : 'q',
				enableKeyEvents : true,
				scope : this,
				listeners : {
					scope : this,
					beforequery : function(queryEvent) {
						if (queryEvent.query.indexOf(" ") == -1) {
							return true;
						} else {
							return false;
						}
					},
					specialkey : function(field, e) {
						if (e.getKey() == e.ENTER) {
							_clickOnSearch();
						}
					},
					beforeselect : function(self, record, index) {
						var tabName = record.data.name.split(':');
						if (tabName.length > 1) {
							record.data.name = tabName[1];
						}

						record.data.name = record.data.field + ":"
								+ record.data.name;
						return true;
					}

				}

			});

	var link = new Ext.Button({
				icon : loadUrl.get('APP_URL')
						+ '/common/res/images/icons/help.png',
				scope : this,
				handler : function() {
					var helpModule = SitoolsDesk.app.findModule("helpWindow");
					if (!Ext.isEmpty(helpModule.getWindow())) {
						helpModule.getWindow().close();
					}
					helpModule.openModule({
								activeNode : "Recherche_OpenSearch"
							});
				},
				width : 20

			});
	var field = new Ext.form.CompositeField({
				fieldLabel : i18n.get("label.search"),
				anchor : '100%',
				defaults : {
					flex : 1
				},
				items : [search, link]
			});

	// set the items of the form
	var items = field;

	// set the search button
	var buttonForm = [{
				text : i18n.get("label.search"),
				scope : this,
				handler : _clickOnSearch
			}];

	// set the search form
	var formPanel = new Ext.FormPanel({
				labelWidth : 75, // label settings here cascade unless
									// overridden
				height : 75,
				frame : true,
				defaultType : 'textfield',
				items : items,
				buttons : buttonForm

			});

	// instanciate the RSS feed component
	var result = new sitools.user.component.openSearchResultFeed({
				input : search,
				dataUrl : config.dataUrl,
				pagging : true,
				datasetName : config.datasetName,
				datasetId : config.datasetId,
				exceptionHttpHandler : function(proxy, type, action, options,
						response, args) {
					// si on a un cookie de session et une erreur 403
					if ((response.status == 403)
							&& !Ext.isEmpty(Ext.util.Cookies.get('hashCode'))) {
						Ext.MessageBox.minWidth = 360;
						Ext.MessageBox.alert(i18n.get('label.session.expired'),
								response.responseText);
						return false;
					}
					return true;
				}
			});

	// instanciate the panel component
	sitools.user.component.datasetOpensearch.superclass.constructor.call(this,
			Ext.apply({
						items : [formPanel, result],
						layout : 'vbox',
						datasetName : config.datasetName,
						layoutConfig : {
							align : 'stretch',
							pack : 'start'
						}

					}, config));

};

Ext.extend(sitools.user.component.datasetOpensearch, Ext.Panel, {
			componentType : "openSearch",
			_getSettings : function() {
				return {
					objectName : "datasetOpenSearch",
					datasetName : this.datasetName,
					preferencesPath : this.preferencesPath,
					preferencesFileName : this.preferencesFileName
				};
			}
		});

Ext.reg('sitools.user.component.datasetOpensearch',
		sitools.user.component.datasetOpensearch);
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*
 * global Ext, sitools, i18n, window, userLogin, projectGlobal, SitoolsDesk,
 * DEFAULT_PREFERENCES_FOLDER, loadUrl, onRequestFeedException
 */
/*
 * @include "../viewDataDetail/simpleViewDataDetails.js" @include
 * "../viewDataDetail/viewDataDetail.js"
 */

Ext.namespace('sitools.user.component');

/**
 * Component used to display opensearch results param : url : the url of the RSS
 * feed
 * 
 * @cfg {string} urlFeed the url of the feed
 * @cfg {string} input The input value to set
 * @cfg {boolean} autoLoad If the store needs to be loaded on start
 * @cfg {string} dataUrl the url of the dataset
 * @cfg {boolean} pagging true to activate the pagging, false otherwise
 * @cfg {} dsInfo informations about the dataset
 * @cfg {} exceptionHttpHandler the handler for httpProxy errors
 * @requires sitools.user.component.simpleViewDataDetail
 * @requires sitools.user.component.viewDataDetail
 * @class sitools.user.component.openSearchResultFeed
 * @extends Ext.grid.GridPanel
 */
sitools.user.component.openSearchResultFeed = function(config) {
	// sitools.component.users.datasets.openSearchResultFeed = function (config)
	// {
	this.pageSize = 10;
	var urlParam = config.urlFeed;
	this.input = config.input;
	this.uriRecords = config.dataUrl + "/records";
	var pagging = config.pagging;
	var url = (urlParam === undefined) ? "/tmp" : urlParam;

	var exceptionHttpHandler = (Ext.isEmpty(config.exceptionHttpHandler))
			? onRequestFeedException
			: config.exceptionHttpHandler;

	this.httpProxy = new Ext.data.HttpProxy({
				url : url,
				restful : true,
				listeners : {
					scope : this,
					exception : exceptionHttpHandler
				}
			});

	this.xmlReader = new sitools.component.users.datasets.XmlReader({
				record : 'item',
				totalProperty : 'opensearch:totalResults'
			}, ['title', 'link', 'guid', 'pubDate', 'description']);

	this.store = new Ext.data.Store({
				proxy : this.httpProxy,
				reader : this.xmlReader,
				autoLoad : config.autoLoad,
				paramNames : {
					start : 'start',
					limit : 'rows'
				},
				listeners : {
					scope : this,
					load : function(self, records, index) {
						if (!pagging && !Ext.isEmpty(this.displayNbResults)) {
							this.displayNbResults
									.setText('Total number of results : '
											+ this.store.getTotalCount());
							// this.getBottomToolbar().doLayout();
						}
						return true;
					},
					exception : function(proxy, type, action, options,
							response, arg) {
						var data = Ext.decode(response.responseText);
						if (!data.success) {
							this.input.markInvalid(i18n.get(data.message));
							this.store.removeAll();
						}
						return true;
					}
				}

			});

	this.store.setDefaultSort('pubDate', "DESC");

	// if (config.autoLoad !== null && config.autoLoad !== undefined &&
	// config.autoLoad) {
	// this.store.load();
	// }

	var columns = [{
				id : 'title',
				header : "Title",
				dataIndex : 'title',
				sortable : true,
				renderer : this.formatTitle
			}, {
				id : 'last',
				header : "Date",
				dataIndex : 'pubDate',
				renderer : this.formatDate,
				sortable : true

			}];

	if (pagging) {
		this.bbar = {
			xtype : 'paging',
			pageSize : this.pageSize,
			store : this.store,
			displayInfo : true,
			displayMsg : i18n.get('paging.display'),
			emptyMsg : i18n.get('paging.empty'),
			totalProperty : 'totalCount'
		};
	} else {
		this.displayNbResults = new Ext.form.Label({
					text : 'Total number of results : '
				});
		this.bbar = {
			items : ['->', this.displayNbResults

			]
		};
	}

	function clickOnRow(self, rowIndex, e) {
		e.stopEvent();
		var rec = self.store.getAt(rowIndex);
		var guid = rec.get("guid");
		if (Ext.isEmpty(guid)) {
			Ext.Msg.alert(i18n.get('label.warning'), i18n
							.get('warning.noGuidFieldDefined')
							+ "<br/>"
							+ i18n.get('warning.noPrimaryKeyDefinedOSNotice'));
			return;
		}
		// si on est pas sur le bureau
		if (Ext.isEmpty(window) || Ext.isEmpty(window.SitoolsDesk)) {
			var component = new sitools.user.component.simpleViewDataDetail({
						fromWhere : "openSearch",
						urlDataDetail : guid
					});
			var win = new Ext.Window({
						stateful : false,
						title : i18n.get('label.viewDataDetail'),
						width : 400,
						height : 600,
						shim : false,
						animCollapse : false,
						constrainHeader : true,
						layout : 'fit'
					});
			win.add(component);
			win.show();
		} else {
			var componentCfg = {
				grid : this,
				fromWhere : "openSearch",
				datasetId : config.datasetId,
				datasetUrl : config.dataUrl,
				datasetName : config.datasetName,
				preferencesPath : "/" + config.datasetName,
				preferencesFileName : "dataDetails"
			};
			var jsObj = sitools.user.component.viewDataDetail;

			var windowConfig = {
				id : "dataDetail" + config.datasetId,
				title : i18n.get('label.viewDataDetail') + " : "
						+ config.datasetName,
				datasetName : config.datasetName,
				iconCls : "openSearch",
				saveToolbar : true,
				type : "dataDetail",
				toolbarItems : [{
							iconCls : 'arrow-back',
							handler : function() {
								this.ownerCt.ownerCt.items.items[0]
										.goPrevious();
							}
						}, {
							iconCls : 'arrow-next',
							handler : function() {
								this.ownerCt.ownerCt.items.items[0].goNext();
							}
						}]
			};
			SitoolsDesk.addDesktopWindow(windowConfig, componentCfg, jsObj,
					true);
		}

	}

	sitools.user.component.openSearchResultFeed.superclass.constructor.call(
			this, {
				columns : columns,
				// hideHeaders : true,
				// region : 'center',
				layout : 'fit',
				flex : 1,
				store : this.store,
				loadMask : {
					msg : i18n.get("label.loadingFeed")
				},
				sm : new Ext.grid.RowSelectionModel({
							singleSelect : true
						}),
				autoExpandColumn : 'title',
				viewConfig : {
					forceFit : true,
					enableRowBody : true,
					showPreview : true,
					getRowClass : this.applyRowClass
				},
				listeners : {
					rowdblclick : clickOnRow
				}
			});

	this.updateStore = function(url) {
		this.httpProxy.setUrl(url, true);
		this.store.load();
	};

};

Ext.extend(sitools.user.component.openSearchResultFeed, Ext.grid.GridPanel, {
	componentType : "feeds",
	// within this function "this" is actually the GridView
	applyRowClass : function(record, rowIndex, p, ds) {
		if (this.showPreview) {
			var xf = Ext.util.Format;
			p.body = '<p class=sous-titre-flux>'
					+ xf.ellipsis(xf.stripTags(record.data.description), 200)
					+ '</p>';
			return 'x-grid3-row-expanded';
		}
		return 'x-grid3-row-collapsed';
	},

	formatDate : function(date) {
		if (!date) {
			return '';
		}
		var now = new Date();
		var d = now.clearTime(true);
		if (date instanceof Date) {
			var notime = date.clearTime(true).getTime();
			if (notime == d.getTime()) {
				return 'Today ' + date.dateFormat('g:i a');
			}
			d = d.add('d', -6);
			if (d.getTime() <= notime) {
				return date.dateFormat('D g:i a');
			}
			return date.dateFormat('n/j g:i a');
		} else {
			return date;
		}
	},

	/**
	 * Specific renderer for title Column
	 * 
	 * @param {}
	 *            value
	 * @param {}
	 *            p
	 * @param {Ext.data.Record}
	 *            record
	 * @return {string}
	 */
	formatTitle : function(value, p, record) {
		var link = record.data.link;
		var xf = Ext.util.Format;
		var res = "";
		if (link !== undefined && link !== "") {
			res = String
					.format(
							'<div class="topic"><a href="{0}" title="{1}"><span class="rss_feed_title">{2}</span></a></div>',
							link, value, xf.ellipsis(xf.stripTags(value), 30));
		} else {
			res = String
					.format(
							'<div class="topic"><span class="rss_feed_title">{0}</span></div>',
							xf.ellipsis(xf.stripTags(value), 30));
		}

		return res;
	}

});

Ext.reg('sitools.user.component.openSearchResultFeed',
		sitools.user.component.openSearchResultFeed);
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, alertFailure, window, loadUrl, sql2ext, SITOOLS_DEFAULT_IHM_DATE_FORMAT, ColumnRendererEnum, SITOOLS_DATE_FORMAT*/

Ext.namespace('sitools.user.component');

/**
 * Data detail Panel view. 
 * 
 * @cfg {string} fromWhere (required) :  "Ext.ux.livegrid" or "openSearch", "plot", "dataView"
 *       used to know how to determine the Url of the record
 * @cfg grid : the grid that contains all the datas 
 * @cfg {string} baseUrl  used only in "data" case. 
 *       used to build the url of the record. Contains datasetAttachement + "/records"
 * @cfg {string} datasetId the datasetId
 * @cfg {string} datasetUrl the dataset url attachment
 * @class sitools.user.component.viewDataDetail
 * @extends Ext.Panel
 */
sitools.user.component.viewDataDetail = Ext.extend(Ext.Panel, {
//sitools.component.users.viewDataDetail = Ext.extend(Ext.Panel, {
	datasetColumnModel : null,
    initComponent : function () {
        var rec;
        switch (this.fromWhere) {
		case "openSearch" : 
	        this.recSelected = this.grid.getSelectionModel().getSelected();
	        this.url = this.encodeUrlPrimaryKey(this.recSelected.data.guid);	        
			break;
		case "dataView" : 
			break;
        case "plot" : 
            break;
		default : 
			this.recSelected = this.selections[0];
	        if (Ext.isEmpty(this.recSelected)) {
				Ext.Msg.alert(i18n.get('label.error'), i18n.get('label.noSelection'));
				return;
	        }
	        var primaryKeyValue = "", primaryKeyName = "";
	        Ext.each(this.recSelected.fields.items, function (field) {
	            if (field.primaryKey) {
	                this.primaryKeyName = field.name;
	            }
	        }, this);
	        
			this.primaryKeyValue = this.recSelected.get(this.primaryKeyName);
	        
	        this.primaryKeyValue = encodeURIComponent(this.primaryKeyValue);
	        
	        this.url = this.baseUrl + this.primaryKeyValue;
			break;
        }
        
        
        this.layout = "border";

        this.linkStore = new Ext.data.Store({
	        fields : [ 'name', 'value', 'image', 'behavior', 'columnRenderer', 'html']
	    }); 
        
        var linkDataview = new Ext.DataView({
	        store : this.linkStore, 
	        tpl : new Ext.XTemplate('<ul>', '<tpl for=".">', 
	                '<li id="{name}" class="img-link"',
	                '<tpl if="this.hasToolTip(toolTip)">',
	                    'ext:qtip="{toolTip}">', 
	                '</tpl>',
	                '<tpl if="this.hasToolTip(toolTip) == false">',
                        'ext:qtip="{name}">', 
                    '</tpl>',
                    '{html}',
	                '</li>', '</tpl>', '</ul>', 
	                {
	                compiled : true, 
	                disableFormats : true,
	                hasToolTip : function (toolTip) {
	                    return !Ext.isEmpty(toolTip);
	                }
	            }),
	        cls : 'linkImageDataView',
	        itemSelector : 'li.img-link',
	        overClass : 'nodes-hover',
            selectedClass : '',
	        singleSelect : true,
	        multiSelect : false,
	        autoScroll : true,
	        listeners : {
	            scope : this,
	            click : this.handleClickOnLink	
	        }
	    });
        
        
        // set the text form
        this.formPanel = new Ext.FormPanel({
            labelAlign : "top",
            anchor : "100%",
            defaults : {
                labelStyle: 'font-weight:bold;'
            },
            padding : 10
            
        });
        
        // set the text form
        this.linkPanel = new Ext.Panel({
            title : i18n.get("label.complementaryInformation"),
            items : [linkDataview],
            anchor : "100%"
        });
        
        // set the search form
        this.formPanelImg = new Ext.FormPanel({
            frame : true,
            autoScroll : true,
            region : "east", 
            hideLabels : true,
            split : (this.fromWhere !== 'dataView'), 
            collapsible : (this.fromWhere !== 'dataView'), 
//            collapsed : (this.fromWhere !== 'dataView'),
            collapsed : false,
            flex : 1,
            title : ((this.fromWhere === 'dataView') ? i18n.get("label.formImagePanelTitle") : null),
            listeners : {
                scope : this,
                expand : function (panel) {
                    
                } 
            }
        });
        
        var centerPanelItems;
        if (this.fromWhere === 'dataView') {
            centerPanelItems = [this.formPanel, this.formPanelImg, this.linkPanel];
        }
        else {
            centerPanelItems = [this.formPanel, this.linkPanel];
        }
        
        //set the center Panel
        this.centerPanel = new Ext.Panel({
            autoScroll : true,
            frame : true,
            region : "center", 
            split : true, 
            layout : {
                type : 'anchor'             
            },
            items : centerPanelItems
        });

       
        this.getCmDefAndbuildForm();
        
        this.componentType = 'dataDetail';
        if (this.fromWhere == 'dataView') {
			this.items = [this.centerPanel];
        }
        else {
			this.items = [ this.centerPanel, this.formPanelImg ];
        }

        this.listeners = {
			scope : this, 
			afterrender : function (panel) {
				panel.getEl().on("contextmenu", function (e, t, o) {
					e.stopPropagation();
				}, this);
			}
        };
        sitools.user.component.viewDataDetail.superclass.initComponent.call(this);
    }, 
    
    afterRender : function () {
        this._loadMaskAnchor = Ext.get(this.body.dom);
	    
        sitools.user.component.viewDataDetail.superclass.afterRender.apply(this, arguments);
       
        
        
    },
    /**
     * Need to save the window Settings
     * @return {}
     */
    _getSettings : function () {
        return {
            objectName : "viewDataDetail", 
            preferencesPath : this.preferencesPath, 
            preferencesFileName : this.preferencesFileName
        };
    }, 
    /**
     * Go to the Next record of the grid passed into parameters
     */
    goNext : function () {
		if (Ext.isEmpty(this.grid)) {
			return;
		}
		var rec, rowSelect;
		switch (this.fromWhere) {
		case "openSearch" : 
			rowSelect = this.grid.getSelectionModel();
	        if (! rowSelect.selectNext()) {
	            return;
	        }
	        rec = rowSelect.getSelected();
			this.url = this.encodeUrlPrimaryKey(rec.data.guid);
			break;
		case "sitools.user.component.dataviews.tplView.TplView" : 
			var index = this.grid.getStore().indexOf(this.recSelected);
			var nextRec = this.grid.getStore().getAt(index + 1);
			if (Ext.isEmpty(nextRec)) {
				return;
			}
			this.primaryKeyValue = nextRec.get(this.primaryKeyName);
            this.primaryKeyValue = encodeURIComponent(this.primaryKeyValue);
            this.url = this.baseUrl + this.primaryKeyValue;
			this.recSelected = nextRec;
            this.grid.select(nextRec);
			break;
		default : 
			rowSelect = this.grid.getSelectionModel();
	        if (! rowSelect.selectNext()) {
	            return;
	        }
	        rec = rowSelect.getSelected();
            this.primaryKeyValue = rec.get(this.primaryKeyName);
            this.primaryKeyValue = encodeURIComponent(this.primaryKeyValue);
            this.url = this.baseUrl + this.primaryKeyValue;
			break;
		}

        this.getCmDefAndbuildForm();	
    }, 
    /**
     * Go to the Previous record of the grid passed into parameters
     */
    goPrevious : function () {
		if (Ext.isEmpty(this.grid)) {
			return;
		}
		var rec, rowSelect;
		switch (this.fromWhere) {
		case "openSearch" : 
			rowSelect = this.grid.getSelectionModel();
	        if (! rowSelect.selectPrevious()) {
	            return;
	        }
	        rec = rowSelect.getSelected();
            this.url = this.encodeUrlPrimaryKey(rec.data.guid);
            break;
		case "sitools.user.component.dataviews.tplView.TplView" : 
			var index = this.grid.getStore().indexOf(this.recSelected);
			var nextRec = this.grid.getStore().getAt(index - 1);
			if (Ext.isEmpty(nextRec)) {
				return;
			}
			this.primaryKeyValue = nextRec.get(this.primaryKeyName);
            this.primaryKeyValue = encodeURIComponent(this.primaryKeyValue);
            this.url = this.baseUrl + this.primaryKeyValue;
			this.recSelected = nextRec;
            this.grid.select(nextRec);
			break;
		default : 
			rowSelect = this.grid.getSelectionModel();
	        if (! rowSelect.selectPrevious()) {
	            return;
	        }
	        rec = rowSelect.getSelected();
            this.primaryKeyValue = rec.get(this.primaryKeyName);
            this.primaryKeyValue = encodeURIComponent(this.primaryKeyValue);
            this.url = this.baseUrl + this.primaryKeyValue;
			break;
		}

        this.getCmDefAndbuildForm();	    
       
    }, 
    /**
     * Build the form according with the values loaded via the Url
     */
    getCmDefAndbuildForm : function () {
        if (Ext.isEmpty(this.datasetColumnModel)) {
		    Ext.Ajax.request({
	            url : this.datasetUrl,
	            method : 'GET',
	            scope : this,
	            success : function (ret) {
					try {
						var Json = Ext.decode(ret.responseText);
						if (!Json.success) {
							throw Json.message;
						}
						this.datasetColumnModel = Json.dataset.columnModel;
						this.buildForm();
					}
					catch (err) {
						Ext.Msg.alert(i18n.get('label.error'), err);
					}
					
	            }, 
	            failure : alertFailure
	        });        
	    }
	    else {
			this.buildForm();
	    }
    }, 
    buildForm : function () {
        
	    if (!Ext.isEmpty(this._loadMaskAnchor)) {
            this._loadMaskAnchor.mask(i18n.get('label.waitMessage'), "x-mask-loading");
        }

        if (!Ext.isEmpty(this.url)) {
            this.linkStore.removeAll();
	        Ext.Ajax.request({
	            url : this.url,
	            method : 'GET',
	            scope : this,
	            success : function (ret) {
	                var data = Ext.decode(ret.responseText);
	                var itemsForm = [];
	                var itemsFormImg = [];
	                if (!data.success) {
	                    Ext.Msg.alert(i18n.get('label.information'), "Server error");
	                    return false;
	                }
	                var record = data.record;
	                var id = record.id;
	                var attributes = record.attributeValues;
	                if (attributes !== undefined) {
	                    var i;
	                    for (i = 0; i < attributes.length; i++) {
	                        var name = attributes[i].name;
	                        
	                        var column = this.findColumn(name);
	                        var value = attributes[i].value;
	                        var valueFormat = value;
	                        
	                        if (sql2ext.get(column.sqlColumnType) == 'dateAsString') {
				                valueFormat = sitools.user.component.dataviews.dataviewUtils.formatDate(value, column);
				            }
				            if (sql2ext.get(column.sqlColumnType) == 'boolean') {
				                valueFormat = value ? i18n.get('label.true') : i18n.get('label.false');
				            }
	                        
	                        var item = new Ext.BoxComponent({
                                fieldLabel : column.header,
                                labelSeparator : "", 
                                html : (Ext.isEmpty(valueFormat) || !Ext.isFunction(valueFormat.toString))
												? valueFormat
												: valueFormat.toString()
                            });
	                        
	                        if (Ext.isEmpty(column) || Ext.isEmpty(column.columnRenderer)) {
		                        itemsForm.push(item);                                
		                    }
		                    else {
                                var columnRenderer = column.columnRenderer;
                                var behavior = "";
                                if (!Ext.isEmpty(column.columnRenderer)) {
                                    behavior = column.columnRenderer.behavior;
                                    var html = sitools.user.component.dataviews.dataviewUtils.getRendererHTML(column, {});
									switch (behavior) {
									case ColumnRendererEnum.URL_LOCAL :
					                case ColumnRendererEnum.URL_EXT_NEW_TAB :
					                case ColumnRendererEnum.URL_EXT_DESKTOP :
					                case ColumnRendererEnum.DATASET_ICON_LINK :
										if (! Ext.isEmpty(value)) {
	                                        if (!Ext.isEmpty(columnRenderer.linkText)) {
	                                            item = new Ext.BoxComponent({
		                                            fieldLabel : column.header,
					                                labelSeparator : "", 
		                                            html : String.format(html, value)
		                                        });	                                         
	                                            itemsForm.push(item);
							                } else if (!Ext.isEmpty(columnRenderer.image)) {
							                    var rec = {
	                                                name : name,
	                                                value : value,
	                                                image : columnRenderer.image.url,
	                                                behavior : behavior,
                                                    columnRenderer : columnRenderer,
                                                    toolTip : columnRenderer.toolTip,
                                                    html : html
                                                    
	                                            };
	                                            rec = new Ext.data.Record(rec);
	                                            this.linkStore.add(rec);                                            
							                }																	
										}                                    
										break;
	                                case ColumnRendererEnum.IMAGE_FROM_SQL : 
                                    case ColumnRendererEnum.IMAGE_THUMB_FROM_IMAGE :
	                                    if (! Ext.isEmpty(value)) {
	                                        var tooltip = "";
	                                        var imageUrl = "";
	                                        

	                                        if (!Ext.isEmpty(columnRenderer.toolTip)) {
	                                            tooltip = columnRenderer.toolTip;
	                                        }
	                                        else {
	                                            tooltip = column.header;
	                                        }
	                                        
						                    if (!Ext.isEmpty(columnRenderer.url)) {
						                        imageUrl = columnRenderer.url;
						                    } else if (!Ext.isEmpty(columnRenderer.columnAlias)) {
						                        imageUrl = this.findRecordValue(record, columnRenderer.columnAlias);            
						                    }
	                                        item = new Ext.BoxComponent({
	                                            html : String.format(html, value, imageUrl),
                                                tooltip : tooltip,
	                                            cls : "x-form-item"
	                                        });                                       
	                                    }
	                                    itemsFormImg.push(item);
	                                    break;
                                    case ColumnRendererEnum.NO_CLIENT_ACCESS :
                                        break;
									default : 
                                        item = new Ext.BoxComponent({
	                                        fieldLabel : column.header,
			                                labelSeparator : "", 
	                                        html : String.format(html, value)
	                                    });                                          
	                                    itemsForm.push(item);
	                                    break;
                                    }
		                        }
		                    }
                        }
	                    this.formPanel.removeAll();
	                    this.formPanelImg.removeAll();
	                    
                        this.formPanel.add(itemsForm);
	                    this.formPanel.doLayout();
                        
                        if (this.linkStore.getCount() === 0) {
                            this.linkPanel.setVisible(false);
                        } else {
                            this.linkPanel.setVisible(true);
                            this.linkPanel.doLayout();
                        }
                        
                        if (itemsFormImg.length === 0) {
                            this.formPanelImg.setVisible(false);
                        } else {
                            this.formPanelImg.add(itemsFormImg);
                            this.formPanelImg.setVisible(true);
                            this.linkPanel.doLayout();
                        }
                        
                        this.formPanelImg.doLayout();
	                    this.doLayout();
	                    if (this._loadMaskAnchor && this._loadMaskAnchor.isMasked()) {
							this._loadMaskAnchor.unmask();
						}
	                    
	                    //Register events on column values with featureTypes  
	                    this.registerClickEvent(attributes);
	                    
                    }
	            },
	            failure : function () {
	                alertFailure();
                    if (this._loadMaskAnchor && this._loadMaskAnchor.isMasked()) {
						this._loadMaskAnchor.unmask();
					}
	            }
	        });
	    }
    }, 
    findColumn : function (columnAlias) {
		var result = null;
		Ext.each(this.datasetColumnModel, function (column) {
			if (column.columnAlias == columnAlias) {
				result = column;
				return;
			}
		}, this);
		return result;
    },
    
    findRecordValue : function (record, columnAlias) {
        var result = null;
        Ext.each(record.attributeValues, function (attr) {
            if (attr.name == columnAlias) {
                result = attr.value;
                return;
            }
        }, this);
        return result;
    },
    
    handleClickOnLink : function (dataView, index, node, e) {
        var data = dataView.getRecord(node).data;
        var behavior = data.behavior;
        switch (behavior) {
        case ColumnRendererEnum.URL_LOCAL:
            sitools.user.component.dataviews.dataviewUtils.downloadData(data.value);
            break;
        case ColumnRendererEnum.URL_EXT_NEW_TAB  :
            window.open(data.value);
            break;
        case ColumnRendererEnum.URL_EXT_DESKTOP  :
            sitools.user.component.dataviews.dataviewUtils.showDisplayableUrl(data.value, data.columnRenderer.displayable);
            break;
        case ColumnRendererEnum.DATASET_ICON_LINK  :
            sitools.user.component.dataviews.dataviewUtils.showDetailsData(data.value, data.columnRenderer.columnAlias, data.columnRenderer.datasetLinkUrl);
            break;    
        default : 
            break;
            
        }
    }, 
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
        Ext.apply(config.windowSettings, {
			width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
			height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
		});
        SitoolsDesk.openModalWindow(me, config);
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
        Ext.apply(config.windowSettings, {
            width : config.windowSettings.winWidth || DEFAULT_WIN_WIDTH,
            height : config.windowSettings.winHeight || DEFAULT_WIN_HEIGHT
        });
        SitoolsDesk.openModalWindow(me, config);
    },
    
    encodeUrlPrimaryKey : function (url) {
      //get the end of the uri and encode it
        var urlSplited = url.split('/');
        var urlReturn = "";
        for (var i = 0; i < urlSplited.length; i++) {
            if (i < urlSplited.length - 1) {
                urlReturn += urlSplited[i] + "/";
            } else {
                urlReturn += encodeURIComponent(urlSplited[i]);
            }
        }
        return urlReturn;
    },
    
    callbackClickFeatureType : function (e, t, o) {
        e.stopEvent();
        var record = o.record;
        var controller = o.controller;            
        var column = o.column;
        sitools.user.component.dataviews.dataviewUtils.featureTypeAction(column, record, controller);
    },
    
    
    registerClickEvent : function (attributes) {
        
        var nodeFormPanel = this.formPanel.getEl().dom;
        var featureTypeNodes = Ext.DomQuery.jsSelect(".featureType", nodeFormPanel);
        
        var formPanelImgPanel = this.formPanelImg.getEl().dom;
        featureTypeNodes = featureTypeNodes.concat(Ext.DomQuery.jsSelect(".featureType", formPanelImgPanel));

        var linkImagePanel = this.linkPanel.getEl().dom;
        featureTypeNodes = featureTypeNodes.concat(Ext.DomQuery.jsSelect(".featureType", linkImagePanel));
        
        var controller = this.grid.getTopToolbar().guiServiceController;
        
        //Create a Record from the attribute Values 
        var jsonObj = {};
        Ext.each(attributes, function (attribute) {
            jsonObj[attribute.name] = attribute.value;
        });
        
        
        Ext.each(featureTypeNodes, function (featureTypeNode) {
            var featureTypeNodeElement = Ext.get(featureTypeNode);
            
            var columnAlias = featureTypeNodeElement.getAttribute("column", "sitools");
            var column = this.findColumn(columnAlias);
            
            featureTypeNodeElement.addListener("click", this.callbackClickFeatureType, this, {
                record : new Ext.data.Record(jsonObj),
                controller : controller,
                column : column
            });
        }, this);
            

        if (this.formPanelImg.collapsible && this.formPanelImg.isVisible()) {    
            this.formPanelImg.collapse();
        }
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, alertFailure*/

Ext.namespace('sitools.user.component');

/**
 * A simple form view to visualize a record. 
 * Builds a form Panel with a form item for each field of the record.
 * @cfg {string} urlDataDetail the url to request the Record.
 * @class sitools.user.component.simpleViewDataDetail
 * @extends Ext.Panel
 */
sitools.user.component.simpleViewDataDetail = Ext.extend(Ext.Panel, {
//sitools.component.users.simpleViewDataDetail = Ext.extend(Ext.Panel, {

    initComponent : function () {
        this.url = this.urlDataDetail;
        //get the end of the uri and encode it
        var urlSplited = this.url.split('/');
        this.url = "";
        for (var i = 0; i < urlSplited.length; i++) {
            if (i < urlSplited.length - 1) {
                this.url += urlSplited[i] + "/";
            } else {
                this.url += encodeURIComponent(urlSplited[i]);
            }
        }

        
        this.layout = "fit";
        this.autoScroll = true;
        /*
         * var store = new Ext.data.JsonStore({ // store configs autoDestroy:
         * true, url: this.url, // reader configs root:
         * 'record.attributeValues', fields: ['name', 'value'], autoLoad : true
         * 
         * });
         */

        // set the search form
        this.formPanel = new Ext.FormPanel({
            frame : true,
            autoScroll : true,
            labelWidth : 150,
            labelAlign : "top"
        });

        var itemsForm = [];

        Ext.Ajax.request({
            url : this.url,
            method : 'GET',
            scope : this,
            success : function (ret) {
                var data = Ext.decode(ret.responseText);
                if (!data.success) {
                    Ext.Msg.alert(i18n.get('label.information'), "Server error");
                    return false;
                }
                var record = data.record;
                var id = record.id;
                var attributes = record.attributeValues;
                if (attributes !== undefined) {
                    var i;
                    for (i = 0; i < attributes.length; i++) {
                        var name = attributes[i].name;
                        var value = attributes[i].value;
                        var item;
                        if (value !== null && value.length > 100) {

                            item = new Ext.form.TextArea({
                                fieldLabel : name,
                                value : value,
                                anchor : "90%",
                                readOnly : true
                            });
                        } else {
                            item = new Ext.form.TextField({
                                fieldLabel : name,
                                value : value,
                                anchor : "90%",
                                readOnly : true
                            });
                        }

                        itemsForm.push(item);

                    }
                    this.formPanel.add(itemsForm);
                    this.formPanel.doLayout();
                }
            },
            failure : alertFailure
        });

        this.componentType = 'detail';
        this.items = [ this.formPanel ];

        sitools.user.component.simpleViewDataDetail.superclass.initComponent.call(this);
    }, 
    _getSettings : function () {
        return {};
    }
});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, window*/
/*!
 * Ext JS Library 3.3.1
 * Copyright(c) 2006-2010 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
/*
 * This is code is also distributed under MIT license for use
 * with jQuery and prototype JavaScript libraries.
 */
/**
 * @class sitools.component.users.datasets.DomQuery Provides high performance
 *        selector/xpath processing by compiling queries into reusable
 *        functions. New pseudo classes and matchers can be plugged. It works on
 *        HTML and XML documents (if a content node is passed in).
 * 
 * 
 * DomQuery supports most of the CSS3 selectors spec, along with some custom
 * selectors and basic XPath.
 * 
 * 
 * 
 * All selectors, attribute filters and pseudos below can be combined infinitely
 * in any order. For example "div.foo:nth-child(odd)[@foo=bar].bar:first" would
 * be a perfectly valid selector. Node filters are processed in the order in
 * which they appear, which allows you to optimize your queries for your
 * document structure.
 * 
 * Element Selectors:
 *  * any element
 * 
 * E an element with the tag E
 * 
 * E F All descendent elements of E that have the tag F
 * 
 * E > F or E/F all direct children elements of E that have the tag F
 * 
 * E + F all elements with the tag F that are immediately preceded by an element
 * with the tag E
 * 
 * E ~ F all elements with the tag F that are preceded by a sibling element with
 * the tag E
 * 
 * 
 * Attribute Selectors:
 * 
 * The use of @ and quotes are optional. For example, div[@foo='bar'] is also a
 * valid attribute selector.
 * 
 * 
 * E[foo] has an attribute "foo"
 * 
 * E[foo=bar] has an attribute "foo" that equals "bar"
 * 
 * E[foo^=bar] has an attribute "foo" that starts with "bar"
 * 
 * E[foo$=bar] has an attribute "foo" that ends with "bar"
 * 
 * E[foo*=bar] has an attribute "foo" that contains the substring "bar"
 * 
 * E[foo%=2] has an attribute "foo" that is evenly divisible by 2
 * 
 * E[foo!=bar] attribute "foo" does not equal "bar"
 * 
 * 
 * Pseudo Classes:
 * 
 * 
 * E:first-child E is the first child of its parent
 * 
 * E:last-child E is the last child of its parent
 * 
 * E:nth-child(n) E is the nth child of its parent (1 based as per the spec)
 * 
 * E:nth-child(odd) E is an odd child of its parent
 * 
 * E:nth-child(even) E is an even child of its parent
 * 
 * E:only-child E is the only child of its parent
 * 
 * E:checked E is an element that is has a checked attribute that is true (e.g.
 * a radio or checkbox)
 * 
 * E:first the first E in the resultset
 * 
 * E:last the last E in the resultset
 * 
 * E:nth(n) the nth E in the resultset (1 based)
 * 
 * E:odd shortcut for :nth-child(odd)
 * 
 * E:even shortcut for :nth-child(even)
 * 
 * E:contains(foo) E's innerHTML contains the substring "foo"
 * 
 * E:nodeValue(foo) E contains a textNode with a nodeValue that equals "foo"
 * 
 * E:not(S) an E element that does not match simple selector S
 * 
 * E:has(S) an E element that has a descendent that matches simple selector S
 * 
 * E:next(S) an E element whose next sibling matches simple selector S
 * 
 * E:prev(S) an E element whose previous sibling matches simple selector S
 * 
 * E:any(S1|S2|S2) an E element which matches any of the simple selectors S1, S2
 * or S3//\\
 * 
 * 
 * CSS Value Selectors:
 * 
 * 
 * E{display=none} css value "display" that equals "none"
 * 
 * E{display^=none} css value "display" that starts with "none"
 * 
 * E{display$=none} css value "display" that ends with "none"
 * 
 * E{display*=none} css value "display" that contains the substring "none"
 * 
 * E{display%=2} css value "display" that is evenly divisible by 2
 * 
 * E{display!=none} css value "display" that does not equal "none"
 * 
 * 
 * @singleton
 */
Ext.namespace("sitools.component.users.datasets");
sitools.component.users.datasets.DomQuery = function () {
    var cache = {}, simpleCache = {}, valueCache = {}, nonSpace = /\S/, trimRe = /^\s+|\s+$/g, tplRe = /\{(\d+)\}/g, modeRe = /^(\s?[\/>+~]\s?|\s|$)/, tagTokenRe = /^(#)?((?:opensearch:)?[\w-\*]+)/, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/,
    // This is for IE MSXML which does not support expandos.
    // IE runs the same speed using setAttribute, however FF slows way down
    // and Safari completely fails so they need to continue to use expandos.
    isIE = window.ActiveXObject ? true : false, key = 30803;

    // this eval is stop the compressor from
    // renaming the variable to something shorter
    eval("var batch = 30803;");

    // Retrieve the child node from a particular
    // parent at the specified index.
    function child(parent, index) {
        var i = 0, n = parent.firstChild;
        while (n) {
            if (n.nodeType == 1) {
                if (++i == index) {
                    return n;
                }
            }
            n = n.nextSibling;
        }
        return null;
    }

    // retrieve the next element node
    function next(n) {
        while ((n = n.nextSibling) && n.nodeType != 1)
            ;
        return n;
    }

    // retrieve the previous element node
    function prev(n) {
        while ((n = n.previousSibling) && n.nodeType != 1)
            ;
        return n;
    }

    // Mark each child node with a nodeIndex skipping and
    // removing empty text nodes.
    function children (parent) {
        var n = parent.firstChild, nodeIndex = -1, nextNode;
        while (n) {
            nextNode = n.nextSibling;
            // clean worthless empty nodes.
            if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
                parent.removeChild(n);
            } else {
                // add an expando nodeIndex
                n.nodeIndex = ++nodeIndex;
            }
            n = nextNode;
        }
        return this;
    }

    // nodeSet - array of nodes
    // cls - CSS Class
    function byClassName (nodeSet, cls) {
        if (!cls) {
            return nodeSet;
        }
        var result = [], ri = -1;
        for ( var i = 0, ci; ci = nodeSet[i]; i++) {
            if ((' ' + ci.className + ' ').indexOf(cls) != -1) {
                result[++ri] = ci;
            }
        }
        return result;
    }
    ;

    function attrValue (n, attr) {
        // if its an array, use the first node.
        if (!n.tagName && typeof n.length != "undefined") {
            n = n[0];
        }
        if (!n) {
            return null;
        }

        if (attr == "for") {
            return n.htmlFor;
        }
        if (attr == "class" || attr == "className") {
            return n.className;
        }
        return n.getAttribute(attr) || n[attr];

    }
    ;

    // ns - nodes
    // mode - false, /, >, +, ~
    // tagName - defaults to "*"
    function getNodes (ns, mode, tagName) {
        var result = [], ri = -1, cs;
        if (!ns) {
            return result;
        }
        tagName = tagName || "*";
        // convert to array
        if (typeof ns.getElementsByTagName != "undefined") {
            ns = [ ns ];
        }

        // no mode specified, grab all elements by tagName
        // at any depth
        if (!mode) {
            for ( var i = 0, ni; ni = ns[i]; i++) {
                cs = ni.getElementsByTagName(tagName);
                for ( var j = 0, ci; ci = cs[j]; j++) {
                    result[++ri] = ci;
                }
            }
            // Direct Child mode (/ or >)
            // E > F or E/F all direct children elements of E that have the tag
        } else if (mode == "/" || mode == ">") {
            var utag = tagName.toUpperCase();
            for ( var i = 0, ni, cn; ni = ns[i]; i++) {
                cn = ni.childNodes;
                for ( var j = 0, cj; cj = cn[j]; j++) {
                    if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') {
                        result[++ri] = cj;
                    }
                }
            }
            // Immediately Preceding mode (+)
            // E + F all elements with the tag F that are immediately preceded
            // by an element with the tag E
        } else if (mode == "+") {
            var utag = tagName.toUpperCase();
            for ( var i = 0, n; n = ns[i]; i++) {
                while ((n = n.nextSibling) && n.nodeType != 1)
                    ;
                if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == '*')) {
                    result[++ri] = n;
                }
            }
            // Sibling mode (~)
            // E ~ F all elements with the tag F that are preceded by a sibling
            // element with the tag E
        } else if (mode == "~") {
            var utag = tagName.toUpperCase();
            for ( var i = 0, n; n = ns[i]; i++) {
                while ((n = n.nextSibling)) {
                    if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') {
                        result[++ri] = n;
                    }
                }
            }
        }
        return result;
    }

    function concat (a, b) {
        if (b.slice) {
            return a.concat(b);
        }
        for ( var i = 0, l = b.length; i < l; i++) {
            a[a.length] = b[i];
        }
        return a;
    }

    function byTag (cs, tagName) {
        if (cs.tagName || cs == document) {
            cs = [ cs ];
        }
        if (!tagName) {
            return cs;
        }
        var result = [], ri = -1;
        tagName = tagName.toLowerCase();
        for ( var i = 0, ci; ci = cs[i]; i++) {
            if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
                result[++ri] = ci;
            }
        }
        return result;
    }

    function byId (cs, id) {
        if (cs.tagName || cs == document) {
            cs = [ cs ];
        }
        if (!id) {
            return cs;
        }
        var result = [], ri = -1;
        for ( var i = 0, ci; ci = cs[i]; i++) {
            if (ci && ci.id == id) {
                result[++ri] = ci;
                return result;
            }
        }
        return result;
    }

    // operators are =, !=, ^=, $=, *=, %=, |= and ~=
    // custom can be "{"
    function byAttribute (cs, attr, value, op, custom) {
        var result = [], ri = -1, useGetStyle = custom == "{", fn = sitools.component.users.datasets.DomQuery.operators[op], a, xml, hasXml;

        for ( var i = 0, ci; ci = cs[i]; i++) {
            // skip non-element nodes.
            if (ci.nodeType != 1) {
                continue;
            }
            // only need to do this for the first node
            if (!hasXml) {
                xml = sitools.component.users.datasets.DomQuery.isXml(ci);
                hasXml = true;
            }

            // we only need to change the property names if we're dealing with
            // html nodes, not XML
            if (!xml) {
                if (useGetStyle) {
                    a = sitools.component.users.datasets.DomQuery.getStyle(ci, attr);
                } else if (attr == "class" || attr == "className") {
                    a = ci.className;
                } else if (attr == "for") {
                    a = ci.htmlFor;
                } else if (attr == "href") {
                    // getAttribute href bug
                    // http://www.glennjones.net/Post/809/getAttributehrefbug.htm
                    a = ci.getAttribute("href", 2);
                } else {
                    a = ci.getAttribute(attr);
                }
            } else {
                a = ci.getAttribute(attr);
            }
            if ((fn && fn(a, value)) || (!fn && a)) {
                result[++ri] = ci;
            }
        }
        return result;
    }

    function byPseudo (cs, name, value) {
        return sitools.component.users.datasets.DomQuery.pseudos[name](cs, value);
    }

    function nodupIEXml (cs) {
        var d = ++key, r;
        cs[0].setAttribute("_nodup", d);
        r = [ cs[0] ];
        for ( var i = 1, len = cs.length; i < len; i++) {
            var c = cs[i];
            if (!c.getAttribute("_nodup") != d) {
                c.setAttribute("_nodup", d);
                r[r.length] = c;
            }
        }
        for ( var i = 0, len = cs.length; i < len; i++) {
            cs[i].removeAttribute("_nodup");
        }
        return r;
    }

    function nodup (cs) {
        if (!cs) {
            return [];
        }
        var len = cs.length, c, i, r = cs, cj, ri = -1;
        if (!len || typeof cs.nodeType != "undefined" || len == 1) {
            return cs;
        }
        if (isIE && typeof cs[0].selectSingleNode != "undefined") {
            return nodupIEXml(cs);
        }
        var d = ++key;
        cs[0]._nodup = d;
        for (i = 1; c = cs[i]; i++) {
            if (c._nodup != d) {
                c._nodup = d;
            } else {
                r = [];
                for ( var j = 0; j < i; j++) {
                    r[++ri] = cs[j];
                }
                for (j = i + 1; cj = cs[j]; j++) {
                    if (cj._nodup != d) {
                        cj._nodup = d;
                        r[++ri] = cj;
                    }
                }
                return r;
            }
        }
        return r;
    }

    function quickDiffIEXml (c1, c2) {
        var d = ++key, r = [];
        for ( var i = 0, len = c1.length; i < len; i++) {
            c1[i].setAttribute("_qdiff", d);
        }
        for ( var i = 0, len = c2.length; i < len; i++) {
            if (c2[i].getAttribute("_qdiff") != d) {
                r[r.length] = c2[i];
            }
        }
        for ( var i = 0, len = c1.length; i < len; i++) {
            c1[i].removeAttribute("_qdiff");
        }
        return r;
    }

    function quickDiff (c1, c2) {
        var len1 = c1.length, d = ++key, r = [];
        if (!len1) {
            return c2;
        }
        if (isIE && typeof c1[0].selectSingleNode != "undefined") {
            return quickDiffIEXml(c1, c2);
        }
        for ( var i = 0; i < len1; i++) {
            c1[i]._qdiff = d;
        }
        for ( var i = 0, len = c2.length; i < len; i++) {
            if (c2[i]._qdiff != d) {
                r[r.length] = c2[i];
            }
        }
        return r;
    }

    function quickId (ns, mode, root, id) {
        if (ns == root) {
            var d = root.ownerDocument || root;
            return d.getElementById(id);
        }
        ns = getNodes(ns, mode, "*");
        return byId(ns, id);
    }

    return {
        getStyle : function (el, name) {
            return Ext.fly(el).getStyle(name);
        },

        /**
         * Compiles a selector/xpath query into a reusable function. The
         * returned function takes one parameter "root" (optional), which is the
         * context node from where the query should start.
         * 
         * @param {String}
         *            selector The selector/xpath query
         * @param {String}
         *            type (optional) Either "select" (the default) or "simple"
         *            for a simple selector match
         * @return {Function}
         */
        compile : function (path, type) {
            type = type || "select";

            // setup fn preamble
            var fn = [ "var f = function(root){\n var mode; ++batch; var n = root || document;\n" ], mode, lastPath, matchers = sitools.component.users.datasets.DomQuery.matchers, matchersLn = matchers.length, modeMatch,
            // accept leading mode switch
            lmode = path.match(modeRe);

            if (lmode && lmode[1]) {
                fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";';
                path = path.replace(lmode[1], "");
            }

            // strip leading slashes
            while (path.substr(0, 1) == "/") {
                path = path.substr(1);
            }

            while (path && lastPath != path) {
                lastPath = path;
                var tokenMatch = path.match(tagTokenRe);
                if (type == "select") {
                    if (tokenMatch) {
                        // ID Selector
                        if (tokenMatch[1] == "#") {
                            fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");';
                        } else {
                            fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");';
                        }
                        path = path.replace(tokenMatch[0], "");
                    } else if (path.substr(0, 1) != '@') {
                        fn[fn.length] = 'n = getNodes(n, mode, "*");';
                    }
                    // type of "simple"
                } else {
                    if (tokenMatch) {
                        if (tokenMatch[1] == "#") {
                            fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");';
                        } else {
                            fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");';
                        }
                        path = path.replace(tokenMatch[0], "");
                    }
                }
                while (!(modeMatch = path.match(modeRe))) {
                    var matched = false;
                    for ( var j = 0; j < matchersLn; j++) {
                        var t = matchers[j];
                        var m = path.match(t.re);
                        if (m) {
                            fn[fn.length] = t.select.replace(tplRe, function (x, i) {
                                return m[i];
                            });
                            path = path.replace(m[0], "");
                            matched = true;
                            break;
                        }
                    }
                    // prevent infinite loop on bad selector
                    if (!matched) {
                        throw 'Error parsing selector, parsing failed at "' + path + '"';
                    }
                }
                if (modeMatch[1]) {
                    fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";';
                    path = path.replace(modeMatch[1], "");
                }
            }
            // close fn out
            fn[fn.length] = "return nodup(n);\n}";

            // eval fn and return it
            eval(fn.join(""));
            return f;
        },

        /**
         * Selects a group of elements.
         * 
         * @param {String}
         *            selector The selector/xpath query (can be a comma
         *            separated list of selectors)
         * @param {Node/String}
         *            root (optional) The start of the query (defaults to
         *            document).
         * @return {Array} An Array of DOM elements which match the selector. If
         *         there are no matches, and empty Array is returned.
         */
        jsSelect : function (path, root, type) {
            // set root to doc if not specified.
            path = path || "";
        	root = root || document;

            if (typeof root == "string") {
                root = document.getElementById(root);
            }
            var paths = path.split(","), results = [];

            // loop over each selector
            for ( var i = 0, len = paths.length; i < len; i++) {
                var subPath = paths[i].replace(trimRe, "");
                // compile and place in cache
                if (!cache[subPath]) {
                    cache[subPath] = sitools.component.users.datasets.DomQuery.compile(subPath);
                    if (!cache[subPath]) {
                        throw subPath + " is not a valid selector";
                    }
                }
                var result = cache[subPath](root);
                if (result && result != document) {
                    results = results.concat(result);
                }
            }

            // if there were multiple selectors, make sure dups
            // are eliminated
            if (paths.length > 1) {
                return nodup(results);
            }
            return results;
        },
        isXml : function (el) {
            var docEl = (el ? el.ownerDocument || el : 0).documentElement;
            return docEl ? docEl.nodeName !== "HTML" : false;
        },
        select : document.querySelectorAll ? function (path, root, type) {
            root = root || document;
            if (!sitools.component.users.datasets.DomQuery.isXml(root)) {
                try {
                    var cs = root.querySelectorAll(path);
                    return Ext.toArray(cs);
                } catch (ex) {
                }
            }
            return sitools.component.users.datasets.DomQuery.jsSelect.call(this, path, root, type);
        } : function (path, root, type) {
            return sitools.component.users.datasets.DomQuery.jsSelect.call(this, path, root, type);
        },

        /**
         * Selects a single element.
         * 
         * @param {String}
         *            selector The selector/xpath query
         * @param {Node}
         *            root (optional) The start of the query (defaults to
         *            document).
         * @return {Element} The DOM element which matched the selector.
         */
        selectNode : function (path, root) {
            return sitools.component.users.datasets.DomQuery.select(path, root)[0];
        },

        /**
         * Selects the value of a node, optionally replacing null with the
         * defaultValue.
         * 
         * @param {String}
         *            selector The selector/xpath query
         * @param {Node}
         *            root (optional) The start of the query (defaults to
         *            document).
         * @param {String}
         *            defaultValue
         * @return {String}
         */
        selectValue : function (path, root, defaultValue) {
            path = path.replace(trimRe, "");
            if (!valueCache[path]) {
                valueCache[path] = sitools.component.users.datasets.DomQuery.compile(path, "select");
            }
            var n = valueCache[path](root), v;
            n = n[0] ? n[0] : n;

            // overcome a limitation of maximum textnode size
            // Rumored to potentially crash IE6 but has not been confirmed.
            // http://reference.sitepoint.com/javascript/Node/normalize
            // https://developer.mozilla.org/En/DOM/Node.normalize
            if (typeof n.normalize == 'function')
                n.normalize();

            v = (n && n.firstChild ? n.firstChild.nodeValue : null);
            return ((v === null || v === undefined || v === '') ? defaultValue : v);
        },

        /**
         * Selects the value of a node, parsing integers and floats. Returns the
         * defaultValue, or 0 if none is specified.
         * 
         * @param {String}
         *            selector The selector/xpath query
         * @param {Node}
         *            root (optional) The start of the query (defaults to
         *            document).
         * @param {Number}
         *            defaultValue
         * @return {Number}
         */
        selectNumber : function (path, root, defaultValue) {
            var v = sitools.component.users.datasets.DomQuery.selectValue(path, root, defaultValue || 0);
            return parseFloat(v);
        },

        /**
         * Returns true if the passed element(s) match the passed simple
         * selector (e.g. div.some-class or span:first-child)
         * 
         * @param {String/HTMLElement/Array}
         *            el An element id, element or array of elements
         * @param {String}
         *            selector The simple selector to test
         * @return {Boolean}
         */
        is : function (el, ss) {
            if (typeof el == "string") {
                el = document.getElementById(el);
            }
            var isArray = Ext.isArray(el), result = sitools.component.users.datasets.DomQuery.filter(isArray ? el : [ el ], ss);
            return isArray ? (result.length == el.length) : (result.length > 0);
        },

        /**
         * Filters an array of elements to only include matches of a simple
         * selector (e.g. div.some-class or span:first-child)
         * 
         * @param {Array}
         *            el An array of elements to filter
         * @param {String}
         *            selector The simple selector to test
         * @param {Boolean}
         *            nonMatches If true, it returns the elements that DON'T
         *            match the selector instead of the ones that match
         * @return {Array} An Array of DOM elements which match the selector. If
         *         there are no matches, and empty Array is returned.
         */
        filter : function (els, ss, nonMatches) {
            ss = ss.replace(trimRe, "");
            if (!simpleCache[ss]) {
                simpleCache[ss] = sitools.component.users.datasets.DomQuery.compile(ss, "simple");
            }
            var result = simpleCache[ss](els);
            return nonMatches ? quickDiff(result, els) : result;
        },

        /**
         * Collection of matching regular expressions and code snippets. Each
         * capture group within () will be replace the {} in the select
         * statement as specified by their index.
         */
        matchers : [ {
            re : /^\.([\w-]+)/,
            select : 'n = byClassName(n, " {1} ");'
        }, {
            re : /^\:([\w-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
            select : 'n = byPseudo(n, "{1}", "{2}");'
        }, {
            re : /^(?:([\[\{])(?:@)?([\w-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
            select : 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'
        }, {
            re : /^#([\w-]+)/,
            select : 'n = byId(n, "{1}");'
        }, {
            re : /^@([\w-]+)/,
            select : 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'
        } ],

        /**
         * Collection of operator comparison functions. The default operators
         * are =, !=, ^=, $=, *=, %=, |= and ~=. New operators can be added as
         * long as the match the format c= where c is any character other than
         * space, > <.
         */
        operators : {
            "=" : function (a, v) {
                return a == v;
            },
            "!=" : function (a, v) {
                return a != v;
            },
            "^=" : function (a, v) {
                return a && a.substr(0, v.length) == v;
            },
            "$=" : function (a, v) {
                return a && a.substr(a.length - v.length) == v;
            },
            "*=" : function (a, v) {
                return a && a.indexOf(v) !== -1;
            },
            "%=" : function (a, v) {
                return (a % v) == 0;
            },
            "|=" : function (a, v) {
                return a && (a == v || a.substr(0, v.length + 1) == v + '-');
            },
            "~=" : function (a, v) {
                return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
            }
        },

        /**
         * 
         * 
         * Object hash of "pseudo class" filter functions which are used when
         * filtering selections. Each function is passed two parameters:
         *  * c : Array An Array of DOM elements to filter. * v : String The
         * argument (if any) supplied in the selector.
         * 
         * 
         * 
         * 
         * 
         * 
         * A filter function returns an Array of DOM elements which conform to
         * the pseudo class.
         * 
         * 
         * 
         * In addition to the provided pseudo classes listed above such as
         * first-child and nth-child, developers may add additional, custom
         * psuedo class filters to select elements according to
         * application-specific requirements.
         * 
         * 
         * 
         * For example, to filter <a> elements to only return links to external
         * resources:
         * 
         * 
         * 
         * sitools.component.users.datasets.DomQuery.pseudos.external =
         * function(c, v){ var r = [], ri = -1; for(var i = 0, ci; ci = c[i];
         * i++){ // Include in result set only if it's a link to an external
         * resource if(ci.hostname != location.hostname){ r[++ri] = ci; } }
         * return r; };
         * 
         * 
         * Then external links could be gathered with the following statement:
         * 
         * var externalLinks = Ext.select("a:external");
         * 
         * 
         */
        pseudos : {
            "first-child" : function (c) {
                var r = [], ri = -1, n;
                for ( var i = 0, ci; ci = n = c[i]; i++) {
                    while ((n = n.previousSibling) && n.nodeType != 1)
                        ;
                    if (!n) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "last-child" : function (c) {
                var r = [], ri = -1, n;
                for ( var i = 0, ci; ci = n = c[i]; i++) {
                    while ((n = n.nextSibling) && n.nodeType != 1)
                        ;
                    if (!n) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "nth-child" : function (c, a) {
                var r = [], ri = -1, m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a), f = (m[1] || 1) - 0, l = m[2] - 0;
                for ( var i = 0, n; n = c[i]; i++) {
                    var pn = n.parentNode;
                    if (batch != pn._batch) {
                        var j = 0;
                        for ( var cn = pn.firstChild; cn; cn = cn.nextSibling) {
                            if (cn.nodeType == 1) {
                                cn.nodeIndex = ++j;
                            }
                        }
                        pn._batch = batch;
                    }
                    if (f == 1) {
                        if (l == 0 || n.nodeIndex == l) {
                            r[++ri] = n;
                        }
                    } else if ((n.nodeIndex + l) % f == 0) {
                        r[++ri] = n;
                    }
                }

                return r;
            },

            "only-child" : function (c) {
                var r = [], ri = -1;
                ;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    if (!prev(ci) && !next(ci)) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "empty" : function (c) {
                var r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    var cns = ci.childNodes, j = 0, cn, empty = true;
                    while (cn = cns[j]) {
                        ++j;
                        if (cn.nodeType == 1 || cn.nodeType == 3) {
                            empty = false;
                            break;
                        }
                    }
                    if (empty) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "contains" : function (c, v) {
                var r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    if ((ci.textContent || ci.innerText || '').indexOf(v) != -1) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "nodeValue" : function (c, v) {
                var r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    if (ci.firstChild && ci.firstChild.nodeValue == v) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "checked" : function (c) {
                var r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    if (ci.checked == true) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "not" : function (c, ss) {
                return sitools.component.users.datasets.DomQuery.filter(c, ss, true);
            },

            "any" : function (c, selectors) {
                var ss = selectors.split('|'), r = [], ri = -1, s;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    for ( var j = 0; s = ss[j]; j++) {
                        if (sitools.component.users.datasets.DomQuery.is(ci, s)) {
                            r[++ri] = ci;
                            break;
                        }
                    }
                }
                return r;
            },

            "odd" : function (c) {
                return this["nth-child"](c, "odd");
            },

            "even" : function (c) {
                return this["nth-child"](c, "even");
            },

            "nth" : function (c, a) {
                return c[a - 1] || [];
            },

            "first" : function (c) {
                return c[0] || [];
            },

            "last" : function (c) {
                return c[c.length - 1] || [];
            },

            "has" : function (c, ss) {
                var s = sitools.component.users.datasets.DomQuery.select, r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    if (s(ss, ci).length > 0) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "next" : function (c, ss) {
                var is = sitools.component.users.datasets.DomQuery.is, r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    var n = next(ci);
                    if (n && is(n, ss)) {
                        r[++ri] = ci;
                    }
                }
                return r;
            },

            "prev" : function (c, ss) {
                var is = sitools.component.users.datasets.DomQuery.is, r = [], ri = -1;
                for ( var i = 0, ci; ci = c[i]; i++) {
                    var n = prev(ci);
                    if (n && is(n, ss)) {
                        r[++ri] = ci;
                    }
                }
                return r;
            }
        }
    };
}();

/**
 * Selects an array of DOM nodes by CSS/XPath selector. Shorthand of
 * {@link sitools.component.users.datasets.DomQuery#select}
 * 
 * @param {String}
 *            path The selector/xpath query
 * @param {Node}
 *            root (optional) The start of the query (defaults to document).
 * @return {Array}
 * @member Ext
 * @method query
 */
Ext.query = sitools.component.users.datasets.DomQuery.select;
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, i18n, window*/
Ext.namespace('sitools.component.users.datasets');

sitools.component.users.datasets.XmlReader = function (meta, recordType) {
    meta = meta || {};

    // backwards compat, convert idPath or id / success
    Ext.applyIf(meta, {
        idProperty : meta.idProperty || meta.idPath || meta.id,
        successProperty : meta.successProperty || meta.success
    });

    sitools.component.users.datasets.XmlReader.superclass.constructor.call(this, meta, recordType || meta.fields);
};
Ext.extend(sitools.component.users.datasets.XmlReader, Ext.data.XmlReader, {

    /**
     * Creates a function to return some particular key of data from a response.
     * 
     * @param {String}
     *            key
     * @return {Function}
     * @private
     * @ignore
     */
    createAccessor : function () {
        var q = sitools.component.users.datasets.DomQuery;
        return function (key) {
            if (Ext.isFunction(key)) {
                return key;
            }
            switch (key) {
            case this.meta.totalProperty:
                return function (root, def) {
                    return q.selectNumber(key, root, def);
                };
                break;
            case this.meta.successProperty:
                return function (root, def) {
                    var sv = q.selectValue(key, root, true);
                    var success = sv !== false && sv !== 'false';
                    return success;
                };
                break;
            default:
                return function (root, def) {
                    return q.selectValue(key, root, def);
                };
                break;
            }
        };
    }()

});
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure*/
Ext.namespace('sitools.component.version');

sitools.component.version.sitoolsVersion = Ext.extend(Ext.Panel, {
    
	layout : 'fit', 
    
    initComponent : function () {
    this.versionUrl = loadUrl.get('APP_URL') + '/version';
        
        var title = new Ext.form.Label({
            html : '<h2>SITools2</h2><br/>' 
        });
        
        var logo = new Ext.form.Label({
            html : '<img src='+loadUrl.get('APP_URL')+'/res/images/logo_02_tailleMoyenne.png>'
        });
        
        
        
        this.credits = new Ext.form.Label({            
        });
        
        var website = new Ext.form.Label({
            html : '<a href="http://www.sitools2.sourceforge.net">sitools2.sourceforge.net</>'
        });
        
        this.versionLabel = new Ext.form.Label({            
        });
        
        this.buildDateLabel = new Ext.form.Label({            
        }); 
        
        var panelVersion = new Ext.Panel({
            title : i18n.get("label.version"),
            layout : 'fit',
            padding : 10
        });
        
        var panelLicence = new Ext.ux.ManagedIFrame.Panel({
            title : i18n.get("label.licence"),
            layout : 'fit',
            defaultSrc : loadUrl.get('APP_URL') + "/res/licences/gpl-3.0.txt"
            
        });
        
        panelVersion.add([logo, title, this.versionLabel, this.buildDateLabel, this.credits, website]);
        
        this.tabs = new Ext.TabPanel({
            activeTab: 0,
            items: [ panelVersion, panelLicence]            
        });
        
        this.items = [this.tabs];
        
            
        this.listeners = {
            scope : this,
            resize : function (window) {
                var size = window.body.getSize();
                this.tabs.setSize(size);
            }
        };
            
        sitools.component.version.sitoolsVersion.superclass.initComponent.call(this);
    },
    
    afterRender : function () {

        sitools.component.version.sitoolsVersion.superclass.afterRender.apply(this, arguments);
        
        Ext.Ajax.request({
                url : this.versionUrl,
                method : 'GET',
                scope : this,
                success : function (ret) {
                    var json = Ext.decode(ret.responseText);
                    if (!json.success) {
                        Ext.Msg.alert(i18n.get('label.warning'), json.message);
                        return false;
                    }
                    var info = json.info;
                    
                    var version = info.version;
                    var buildDate = info.buildDate;
                    var copyright = info.copyright;
                    
                    this.versionLabel.setText("<h3>Version : " + version + "</h3>", false);                    
                    this.buildDateLabel.setText("<h3>Build date : " + buildDate + "</h3>", false);                    
                    this.credits.setText(String.format("<p>{0}</p><br>", copyright), false);
                    //this.doLayout();
                    
                },
                failure : alertFailure
            });
        
        var size = this.ownerCt.body.getSize();
        this.tabs.setSize(size);
        
    }
});

function showVersion () {
	var versionHelp = Ext.getCmp('winVersionId');
    if (!versionHelp) {
        var panelHelp = new sitools.component.version.sitoolsVersion();
        versionHelp = new Ext.Window({
            title : i18n.get('label.version'),            
            id : 'winVersionId', 
            items : [panelHelp], 
            modal : false, 
			width : 700,
			height : 480,
			resizable : false, 
            modal : true,
			buttons : [{
                text : i18n.get('label.close'),
                
                handler : function () {
                    this.ownerCt.ownerCt.close();
                }
            } ]


        });
        

        versionHelp.show();
        
    } else {
        versionHelp.show();
    }
}

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, getDesktop*/
Ext.ns('sitools.widget');

/**
 * A specific window to display preview Images in user desktop. 
 * @class sitools.widget.WindowImageViewer
 * @config {boolean} resizeImage true to resize the image according to the desktop, image ratio is also keeped. 
 * false to keep the image size with scrollbars if needed. Default to false
 * @extends Ext.Window
 */
sitools.widget.WindowImageViewer = Ext.extend(Ext.Window, {
    resizeImage : false, 
    maximizable : true, 
    modal : true, 
    minHeight : 0,
    minWidth : 0,
    initComponent : function () {
//        this.renderTo = SitoolsDesk.getDesktop().getDesktopEl();
    
        if (!this.resizeImage) {
	        this.panel = new Ext.Panel({                
	            bodyCfg : {
	                tag : 'img',
	                src : this.src
	            },
	            listeners :  {
	                scope : this,
	                render : function () {
		                this.panel.body.on('load', this.onImageLoad, this, {
				            single : true
				        });
		            }
	            }
	        });
            this.items = [this.panel];
            this.autoScroll=true;
        } else {
            this.bodyCfg = {
                tag : 'img',
                src : this.src
            };
        }
        this.constrain = true;
        sitools.widget.WindowImageViewer.superclass.initComponent.apply(this, arguments);
    },
    
    onRender : function () {
        sitools.widget.WindowImageViewer.superclass.onRender.apply(this, arguments);
        if(this.resizeImage){
            this.body.on('load', this.onImageLoad, this, {
                single : true
            });
        }
    },
    /**
     * Method called when the image is loaded. It is in charge of resizing the image according to the desktop size
     */
    onImageLoad : function () {
        var imgTag = Ext.DomQuery.select("div[id='"+this.id+"'] img")[0];
		var hi = this.body.dom.offsetHeight;
		var wi = this.body.dom.offsetWidth;
        
        var hiImg = imgTag.offsetHeight;
        var wiImg = imgTag.offsetWidth;
        
        if (!this.resizeImage) {
            this.panel.setSize(wiImg, hiImg);
        }

		var desktop = getDesktop();
		var ww = desktop.getWinWidth();
		var hw = desktop.getWinHeight();

		var reduce = false;

		if (hi > hw) {
			wi = wi * hw / hi;
			hi = hw;
			reduce = true;
		}
		if (wi > ww) {
			hi = hi * ww / wi;
			wi = ww;
			reduce = true;
		}

		if (reduce) {
			hi *= 0.9;
			wi *= 0.9;
		}

		this.setSize(wi + this.getFrameWidth(), hi + this.getFrameHeight());
        
		// if (Ext.isIE) {
		this.center();
		// }
	},
    
    setSrc : function (src) {
        var panel;
        if(resizeImage){
            panel = this;
        }else {
            panel = this.panel;
        }
        panel.body.on('load', this.onImageLoad, this, {
            single : true
        });
        panel.body.dom.style.width = panel.body.dom.style.width = 'auto';
        panel.body.dom.src = src;
    },
    
    initEvents : function () {
        sitools.widget.WindowImageViewer.superclass.initEvents.apply(this, arguments);
        if (this.resizer && this.resizeImage) {
            this.resizer.preserveRatio = true;
        }
    }
});

/**
 * A specific panel to display preview Images in user desktop. 
 * @class sitools.widget.WindowImageViewer
 * @extends Ext.Window
 */
sitools.widget.PanelImageViewer = Ext.extend(Ext.Panel, {

    initComponent : function () {
        this.bodyCfg = {
            tag : 'img',
            src : this.src
        };
        sitools.widget.PanelImageViewer.superclass.initComponent.apply(this, arguments);
    },

    onRender : function () {
        sitools.widget.PanelImageViewer.superclass.onRender.apply(this, arguments);
        this.body.on('load', this.onImageLoad, this, {
            single : true
        });
    },

    onImageLoad : function () {
        var h = this.getFrameHeight(), w = this.getFrameWidth();
        this.setSize(this.body.dom.offsetWidth + w, this.body.dom.offsetHeight + h);
        if (Ext.isIE) {
            this.center();
        }
    },

    setSrc : function (src) {
        this.body.on('load', this.onImageLoad, this, {
            single : true
        });
        this.body.dom.style.width = this.body.dom.style.width = 'auto';
        this.body.dom.src = src;
    },

    initEvents : function () {
        sitools.widget.PanelImageViewer.superclass.initEvents.apply(this, arguments);
        if (this.resizer) {
            this.resizer.preserveRatio = true;
        }
    }, 
    /**
     * Method called when trying to show this component with fixed navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInFixedNav : function (me, config) {
    	me.show();
    }, 
    /**
     * Method called when trying to show this component with Desktop navigation
     * 
     * @param {sitools.user.component.viewDataDetail} me the dataDetail view
     * @param {} config config options
     * @returns
     */
    showMeInDesktopNav : function (me, config) {
    	me.show();
    }
    
});

/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
/**
 * @class Ext.ux.Spinner
 * @extends Ext.util.Observable
 * Creates a Spinner control utilized by Ext.ux.form.SpinnerField
 */
Ext.ux.Spinner = Ext.extend(Ext.util.Observable, {
    incrementValue: 1,
    alternateIncrementValue: 5,
    triggerClass: 'x-form-spinner-trigger',
    splitterClass: 'x-form-spinner-splitter',
    alternateKey: Ext.EventObject.shiftKey,
    defaultValue: 0,
    accelerate: false,

    constructor: function(config){
        Ext.ux.Spinner.superclass.constructor.call(this, config);
        Ext.apply(this, config);
        this.mimicing = false;
    },

    init: function(field){
        this.field = field;

        field.afterMethod('onRender', this.doRender, this);
        field.afterMethod('onEnable', this.doEnable, this);
        field.afterMethod('onDisable', this.doDisable, this);
        field.afterMethod('afterRender', this.doAfterRender, this);
        field.afterMethod('onResize', this.doResize, this);
        field.afterMethod('onFocus', this.doFocus, this);
        field.beforeMethod('onDestroy', this.doDestroy, this);
    },

    doRender: function(ct, position){
        var el = this.el = this.field.getEl();
        var f = this.field;

        if (!f.wrap) {
            f.wrap = this.wrap = el.wrap({
                cls: "x-form-field-wrap"
            });
        }
        else {
            this.wrap = f.wrap.addClass('x-form-field-wrap');
        }

        this.trigger = this.wrap.createChild({
            tag: "img",
            src: Ext.BLANK_IMAGE_URL,
            cls: "x-form-trigger " + this.triggerClass
        });

        if (!f.width) {
            this.wrap.setWidth(el.getWidth() + this.trigger.getWidth());
        }

        this.splitter = this.wrap.createChild({
            tag: 'div',
            cls: this.splitterClass,
            style: 'width:13px; height:2px;'
        });
        this.splitter.setRight((Ext.isIE) ? 1 : 2).setTop(10).show();

        this.proxy = this.trigger.createProxy('', this.splitter, true);
        this.proxy.addClass("x-form-spinner-proxy");
        this.proxy.setStyle('left', '0px');
        this.proxy.setSize(14, 1);
        this.proxy.hide();
        this.dd = new Ext.dd.DDProxy(this.splitter.dom.id, "SpinnerDrag", {
            dragElId: this.proxy.id
        });

        this.initTrigger();
        this.initSpinner();
    },

    doAfterRender: function(){
        var y;
        if (Ext.isIE && this.el.getY() != (y = this.trigger.getY())) {
            this.el.position();
            this.el.setY(y);
        }
    },

    doEnable: function(){
        if (this.wrap) {
            this.wrap.removeClass(this.field.disabledClass);
        }
    },

    doDisable: function(){
        if (this.wrap) {
            this.wrap.addClass(this.field.disabledClass);
            this.el.removeClass(this.field.disabledClass);
        }
    },

    doResize: function(w, h){
        if (typeof w == 'number') {
            this.el.setWidth(w - this.trigger.getWidth());
        }
        this.wrap.setWidth(this.el.getWidth() + this.trigger.getWidth());
    },

    doFocus: function(){
        if (!this.mimicing) {
            this.wrap.addClass('x-trigger-wrap-focus');
            this.mimicing = true;
            Ext.get(Ext.isIE ? document.body : document).on("mousedown", this.mimicBlur, this, {
                delay: 10
            });
            this.el.on('keydown', this.checkTab, this);
        }
    },

    // private
    checkTab: function(e){
        if (e.getKey() == e.TAB) {
            this.triggerBlur();
        }
    },

    // private
    mimicBlur: function(e){
        if (!this.wrap.contains(e.target) && this.field.validateBlur(e)) {
            this.triggerBlur();
        }
    },

    // private
    triggerBlur: function(){
        this.mimicing = false;
        Ext.get(Ext.isIE ? document.body : document).un("mousedown", this.mimicBlur, this);
        this.el.un("keydown", this.checkTab, this);
        this.field.beforeBlur();
        this.wrap.removeClass('x-trigger-wrap-focus');
        this.field.onBlur.call(this.field);
    },

    initTrigger: function(){
        this.trigger.addClassOnOver('x-form-trigger-over');
        this.trigger.addClassOnClick('x-form-trigger-click');
    },

    initSpinner: function(){
        this.field.addEvents({
            'spin': true,
            'spinup': true,
            'spindown': true
        });

        this.keyNav = new Ext.KeyNav(this.el, {
            "up": function(e){
                e.preventDefault();
                this.onSpinUp();
            },

            "down": function(e){
                e.preventDefault();
                this.onSpinDown();
            },

            "pageUp": function(e){
                e.preventDefault();
                this.onSpinUpAlternate();
            },

            "pageDown": function(e){
                e.preventDefault();
                this.onSpinDownAlternate();
            },

            scope: this
        });

        this.repeater = new Ext.util.ClickRepeater(this.trigger, {
            accelerate: this.accelerate
        });
        this.field.mon(this.repeater, "click", this.onTriggerClick, this, {
            preventDefault: true
        });

        this.field.mon(this.trigger, {
            mouseover: this.onMouseOver,
            mouseout: this.onMouseOut,
            mousemove: this.onMouseMove,
            mousedown: this.onMouseDown,
            mouseup: this.onMouseUp,
            scope: this,
            preventDefault: true
        });

        this.field.mon(this.wrap, "mousewheel", this.handleMouseWheel, this);

        this.dd.setXConstraint(0, 0, 10)
        this.dd.setYConstraint(1500, 1500, 10);
        this.dd.endDrag = this.endDrag.createDelegate(this);
        this.dd.startDrag = this.startDrag.createDelegate(this);
        this.dd.onDrag = this.onDrag.createDelegate(this);
    },

    onMouseOver: function(){
        if (this.disabled) {
            return;
        }
        var middle = this.getMiddle();
        this.tmpHoverClass = (Ext.EventObject.getPageY() < middle) ? 'x-form-spinner-overup' : 'x-form-spinner-overdown';
        this.trigger.addClass(this.tmpHoverClass);
    },

    //private
    onMouseOut: function(){
        this.trigger.removeClass(this.tmpHoverClass);
    },

    //private
    onMouseMove: function(){
        if (this.disabled) {
            return;
        }
        var middle = this.getMiddle();
        if (((Ext.EventObject.getPageY() > middle) && this.tmpHoverClass == "x-form-spinner-overup") ||
        ((Ext.EventObject.getPageY() < middle) && this.tmpHoverClass == "x-form-spinner-overdown")) {
        }
    },

    //private
    onMouseDown: function(){
        if (this.disabled) {
            return;
        }
        var middle = this.getMiddle();
        this.tmpClickClass = (Ext.EventObject.getPageY() < middle) ? 'x-form-spinner-clickup' : 'x-form-spinner-clickdown';
        this.trigger.addClass(this.tmpClickClass);
    },

    //private
    onMouseUp: function(){
        this.trigger.removeClass(this.tmpClickClass);
    },

    //private
    onTriggerClick: function(){
        if (this.disabled || this.el.dom.readOnly) {
            return;
        }
        var middle = this.getMiddle();
        var ud = (Ext.EventObject.getPageY() < middle) ? 'Up' : 'Down';
        this['onSpin' + ud]();
    },

    //private
    getMiddle: function(){
        var t = this.trigger.getTop();
        var h = this.trigger.getHeight();
        var middle = t + (h / 2);
        return middle;
    },

    //private
    //checks if control is allowed to spin
    isSpinnable: function(){
        if (this.disabled || this.el.dom.readOnly) {
            Ext.EventObject.preventDefault(); //prevent scrolling when disabled/readonly
            return false;
        }
        return true;
    },

    handleMouseWheel: function(e){
        //disable scrolling when not focused
        if (this.wrap.hasClass('x-trigger-wrap-focus') == false) {
            return;
        }

        var delta = e.getWheelDelta();
        if (delta > 0) {
            this.onSpinUp();
            e.stopEvent();
        }
        else
            if (delta < 0) {
                this.onSpinDown();
                e.stopEvent();
            }
    },

    //private
    startDrag: function(){
        this.proxy.show();
        this._previousY = Ext.fly(this.dd.getDragEl()).getTop();
    },

    //private
    endDrag: function(){
        this.proxy.hide();
    },

    //private
    onDrag: function(){
        if (this.disabled) {
            return;
        }
        var y = Ext.fly(this.dd.getDragEl()).getTop();
        var ud = '';

        if (this._previousY > y) {
            ud = 'Up';
        } //up
        if (this._previousY < y) {
            ud = 'Down';
        } //down
        if (ud != '') {
            this['onSpin' + ud]();
        }

        this._previousY = y;
    },

    //private
    onSpinUp: function(){
        if (this.isSpinnable() == false) {
            return;
        }
        if (Ext.EventObject.shiftKey == true) {
            this.onSpinUpAlternate();
            return;
        }
        else {
            this.spin(false, false);
        }
        this.field.fireEvent("spin", this);
        this.field.fireEvent("spinup", this);
    },

    //private
    onSpinDown: function(){
        if (this.isSpinnable() == false) {
            return;
        }
        if (Ext.EventObject.shiftKey == true) {
            this.onSpinDownAlternate();
            return;
        }
        else {
            this.spin(true, false);
        }
        this.field.fireEvent("spin", this);
        this.field.fireEvent("spindown", this);
    },

    //private
    onSpinUpAlternate: function(){
        if (this.isSpinnable() == false) {
            return;
        }
        this.spin(false, true);
        this.field.fireEvent("spin", this);
        this.field.fireEvent("spinup", this);
    },

    //private
    onSpinDownAlternate: function(){
        if (this.isSpinnable() == false) {
            return;
        }
        this.spin(true, true);
        this.field.fireEvent("spin", this);
        this.field.fireEvent("spindown", this);
    },

    spin: function(down, alternate){
        var v = parseFloat(this.field.getValue());
        var incr = (alternate == true) ? this.alternateIncrementValue : this.incrementValue;
        (down == true) ? v -= incr : v += incr;

        v = (isNaN(v)) ? this.defaultValue : v;
        v = this.fixBoundries(v);
        this.field.setRawValue(v);
    },

    fixBoundries: function(value){
        var v = value;

        if (this.field.minValue != undefined && v < this.field.minValue) {
            v = this.field.minValue;
        }
        if (this.field.maxValue != undefined && v > this.field.maxValue) {
            v = this.field.maxValue;
        }

        return this.fixPrecision(v);
    },

    // private
    fixPrecision: function(value){
        var nan = isNaN(value);
        if (!this.field.allowDecimals || this.field.decimalPrecision == -1 || nan || !value) {
            return nan ? '' : value;
        }
        return parseFloat(parseFloat(value).toFixed(this.field.decimalPrecision));
    },

    doDestroy: function(){
        if (this.trigger) {
            this.trigger.remove();
        }
        if (this.wrap) {
            this.wrap.remove();
            delete this.field.wrap;
        }

        if (this.splitter) {
            this.splitter.remove();
        }

        if (this.dd) {
            this.dd.unreg();
            this.dd = null;
        }

        if (this.proxy) {
            this.proxy.remove();
        }

        if (this.repeater) {
            this.repeater.purgeListeners();
        }
    }
});

//backwards compat
Ext.form.Spinner = Ext.ux.Spinner;
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.2.1
 * Copyright(c) 2006-2010 Ext JS, Inc.
 * licensing@extjs.com
 * http://www.extjs.com/license
 */
Ext.ns('Ext.ux.form');

/**
 * @class Ext.ux.form.SpinnerField
 * @extends Ext.form.NumberField
 * Creates a field utilizing Ext.ux.Spinner
 * @xtype spinnerfield
 */
Ext.ux.form.SpinnerField = Ext.extend(Ext.form.NumberField, {
    actionMode: 'wrap',
    deferHeight: true,
    autoSize: Ext.emptyFn,
    onBlur: Ext.emptyFn,
    adjustSize: Ext.BoxComponent.prototype.adjustSize,

	constructor: function(config) {
		var spinnerConfig = Ext.copyTo({}, config, 'incrementValue,alternateIncrementValue,accelerate,defaultValue,triggerClass,splitterClass');

		var spl = this.spinner = new Ext.ux.Spinner(spinnerConfig);

		var plugins = config.plugins
			? (Ext.isArray(config.plugins)
				? config.plugins.push(spl)
				: [config.plugins, spl])
			: spl;

		Ext.ux.form.SpinnerField.superclass.constructor.call(this, Ext.apply(config, {plugins: plugins}));
	},

    // private
    getResizeEl: function(){
        return this.wrap;
    },

    // private
    getPositionEl: function(){
        return this.wrap;
    },

    // private
    alignErrorIcon: function(){
        if (this.wrap) {
            this.errorIcon.alignTo(this.wrap, 'tl-tr', [2, 0]);
        }
    },

    validateBlur: function(){
        return true;
    }
});

Ext.reg('spinnerfield', Ext.ux.form.SpinnerField);

//backwards compat
Ext.form.SpinnerField = Ext.ux.form.SpinnerField;
/**
 * Define a specific DatePicker to offer possibility to choose Hours Minutes and Seconds
 * @class Ext.SitoolsDatePicker
 * @extends Ext.BoxComponent
 */
Ext.SitoolsDatePicker = Ext.extend(Ext.BoxComponent, {
    
    todayText : 'Today',
    /**
     * @cfg {String} okText
     * The text to display on the ok button (defaults to <code>'&#160;OK&#160;'</code> to give the user extra clicking room)
     */
    okText : '&#160;OK&#160;',
    /**
     * @cfg {String} cancelText
     * The text to display on the cancel button (defaults to <code>'Cancel'</code>)
     */
    cancelText : 'Cancel',
    /**
     * @cfg {Function} handler
     * Optional. A function that will handle the select event of this picker.
     * The handler is passed the following parameters:<div class="mdetail-params"><ul>
     * <li><code>picker</code> : DatePicker<div class="sub-desc">This DatePicker.</div></li>
     * <li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li>
     * </ul></div>
     */
    /**
     * @cfg {Object} scope
     * The scope (<code><b>this</b></code> reference) in which the <code>{@link #handler}</code>
     * function will be called.  Defaults to this DatePicker instance.
     */
    /**
     * @cfg {String} todayTip
     * A string used to format the message for displaying in a tooltip over the button that
     * selects the current date. Defaults to <code>'{0} (Spacebar)'</code> where
     * the <code>{0}</code> token is replaced by today's date.
     */
    todayTip : '{0} (Spacebar)',
    /**
     * @cfg {String} minText
     * The error text to display if the minDate validation fails (defaults to <code>'This date is before the minimum date'</code>)
     */
    minText : 'This date is before the minimum date',
    /**
     * @cfg {String} maxText
     * The error text to display if the maxDate validation fails (defaults to <code>'This date is after the maximum date'</code>)
     */
    maxText : 'This date is after the maximum date',
    /**
     * @cfg {String} format
     * The default date format string which can be overriden for localization support.  The format must be
     * valid according to {@link Date#parseDate} (defaults to <code>'m/d/y'</code>).
     */
    format : 'm/d/y',
    /**
     * @cfg {String} disabledDaysText
     * The tooltip to display when the date falls on a disabled day (defaults to <code>'Disabled'</code>)
     */
    disabledDaysText : 'Disabled',
    /**
     * @cfg {String} disabledDatesText
     * The tooltip text to display when the date falls on a disabled date (defaults to <code>'Disabled'</code>)
     */
    disabledDatesText : 'Disabled',
    /**
     * @cfg {Array} monthNames
     * An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
     */
    monthNames : Date.monthNames,
    /**
     * @cfg {Array} dayNames
     * An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
     */
    dayNames : Date.dayNames,
    /**
     * @cfg {String} nextText
     * The next month navigation button tooltip (defaults to <code>'Next Month (Control+Right)'</code>)
     */
    nextText : 'Next Month (Control+Right)',
    /**
     * @cfg {String} prevText
     * The previous month navigation button tooltip (defaults to <code>'Previous Month (Control+Left)'</code>)
     */
    prevText : 'Previous Month (Control+Left)',
    /**
     * @cfg {String} monthYearText
     * The header month selector tooltip (defaults to <code>'Choose a month (Control+Up/Down to move years)'</code>)
     */
    monthYearText : 'Choose a month (Control+Up/Down to move years)',
    /**
     * @cfg {Number} startDay
     * Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)
     */
    startDay : 0,
    /**
     * @cfg {Boolean} showToday
     * False to hide the footer area containing the Today button and disable the keyboard handler for spacebar
     * that selects the current date (defaults to <code>true</code>).
     */
    showToday : true,
    
    /**
     * @cfg {Boolean} showTime
     * False to hide the footer area containing the hour definition
     * (defaults to <code>false</code>).
     */
    showTime : false, 
    
    
    
    

    
    // private
    // Set by other components to stop the picker focus being updated when the value changes.
    focusOnSelect: true,

    
    
    // default value used to initialise each date in the DatePicker
    // (note: 12 noon was chosen because it steers well clear of all DST timezone changes)
    initHour: 12, 

    
    initComponent : function(){
        Ext.SitoolsDatePicker.superclass.initComponent.call(this);

        this.value = this.value ?
                 this.value.clearTime(true) : new Date().clearTime();
		this.hourValue = this.value ? this.value.getHours() : new Date().getHours();
		this.minuteValue = this.value ? this.value.getMinutes() : new Date().getMinutes();
		this.secondValue = this.value ? this.value.getSeconds() : new Date().getSeconds();
		
        this.addEvents(
            
            'select'
        );

        if(this.handler){
            this.on('select', this.handler,  this.scope || this);
        }

        this.initDisabledDays();
    },

    
    // private
    initDisabledDays : function(){
        if(!this.disabledDatesRE && this.disabledDates){
            var dd = this.disabledDates,
                len = dd.length - 1,
                re = '(?:';

            Ext.each(dd, function(d, i){
                re += Ext.isDate(d) ? '^' + Ext.escapeRe(d.dateFormat(this.format)) + '$' : dd[i];
                if(i != len){
                    re += '|';
                }
            }, this);
            this.disabledDatesRE = new RegExp(re + ')');
        }
    },

    
    /**
     * Replaces any existing disabled dates with new values and refreshes the DatePicker.
     * @param {Array/RegExp} disabledDates An array of date strings (see the {@link #disabledDates} config
     * for details on supported values), or a JavaScript regular expression used to disable a pattern of dates.
     */
    setDisabledDates : function(dd){
        if(Ext.isArray(dd)){
            this.disabledDates = dd;
            this.disabledDatesRE = null;
        }else{
            this.disabledDatesRE = dd;
        }
        this.initDisabledDays();
        this.update(this.value, true);
    },

    
    /**
     * Replaces any existing disabled days (by index, 0-6) with new values and refreshes the DatePicker.
     * @param {Array} disabledDays An array of disabled day indexes. See the {@link #disabledDays} config
     * for details on supported values.
     */
    setDisabledDays : function(dd){
        this.disabledDays = dd;
        this.update(this.value, true);
    },

    
    /**
     * Replaces any existing {@link #minDate} with the new value and refreshes the DatePicker.
     * @param {Date} value The minimum date that can be selected
     */
    setMinDate : function(dt){
        this.minDate = dt;
        this.update(this.value, true);
    },

    
    /**
     * Replaces any existing {@link #maxDate} with the new value and refreshes the DatePicker.
     * @param {Date} value The maximum date that can be selected
     */
    setMaxDate : function(dt){
        this.maxDate = dt;
        this.update(this.value, true);
    },

    
    /**
     * Sets the value of the date field
     * @param {Date} value The date to set
     */
    setValue : function(value){
        this.value = value;
        this.update(this.value);
    },

    
    /**
     * Gets the current selected value of the date field
     * @return {Date} The selected date
     */
    getValue : function(){
        return this.value;
    },

    
    // private
    focus : function(){
        this.update(this.activeDate);
        if (this.showTime) {
        	this.updateTime(this.activeDate);
        }
    },
    // private
	updateTime : function (date) {
		this.hourField.setValue(date.getHours());
		this.minuteField.setValue(date.getMinutes());
		this.secondField.setValue(date.getSeconds());
	}, 
    
    // private
    onEnable: function(initial){
        Ext.SitoolsDatePicker.superclass.onEnable.call(this);
        this.doDisabled(false);
        this.update(initial ? this.value : this.activeDate);
        if(Ext.isIE){
            this.el.repaint();
        }

    },

    
    // private
    onDisable : function(){
        Ext.SitoolsDatePicker.superclass.onDisable.call(this);
        this.doDisabled(true);
        if(Ext.isIE && !Ext.isIE8){
            /* Really strange problem in IE6/7, when disabled, have to explicitly
             * repaint each of the nodes to get them to display correctly, simply
             * calling repaint on the main element doesn't appear to be enough.
             */
            
             Ext.each([].concat(this.textNodes, this.el.query('th span')), function(el){
                 Ext.fly(el).repaint();
             });
        }
    },

    
    // private
    doDisabled : function(disabled){
        this.keyNav.setDisabled(disabled);
        this.prevRepeater.setDisabled(disabled);
        this.nextRepeater.setDisabled(disabled);
        if(this.showToday){
            this.todayKeyListener.setDisabled(disabled);
            this.todayBtn.setDisabled(disabled);
        }
    },

    
    // private
    onRender : function(container, position){
        var m = [
             '<table cellspacing="0">',
                '<tr><td class="x-date-left"><a href="#" title="', this.prevText ,'">&#160;</a></td><td class="x-date-middle" align="center"></td><td class="x-date-right"><a href="#" title="', this.nextText ,'">&#160;</a></td></tr>',
                '<tr><td colspan="3"><table class="x-date-inner" cellspacing="0"><thead><tr>'],
                dn = this.dayNames,
                i;
        for(i = 0; i < 7; i++){
            var d = this.startDay+i;
            if(d > 6){
                d = d-7;
            }
            m.push('<th><span>', dn[d].substr(0,1), '</span></th>');
        }
        m[m.length] = '</tr></thead><tbody><tr>';
        for(i = 0; i < 42; i++) {
            if(i % 7 === 0 && i !== 0){
                m[m.length] = '</tr><tr>';
            }
            m[m.length] = '<td><a href="#" hidefocus="on" class="x-date-date" tabIndex="1"><em><span></span></em></a></td>';
        }
        m.push('</tr></tbody></table></td></tr>',
                this.showTime ? '<tr><td colspan="3" class="x-date-time" align="center"></td></tr>' : '',
                this.showToday ? '<tr><td colspan="3" class="x-date-bottom" align="center"></td></tr>' : '',
                '</table><div class="x-date-mp"></div>');

        var el = document.createElement('div');
        el.className = 'x-date-picker';
        el.innerHTML = m.join('');

        container.dom.insertBefore(el, position);

        this.el = Ext.get(el);
        this.eventEl = Ext.get(el.firstChild);

        this.prevRepeater = new Ext.util.ClickRepeater(this.el.child('td.x-date-left a'), {
            handler: this.showPrevMonth,
            scope: this,
            preventDefault:true,
            stopDefault:true
        });

        this.nextRepeater = new Ext.util.ClickRepeater(this.el.child('td.x-date-right a'), {
            handler: this.showNextMonth,
            scope: this,
            preventDefault:true,
            stopDefault:true
        });

        this.monthPicker = this.el.down('div.x-date-mp');
        this.monthPicker.enableDisplayMode('block');

        this.keyNav = new Ext.KeyNav(this.eventEl, {
            'left' : function(e){
                if(e.ctrlKey){
                    this.showPrevMonth();
                }else{
                    this.update(this.activeDate.add('d', -1));
                }
            },

            'right' : function(e){
                if(e.ctrlKey){
                    this.showNextMonth();
                }else{
                    this.update(this.activeDate.add('d', 1));
                }
            },

            'up' : function(e){
                if(e.ctrlKey){
                    this.showNextYear();
                }else{
                    this.update(this.activeDate.add('d', -7));
                }
            },

            'down' : function(e){
                if(e.ctrlKey){
                    this.showPrevYear();
                }else{
                    this.update(this.activeDate.add('d', 7));
                }
            },

            'pageUp' : function(e){
                this.showNextMonth();
            },

            'pageDown' : function(e){
                this.showPrevMonth();
            },

            'enter' : function(e){
                e.stopPropagation();
                return true;
            },

            scope : this
        });
		//Suppress unselectable option to allow chrome input fields to be modified.
//        this.el.unselectable();

        this.cells = this.el.select('table.x-date-inner tbody td');
        this.textNodes = this.el.query('table.x-date-inner tbody span');

        this.mbtn = new Ext.Button({
            text: '&#160;',
            tooltip: this.monthYearText,
            renderTo: this.el.child('td.x-date-middle', true)
        });
        this.mbtn.el.child('em').addClass('x-btn-arrow');

        if(this.showToday){
            this.todayKeyListener = this.eventEl.addKeyListener(Ext.EventObject.SPACE, this.selectToday,  this);
            var today = (new Date()).dateFormat(this.format);
            this.todayBtn = new Ext.Button({
                renderTo: this.el.child('td.x-date-bottom', true),
                text: String.format(this.todayText, today),
                tooltip: String.format(this.todayTip, today),
                handler: this.selectToday,
                scope: this
            });
        }
        
        
        if (this.showTime){

        	this.hourField = new Ext.form.TextField({
                value : this.hourValue, 
                width : "25"
                , 
            	listeners : {
                	scope : this, 
                	specialkey : function (field, e) {
                		if (e.getKey() == e.TAB) {
                			if (e.shiftKey) {
                				this.secondField.focus();
                			}
                			else {
                				this.minuteField.focus();
                			}
                		}
                		
                	}
                }
                , 
                maxLength : 2, 
                maskRe : /[0-9]/, 
                disabled : false, 
                validationEvent : "blur", 
                validator : function (value) {
                	var intValue = parseInt(value);
                	if (!Ext.isEmpty(intValue) && intValue <= 23 && intValue >= 0) {
                		if (value.length == 1) {
                			this.setValue("0" + value);
                		}
                		return true;
                	}
                	else {
                		return "incorrect Value";
                	}
                }
            });
        	this.minuteField = new Ext.form.TextField({
                value : this.minuteValue, 
                width : "25", 
            	listeners : {
                	scope : this, 
                	specialkey : function (field, e) {
                		if (e.getKey() == e.TAB) {
                			if (e.shiftKey) {
                				this.hourField.focus();
                			}
                			else {
                				this.secondField.focus();
                			}
                		}
                		
                	}
                }, 
                maxLength : 2, 
                maskRe : /[0-9]/, 
                validationEvent : "blur", 
                validator : function (value) {
                	var intValue = parseInt(value);
                	if (!Ext.isEmpty(intValue) && intValue <= 59 && intValue >= 0) {
                		if (value.length == 1) {
                			this.setValue("0" + value);
                		}
                		return true;
                	}
                	else {
                		return "incorrect Value";
                	}
                }
            });

        	this.secondField = new Ext.form.TextField({
                value : this.minuteValue, 
                width : "25", 
            	listeners : {
                	scope : this, 
                	specialkey : function (field, e) {
                		if (e.getKey() == e.TAB) {
                			if (e.shiftKey) {
                				this.minuteField.focus();
                			}
                			else {
                				this.hourField.focus();
                			}
                		}
                		
                	}
                }, 
                maxLength : 2, 
                maskRe : /[0-9]/, 
                validationEvent : "blur", 
                validator : function (value) {
                	var intValue = parseInt(value);
                	if (!Ext.isEmpty(intValue) && intValue <= 59 && intValue >= 0) {
                		if (value.length == 1) {
                			this.setValue("0" + value);
                		}
                		return true;
                	}
                	else {
                		return "incorrect Value";
                	}
                }
            });

            var sepLabel1 = new Ext.form.DisplayField({
            	value : ":"
            });
            var sepLabel2 = new Ext.form.DisplayField({
            	value : ":"
            });
            
            this.timeForm = new Ext.form.FormPanel({
        		labelWidth : 1,
        		itemsCls : "sitools-no-margin",
        		items : [{
        			xtype : "compositefield",
        			width : 135,
        			style : {
        				padding : "3px"
        			},
        			items : [this.hourField, sepLabel1, this.minuteField, sepLabel2, this.secondField]
        		}], 
        		renderTo : this.el.child('td.x-date-time', true)
        	});
            /**/
        }
        this.mon(this.eventEl, 'mousewheel', this.handleMouseWheel, this);
        this.mon(this.eventEl, 'click', this.handleDateClick,  this, {delegate: 'a.x-date-date'});
        this.mon(this.mbtn, 'click', this.showMonthPicker, this);
        this.onEnable(true);
    },  

    
    // private
    createMonthPicker : function(){
        if(!this.monthPicker.dom.firstChild){
            var buf = ['<table border="0" cellspacing="0">'];
            for(var i = 0; i < 6; i++){
                buf.push(
                    '<tr><td class="x-date-mp-month"><a href="#">', Date.getShortMonthName(i), '</a></td>',
                    '<td class="x-date-mp-month x-date-mp-sep"><a href="#">', Date.getShortMonthName(i + 6), '</a></td>',
                    i === 0 ?
                    '<td class="x-date-mp-ybtn" align="center"><a class="x-date-mp-prev"></a></td><td class="x-date-mp-ybtn" align="center"><a class="x-date-mp-next"></a></td></tr>' :
                    '<td class="x-date-mp-year"><a href="#"></a></td><td class="x-date-mp-year"><a href="#"></a></td></tr>'
                );
            }
            buf.push(
                '<tr class="x-date-mp-btns"><td colspan="4"><button type="button" class="x-date-mp-ok">',
                    this.okText,
                    '</button><button type="button" class="x-date-mp-cancel">',
                    this.cancelText,
                    '</button></td></tr>',
                '</table>'
            );
            this.monthPicker.update(buf.join(''));

            this.mon(this.monthPicker, 'click', this.onMonthClick, this);
            this.mon(this.monthPicker, 'dblclick', this.onMonthDblClick, this);

            this.mpMonths = this.monthPicker.select('td.x-date-mp-month');
            this.mpYears = this.monthPicker.select('td.x-date-mp-year');

            this.mpMonths.each(function(m, a, i){
                i += 1;
                if((i%2) === 0){
                    m.dom.xmonth = 5 + Math.round(i * 0.5);
                }else{
                    m.dom.xmonth = Math.round((i-1) * 0.5);
                }
            });
        }
    },

    
    // private
    showMonthPicker : function(){
        if(!this.disabled){
            this.createMonthPicker();
            var size = this.el.getSize();
            this.monthPicker.setSize(size);
            this.monthPicker.child('table').setSize(size);

            this.mpSelMonth = (this.activeDate || this.value).getMonth();
            this.updateMPMonth(this.mpSelMonth);
            this.mpSelYear = (this.activeDate || this.value).getFullYear();
            this.updateMPYear(this.mpSelYear);

            this.monthPicker.slideIn('t', {duration:0.2});
        }
    },

    
    // private
    updateMPYear : function(y){
        this.mpyear = y;
        var ys = this.mpYears.elements;
        for(var i = 1; i <= 10; i++){
            var td = ys[i-1], y2;
            if((i%2) === 0){
                y2 = y + Math.round(i * 0.5);
                td.firstChild.innerHTML = y2;
                td.xyear = y2;
            }else{
                y2 = y - (5-Math.round(i * 0.5));
                td.firstChild.innerHTML = y2;
                td.xyear = y2;
            }
            this.mpYears.item(i-1)[y2 == this.mpSelYear ? 'addClass' : 'removeClass']('x-date-mp-sel');
        }
    },

    
    // private
    updateMPMonth : function(sm){
        this.mpMonths.each(function(m, a, i){
            m[m.dom.xmonth == sm ? 'addClass' : 'removeClass']('x-date-mp-sel');
        });
    },

    
    // private
    selectMPMonth : function(m){

    },

    
    // private
    onMonthClick : function(e, t){
        e.stopEvent();
        var el = new Ext.Element(t), pn;
        if(el.is('button.x-date-mp-cancel')){
            this.hideMonthPicker();
        }
        else if(el.is('button.x-date-mp-ok')){
            var d = new Date(this.mpSelYear, this.mpSelMonth, (this.activeDate || this.value).getDate());
            if(d.getMonth() != this.mpSelMonth){
                
                d = new Date(this.mpSelYear, this.mpSelMonth, 1).getLastDateOfMonth();
            }
            this.update(d);
            this.hideMonthPicker();
        }
        else if((pn = el.up('td.x-date-mp-month', 2))){
            this.mpMonths.removeClass('x-date-mp-sel');
            pn.addClass('x-date-mp-sel');
            this.mpSelMonth = pn.dom.xmonth;
        }
        else if((pn = el.up('td.x-date-mp-year', 2))){
            this.mpYears.removeClass('x-date-mp-sel');
            pn.addClass('x-date-mp-sel');
            this.mpSelYear = pn.dom.xyear;
        }
        else if(el.is('a.x-date-mp-prev')){
            this.updateMPYear(this.mpyear-10);
        }
        else if(el.is('a.x-date-mp-next')){
            this.updateMPYear(this.mpyear+10);
        }
    },

    
    // private
    onMonthDblClick : function(e, t){
        e.stopEvent();
        var el = new Ext.Element(t), pn;
        if((pn = el.up('td.x-date-mp-month', 2))){
            this.update(new Date(this.mpSelYear, pn.dom.xmonth, (this.activeDate || this.value).getDate()));
            this.hideMonthPicker();
        }
        else if((pn = el.up('td.x-date-mp-year', 2))){
            this.update(new Date(pn.dom.xyear, this.mpSelMonth, (this.activeDate || this.value).getDate()));
            this.hideMonthPicker();
        }
    },

    
    // private
    hideMonthPicker : function(disableAnim){
        if(this.monthPicker){
            if(disableAnim === true){
                this.monthPicker.hide();
            }else{
                this.monthPicker.slideOut('t', {duration:0.2});
            }
        }
    },

    
    // private
    showPrevMonth : function(e){
        this.update(this.activeDate.add('mo', -1));
    },

    
    // private
    showNextMonth : function(e){
        this.update(this.activeDate.add('mo', 1));
    },

    
    // private
    showPrevYear : function(){
        this.update(this.activeDate.add('y', -1));
    },

    
    // private
    showNextYear : function(){
        this.update(this.activeDate.add('y', 1));
    },

    
    // private
    handleMouseWheel : function(e){
        e.stopEvent();
        if(!this.disabled){
            var delta = e.getWheelDelta();
            if(delta > 0){
                this.showPrevMonth();
            } else if(delta < 0){
                this.showNextMonth();
            }
        }
    },

    
    // private
    handleDateClick : function(e, t){
        e.stopEvent();
        if(!this.disabled && t.dateValue && !Ext.fly(t.parentNode).hasClass('x-date-disabled')){
            this.cancelFocus = this.focusOnSelect === false;
            var date = new Date(t.dateValue);
            if (this.showTime) {
	            date = date.add(Date.HOUR, this.hourField.getValue());
	            date = date.add(Date.MINUTE, this.minuteField.getValue());
	            date = date.add(Date.SECOND, this.secondField.getValue());
	            if (!this.hourField.isValid() || !this.minuteField.isValid() || !this.secondField.isValid()) {
	            	return;
	            }
            }
            this.setValue(date);
            delete this.cancelFocus;
            this.fireEvent('select', this, this.value);
        }
    },

    
    // private
    selectToday : function(){
        if(this.todayBtn && !this.todayBtn.disabled){
            var dateNow = new Date();
            this.setValue(dateNow);
            if (this.showTime) {
		        this.hourField.setValue(dateNow.getHours());
	            this.minuteField.setValue(dateNow.getMinutes());
	            this.secondField.setValue(dateNow.getSeconds());
            }
            this.fireEvent('select', this, this.value);
        }
    },

    
    // private
    update : function(date, forceRefresh){
        if(this.rendered){
            if (!Ext.isDate(date)) {
            	date = new Date();	
            }
            var vd = this.activeDate, vis = this.isVisible();
            var dateWithoutTime = new Date(date.getTime());
            
            dateWithoutTime.setHours(0);
            dateWithoutTime.setMinutes(0);
            dateWithoutTime.setMilliseconds(0);
            dateWithoutTime.setSeconds(0);
            this.activeDate = date;
            if(!forceRefresh && vd && this.el){
                var t = dateWithoutTime.getTime();
                if(vd.getMonth() == dateWithoutTime.getMonth() && vd.getFullYear() == dateWithoutTime.getFullYear()){
                    this.cells.removeClass('x-date-selected');
                    this.cells.each(function(c){
                       if(c.dom.firstChild.dateValue == t){
                           c.addClass('x-date-selected');
                           if(vis && !this.cancelFocus){
                               Ext.fly(c.dom.firstChild).focus(50);
                           }
                           return false;
                       }
                    }, this);
                    return;
                }
            }
            var days = date.getDaysInMonth(),
                firstOfMonth = date.getFirstDateOfMonth(),
                startingPos = firstOfMonth.getDay()-this.startDay;

            if(startingPos < 0){
                startingPos += 7;
            }
            days += startingPos;

            var pm = date.add('mo', -1),
                prevStart = pm.getDaysInMonth()-startingPos,
                cells = this.cells.elements,
                textEls = this.textNodes,
                
                d = (new Date(pm.getFullYear(), pm.getMonth(), prevStart, this.initHour));
                d.setHours(pm.getHours());
                d.setMinutes(pm.getMinutes());
                d.setSeconds(pm.getSeconds());
                
                today = new Date().getTime(),
                sel = date.clearTime(true).getTime(),
                min = this.minDate ? this.minDate.clearTime(true) : Number.NEGATIVE_INFINITY,
                max = this.maxDate ? this.maxDate.clearTime(true) : Number.POSITIVE_INFINITY,
                ddMatch = this.disabledDatesRE,
                ddText = this.disabledDatesText,
                ddays = this.disabledDays ? this.disabledDays.join('') : false,
                ddaysText = this.disabledDaysText,
                format = this.format;

            if(this.showToday){
                var td = new Date().clearTime(),
                    disable = (td < min || td > max ||
                    (ddMatch && format && ddMatch.test(td.dateFormat(format))) ||
                    (ddays && ddays.indexOf(td.getDay()) != -1));

                if(!this.disabled){
                    this.todayBtn.setDisabled(disable);
                    this.todayKeyListener[disable ? 'disable' : 'enable']();
                }
            }

            var setCellClass = function(cal, cell){
                cell.title = '';
                var t = d.clearTime(true).getTime();
                cell.firstChild.dateValue = t;
                if(t == today){
                    cell.className += ' x-date-today';
                    cell.title = cal.todayText;
                }
                if(t == sel){
                    cell.className += ' x-date-selected';
                    if(vis){
                        Ext.fly(cell.firstChild).focus(50);
                    }
                }
                
                if(t < min) {
                    cell.className = ' x-date-disabled';
                    cell.title = cal.minText;
                    return;
                }
                if(t > max) {
                    cell.className = ' x-date-disabled';
                    cell.title = cal.maxText;
                    return;
                }
                if(ddays){
                    if(ddays.indexOf(d.getDay()) != -1){
                        cell.title = ddaysText;
                        cell.className = ' x-date-disabled';
                    }
                }
                if(ddMatch && format){
                    var fvalue = d.dateFormat(format);
                    if(ddMatch.test(fvalue)){
                        cell.title = ddText.replace('%0', fvalue);
                        cell.className = ' x-date-disabled';
                    }
                }
            };

            var i = 0;
            for(; i < startingPos; i++) {
                textEls[i].innerHTML = (++prevStart);
                d.setDate(d.getDate()+1);
                cells[i].className = 'x-date-prevday';
                setCellClass(this, cells[i]);
            }
            for(; i < days; i++){
                var intDay = i - startingPos + 1;
                textEls[i].innerHTML = (intDay);
                d.setDate(d.getDate()+1);
                cells[i].className = 'x-date-active';
                setCellClass(this, cells[i]);
            }
            var extraDays = 0;
            for(; i < 42; i++) {
                 textEls[i].innerHTML = (++extraDays);
                 d.setDate(d.getDate()+1);
                 cells[i].className = 'x-date-nextday';
                 setCellClass(this, cells[i]);
            }

            this.mbtn.setText(this.monthNames[date.getMonth()] + ' ' + date.getFullYear());

            if(!this.internalRender){
                var main = this.el.dom.firstChild,
                    w = main.offsetWidth;
                this.el.setWidth(w + this.el.getBorderWidth('lr'));
                Ext.fly(main).setWidth(w);
                this.internalRender = true;
                
                
                
                if(Ext.isOpera && !this.secondPass){
                    main.rows[0].cells[1].style.width = (w - (main.rows[0].cells[0].offsetWidth+main.rows[0].cells[2].offsetWidth)) + 'px';
                    this.secondPass = true;
                    this.update.defer(10, this, [date]);
                }
            }
        }
    },

    
    // private
    beforeDestroy : function() {
        if(this.rendered){
            Ext.destroy(
                this.keyNav,
                this.monthPicker,
                this.eventEl,
                this.mbtn,
                this.nextRepeater,
                this.prevRepeater,
                this.cells.el,
                this.todayBtn
            );
            delete this.textNodes;
            delete this.cells.elements;
        }
    }

    
});

Ext.reg('datepicker', Ext.SitoolsDatePicker);


/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.3.1
 * Copyright(c) 2006-2010 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
/**
 * Possibilité de paramétrer le zindex de cette fenêtre pour qu'elle reste toujours au dessus d'une autre fenêtre.
 * C'est utile dans le cas ou on utilise ce composant dans l'éditeur HTML CKEDITOR puisque ses fenêtres sont ouvertes
 * en dehors du windowManager de Sitools 
 */
var ImageChooser = function(config){
	this.config = config;
}

ImageChooser.prototype = {
    // cache data by image name for easy lookup
    lookup : {},

	show : function(el, callback){
		if(!this.win){
			this.initTemplates();

			this.store = new Ext.data.JsonStore({
			    url: this.config.url,
			    root: 'items',
			    fields: [
			        'name', 'url',
			        {name:'size', type: 'float'},
			        {name:'lastmod', type:'date', dateFormat:'timestamp'}
			    ],
			    listeners: {
			    	scope : this,
			    	load : function (store, records, options) {
			    		Ext.each(records, function(record){
			    			var url = new Reference(record.get('url'));
			    			var recordUrl = url.getFile();
			    			record.set("url", recordUrl);
			    		});
			    		this.view.select(0);
			    	}
			    }
			});
			
			// S'il y a une exception et que c'est une datatstorage, on essaye de créer le dossier de l'url
			if (!Ext.isEmpty(this.config.urlToUpload) && this.config.isDatastorage == true) {
			    this.store.addListener('exception', function (misc) {
			        Ext.Ajax.request({
                        url : this.config.urlToUpload,
                        method : 'PUT',
                        success : function (ret) {
                        },
                        failure : alertFailure
                    });
			    }, this);
			}
			
			this.store.load();

			var formatSize = function(data){
		        if(data.size < 1024) {
		            return data.size + " bytes";
		        } else {
		            return (Math.round(((data.size*10) / 1024))/10) + " KB";
		        }
		    };

			var formatData = function(data){
		    	data.shortName = data.name.ellipse(15);
		    	data.sizeString = formatSize(data);
		    	data.dateString = new Date(data.lastmod).format("d/m/Y g:i a");
		    	this.lookup[data.name] = data;
		    	return data;
		    };

		    this.view = new Ext.DataView({
				tpl: this.thumbTemplate,
				id : 'imageChooserDataViewId', 
				singleSelect: true,
				overClass:'x-view-over',
				itemSelector: 'div.thumb-wrap',
				emptyText : '<div style="padding:10px;">No images match the specified filter</div>',
				store: this.store,
				listeners: {
					'selectionchange': {fn:this.showDetails, scope:this, buffer:100},
					'dblclick'       : {fn:this.doCallback, scope:this},
					'loadexception'  : {fn:this.onLoadException, scope:this},
					'beforeselect'   : {fn:function(view){
				        return view.store.getRange().length > 0;
				    }}
				},
				prepareData: formatData.createDelegate(this)
			});

		    if (!Ext.isEmpty(fp)){
		    	fp.destroy();
		    }
		    var fp = new Ext.FormPanel({
		        fileUpload: true,
		        frame: true,
		        formId : 'formUploadId', 
		        autoHeight: true,
		        bodyStyle: 'padding: 10px 10px 0 10px;',
		        labelWidth: 50,
		        defaults: {
		            anchor: '95%',
		            allowBlank: false,
		            msgTarget: 'side'
		        },
		        items: [{
		            xtype: 'fileuploadfield',
		            id: 'form-file',
//		            emptyText: 'Select an image',
		            fieldLabel: 'Photo',
		            name: 'image',
		            buttonText: '',
		            buttonCfg: {
		                iconCls: 'upload-icon'
		            }
		        }],
		        buttons: [{
		            text: i18n.get('label.uploadFile'),
		            scope : this, 
		            handler: function(){
		                if(fp.getForm().isValid()){
		                    
		                    var urlUpload;
		                    if (!Ext.isEmpty(this.config.urlToUpload)) {
		                        urlUpload = this.config.urlToUpload;
		                    } else {
		                        urlUpload = loadUrl.get('APP_URL') + '/upload/';
		                    }
		                    
		                	Ext.Ajax.request ({
		                		url : urlUpload,
		                		form : 'formUploadId', 
		                		isUpload : true,
		                		waitMsg : "wait...", 
		                		method : 'POST', 
		                		scope : this,
		                		success : function (response) {
			                		new Ext.ux.Notification({
			    						iconCls:	'x-icon-information',
			    						title:	  i18n.get('label.information'),
			    						html:	  i18n.get ('label.imageUploaded'),
			    						autoDestroy: true,
			    						hideDelay:  1000,
			    						listeners : {
			    							scope : this,
			    							destroy : function (win) {
			    								this.bringToFront(this.win);			    											    								
			    							},
			    							show : function (win) {
			    								this.bringToFront(this.win);
			    							}
			    						}
			    					}).show(document);
			                		
			                		Ext.getCmp('imageChooserDataViewId').refresh();
		                			
		                		}, 
		                		failure : function (response){
		                			Ext.Msg.alert (i18n.get('label.error'));
		                		}, 
		                		callback : function () {
		                			Ext.getCmp('imageChooserDataViewId').getStore().load();
		                			Ext.getCmp('imageChooserDataViewId').refresh();
		                		}
		                	});
		                }
		            }
		        }]
		    });

		    var cfg = {
		    	title: i18n.get('label.chooseImage'),
		    	id: 'img-chooser-dlg',
		    	layout: 'border',
				minWidth: 500,
				minHeight: 450,
				modal: true,
//				closeAction: 'hide',
				border: false,
				items:[{
					id: 'img-chooser-view',
					region: 'center',
					autoScroll: true,
					items: this.view,
                    tbar:[{
                    	text: i18n.get ('label.filter')
                    },{
                    	xtype: 'textfield',
                    	id: 'filter',
                    	selectOnFocus: true,
                    	width: 100,
                    	listeners: {
                    		'render': {fn:function(){
						    	Ext.getCmp('filter').getEl().on('keyup', function(){
						    		this.filter();
						    	}, this, {buffer:500});
                    		}, scope:this}
                    	}
                    }, ' ', '-', {
                    	text: i18n.get ('label.sortBy')
                    }, {
                    	id: 'sortSelect',
                    	xtype: 'combo',
				        typeAhead: true,
				        triggerAction: 'all',
				        width: 100,
				        editable: false,
				        mode: 'local',
				        displayField: 'desc',
				        valueField: 'name',
				        lazyInit: false,
				        value: 'name',
				        store: new Ext.data.ArrayStore({
					        fields: ['name', 'desc'],
					        data : [['name', 'Name'],['size', 'File Size'],['lastmod', 'Last Modified']]
					    }),
					    listeners: {
							'select': {fn:this.sortImages, scope:this}
					    }
				    }]
				},{
					id: 'img-detail-panel',
					region: 'east',
					split: true,
					width: 150,
					minWidth: 150,
					maxWidth: 250
				},{
					id: 'img-upload-panel', 
					title : i18n.get('label.uploadFile'),
					region: 'south', 
					collapsible : true, 
					autoHeight : true, 
//					height : 100, 
					items: [fp]
				}],
				buttons: [{
					id: 'ok-btn',
					text: 'OK',
					handler: this.doCallback,
					scope: this
				},{
					text: 'Cancel',
					handler: function(){ this.win.close(); },
					scope: this
				}],
				keys: {
					key: 27, // Esc key
					handler: function(){ this.win.close(); },
					scope: this
				},
				listeners : {
					scope : this,
					activate : function (win) {
						this.bringToFront(win);
					},
					show : function (win) {
						this.bringToFront(win);
					}
				}
			};
			Ext.apply(cfg, this.config);
		    this.win = new Ext.Window(cfg);
		}

		this.reset();
	    this.win.show(el);
	    
		this.callback = callback;
		this.animateTarget = el;
	},

	initTemplates : function(){
		this.thumbTemplate = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="thumb-wrap" id="{name}">',
				'<div class="thumb"><img src="{[this.formatUrl(values.url)]}" height="96" width="96" title="{name}"></div>',
				'<span>{shortName}</span></div>',
			'</tpl>', {
			formatUrl : function(url) {
				var url = new Reference(url);
    			return url.getFile();
	        }
		});
		this.thumbTemplate.compile();

		this.detailsTemplate = new Ext.XTemplate(
			'<div class="details">',
				'<tpl for=".">',
					'<img height="96" width="96" src="{url}"><div class="details-info">',
					'<b>Image Name:</b>',
					'<span>{name}</span>',
					'<b>Size:</b>',
					'<span>{sizeString}</span>',
					'<b>Last Modified:</b>',
					'<span>{dateString}</span></div>',
				'</tpl>',
			'</div>'
		);
		this.detailsTemplate.compile();
	},

	showDetails : function(){
	    var selNode = this.view.getSelectedNodes();
	    var detailEl = Ext.getCmp('img-detail-panel').body;
		if(selNode && selNode.length > 0){
			selNode = selNode[0];
			Ext.getCmp('ok-btn').enable();
		    var data = this.lookup[selNode.id];
            detailEl.hide();
            this.detailsTemplate.overwrite(detailEl, data);
            detailEl.slideIn('l', {stopFx:true,duration:.2});
		}else{
		    Ext.getCmp('ok-btn').disable();
		    detailEl.update('');
		}
	},

	filter : function(){
		var filter = Ext.getCmp('filter');
		this.view.store.filter('name', filter.getValue());
		this.view.select(0);
	},

	sortImages : function(){
		var v = Ext.getCmp('sortSelect').getValue();
    	this.view.store.sort(v, v == 'name' ? 'asc' : 'desc');
    	this.view.select(0);
    },

	reset : function(){
		if(this.win.rendered){
			Ext.getCmp('filter').reset();
			this.view.getEl().dom.scrollTop = 0;
		}
	    this.view.store.clearFilter();
		this.view.select(0);
	},

	doCallback : function(){
        var selNode = this.view.getSelectedNodes()[0];
		var callback = this.callback;
		var lookup = this.lookup;
		var config = this.config;
		if(selNode && callback){
			var data = lookup[selNode.id];
			callback(data, config);
		}; 
		this.win.close();
    },

	onLoadException : function(v,o){
	    this.view.getEl().update('<div style="padding:10px;">Error loading images.</div>');
	},
	
	bringToFront : function (win){
		if (win && !Ext.isEmpty(win.zindex) && win.isVisible()) {
			win.focus();
			win.setZIndex(win.zindex);
		}
	}
};

String.prototype.ellipse = function(maxLength){
    if(this.length > maxLength){
        return this.substr(0, maxLength-3) + '...';
    }
    return this;
};
/*******************************************************************************
 * Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/*global Ext, sitools, i18n, sql2ext, extColModelToSrv, window,
 extColModelToJsonColModel, DEFAULT_NEAR_LIMIT_SIZE,
 DEFAULT_LIVEGRID_BUFFER_SIZE, SITOOLS_DEFAULT_IHM_DATE_FORMAT,
 DEFAULT_PREFERENCES_FOLDER, SitoolsDesk, getDesktop, userLogin, projectGlobal, ColumnRendererEnum, SITOOLS_DATE_FORMAT
*/
Ext.namespace('sitools.user.component.module');

/**
 * A Simple Object to publish common methods to use module in Sitools2.
 */
sitools.user.component.module.moduleUtils = {
        
        openModule : function (moduleId) {
            var module = SitoolsDesk.app.getModule(moduleId);
            if (Ext.isEmpty(module)) {
                return Ext.Msg.alert(i18n.get('label.info'), i18n.get('label.notEnoughtRightModule'));
            }
            module.openModule();
        }
};/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*
 * Ext JS Library 3.3.1
 * Copyright(c) 2006-2010 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */
Ext.ns('Ext.ux.form');

/**
 * @class Ext.ux.form.FileUploadField
 * @extends Ext.form.TextField
 * Creates a file upload field.
 * @xtype fileuploadfield
 */
Ext.ux.form.FileUploadField = Ext.extend(Ext.form.TextField,  {
    /**
     * @cfg {String} buttonText The button text to display on the upload button (defaults to
     * 'Browse...').  Note that if you supply a value for {@link #buttonCfg}, the buttonCfg.text
     * value will be used instead if available.
     */
    buttonText: 'Browse...',
    /**
     * @cfg {Boolean} buttonOnly True to display the file upload field as a button with no visible
     * text field (defaults to false).  If true, all inherited TextField members will still be available.
     */
    buttonOnly: false,
    /**
     * @cfg {Number} buttonOffset The number of pixels of space reserved between the button and the text field
     * (defaults to 3).  Note that this only applies if {@link #buttonOnly} = false.
     */
    buttonOffset: 3,
    /**
     * @cfg {Object} buttonCfg A standard {@link Ext.Button} config object.
     */

    // private
    readOnly: true,

    /**
     * @hide
     * @method autoSize
     */
    autoSize: Ext.emptyFn,

    // private
    initComponent: function(){
        Ext.ux.form.FileUploadField.superclass.initComponent.call(this);

        this.addEvents(
            /**
             * @event fileselected
             * Fires when the underlying file input field's value has changed from the user
             * selecting a new file from the system file selection dialog.
             * @param {Ext.ux.form.FileUploadField} this
             * @param {String} value The file value returned by the underlying file input field
             */
            'fileselected'
        );
    },

    // private
    onRender : function(ct, position){
        Ext.ux.form.FileUploadField.superclass.onRender.call(this, ct, position);

        this.wrap = this.el.wrap({cls:'x-form-field-wrap x-form-file-wrap'});
        this.el.addClass('x-form-file-text');
        this.el.dom.removeAttribute('name');
        this.createFileInput();

        var btnCfg = Ext.applyIf(this.buttonCfg || {}, {
            text: this.buttonText
        });
        this.button = new Ext.Button(Ext.apply(btnCfg, {
            renderTo: this.wrap,
            cls: 'x-form-file-btn' + (btnCfg.iconCls ? ' x-btn-icon' : '')
        }));

        if(this.buttonOnly){
            this.el.hide();
            this.wrap.setWidth(this.button.getEl().getWidth());
        }

        this.bindListeners();
        this.resizeEl = this.positionEl = this.wrap;
    },
    
    bindListeners: function(){
        this.fileInput.on({
            scope: this,
            mouseenter: function() {
                this.button.addClass(['x-btn-over','x-btn-focus'])
            },
            mouseleave: function(){
                this.button.removeClass(['x-btn-over','x-btn-focus','x-btn-click'])
            },
            mousedown: function(){
                this.button.addClass('x-btn-click')
            },
            mouseup: function(){
                this.button.removeClass(['x-btn-over','x-btn-focus','x-btn-click'])
            },
            change: function(){
                var v = this.fileInput.dom.value;
                this.setValue(v);
                this.fireEvent('fileselected', this, v);    
            }
        }); 
    },
    
    createFileInput : function() {
        this.fileInput = this.wrap.createChild({
            id: this.getFileInputId(),
            name: this.name||this.getId(),
            cls: 'x-form-file',
            tag: 'input',
            type: 'file',
            size: 1
        });
    },
    
    reset : function(){
        this.fileInput.remove();
        this.createFileInput();
        this.bindListeners();
        Ext.ux.form.FileUploadField.superclass.reset.call(this);
    },

    // private
    getFileInputId: function(){
        return this.id + '-file';
    },

    // private
    onResize : function(w, h){
        Ext.ux.form.FileUploadField.superclass.onResize.call(this, w, h);

        this.wrap.setWidth(w);

        if(!this.buttonOnly){
            var w = this.wrap.getWidth() - this.button.getEl().getWidth() - this.buttonOffset;
            this.el.setWidth(w);
        }
    },

    // private
    onDestroy: function(){
        Ext.ux.form.FileUploadField.superclass.onDestroy.call(this);
        Ext.destroy(this.fileInput, this.button, this.wrap);
    },
    
    onDisable: function(){
        Ext.ux.form.FileUploadField.superclass.onDisable.call(this);
        this.doDisable(true);
    },
    
    onEnable: function(){
        Ext.ux.form.FileUploadField.superclass.onEnable.call(this);
        this.doDisable(false);

    },
    
    // private
    doDisable: function(disabled){
        this.fileInput.dom.disabled = disabled;
        this.button.setDisabled(disabled);
    },


    // private
    preFocus : Ext.emptyFn,

    // private
    alignErrorIcon : function(){
        this.errorIcon.alignTo(this.wrap, 'tl-tr', [2, 0]);
    }

});

Ext.reg('fileuploadfield', Ext.ux.form.FileUploadField);

// backwards compat
Ext.form.FileUploadField = Ext.ux.form.FileUploadField;
/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools*/
/* 
 * @include "desktop/desktop.js" 
 */
var SitoolsDesk = new sitools.user.desktop.App();
SitoolsDesk.initDesktopApplication();/***************************************
* Copyright 2010-2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
* 
* This file is part of SITools2.
* 
* SITools2 is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* SITools2 is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with SITools2.  If not, see <http://www.gnu.org/licenses/>.
***************************************/
/*global Ext, sitools, ID, i18n, document, showResponse, alertFailure, LOCALE, ImageChooser, 
 showHelp, loadUrl, ColumnRendererEnum*/

Ext.namespace('sitools.admin.datasets.columnRenderer');
/**
 * List of constants
 * @type sitools.admin.datasets.columnRenderer.columnRenderEnum
 */
sitools.admin.datasets.columnRenderer.behaviorEnum = {
    /**
	 * URL_LOCAL constant
	 * @static
	 * @type String
	 */
	URL_LOCAL : "localUrl",
	/**
	 * URL_EXT_NEW_TAB constant
	 * @static
	 * @type String
	 */
	URL_EXT_NEW_TAB : "extUrlNewTab",
	/**
	 * URL_EXT_DESKTOP constant
	 * @static
	 * @type String
	 */
	URL_EXT_DESKTOP : "extUrlDesktop",
	/**
	 * IMAGE_NO_THUMB constant
	 * @static
	 * @type String
	 */
	IMAGE_NO_THUMB : "ImgNoThumb",
	/**
	 * IMAGE_THUMB_FROM_IMAGE constant
	 * @static
	 * @type String
	 */
	IMAGE_THUMB_FROM_IMAGE : "ImgAutoThumb",
	/**
	 * IMAGE_FROM_SQL constant
	 * @static
	 * @type String
	 */
	IMAGE_FROM_SQL : "ImgThumbSQL",
	/**
	 * DATASET_LINK constant
	 * @static
	 * @type String
	 */
	DATASET_LINK : "datasetLink",
	/**
	 * DATASET_ICON_LINK constant
	 * @static
	 * @type String
	 */
	DATASET_ICON_LINK : "datasetIconLink",
	/**
	 * NO_CLIENT_ACCESS constant
	 * @static
	 * @type String
	 */
	NO_CLIENT_ACCESS : "noClientAccess",
    
    
    getColumnRendererCategoryFromBehavior : function (behavior) {
        var category;
        switch (behavior) {
		case ColumnRendererEnum.URL_LOCAL:
		case ColumnRendererEnum.URL_EXT_NEW_TAB:
		case ColumnRendererEnum.URL_EXT_DESKTOP:
            category = "URL";
            break;
        case ColumnRendererEnum.IMAGE_NO_THUMB:
        case ColumnRendererEnum.IMAGE_THUMB_FROM_IMAGE:
        case ColumnRendererEnum.IMAGE_FROM_SQL:
            category = "Image";
            break;
        case ColumnRendererEnum.DATASET_LINK:
        case ColumnRendererEnum.DATASET_ICON_LINK:
            category = "DataSetLink";
            break;
        case ColumnRendererEnum.NO_CLIENT_ACCESS:
            category = "Other";
            break;
        default :
            category = "";
            break;            
        }
        return category;
    }, 
    /**
     * According to a given column Renderer, return true if the column should be displayed as an image
     * @param {Object} cr the Column Renderer
     * @return {Boolean} true when displaying an image, false otherwise.
     */
    isDisplayingImage : function (cr) {
    	var result = false;
    	switch (cr.behavior) {
        case ColumnRendererEnum.IMAGE_THUMB_FROM_IMAGE:
        case ColumnRendererEnum.IMAGE_FROM_SQL:
	    case ColumnRendererEnum.DATASET_ICON_LINK:
            result = true;
	        break;
   		case ColumnRendererEnum.URL_LOCAL:
		case ColumnRendererEnum.URL_EXT_NEW_TAB:
		case ColumnRendererEnum.URL_EXT_DESKTOP:
			if (cr.type == "Image")
			result = true;
			break;
    	}
    	return result;
		
    }
};

var ColumnRendererEnum = sitools.admin.datasets.columnRenderer.behaviorEnum;/*
 * Javascript FITS Reader 0.2
 * Copyright (c) 2010 Stuart Lowe http://lcogt.net/
 *
 * Licensed under the MPL http://www.mozilla.org/MPL/MPL-1.1.txt
 *
 * Requires Jacob Seidelin's binaryajax.js from http://www.nihilogic.dk/labs/exif/
 */

function FITS (input) {
    this.src = (typeof input == "string") ? input : "";
    this.img = {
        complete : false
    };
    this.xmp = ""; // Will hold the XMP string (for test purposes)
    this.avmdata = false;
    this.tags = {};
    this.stretch = "linear";
    this.color = "gray";
    this.depth = 0;
    this.z = 0;
    this.events = {
        load : "",
        click : "",
        mousemove : ""
    }; // Let's define some events
    this.data = {
        load : "",
        click : "",
        mousemove : ""
    }; // Let's define some event data
}

// Loads the FITS file using an ajax request. To call your own function after
// the FITS file is loaded, you should either provide a callback directly or
// have
// already set the load function.
FITS.prototype.load = function (source, image, fnCallback, fnError) {
    if (typeof source == "string")
        this.src = source;
    if (image != null)
        this.image = image;
    
    if (typeof this.src == "string") {
        this.image = null;
        var _obj = this;
        if (typeof fnCallback == "function")
            _obj.bind("load", fnCallback);
        BinaryAjax(_obj.src, function (oHTTP) {
            var i = _obj.readFITSHeader(oHTTP.binaryResponse);
            if (_obj.header.NAXIS >= 2)
                success = _obj.readFITSImage(oHTTP.binaryResponse, i);
            _obj.triggerEvent("load");
        }, fnError);
    }
    return this;
};

// Parse the ASCII header from the FITS file. It should be at the start.
FITS.prototype.readFITSHeader = function (oFile) {
    var iLength = oFile.getLength();
    var iOffset = 0;
    var header = {};
    var key;
    var val;
    var inHeader = 1;

    while (iOffset < iLength && inHeader) {
        str = oFile.getStringAt(iOffset, 80);
        iOffset += 80;
        var eq = str.indexOf('=');
        key = trim(str.substring(0, eq));
        val = trim(str.substring(eq + 1, Math.max(str.indexOf('/'), str.length)));
        if (key.length > 0) {
            if (val.indexOf("'") == 0) {
                // It is a string
                val = val.substring(1, val.length - 2);
            } else {
                if (val.indexOf('.') >= 0)
                    val = parseFloat(val); // Floating point
                else
                    val = parseInt(val); // Integer
            }
            header[key] = val;
        }
        if (str.indexOf('END') == 0)
            inHeader = 0;
        // console.log(header)
    }

    this.header = header;
    if (this.header.NAXIS >= 2) {
        if (typeof this.header.NAXIS1 == "number")
            this.width = this.header.NAXIS1;
        if (typeof this.header.NAXIS2 == "number")
            this.height = this.header.NAXIS2;
    }

    if (this.header.NAXIS > 2 && typeof this.header.NAXIS3 == "number")
        this.depth = this.header.NAXIS3;
    else
        this.depth = 1;

    if (typeof this.header.BSCALE == "undefined")
        this.header.BSCALE = 1;
    if (typeof this.header.BZERO == "undefined")
        this.header.BZERO = 0;

    // Remove any space padding
    while (iOffset < iLength && oFile.getStringAt(iOffset, 1) == " ")
        iOffset++;

    return iOffset;
};

// Parse the FITS image from the file
FITS.prototype.readFITSImage = function (oFile, iOffset) {
    var iLength = oFile.getLength();
    var i = 0;
    this.z = 0;
    this.image = new Array(this.width * this.height * this.depth);
    var bBigEnd = (typeof this.header.BYTEORDR == "undefined"); // FITS is
                                                                // defined as
                                                                // big endian

    // BITPIX
    // 8-bit (unsigned) integer bytes
    // 16-bit (signed) integers
    // 32-bit (signed) integers
    // 32-bit single precision floating point real numbers
    // 64-bit double precision floating point real numbers
    //
    // Should actually deal with the different cases
    var p = 0;

    if (this.header.BITPIX == 16) {
        i = iOffset;
        while (i < iLength) {
            val = oFile.getSShortAt(i, bBigEnd);
            this.image[p++] = val * this.header.BSCALE + this.header.BZERO;
            i += 2;
        }
        return true;
    } else if (this.header.BITPIX == -32) {
        i = iOffset;
        var x;
        while (i < iLength) {
            x = val = oFile.getLongAt(i, true); // IEEE float32 is always
                                                // big-endian
            if (val != 0)
                val = (1.0 + ((val & 0x007fffff) / 0x0800000)) * Math.pow(2, ((val & 0x7f800000) >> 23) - 127);
            // val = (((0x8000000|(val&0x007fffff))/0x0800000)) *
            // Math.pow(2,(val&0x7f800000)>>23 - 127);
            // val = (val&0x7f800000)>>23-127
            // val = val&0x07fffff

            // alert(x + ' ' + val.toSource())
            // break
            if (x < 0)
                val = -val;
            this.image[p++] = val * this.header.BSCALE + this.header.BZERO;

            i += 4;
        }
        return true;
    } else
        return false;
};

// Use <canvas> to draw a 2D image
FITS.prototype.draw = function (id, type) {
    id = id || this.id;
    this.id = id;
    type = type || this.stretch;

    // Now we want to build the <canvas> element that will hold our image
    var el = document.getElementById(id);
    if (el != null) {
        // Look for a <canvas> with the specified ID or fall back on a <div>
        if (typeof el == "object" && el.tagName != "CANVAS") {
            // Looks like the element is a container for our <canvas>
            el.setAttribute('id', this.id + 'holder');
            var canvas = document.createElement('canvas');
            canvas.style.display = 'block';
            canvas.setAttribute('width', this.width);
            canvas.setAttribute('height', this.height);
            canvas.setAttribute('id', this.id);
            el.appendChild(canvas);
            // For excanvas we need to initialise the newly created <canvas>
            if (/* @cc_on!@ */false)
                el = G_vmlCanvasManager.initElement(this.canvas);
        } else {
            // Define the size of the canvas
            // Excanvas doesn't seem to attach itself to the existing
            // <canvas> so we make a new one and replace it.
            if (/* @cc_on!@ */false) {
                var canvas = document.createElement('canvas');
                canvas.style.display = 'block';
                canvas.setAttribute('width', this.width);
                canvas.setAttribute('height', this.height);
                canvas.setAttribute('id', this.id);
                el.parentNode.replaceChild(canvas, el);
                if (/* @cc_on!@ */false)
                    el = G_vmlCanvasManager.initElement(elcanvas);
            } else {
                el.setAttribute('width', this.width);
                el.setAttribute('height', this.height);
            }
        }
        this.canvas = document.getElementById(id);
    } else
        this.canvas = el;
    this.ctx = this.canvas.getContext("2d");
    var _obj = this;
    // The object didn't exist before so we add a click event to it
    if (typeof this.events.click == "function")
        addEvent(this.canvas, "click", function (e) {
            _obj.clickListener(e);
        });
    if (typeof this.events.mousemove == "function")
        addEvent(this.canvas, "mousemove", function (e) {
            _obj.moveListener(e);
        });

    // create a new batch of pixels with the same
    // dimensions as the image:
    try {
        imageData = this.ctx.createImageData(this.width, this.height);
    }
    catch (e) {
        return e;
    }

    var pos = 0;
    this.update(type, 0);
    return true;
};

// Calculate the pixel values using a defined stretch type and draw onto the
// canvas
FITS.prototype.update = function (inp, callback) {
    if (typeof inp == "object") {
        this.stretch = (typeof inp.stretch == "string") ? inp.stretch : this.stretch;
        if (typeof inp.index != "number" && this.z)
            inp.index = this.z;
        this.z = Math.max(0, Math.min(this.depth - 1, Math.abs(inp.index || 0)));
        this.color = (typeof inp.color == "string") ? inp.color : this.color;
    } else {
        if (typeof inp == "string")
            this.stretch = inp;
    }
    if (this.image == null)
        return 0;

    var mean = 0;
    var median = 0;
    var image = new Array(this.width * this.height);
    var j = 0;
    var i = 0;
    var count = 0;
    var val;
    var start = this.width * this.height * this.z;

    var max;
    var min;
    var stop = start + image.length;

    if (inp.max != undefined && inp.min != undefined) {
        max = inp.max;
        min = inp.min;
    } else {
        max = this.image[start];
        min = this.image[start];

        for (i = start; i < stop; i++) {
            val = this.image[i];
            mean += val;
            if (val > max)
                max = val;
            if (val < min)
                min = val;
        }
    }

    mean /= this.image.length;

    // Calculating the median on the whole image is time consuming.
    // Instead, we'll extract three patches that are 100th the area
    var sorted = new Array();
    // One patch on the top edge (100th of full image)
    for (j = 0; j < Math.round(this.height * 0.1); j++)
        for ( var i = Math.round(this.width * 0.45); i < Math.round(this.width * 0.55); i++)
            sorted[count++] = this.image[start + j * this.width + i];
    // A patch to the lower left of centre (100th of full image)
    for (j = Math.round(this.height * 0.55); j < Math.round(this.height * 0.65); j++)
        for (i = Math.round(this.width * 0.35); i < Math.round(this.width * 0.45); i++)
            sorted[count++] = this.image[start + j * this.width + i];
    // A patch to the right (100th of full image)
    for (j = Math.round(this.height * 0.45); j < Math.round(this.height * 0.55); j++)
        for (i = Math.round(this.width * 0.85); i < Math.round(this.width * 0.95); i++)
            sorted[count++] = this.image[start + j * this.width + i];
    sorted.sort(function sortNumber (a, b) {
        return a - b;
    });
    median = sorted[Math.floor(sorted.length / 2)];

    // Fudge factors
    if (this.stretch == "log") {
        upper = Math.log(max);
        lower = Math.log(sorted[Math.floor(sorted.length / 20)]);
        if (isNaN(lower))
            lower = 1;
    } else if (this.stretch == "loglog") {
        upper = Math.log(Math.log(max));
        lower = Math.log(Math.log(sorted[Math.floor(sorted.length / 20)]));
        if (isNaN(lower))
            lower = 1;
    } else if (this.stretch == "sqrtlog") {
        upper = Math.sqrt(Math.log(max));
        lower = Math.sqrt(Math.log(sorted[Math.floor(sorted.length / 20)]));
        if (isNaN(lower))
            lower = 1;
    } else {
        upper = max - (max - min) * 0.2;
        lower = sorted[Math.floor(sorted.length / 10)];
        if (lower > upper)
            lower = min;
    }
    range = (upper - lower);

    if (this.stretch == "linear")
        for (j = 0, i = start; i < stop; j++, i++)
            image[j] = 255 * ((this.image[i] - lower) / range);
    if (this.stretch == "sqrt")
        for (j = 0, i = start; i < stop; j++, i++)
            image[j] = 255 * Math.sqrt((this.image[i] - lower) / range);
    if (this.stretch == "cuberoot")
        for (j = 0, i = start; i < stop; j++, i++)
            image[j] = 255 * Math.pow((this.image[i] - lower) / range, 0.333);
    if (this.stretch == "log")
        for (j = 0, i = start; i < stop; j++, i++)
            image[j] = 255 * (Math.log(this.image[i]) - lower) / range;
    if (this.stretch == "loglog")
        for (j = 0, i = start; i < stop; j++, i++)
            image[j] = 255 * (Math.log(Math.log(this.image[i])) - lower) / range;
    if (this.stretch == "sqrtlog")
        for (j = 0, i = start; i < stop; j++, i++)
            image[j] = 255 * (Math.sqrt(Math.log(this.image[i])) - lower) / range;
    for (i = 0; i < image.length; i++) {
        val = image[i];
        if (isNaN(val))
            image[i] = 0;
        else if (val < 0)
            image[i] = 0;
        else if (val > 255)
            image[i] = 255;
        else
            image[i] = val;
    }

    var row = 0;
    var col = 0;
    var i = 0;
    for (row = 0; row < this.height; row++) {
        for (col = 0; col < this.width; col++) {
            pos = ((this.height - row) * this.width + col) * 4;
            c = this.colorImage(image[i], this.color);
            // if(i < 3) console.log(c,image[i])
            imageData.data[pos] = c.r;
            imageData.data[pos + 1] = c.g;
            imageData.data[pos + 2] = c.b;
            imageData.data[pos + 3] = 0xff; // alpha
            i++;
        }
    }
    str = "";
    // put pixel data on canvas
    this.ctx.putImageData(imageData, 0, 0);
    
    if (typeof callback == "function") {
        callback();
    }
    
//    return imageData;
};

FITS.prototype.getCursor = function (e) {
    var x;
    var y;
    if (e.pageX != undefined && e.pageY != undefined) {
        x = e.pageX;
        y = e.pageY;
    } else {
        x = e.clientX + document.body.scrollLeft + document.body.scrollLeft + document.documentElement.scrollLeft;
        y = e.clientY + document.body.scrollTop + document.body.scrollTop + document.documentElement.scrollTop;
    }

    var target = e.target;
    while (target) {
        x -= target.offsetLeft;
        y -= target.offsetTop;
        target = target.offsetParent;
        // alert(typeof target)
    }
    this.cursor = {
        x : x,
        y : y
    };
};

FITS.prototype.clickListener = function (e) {
    this.getCursor(e);
    this.triggerEvent("click", {
        x : this.cursor.x,
        y : this.cursor.y
    });
};

FITS.prototype.moveListener = function (e) {
    this.getCursor(e);
    this.triggerEvent("mousemove", {
        x : this.cursor.x,
        y : this.cursor.y
    });
};

FITS.prototype.bind = function (ev, data, fn) {
    if (!fn && typeof data == "function")
        fn = data;
    if (typeof data != "object")
        data = {};
    if (typeof ev != "string" || typeof fn != "function")
        return this;
    if (this.events[ev])
        this.events[ev].push(fn);
    else
        this.events[ev] = [ fn ];
    if (this.data[ev])
        this.data[ev].push(data);
    else
        this.data[ev] = [ data ];
    return this;
};
// Trigger a defined event with arguments.
FITS.prototype.triggerEvent = function (ev, args) {
    if (typeof ev != "string")
        return;
    if (typeof args != "object")
        args = {};
    //var _obj = this;
    if (typeof this.events[ev] == "object") {
        for (var i = 0; i < this.events[ev].length; i++) {
            tmpargs = args;
            tmpargs.data = this.data[ev][i];
            if (typeof this.events[ev][i] == "function")
                this.events[ev][i].call(this, tmpargs);
        }
    }
};
// Colour scales defined by SAOImage
FITS.prototype.colorImage = function (v, type) {
    if (type == "blackbody" || type == "heat")
        return {
            r : ((v <= 127.5) ? v * 2 : 255),
            g : ((v > 63.75) ? ((v < 191.25) ? (v - 63.75) * 2 : 255) : 0),
            b : ((v > 127.5) ? (v - 127.5) * 2 : 0)
        };
    else if (type == "A")
        return {
            r : ((v <= 63.75) ? 0 : ((v <= 127.5) ? (v - 63.75) * 4 : 255)),
            g : ((v <= 63.75) ? v * 4 : ((v <= 127.5) ? (127.5 - v) * 4 : ((v < 191.25) ? 0 : (v - 191.25) * 4))),
            b : ((v < 31.875) ? 0 : ((v < 127.5) ? (v - 31.875) * 8 / 3 : ((v < 191.25) ? (191.25 - v) * 4 : 0)))
        };
    else if (type == "B")
        return {
            r : ((v <= 63.75) ? 0 : ((v <= 127.5) ? (v - 63.75) * 4 : 255)),
            g : ((v <= 127.5) ? 0 : ((v <= 191.25) ? (v - 127.5) * 4 : 255)),
            b : ((v < 63.75) ? v * 4 : ((v < 127.5) ? (127.5 - v) * 4 : ((v < 191.25) ? 0 : (v - 191.25) * 4)))
        };
    else
        return {
            r : v,
            g : v,
            b : v
        };

};

// Helpful functions

// Cross-browser way to add an event
if (typeof addEvent != "function") {
    function addEvent (oElement, strEvent, fncHandler, scope) {
        if (oElement.addEventListener)
            oElement.addEventListener(strEvent, fncHandler, false);
        else if (oElement.attachEvent)
            oElement.attachEvent("on" + strEvent, fncHandler);
    }
}

function trim (s) {
    s = s.replace(/(^\s*)|(\s*$)/gi, "");
    s = s.replace(/[ ]{2,}/gi, " ");
    s = s.replace(/\n /, "\n");
    return s;
}

/*
 * Binary Ajax 0.1.10
 * Copyright (c) 2008 Jacob Seidelin, cupboy@gmail.com, http://blog.nihilogic.dk/
 * Licensed under the MPL License [http://www.nihilogic.dk/licenses/mpl-license.txt]
 */


var BinaryFile = function(strData, iDataOffset, iDataLength) {
	var data = strData;
	var dataOffset = iDataOffset || 0;
	var dataLength = 0;

	this.getRawData = function() {
		return data;
	}

	if (typeof strData == "string") {
		dataLength = iDataLength || data.length;

		this.getByteAt = function(iOffset) {
			return data.charCodeAt(iOffset + dataOffset) & 0xFF;
		}
		
		this.getBytesAt = function(iOffset, iLength) {
			var aBytes = [];
			
			for (var i = 0; i < iLength; i++) {
				aBytes[i] = data.charCodeAt((iOffset + i) + dataOffset) & 0xFF
			};
			
			return aBytes;
		}
	} else if (typeof strData == "unknown") {
		dataLength = iDataLength || IEBinary_getLength(data);

		this.getByteAt = function(iOffset) {
			return IEBinary_getByteAt(data, iOffset + dataOffset);
		}

		this.getBytesAt = function(iOffset, iLength) {
			return new VBArray(IEBinary_getBytesAt(data, iOffset + dataOffset, iLength)).toArray();
		}
	}

	this.getLength = function() {
		return dataLength;
	}

	this.getSByteAt = function(iOffset) {
		var iByte = this.getByteAt(iOffset);
		if (iByte > 127)
			return iByte - 256;
		else
			return iByte;
	}

	this.getShortAt = function(iOffset, bBigEndian) {
		var iShort = bBigEndian ? 
			(this.getByteAt(iOffset) << 8) + this.getByteAt(iOffset + 1)
			: (this.getByteAt(iOffset + 1) << 8) + this.getByteAt(iOffset)
		if (iShort < 0) iShort += 65536;
		return iShort;
	}
	this.getSShortAt = function(iOffset, bBigEndian) {
		var iUShort = this.getShortAt(iOffset, bBigEndian);
		if (iUShort > 32767)
			return iUShort - 65536;
		else
			return iUShort;
	}
	this.getLongAt = function(iOffset, bBigEndian) {
		var iByte1 = this.getByteAt(iOffset),
			iByte2 = this.getByteAt(iOffset + 1),
			iByte3 = this.getByteAt(iOffset + 2),
			iByte4 = this.getByteAt(iOffset + 3);

		var iLong = bBigEndian ? 
			(((((iByte1 << 8) + iByte2) << 8) + iByte3) << 8) + iByte4
			: (((((iByte4 << 8) + iByte3) << 8) + iByte2) << 8) + iByte1;
		if (iLong < 0) iLong += 4294967296;
		return iLong;
	}
	this.getSLongAt = function(iOffset, bBigEndian) {
		var iULong = this.getLongAt(iOffset, bBigEndian);
		if (iULong > 2147483647)
			return iULong - 4294967296;
		else
			return iULong;
	}

	this.getStringAt = function(iOffset, iLength) {
		var aStr = [];
		
		var aBytes = this.getBytesAt(iOffset, iLength);
		for (var j=0; j < iLength; j++) {
			aStr[j] = String.fromCharCode(aBytes[j]);
		}
		return aStr.join("");
	}
	
	this.getCharAt = function(iOffset) {
		return String.fromCharCode(this.getByteAt(iOffset));
	}
	this.toBase64 = function() {
		return window.btoa(data);
	}
	this.fromBase64 = function(strBase64) {
		data = window.atob(strBase64);
	}
}


var BinaryAjax = (function() {

	function createRequest() {
		var oHTTP = null;
		if (window.ActiveXObject) {
			oHTTP = new ActiveXObject("Microsoft.XMLHTTP");
		} else if (window.XMLHttpRequest) {
			oHTTP = new XMLHttpRequest();
		}
		return oHTTP;
	}

	function getHead(strURL, fncCallback, fncError) {
		var oHTTP = createRequest();
		if (oHTTP) {
			if (fncCallback) {
				if (typeof(oHTTP.onload) != "undefined") {
					oHTTP.onload = function() {
						if (oHTTP.status == "200") {
							fncCallback(this);
						} else {
							if (fncError) fncError();
						}
						oHTTP = null;
					};
				} else {
					oHTTP.onreadystatechange = function() {
						if (oHTTP.readyState == 4) {
							if (oHTTP.status == "200") {
								fncCallback(this);
							} else {
								if (fncError) fncError(oHTTP);
							}
							oHTTP = null;
						}
					};
				}
			}
			oHTTP.open("HEAD", strURL, true);
			oHTTP.send(null);
		} else {
			if (fncError) fncError();
		}
	}

	function sendRequest(strURL, fncCallback, fncError, aRange, bAcceptRanges, iFileSize) {
		var oHTTP = createRequest();
		if (oHTTP) {

			var iDataOffset = 0;
			if (aRange && !bAcceptRanges) {
				iDataOffset = aRange[0];
			}
			var iDataLen = 0;
			if (aRange) {
				iDataLen = aRange[1]-aRange[0]+1;
			}

			if (fncCallback) {
				if (typeof(oHTTP.onload) != "undefined") {
					oHTTP.onload = function() {
						if (oHTTP.status == "200" || oHTTP.status == "206" || oHTTP.status == "0") {
							oHTTP.binaryResponse = new BinaryFile(oHTTP.responseText, iDataOffset, iDataLen);
							oHTTP.fileSize = iFileSize || oHTTP.getResponseHeader("Content-Length");
							fncCallback(oHTTP);
						} else {
							if (fncError) fncError();
						}
						oHTTP = null;
					};
				} else {
					oHTTP.onreadystatechange = function() {
						if (oHTTP.readyState == 4) {
							if (oHTTP.status == "200" || oHTTP.status == "206" || oHTTP.status == "0") {
								// IE6 craps if we try to extend the XHR object
								var oRes = {
									status : oHTTP.status,
									// IE needs responseBody, Chrome/Safari needs responseText
									binaryResponse : new BinaryFile(
										typeof oHTTP.responseBody == "unknown" ? oHTTP.responseBody : oHTTP.responseText, iDataOffset, iDataLen
									),
									fileSize : iFileSize || oHTTP.getResponseHeader("Content-Length")
								};
								fncCallback(oRes);
							} else {
								if (fncError) fncError();
							}
							oHTTP = null;
						}
					};
				}
			}
			oHTTP.open("GET", strURL, true);

			if (oHTTP.overrideMimeType) oHTTP.overrideMimeType('text/plain; charset=x-user-defined');

			if (aRange && bAcceptRanges) {
				oHTTP.setRequestHeader("Range", "bytes=" + aRange[0] + "-" + aRange[1]);
			}

//			oHTTP.setRequestHeader("If-Modified-Since", "Sat, 1 Jan 1970 00:00:00 GMT");

			oHTTP.send(null);
		} else {
			if (fncError) fncError();
		}
	}

	return function(strURL, fncCallback, fncError, aRange) {

		if (aRange) {
			getHead(
				strURL, 
				function(oHTTP) {
					var iLength = parseInt(oHTTP.getResponseHeader("Content-Length"),10);
					var strAcceptRanges = oHTTP.getResponseHeader("Accept-Ranges");

					var iStart, iEnd;
					iStart = aRange[0];
					if (aRange[0] < 0) 
						iStart += iLength;
					iEnd = iStart + aRange[1] - 1;

					sendRequest(strURL, fncCallback, fncError, [iStart, iEnd], (strAcceptRanges == "bytes"), iLength);
				}
			);

		} else {
			sendRequest(strURL, fncCallback, fncError);
		}
	}

}());

/*
document.write(
	"<script type='text/vbscript'>\r\n"
	+ "Function IEBinary_getByteAt(strBinary, iOffset)\r\n"
	+ "	IEBinary_getByteAt = AscB(MidB(strBinary,iOffset+1,1))\r\n"
	+ "End Function\r\n"
	+ "Function IEBinary_getLength(strBinary)\r\n"
	+ "	IEBinary_getLength = LenB(strBinary)\r\n"
	+ "End Function\r\n"
	+ "</script>\r\n"
);
*/

document.write(
	"<script type='text/vbscript'>\r\n"
	+ "Function IEBinary_getByteAt(strBinary, iOffset)\r\n"
	+ "	IEBinary_getByteAt = AscB(MidB(strBinary, iOffset + 1, 1))\r\n"
	+ "End Function\r\n"
	+ "Function IEBinary_getBytesAt(strBinary, iOffset, iLength)\r\n"
	+ "  Dim aBytes()\r\n"
	+ "  ReDim aBytes(iLength - 1)\r\n"
	+ "  For i = 0 To iLength - 1\r\n"
	+ "   aBytes(i) = IEBinary_getByteAt(strBinary, iOffset + i)\r\n"  
	+ "  Next\r\n"
	+ "  IEBinary_getBytesAt = aBytes\r\n" 
	+ "End Function\r\n"
	+ "Function IEBinary_getLength(strBinary)\r\n"
	+ "	IEBinary_getLength = LenB(strBinary)\r\n"
	+ "End Function\r\n"
	+ "</script>\r\n"
);// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
document.createElement("canvas").getContext||(function(){var s=Math,j=s.round,F=s.sin,G=s.cos,V=s.abs,W=s.sqrt,k=10,v=k/2;function X(){return this.context_||(this.context_=new H(this))}var L=Array.prototype.slice;function Y(b,a){var c=L.call(arguments,2);return function(){return b.apply(a,c.concat(L.call(arguments)))}}var M={init:function(b){if(/MSIE/.test(navigator.userAgent)&&!window.opera){var a=b||document;a.createElement("canvas");a.attachEvent("onreadystatechange",Y(this.init_,this,a))}},init_:function(b){b.namespaces.g_vml_||
b.namespaces.add("g_vml_","urn:schemas-microsoft-com:vml","#default#VML");b.namespaces.g_o_||b.namespaces.add("g_o_","urn:schemas-microsoft-com:office:office","#default#VML");if(!b.styleSheets.ex_canvas_){var a=b.createStyleSheet();a.owningElement.id="ex_canvas_";a.cssText="canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}g_vml_\\:*{behavior:url(#default#VML)}g_o_\\:*{behavior:url(#default#VML)}"}var c=b.getElementsByTagName("canvas"),d=0;for(;d<c.length;d++)this.initElement(c[d])},
initElement:function(b){if(!b.getContext){b.getContext=X;b.innerHTML="";b.attachEvent("onpropertychange",Z);b.attachEvent("onresize",$);var a=b.attributes;if(a.width&&a.width.specified)b.style.width=a.width.nodeValue+"px";else b.width=b.clientWidth;if(a.height&&a.height.specified)b.style.height=a.height.nodeValue+"px";else b.height=b.clientHeight}return b}};function Z(b){var a=b.srcElement;switch(b.propertyName){case "width":a.style.width=a.attributes.width.nodeValue+"px";a.getContext().clearRect();
break;case "height":a.style.height=a.attributes.height.nodeValue+"px";a.getContext().clearRect();break}}function $(b){var a=b.srcElement;if(a.firstChild){a.firstChild.style.width=a.clientWidth+"px";a.firstChild.style.height=a.clientHeight+"px"}}M.init();var N=[],B=0;for(;B<16;B++){var C=0;for(;C<16;C++)N[B*16+C]=B.toString(16)+C.toString(16)}function I(){return[[1,0,0],[0,1,0],[0,0,1]]}function y(b,a){var c=I(),d=0;for(;d<3;d++){var f=0;for(;f<3;f++){var h=0,g=0;for(;g<3;g++)h+=b[d][g]*a[g][f];c[d][f]=
h}}return c}function O(b,a){a.fillStyle=b.fillStyle;a.lineCap=b.lineCap;a.lineJoin=b.lineJoin;a.lineWidth=b.lineWidth;a.miterLimit=b.miterLimit;a.shadowBlur=b.shadowBlur;a.shadowColor=b.shadowColor;a.shadowOffsetX=b.shadowOffsetX;a.shadowOffsetY=b.shadowOffsetY;a.strokeStyle=b.strokeStyle;a.globalAlpha=b.globalAlpha;a.arcScaleX_=b.arcScaleX_;a.arcScaleY_=b.arcScaleY_;a.lineScale_=b.lineScale_}function P(b){var a,c=1;b=String(b);if(b.substring(0,3)=="rgb"){var d=b.indexOf("(",3),f=b.indexOf(")",d+
1),h=b.substring(d+1,f).split(",");a="#";var g=0;for(;g<3;g++)a+=N[Number(h[g])];if(h.length==4&&b.substr(3,1)=="a")c=h[3]}else a=b;return{color:a,alpha:c}}function aa(b){switch(b){case "butt":return"flat";case "round":return"round";case "square":default:return"square"}}function H(b){this.m_=I();this.mStack_=[];this.aStack_=[];this.currentPath_=[];this.fillStyle=this.strokeStyle="#000";this.lineWidth=1;this.lineJoin="miter";this.lineCap="butt";this.miterLimit=k*1;this.globalAlpha=1;this.canvas=b;
var a=b.ownerDocument.createElement("div");a.style.width=b.clientWidth+"px";a.style.height=b.clientHeight+"px";a.style.overflow="hidden";a.style.position="absolute";b.appendChild(a);this.element_=a;this.lineScale_=this.arcScaleY_=this.arcScaleX_=1}var i=H.prototype;i.clearRect=function(){this.element_.innerHTML=""};i.beginPath=function(){this.currentPath_=[]};i.moveTo=function(b,a){var c=this.getCoords_(b,a);this.currentPath_.push({type:"moveTo",x:c.x,y:c.y});this.currentX_=c.x;this.currentY_=c.y};
i.lineTo=function(b,a){var c=this.getCoords_(b,a);this.currentPath_.push({type:"lineTo",x:c.x,y:c.y});this.currentX_=c.x;this.currentY_=c.y};i.bezierCurveTo=function(b,a,c,d,f,h){var g=this.getCoords_(f,h),l=this.getCoords_(b,a),e=this.getCoords_(c,d);Q(this,l,e,g)};function Q(b,a,c,d){b.currentPath_.push({type:"bezierCurveTo",cp1x:a.x,cp1y:a.y,cp2x:c.x,cp2y:c.y,x:d.x,y:d.y});b.currentX_=d.x;b.currentY_=d.y}i.quadraticCurveTo=function(b,a,c,d){var f=this.getCoords_(b,a),h=this.getCoords_(c,d),g={x:this.currentX_+
0.6666666666666666*(f.x-this.currentX_),y:this.currentY_+0.6666666666666666*(f.y-this.currentY_)};Q(this,g,{x:g.x+(h.x-this.currentX_)/3,y:g.y+(h.y-this.currentY_)/3},h)};i.arc=function(b,a,c,d,f,h){c*=k;var g=h?"at":"wa",l=b+G(d)*c-v,e=a+F(d)*c-v,m=b+G(f)*c-v,r=a+F(f)*c-v;if(l==m&&!h)l+=0.125;var n=this.getCoords_(b,a),o=this.getCoords_(l,e),q=this.getCoords_(m,r);this.currentPath_.push({type:g,x:n.x,y:n.y,radius:c,xStart:o.x,yStart:o.y,xEnd:q.x,yEnd:q.y})};i.rect=function(b,a,c,d){this.moveTo(b,
a);this.lineTo(b+c,a);this.lineTo(b+c,a+d);this.lineTo(b,a+d);this.closePath()};i.strokeRect=function(b,a,c,d){var f=this.currentPath_;this.beginPath();this.moveTo(b,a);this.lineTo(b+c,a);this.lineTo(b+c,a+d);this.lineTo(b,a+d);this.closePath();this.stroke();this.currentPath_=f};i.fillRect=function(b,a,c,d){var f=this.currentPath_;this.beginPath();this.moveTo(b,a);this.lineTo(b+c,a);this.lineTo(b+c,a+d);this.lineTo(b,a+d);this.closePath();this.fill();this.currentPath_=f};i.createLinearGradient=function(b,
a,c,d){var f=new D("gradient");f.x0_=b;f.y0_=a;f.x1_=c;f.y1_=d;return f};i.createRadialGradient=function(b,a,c,d,f,h){var g=new D("gradientradial");g.x0_=b;g.y0_=a;g.r0_=c;g.x1_=d;g.y1_=f;g.r1_=h;return g};i.drawImage=function(b){var a,c,d,f,h,g,l,e,m=b.runtimeStyle.width,r=b.runtimeStyle.height;b.runtimeStyle.width="auto";b.runtimeStyle.height="auto";var n=b.width,o=b.height;b.runtimeStyle.width=m;b.runtimeStyle.height=r;if(arguments.length==3){a=arguments[1];c=arguments[2];h=g=0;l=d=n;e=f=o}else if(arguments.length==
5){a=arguments[1];c=arguments[2];d=arguments[3];f=arguments[4];h=g=0;l=n;e=o}else if(arguments.length==9){h=arguments[1];g=arguments[2];l=arguments[3];e=arguments[4];a=arguments[5];c=arguments[6];d=arguments[7];f=arguments[8]}else throw Error("Invalid number of arguments");var q=this.getCoords_(a,c),t=[];t.push(" <g_vml_:group",' coordsize="',k*10,",",k*10,'"',' coordorigin="0,0"',' style="width:',10,"px;height:",10,"px;position:absolute;");if(this.m_[0][0]!=1||this.m_[0][1]){var E=[];E.push("M11=",
this.m_[0][0],",","M12=",this.m_[1][0],",","M21=",this.m_[0][1],",","M22=",this.m_[1][1],",","Dx=",j(q.x/k),",","Dy=",j(q.y/k),"");var p=q,z=this.getCoords_(a+d,c),w=this.getCoords_(a,c+f),x=this.getCoords_(a+d,c+f);p.x=s.max(p.x,z.x,w.x,x.x);p.y=s.max(p.y,z.y,w.y,x.y);t.push("padding:0 ",j(p.x/k),"px ",j(p.y/k),"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(",E.join(""),", sizingmethod='clip');")}else t.push("top:",j(q.y/k),"px;left:",j(q.x/k),"px;");t.push(' ">','<g_vml_:image src="',b.src,
'"',' style="width:',k*d,"px;"," height:",k*f,'px;"',' cropleft="',h/n,'"',' croptop="',g/o,'"',' cropright="',(n-h-l)/n,'"',' cropbottom="',(o-g-e)/o,'"'," />","</g_vml_:group>");this.element_.insertAdjacentHTML("BeforeEnd",t.join(""))};i.stroke=function(b){var a=[],c=P(b?this.fillStyle:this.strokeStyle),d=c.color,f=c.alpha*this.globalAlpha;a.push("<g_vml_:shape",' filled="',!!b,'"',' style="position:absolute;width:',10,"px;height:",10,'px;"',' coordorigin="0 0" coordsize="',k*10," ",k*10,'"',' stroked="',
!b,'"',' path="');var h={x:null,y:null},g={x:null,y:null},l=0;for(;l<this.currentPath_.length;l++){var e=this.currentPath_[l];switch(e.type){case "moveTo":a.push(" m ",j(e.x),",",j(e.y));break;case "lineTo":a.push(" l ",j(e.x),",",j(e.y));break;case "close":a.push(" x ");e=null;break;case "bezierCurveTo":a.push(" c ",j(e.cp1x),",",j(e.cp1y),",",j(e.cp2x),",",j(e.cp2y),",",j(e.x),",",j(e.y));break;case "at":case "wa":a.push(" ",e.type," ",j(e.x-this.arcScaleX_*e.radius),",",j(e.y-this.arcScaleY_*e.radius),
" ",j(e.x+this.arcScaleX_*e.radius),",",j(e.y+this.arcScaleY_*e.radius)," ",j(e.xStart),",",j(e.yStart)," ",j(e.xEnd),",",j(e.yEnd));break}if(e){if(h.x==null||e.x<h.x)h.x=e.x;if(g.x==null||e.x>g.x)g.x=e.x;if(h.y==null||e.y<h.y)h.y=e.y;if(g.y==null||e.y>g.y)g.y=e.y}}a.push(' ">');if(b)if(typeof this.fillStyle=="object"){var m=this.fillStyle,r=0,n={x:0,y:0},o=0,q=1;if(m.type_=="gradient"){var t=m.x1_/this.arcScaleX_,E=m.y1_/this.arcScaleY_,p=this.getCoords_(m.x0_/this.arcScaleX_,m.y0_/this.arcScaleY_),
z=this.getCoords_(t,E);r=Math.atan2(z.x-p.x,z.y-p.y)*180/Math.PI;if(r<0)r+=360;if(r<1.0E-6)r=0}else{var p=this.getCoords_(m.x0_,m.y0_),w=g.x-h.x,x=g.y-h.y;n={x:(p.x-h.x)/w,y:(p.y-h.y)/x};w/=this.arcScaleX_*k;x/=this.arcScaleY_*k;var R=s.max(w,x);o=2*m.r0_/R;q=2*m.r1_/R-o}var u=m.colors_;u.sort(function(ba,ca){return ba.offset-ca.offset});var J=u.length,da=u[0].color,ea=u[J-1].color,fa=u[0].alpha*this.globalAlpha,ga=u[J-1].alpha*this.globalAlpha,S=[],l=0;for(;l<J;l++){var T=u[l];S.push(T.offset*q+
o+" "+T.color)}a.push('<g_vml_:fill type="',m.type_,'"',' method="none" focus="100%"',' color="',da,'"',' color2="',ea,'"',' colors="',S.join(","),'"',' opacity="',ga,'"',' g_o_:opacity2="',fa,'"',' angle="',r,'"',' focusposition="',n.x,",",n.y,'" />')}else a.push('<g_vml_:fill color="',d,'" opacity="',f,'" />');else{var K=this.lineScale_*this.lineWidth;if(K<1)f*=K;a.push("<g_vml_:stroke",' opacity="',f,'"',' joinstyle="',this.lineJoin,'"',' miterlimit="',this.miterLimit,'"',' endcap="',aa(this.lineCap),
'"',' weight="',K,'px"',' color="',d,'" />')}a.push("</g_vml_:shape>");this.element_.insertAdjacentHTML("beforeEnd",a.join(""))};i.fill=function(){this.stroke(true)};i.closePath=function(){this.currentPath_.push({type:"close"})};i.getCoords_=function(b,a){var c=this.m_;return{x:k*(b*c[0][0]+a*c[1][0]+c[2][0])-v,y:k*(b*c[0][1]+a*c[1][1]+c[2][1])-v}};i.save=function(){var b={};O(this,b);this.aStack_.push(b);this.mStack_.push(this.m_);this.m_=y(I(),this.m_)};i.restore=function(){O(this.aStack_.pop(),
this);this.m_=this.mStack_.pop()};function ha(b){var a=0;for(;a<3;a++){var c=0;for(;c<2;c++)if(!isFinite(b[a][c])||isNaN(b[a][c]))return false}return true}function A(b,a,c){if(!!ha(a)){b.m_=a;if(c)b.lineScale_=W(V(a[0][0]*a[1][1]-a[0][1]*a[1][0]))}}i.translate=function(b,a){A(this,y([[1,0,0],[0,1,0],[b,a,1]],this.m_),false)};i.rotate=function(b){var a=G(b),c=F(b);A(this,y([[a,c,0],[-c,a,0],[0,0,1]],this.m_),false)};i.scale=function(b,a){this.arcScaleX_*=b;this.arcScaleY_*=a;A(this,y([[b,0,0],[0,a,
0],[0,0,1]],this.m_),true)};i.transform=function(b,a,c,d,f,h){A(this,y([[b,a,0],[c,d,0],[f,h,1]],this.m_),true)};i.setTransform=function(b,a,c,d,f,h){A(this,[[b,a,0],[c,d,0],[f,h,1]],true)};i.clip=function(){};i.arcTo=function(){};i.createPattern=function(){return new U};function D(b){this.type_=b;this.r1_=this.y1_=this.x1_=this.r0_=this.y0_=this.x0_=0;this.colors_=[]}D.prototype.addColorStop=function(b,a){a=P(a);this.colors_.push({offset:b,color:a.color,alpha:a.alpha})};function U(){}G_vmlCanvasManager=
M;CanvasRenderingContext2D=H;CanvasGradient=D;CanvasPattern=U})();
// Generated by CoffeeScript 1.4.0
(function() {
	var BinaryTable, CompressedImage, DataUnit, Decompress, ASTROFITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords, __indexOf = [].indexOf
			|| function(item) {
				for (var i = 0, l = this.length; i < l; i++) {
					if (i in this && this[i] === item)
						return i;
				}
				return -1;
			}, __hasProp = {}.hasOwnProperty, __extends = function(child,
			parent) {
		for (var key in parent) {
			if (__hasProp.call(parent, key))
				child[key] = parent[key];
		}
		function ctor() {
			this.constructor = child;
		}
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
		child.__super__ = parent.prototype;
		return child;
	}, __slice = [].slice, __bind = function(fn, me) {
		return function() {
			return fn.apply(me, arguments);
		};
	};

	if (this.astro == null) {
		this.astro = {};
	}

	ASTROFITS = {};

	ASTROFITS.version = '0.2.3';

	this.astro.ASTROFITS = ASTROFITS;

	moduleKeywords = ['included', 'extended'];

	Module = (function() {

		function Module() {
		}

		Module.include = function(obj) {
			var key, value, _ref;
			if (!obj) {
				throw 'include(obj) requires obj';
			}
			for (key in obj) {
				value = obj[key];
				if (__indexOf.call(moduleKeywords, key) < 0) {
					this.prototype[key] = value;
				}
			}
			if ((_ref = obj.included) != null) {
				_ref.apply(this);
			}
			return this;
		};

		Module.extend = function(obj) {
			var key, value, _ref;
			if (!obj) {
				throw 'extend(obj) requires obj';
			}
			for (key in obj) {
				value = obj[key];
				if (__indexOf.call(moduleKeywords, key) < 0) {
					this[key] = value;
				}
			}
			if ((_ref = obj.extended) != null) {
				_ref.apply(this);
			}
			return this;
		};

		Module.proxy = function(func) {
			var _this = this;
			return function() {
				return func.apply(_this, arguments);
			};
		};

		Module.prototype.proxy = function(func) {
			var _this = this;
			return function() {
				return func.apply(_this, arguments);
			};
		};

		return Module;

	})();

	this.astro.ASTROFITS.Module = Module;

	DataUnit = (function(_super) {

		__extends(DataUnit, _super);

		function DataUnit(view, header) {
			this.view = view;
			this.begin = this.current = view.tell();
			this.length = void 0;
		}

		return DataUnit;

	})(Module);

	this.astro.ASTROFITS.DataUnit = DataUnit;

	HeaderVerify = {
		verifyOrder : function(keyword, order) {
			if (order !== this.cardIndex) {
				return console.warn("" + keyword + " should appear at index "
						+ this.cardIndex + " in the ASTROFITS header");
			}
		},
		verifyBetween : function(keyword, value, lower, upper) {
			if (!(value >= lower && value <= upper)) {
				throw "The " + keyword + " value of " + value
						+ " is not between " + lower + " and " + upper;
			}
		},
		verifyBoolean : function(value) {
			if (value === "T") {
				return true;
			} else {
				return false;
			}
		},
		Functions : {
			SIMPLE : function() {
				var args, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				value = arguments[0];
				this.primary = true;
				this.verifyOrder("SIMPLE", 0);
				return this.verifyBoolean(value);
			},
			XTENSION : function() {
				var args, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				value = arguments[0];
				this.extension = true;
				this.extensionType = value;
				this.verifyOrder("XTENSION", 0);
				return value;
			},
			BITPIX : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "BITPIX";
				value = parseInt(arguments[0]);
				this.verifyOrder(key, 1);
				if (value !== 8 && value !== 16 && value !== 32 && value !== 64
						&& value !== (-32) && value !== (-64)) {
					throw "" + key + " value " + value + " is not permitted";
				}
				return value;
			},
			NAXIS : function() {
				var args, array, key, required, value, _ref;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "NAXIS";
				value = parseInt(arguments[0]);
				array = arguments[1];
				if (!array) {
					this.verifyOrder(key, 2);
					this.verifyBetween(key, value, 0, 999);
					if (this.isExtension()) {
						if ((_ref = this.extensionType) === "TABLE"
								|| _ref === "BINTABLE") {
							required = 2;
							if (value !== required) {
								throw "" + key + " must be " + required
										+ " for TABLE and BINTABLE extensions";
							}
						}
					}
				}
				return value;
			},
			PCOUNT : function() {
				var args, key, order, required, value, _ref;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "PCOUNT";
				value = parseInt(arguments[0]);
				order = 1 + 1 + 1 + this["NAXIS"];
				this.verifyOrder(key, order);
				if (this.isExtension()) {
					if ((_ref = this.extensionType) === "IMAGE"
							|| _ref === "TABLE") {
						required = 0;
						if (value !== required) {
							throw "" + key + " must be " + required
									+ " for the " + this.extensionType
									+ " extensions";
						}
					}
				}
				return value;
			},
			GCOUNT : function() {
				var args, key, order, required, value, _ref;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "GCOUNT";
				value = parseInt(arguments[0]);
				order = 1 + 1 + 1 + this["NAXIS"] + 1;
				this.verifyOrder(key, order);
				if (this.isExtension()) {
					if ((_ref = this.extensionType) === "IMAGE"
							|| _ref === "TABLE" || _ref === "BINTABLE") {
						required = 1;
						if (value !== required) {
							throw "" + key + " must be " + required
									+ " for the " + this.extensionType
									+ " extensions";
						}
					}
				}
				return value;
			},
			EXTEND : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "EXTEND";
				value = arguments[0];
				if (!this.isPrimary()) {
					throw "" + key + " must only appear in the primary header";
				}
				return this.verifyBoolean(value);
			},
			BSCALE : function() {
				var args;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			BZERO : function() {
				var args;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			BLANK : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "BLANK";
				value = arguments[0];
				// if (!(this["BITPIX"] > 0)) {
				// throw "" + key + " is not to be used for BITPIX = " +
				// this['BITPIX'];
				// }
				return parseInt(value);
			},
			DATAMIN : function() {
				var args;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			DATAMAX : function() {
				var args;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				return parseFloat(arguments[0]);
			},
			EXTVER : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "EXTVER";
				value = arguments[0];
				value = parseInt(value);
				return value;
			},
			EXTLEVEL : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "EXTLEVEL";
				value = arguments[0];
				value = parseInt(value);
				return value;
			},
			TFIELDS : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "TFIELDS";
				value = arguments[0];
				value = parseInt(value);
				this.verifyBetween(key, value, 0, 999);
				return value;
			},
			TBCOL : function() {
				var args, index, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "TBCOL";
				value = arguments[0];
				index = arguments[2];
				this.verifyBetween(key, index, 0, this["TFIELDS"]);
				return value;
			},
			ZIMAGE : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZIMAGE";
				value = arguments[0];
				return this.verifyBoolean(value);
			},
			ZCMPTYPE : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZCMPTYPE";
				value = arguments[0];
				if (value !== 'GZIP_1' && value !== 'RICE_1'
						&& value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
					throw "" + key + " value " + value + " is not permitted";
				}
				if (value !== 'RICE_1' && value !== 'GZIP_1') {
					throw "Compress type " + value + " is not yet implement";
				}
				return value;
			},
			ZBITPIX : function() {
				var args, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZBITPIX";
				value = parseInt(arguments[0]);
				if (value !== 8 && value !== 16 && value !== 32 && value !== 64
						&& value !== (-32) && value !== (-64)) {
					throw "" + key + " value " + value + " is not permitted";
				}
				return value;
			},
			ZNAXIS : function() {
				var args, array, key, value;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZNAXIS";
				value = parseInt(arguments[0]);
				array = arguments[1];
				value = value;
				if (!array) {
					this.verifyBetween(key, value, 0, 999);
				}
				return value;
			},
			ZTILE : function() {
				var args, key;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZTILE";
				return parseInt(arguments[0]);
			},
			ZSIMPLE : function() {
				var args;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				if (arguments[0] === "T") {
					return true;
				} else {
					return false;
				}
			},
			ZPCOUNT : function() {
				var args, key;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZPCOUNT";
				return parseInt(arguments[0]);
			},
			ZGCOUNT : function() {
				var args, key;
				args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				key = "ZGCOUNT";
				return parseInt(arguments[0]);
			}
		}
	};

	this.astro.ASTROFITS.HeaderVerify = HeaderVerify;

	Header = (function(_super) {

		__extends(Header, _super);

		Header.keywordPattern = /^([A-Z0-9_-]+)\s*=\s*(.*)/;

		Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

		Header.stringPattern = /'(.*)'\s*\/*(.*)/;

		Header.arrayPattern = /([A-Za-z]+)(\d+)/;

		Header.include(HeaderVerify);

		function Header() {
			this.init = __bind(this.init, this);

			var method, name, _ref;
			this.primary = false;
			this.extension = false;
			this.verifyCard = {};
			_ref = this.Functions;
			for (name in _ref) {
				method = _ref[name];
				this.verifyCard[name] = this.proxy(method);
			}
			this.cards = {};
			this.cardIndex = 0;
		}

		Header.prototype.get = function(key) {
			if (this.contains(key)) {
				return this.cards[key];
			} else {
				return console.warn("Header does not contain the key " + key);
			}
		};

		Header.prototype.getIndex = function(key) {
			if (this.contains(key)) {
				return this.cards[key][0];
			} else {
				return console.warn("Header does not contain the key " + key);
			}
		};

		Header.prototype.getComment = function(key) {
			if (this.contains(key)) {
				if (this.cards[key][2] != null) {
					return this.cards[key][2];
				} else {
					return console.warn("" + key
							+ " does not contain a comment");
				}
			} else {
				return console.warn("Header does not contain the key " + key);
			}
		};

		Header.prototype.getComments = function() {
			if (this.contains('COMMENT')) {
				return this.cards['COMMENT'];
			} else {
				return console
						.warn("Header does not contain any COMMENT fields");
			}
		};

		Header.prototype.getHistory = function() {
			if (this.contains('HISTORY')) {
				return this.cards['HISTORY'];
			} else {
				return console
						.warn("Header does not contain any HISTORY fields");
			}
		};

		Header.prototype.set = function(key, value, comment) {
			this.cards[key] = comment ? [this.cardIndex, value, comment] : [
					this.cardIndex, value];
			return this.cardIndex += 1;
		};

		Header.prototype.setComment = function(comment) {
			if (!this.contains("COMMENT")) {
				this.cards["COMMENT"] = [];
				this.cardIndex += 1;
			}
			return this.cards["COMMENT"].push(comment);
		};

		Header.prototype.setHistory = function(history) {
			if (!this.contains("HISTORY")) {
				this.cards["HISTORY"] = [];
				this.cardIndex += 1;
			}
			return this.cards["HISTORY"].push(history);
		};

		Header.prototype.contains = function(keyword) {
			return this.cards.hasOwnProperty(keyword);
		};

		Header.prototype.readCard = function(line) {
			var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
			match = line.match(Header.keywordPattern);
			if (match == null) {
				return;
			}
			_ref = match.slice(1), key = _ref[0], value = _ref[1];
			if (key === "COMMENT" || key === "HISTORY") {
				match[1] = value.trim();
			} else if (value[0] === "'") {
				match = value.match(Header.stringPattern);
				match[1] = match[1].trim();
			} else {
				match = value.match(Header.nonStringPattern);
				match[1] = (_ref1 = match[1][0]) === "T" || _ref1 === "F"
						? match[1].trim()
						: parseFloat(match[1]);
			}
			match[2] = match[2].trim();
			_ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
			keyToVerify = key;
			_ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
			match = key.match(Header.arrayPattern);
			if (match != null) {
				keyToVerify = match[1];
				_ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
			}
			if (this.verifyCard.hasOwnProperty(keyToVerify)) {
				value = this.verifyCard[keyToVerify](value, array, index);
			}
			switch (key) {
				case "COMMENT" :
					return this.setComment(value);
				case "HISTORY" :
					return this.setHistory(value);
				default :
					this.set(key, value, comment);
					return this.__defineGetter__(key, function() {
								return this.cards[key][1];
							});
			}
		};

		Header.prototype.init = function(block) {
			var i, line, lineWidth, maxNumLines, numLines, _i, _ref, _results;
			lineWidth = 80;
			numLines = block.length / lineWidth;
			maxNumLines = 600;
			numLines = numLines < maxNumLines ? numLines : maxNumLines;
			_results = [];
			for (i = _i = 0, _ref = numLines - 1; 0 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
				line = block.slice(i * lineWidth, (i + 1) * lineWidth);
				_results.push(this.readCard(line));
			}
			return _results;
		};

		Header.prototype.hasDataUnit = function() {
			if (this["NAXIS"] === 0) {
				return false;
			} else {
				return true;
			}
		};

		Header.prototype.isPrimary = function() {
			return this.primary;
		};

		Header.prototype.isExtension = function() {
			return this.extension;
		};

		return Header;

	})(Module);

	this.astro.ASTROFITS.Header = Header;

	ImageUtils = {
		initArray : function(arrayType) {
			return this.data = new arrayType(this.width * this.height);
		},
		getExtremes : function() {
			var index, max, min, value, _ref, _ref1;
			if ((this.min != null) && (this.max != null)) {
				return [this.min, this.max];
			}
			index = this.data.length;
			while (index--) {
				value = this.data[index];
				if (isNaN(value)) {
					continue;
				}
				_ref = [value, value], min = _ref[0], max = _ref[1];
				break;
			}
			while (index--) {
				value = this.data[index];
				if (isNaN(value)) {
					continue;
				}
				if (value < min) {
					min = value;
				}
				if (value > max) {
					max = value;
				}
			}
			_ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
			return [this.min, this.max];
		},
		getPixel : function(x, y) {
			return this.data[y * this.width + x];
		}
	};

	this.astro.ASTROFITS.ImageUtils = ImageUtils;

	Image = (function(_super) {

		__extends(Image, _super);

		Image.include(ImageUtils);

		function Image(view, header) {
			var bitpix, i, naxis, _i, _this = this;
			Image.__super__.constructor.apply(this, arguments);
			naxis = header["NAXIS"];
			bitpix = header["BITPIX"];
			this.naxis = [];
			for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis
					? ++_i
					: --_i) {
				this.naxis.push(header["NAXIS" + i]);
			}
			this.width = header["NAXIS1"];
			this.height = header["NAXIS2"] || 1;
			this.bzero = header["BZERO"] || 0;
			this.bscale = header["BSCALE"] || 1;
			this.rowByteSize = this.width * Math.abs(bitpix) / 8;
			this.totalRowsRead = 0;
			this.length = this.naxis.reduce(function(a, b) {
						return a * b;
					}) * Math.abs(bitpix) / 8;
			this.data = void 0;
			this.frame = 0;
			switch (bitpix) {
				case 8 :
					if (this.bscale % 1 === 0) {
						this.arrayType = Uint8Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint8();
						};
					} else {
						this.arrayType = Float32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint8();
						};
					}
					break;
				case 16 :
					if (this.bscale % 1 === 0) {
						this.arrayType = Int16Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getInt16();
						};
					} else {
						this.arrayType = Float32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getInt16();
						};
					}
					break;
				case 32 :
					if (this.bscale % 1 === 0) {
						this.arrayType = Int32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint32();
						};
					} else {
						this.arrayType = Float32Array;
						this.accessor = function() {
							return _this.bzero + _this.bscale
									* _this.view.getUint32();
						};
					}
					break;
				case 64 :
					this.arrayType = this.bscale % 1 === 0
							? Int32Array
							: Float32Array;
					console.warn("Unusual behaviour with 64 bit integers.");
					this.accessor = function() {
						var factor, highByte, lowByte, mod, value;
						highByte = Math.abs(_this.view.getInt32());
						lowByte = Math.abs(_this.view.getInt32());
						mod = highByte % 10;
						factor = mod ? -1 : 1;
						highByte -= mod;
						value = factor * ((highByte << 32) | lowByte);
						return _this.bzero + _this.bscale * value;
					};
					break;
				case -32 :
					this.arrayType = Float32Array;
					this.accessor = function() {
						return _this.bzero + _this.bscale
								* _this.view.getFloat32();
					};
					break;
				case -64 :
					this.arrayType = Float64Array;
					this.accessor = function() {
						return _this.bzero + _this.bscale
								* _this.view.getFloat64();
					};
					break;
				default :
					throw "Invalid BITPIX.";
			}
		}

		Image.prototype.getRow = function() {
			var i, _i, _ref;
			this.current = this.begin + this.totalRowsRead * this.rowByteSize;
			this.view.seek(this.current);
			for (i = _i = 0, _ref = this.width - 1; 0 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
				this.data[this.width * this.rowsRead + i] = this.accessor();
			}
			this.rowsRead += 1;
			return this.totalRowsRead += 1;
		};

		Image.prototype.getFrame = function(frame) {
			var height;
			this.frame = frame != null ? frame : this.frame;
			if (this.data == null) {
				this.initArray(this.arrayType);
			}
			this.totalRowsRead = this.width * this.frame;
			this.rowsRead = 0;
			height = this.height;
			while (height--) {
				this.getRow();
			}
			this.frame += 1;
			return this.data;
		};

		Image.prototype.seek = function(frame) {
			if (frame == null) {
				frame = 0;
			}
			if (this.naxis.length === 2) {
				this.totalRowsRead = 0;
				return this.frame = 0;
			} else {
				this.totalRowsRead = this.height * frame;
				return this.frame = this.height / this.totalRowsRead - 1;
			}
		};

		Image.prototype.isDataCube = function() {
			if (this.naxis.length > 2) {
				return true;
			} else {
				return false;
			}
		};

		return Image;

	})(DataUnit);

	this.astro.ASTROFITS.Image = Image;

	Tabular = (function(_super) {

		__extends(Tabular, _super);

		Tabular.dataAccessors = {
			L : function(view) {
				if (view.getInt8() === 84) {
					return true;
				} else {
					return false;
				}
			},
			X : function(view) {
				throw "Data type not yet implemented";
			},
			B : function(view) {
				return view.getUint8();
			},
			I : function(view) {
				return view.getInt16();
			},
			J : function(view) {
				return view.getInt32();
			},
			K : function(view) {
				var factor, highByte, lowByte, mod, value;
				highByte = Math.abs(view.getInt32());
				lowByte = Math.abs(view.getInt32());
				mod = highByte % 10;
				factor = mod ? -1 : 1;
				highByte -= mod;
				value = factor * ((highByte << 32) | lowByte);
				console
						.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
				return value;
			},
			A : function(view) {
				return view.getChar();
			},
			E : function(view) {
				return view.getFloat32();
			},
			D : function(view) {
				return view.getFloat64();
			},
			C : function(view) {
				return [view.getFloat32(), view.getFloat32()];
			},
			M : function(view) {
				return [view.getFloat64(), view.getFloat64()];
			}
		};

		function Tabular(view, header) {
			this.getRow = __bind(this.getRow, this);
			Tabular.__super__.constructor.apply(this, arguments);
			this.rowByteSize = header["NAXIS1"];
			this.rows = header["NAXIS2"];
			this.cols = header["TFIELDS"];
			this.length = this.tableLength = this.rowByteSize * this.rows;
			this.rowsRead = 0;
			this.columns = this.getColumnNames(header);
			this.accessors = [];
		}

		Tabular.prototype.getRow = function(row) {
			var accessor, index, _i, _len, _ref;
			if (row == null) {
				row = null;
			}
			if (row != null) {
				this.rowsRead = row;
			}
			this.current = this.begin + this.rowsRead * this.rowByteSize;
			this.view.seek(this.current);
			row = {};
			_ref = this.accessors;
			for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
				accessor = _ref[index];
				row[this.columns[index]] = accessor();
			}
			this.rowsRead += 1;
			return row;
		};

		Tabular.prototype.getColumnNames = function(header) {
			var columnNames, i, key, _i, _ref;
			columnNames = [];
			for (i = _i = 1, _ref = this.cols; 1 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
				key = "TTYPE" + i;
				if (!header.contains(key)) {
					return null;
				}
				columnNames.push(header[key]);
			}
			return columnNames;
		};

		return Tabular;

	})(DataUnit);

	this.astro.ASTROFITS.Tabular = Tabular;

	Table = (function(_super) {

		__extends(Table, _super);

		Table.formPattern = /([AIFED])(\d+)\.*(\d+)*/;

		Table.dataAccessors = {
			A : function(value) {
				return value.trim();
			},
			I : function(value) {
				return parseInt(value);
			},
			F : function(value) {
				return parseFloat(value);
			},
			E : function(value) {
				return parseFloat(value);
			},
			D : function(value) {
				return parseFloat(value);
			}
		};

		function Table(view, header) {
			this.getRow = __bind(this.getRow, this);

			var form, i, match, _fn, _i, _ref, _this = this;
			Table.__super__.constructor.apply(this, arguments);
			_fn = function() {
				var accessor, dataType, decimals, length, _ref1;
				_ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
				accessor = function(value) {
					return Table.dataAccessors[dataType](value);
				};
				return _this.accessors.push(accessor);
			};
			for (i = _i = 1, _ref = this.cols; 1 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
				form = header["TFORM" + i];
				match = form.match(Table.formPattern);
				_fn();
			}
		}

		Table.prototype.getRow = function(row) {
			var i, index, line, value, _i, _j, _len, _ref;
			if (row == null) {
				row = null;
			}
			if (row != null) {
				this.rowsRead = row;
			}
			this.current = this.begin + this.rowsRead * this.rowByteSize;
			this.view.seek(this.current);
			line = "";
			for (i = _i = 1, _ref = this.rowByteSize; 1 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
				line += this.view.getChar();
			}
			line = line.trim().split(/\s+/);
			row = {};
			for (index = _j = 0, _len = line.length; _j < _len; index = ++_j) {
				value = line[index];
				row[this.columns[index]] = this.accessors[index](value);
			}
			this.rowsRead += 1;
			return row;
		};

		return Table;

	})(Tabular);

	this.astro.ASTROFITS.Table = Table;

	BinaryTable = (function(_super) {

		__extends(BinaryTable, _super);

		BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

		BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

		function BinaryTable(view, header) {
			var dataType, i, keyword, length, match, value, _i, _ref, _ref1, _this = this;
			BinaryTable.__super__.constructor.apply(this, arguments);
			for (i = _i = 1, _ref = this.cols; 1 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
				keyword = "TFORM" + i;
				value = header[keyword];
				match = value.match(BinaryTable.arrayDescriptorPattern);
				if (match != null) {
					(function() {
						var accessor, dataType;
						dataType = match[1];
						accessor = function() {
							var data, length, offset, _j;
							length = _this.view.getInt32();
							offset = _this.view.getInt32();
							_this.current = _this.view.tell();
							_this.view.seek(_this.begin + _this.tableLength
									+ offset);
							data = [];
							for (i = _j = 1; 1 <= length
									? _j <= length
									: _j >= length; i = 1 <= length
									? ++_j
									: --_j) {
								data
										.push(BinaryTable.dataAccessors[dataType](_this.view));
							}
							_this.view.seek(_this.current);
							return data;
						};
						return _this.accessors.push(accessor);
					})();
				} else {
					match = value.match(BinaryTable.dataTypePattern);
					_ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
					length = length ? parseInt(length) : 0;
					if (length === 0 || length === 1) {
						(function(dataType) {
							var accessor;
							accessor = function() {
								var data;
								data = BinaryTable.dataAccessors[dataType](_this.view);
								return data;
							};
							return _this.accessors.push(accessor);
						})(dataType);
					} else {
						(function(dataType, length) {
							var accessor, numBytes;
							if (dataType === 'X') {
								numBytes = Math.log(length) / Math.log(2);
								accessor = function() {
									var bit, bitarray, byte, byte2bits, data, _j, _k, _len;
									byte2bits = function(byte) {
										var bitarray;
										bitarray = [];
										i = 128;
										while (i >= 1) {
											bitarray.push((byte & i ? 1 : 0));
											i /= 2;
										}
										return bitarray;
									};
									data = [];
									for (i = _j = 1; 1 <= numBytes
											? _j <= numBytes
											: _j >= numBytes; i = 1 <= numBytes
											? ++_j
											: --_j) {
										byte = _this.view.getUint8();
										bitarray = byte2bits(byte);
										for (_k = 0, _len = bitarray.length; _k < _len; _k++) {
											bit = bitarray[_k];
											data.push(bit);
										}
									}
									return data.slice(0, +(length - 1) + 1
													|| 9e9);
								};
							} else if (dataType === 'A') {
								accessor = function() {
									var data, _j;
									data = '';
									for (i = _j = 1; 1 <= length
											? _j <= length
											: _j >= length; i = 1 <= length
											? ++_j
											: --_j) {
										data += BinaryTable.dataAccessors[dataType](_this.view);
									}
									return data.trim();
								};
							} else {
								accessor = function() {
									var data, _j;
									data = [];
									for (i = _j = 1; 1 <= length
											? _j <= length
											: _j >= length; i = 1 <= length
											? ++_j
											: --_j) {
										data
												.push(BinaryTable.dataAccessors[dataType](_this.view));
									}
									return data;
								};
							}
							return _this.accessors.push(accessor);
						})(dataType, length);
					}
				}
			}
		}

		return BinaryTable;

	})(Tabular);

	this.astro.ASTROFITS.BinaryTable = BinaryTable;

	Decompress = {
		Rice : function(array, arrayLen, blocksize, bytepix, pixels, nx) {
			var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
			bbits = 1 << fsbits;
			_ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
			nonzeroCount = new Uint8Array(256);
			nzero = 8;
			_ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
			while (i >= 0) {
				while (i >= k) {
					nonzeroCount[i] = nzero;
					i -= 1;
				}
				k = k / 2;
				nzero -= 1;
			}
			nonzeroCount[0] = 0;
			b = array[pointer];
			pointer += 1;
			nbits = 8;
			i = 0;
			while (i < nx) {
				nbits -= fsbits;
				while (nbits < 0) {
					b = (b << 8) | array[pointer];
					pointer += 1;
					nbits += 8;
				}
				fs = (b >> nbits) - 1;
				b &= (1 << nbits) - 1;
				imax = i + blocksize;
				if (imax > nx) {
					imax = nx;
				}
				if (fs < 0) {
					while (i < imax) {
						array[i] = lastpix;
						i++;
					}
				} else if (fs === fsmax) {
					while (i < imax) {
						k = bbits - nbits;
						diff = b << k;
						k -= 8;
						while (k >= 0) {
							b = array[pointer];
							pointer += 1;
							diff |= b << k;
							k -= 8;
						}
						if (nbits > 0) {
							b = array[pointer];
							pointer += 1;
							diff |= b >> (-k);
							b &= (1 << nbits) - 1;
						} else {
							b = 0;
						}
						if ((diff & 1) === 0) {
							diff = diff >> 1;
						} else {
							diff = ~(diff >> 1);
						}
						array[i] = diff + lastpix;
						lastpix = array[i];
						i++;
					}
				} else {
					while (i < imax) {
						while (b === 0) {
							nbits += 8;
							b = array[pointer];
							pointer += 1;
						}
						nzero = nbits - nonzeroCount[b];
						nbits -= nzero + 1;
						b ^= 1 << nbits;
						nbits -= fs;
						while (nbits < 0) {
							b = (b << 8) | array[pointer];
							pointer += 1;
							nbits += 8;
						}
						diff = (nzero << fs) | (b >> nbits);
						b &= (1 << nbits) - 1;
						if ((diff & 1) === 0) {
							diff = diff >> 1;
						} else {
							diff = ~(diff >> 1);
						}
						pixels[i] = diff + lastpix;
						lastpix = pixels[i];
						i++;
					}
				}
			}
			return pixels;
		},
		RiceSetup : {
			1 : function(array) {
				var fsbits, fsmax, lastpix, pointer;
				pointer = 0;
				fsbits = 3;
				fsmax = 6;
				lastpix = array[pointer];
				pointer += 1;
				return [fsbits, fsmax, lastpix, pointer];
			},
			2 : function(array) {
				var bytevalue, fsbits, fsmax, lastpix, pointer;
				pointer = 0;
				fsbits = 4;
				fsmax = 14;
				lastpix = 0;
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue << 8);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | bytevalue;
				return [fsbits, fsmax, lastpix, pointer];
			},
			4 : function(array) {
				var bytevalue, fsbits, fsmax, lastpix, pointer;
				pointer = 0;
				fsbits = 5;
				fsmax = 25;
				lastpix = 0;
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue << 24);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue << 16);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | (bytevalue << 8);
				bytevalue = array[pointer];
				pointer += 1;
				lastpix = lastpix | bytevalue;
				return [fsbits, fsmax, lastpix, pointer];
			}
		},
		gzip : function(array) {
			throw "Not yet implemented";
		},
		plio : function(array, length) {
			throw "Not yet implemented";
		},
		hcompress : function(array, length) {
			throw "Not yet implemented";
		}
	};

	this.astro.ASTROFITS.Decompress = Decompress;

	CompressedImage = (function(_super) {

		__extends(CompressedImage, _super);

		CompressedImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

		CompressedImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

		CompressedImage.include(ImageUtils);

		CompressedImage.extend(Decompress);

		CompressedImage.typedArray = {
			B : Uint8Array,
			I : Int16Array,
			J : Int32Array,
			E : Float32Array,
			D : Float64Array,
			1 : Uint8Array,
			2 : Uint8Array,
			4 : Int16Array,
			8 : Int32Array
		};

		function CompressedImage(view, header) {
			var i, key, value, ztile, _i, _ref;
			CompressedImage.__super__.constructor.apply(this, arguments);
			this.length += header["PCOUNT"];
			this.zcmptype = header["ZCMPTYPE"];
			this.zbitpix = header["ZBITPIX"];
			this.znaxis = header["ZNAXIS"];
			this.zblank = CompressedImage.setValue(header, "ZBLANK", void 0);
			this.blank = CompressedImage.setValue(header, "BLANK", void 0);
			this.ztile = [];
			for (i = _i = 1, _ref = this.znaxis; 1 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
				ztile = header.contains("ZTILE" + i)
						? header["ZTILE" + i]
						: i === 1 ? header["ZNAXIS1"] : 1;
				this.ztile.push(ztile);
			}
			this.width = header["ZNAXIS1"];
			this.height = header["ZNAXIS2"] || 1;
			this.algorithmParameters = {};
			i = 1;
			while (true) {
				key = "ZNAME" + i;
				if (!header.contains(key)) {
					break;
				}
				value = "ZVAL" + i;
				this.algorithmParameters[header[key]] = header[value];
				i += 1;
			}
			if (this.zcmptype === 'RICE_1') {
				this.setRiceDefaults();
			}
			this.zmaskcmp = CompressedImage
					.setValue(header, "ZMASKCMP", void 0);
			this.zquantiz = CompressedImage.setValue(header, "ZQUANTIZ",
					"LINEAR_SCALING");
			this.bzero = CompressedImage.setValue(header, "BZERO", 0);
			this.bscale = CompressedImage.setValue(header, "BSCALE", 1);
			this.defineColumnAccessors(header);
			this.defineGetRow();
		}

		CompressedImage.prototype.defineColumnAccessors = function(header) {
			var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results, _this = this;
			this.columnNames = {};
			_results = [];
			for (i = _i = 1, _ref = this.cols; 1 <= _ref
					? _i <= _ref
					: _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
				value = header["TFORM" + i];
				match = value.match(CompressedImage.arrayDescriptorPattern);
				ttype = header["TTYPE" + i].toUpperCase();
				this.columnNames[ttype] = i - 1;
				accessor = null;
				if (match != null) {
					dataType = match[1];
					switch (ttype) {
						case "COMPRESSED_DATA" :
							(function(dataType) {
								return accessor = function() {
									var data, pixels;
									data = _this._accessor(dataType);
									if (data == null) {
										return new Float32Array(_this.ztile[0]);
									}
									pixels = new CompressedImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
									CompressedImage
											.Rice(
													data,
													length,
													_this.algorithmParameters["BLOCKSIZE"],
													_this.algorithmParameters["BYTEPIX"],
													pixels, _this.ztile[0]);
									return pixels;
								};
							})(dataType);
							break;
						case "UNCOMPRESSED_DATA" :
							(function(dataType) {
								return accessor = _this._accessor(dataType);
							})(dataType);
							break;
						case "GZIP_COMPRESSED_DATA" :
							(function(dataType) {
								return accessor = function() {
									var data, index, item, _j, _len;
									data = _this._accessor(dataType);
									if (data != null) {
										data = new Float32Array(_this.width);
										for (index = _j = 0, _len = data.length; _j < _len; index = ++_j) {
											item = data[index];
											data[index] = NaN;
										}
										return data;
									} else {
										return null;
									}
								};
							})(dataType);
							break;
						default :
							(function(dataType) {
								return accessor = _this._accessor(dataType);
							})(dataType);
					}
				} else {
					match = value.match(CompressedImage.dataTypePattern);
					_ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
					length = length != null ? parseInt(length) : 0;
					if (length === 0 || length === 1) {
						(function(dataType) {
							return accessor = function() {
								return CompressedImage.dataAccessors[dataType](_this.view);
							};
						})(dataType);
					} else {
						(function(length, dataType) {
							return accessor = function() {
								var data, _j, _ref2;
								data = new CompressedImage.typedArray[dataType](length);
								for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2
										? _j <= _ref2
										: _j >= _ref2; i = 0 <= _ref2
										? ++_j
										: --_j) {
									data[i] = CompressedImage.dataAccessors[dataType](_this.view);
								}
								return data;
							};
						})(length, dataType);
					}
				}
				_results.push(this.accessors.push(accessor));
			}
			return _results;
		};

		CompressedImage.prototype.defineGetRow = function() {
			var hasBlanks;
			this.totalRowsRead = 0;
			hasBlanks = (this.zblank != null) || (this.blank != null)
					|| this.columnNames.hasOwnProperty("ZBLANK");
			return this.getRow = hasBlanks
					? this.getRowHasBlanks
					: this.getRowNoBlanks;
		};

		CompressedImage.prototype.setRiceDefaults = function() {
			if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
				this.algorithmParameters["BLOCKSIZE"] = 32;
			}
			if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
				return this.algorithmParameters["BYTEPIX"] = 4;
			}
		};

		CompressedImage.setValue = function(header, key, defaultValue) {
			if (header.contains(key)) {
				return header[key];
			} else {
				return defaultValue;
			}
		};

		CompressedImage.prototype.getRowHasBlanks = function() {
			var blank, data, index, location, scale, value, zero, _i, _len, _ref;
			_ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
			for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
				value = data[index];
				location = this.totalRowsRead * this.width + index;
				this.data[location] = value === blank ? NaN : zero + scale
						* value;
			}
			this.rowsRead += 1;
			return this.totalRowsRead += 1;
		};

		CompressedImage.prototype.getRowNoBlanks = function() {
			var blank, data, index, location, scale, value, zero, _i, _len, _ref;
			_ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
			for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
				value = data[index];
				location = this.totalRowsRead * this.width + index;
				this.data[location] = zero + scale * value;
			}
			this.rowsRead += 1;
			return this.totalRowsRead += 1;
		};

		CompressedImage.prototype.getFrame = function() {
			var height;
			if (this.data == null) {
				this.initArray(Float32Array);
			}
			this.totalRowsRead = 0;
			this.rowsRead = 0;
			height = this.height;
			while (height--) {
				this.getRow();
			}
			return this.data;
		};

		CompressedImage.prototype._accessor = function(dataType) {
			var data, i, length, offset, _i, _ref, _ref1;
			_ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
			if (length === 0) {
				return null;
			}
			data = new CompressedImage.typedArray[dataType](length);
			this.current = this.view.tell();
			this.view.seek(this.begin + this.tableLength + offset);
			for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1
					? _i <= _ref1
					: _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
				data[i] = CompressedImage.dataAccessors[dataType](this.view);
			}
			this.view.seek(this.current);
			return data;
		};

		CompressedImage.prototype._getRow = function() {
			var accessor, blank, data, row, scale, zero, _i, _len, _ref;
			this.current = this.begin + this.totalRowsRead * this.rowByteSize;
			this.view.seek(this.current);
			row = [];
			_ref = this.accessors;
			for (_i = 0, _len = _ref.length; _i < _len; _i++) {
				accessor = _ref[_i];
				row.push(accessor());
			}
			data = row[this.columnNames["COMPRESSED_DATA"]]
					|| row[this.columnNames["UNCOMPRESSED_DATA"]]
					|| row[this.columnNames["GZIP_COMPRESSED_DATA"]];
			blank = row[this.columnNames["ZBLANK"]] || this.zblank;
			scale = row[this.columnNames["ZSCALE"]] || this.bscale;
			zero = row[this.columnNames["ZZERO"]] || this.bzero;
			return [data, blank, scale, zero];
		};

		CompressedImage.subtractiveDither1 = function() {
			throw "Not yet implemented";
		};

		CompressedImage.linearScaling = function() {
			throw "Not yet implemented";
		};

		return CompressedImage;

	})(Tabular);

	this.astro.ASTROFITS.CompressedImage = CompressedImage;

	HDU = (function() {

		function HDU(header, data) {
			this.header = header;
			this.data = data;
		}

		HDU.prototype.hasData = function() {
			if (this.data != null) {
				return true;
			} else {
				return false;
			}
		};

		HDU.prototype.getCard = function(key) {
			return this.header[key];
		};

		return HDU;

	})();

	this.astro.ASTROFITS.HDU = HDU;

	File = (function() {

		File.LINEWIDTH = 80;

		File.BLOCKLENGTH = 2880;

		File.getType = function(obj) {
			return Object.prototype.toString.call(obj).slice(8, -1)
					.toLowerCase();
		};

		function File(buffer) {
			var name;
			name = File.getType(buffer);
			switch (name) {
				case 'arraybuffer' :
					this.initFromBuffer(buffer);
					break;
				case 'object' :
					this.initFromObject(buffer);
					break;
				default :
					throw 'fitsjs cannot initialize object';
			}
		}

		File.excessBytes = function(length) {
			return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH))
					% File.BLOCKLENGTH;
		};

		File.extendDataView = function(view) {
			var getFloat32, getFloat64, getInt16, getInt32, getInt8, getUint16, getUint32, getUint8;
			DataView.prototype.getString = function(length) {
				var c, i, value, _i, _ref;
				value = '';
				for (i = _i = 0, _ref = length - 1; 0 <= _ref
						? _i <= _ref
						: _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
					c = this.getUint8();
					value += String.fromCharCode(c > 127 ? 65533 : c);
				}
				return value;
			};
			DataView.prototype.getChar = function() {
				return this.getString(1);
			};
			view.offset = 0;
			getInt8 = view.getInt8;
			getUint8 = view.getUint8;
			getInt16 = view.getInt16;
			getUint16 = view.getUint16;
			getInt32 = view.getInt32;
			getUint32 = view.getUint32;
			getFloat32 = view.getFloat32;
			getFloat64 = view.getFloat64;
			view.getInt8 = function() {
				var value;
				value = getInt8.apply(this, [this.offset]);
				this.offset += 1;
				return value;
			};
			view.getUint8 = function() {
				var value;
				value = getUint8.apply(this, [this.offset]);
				this.offset += 1;
				return value;
			};
			view.getInt16 = function() {
				var value;
				value = getInt16.apply(this, [this.offset, false]);
				this.offset += 2;
				return value;
			};
			view.getUint16 = function() {
				var value;
				value = getUint16.apply(this, [this.offset, false]);
				this.offset += 2;
				return value;
			};
			view.getInt32 = function() {
				var value;
				value = getInt32.apply(this, [this.offset, false]);
				this.offset += 4;
				return value;
			};
			view.getUint32 = function() {
				var value;
				value = getUint32.apply(this, [this.offset, false]);
				this.offset += 4;
				return value;
			};
			view.getFloat32 = function() {
				var value;
				value = getFloat32.apply(this, [this.offset, false]);
				this.offset += 4;
				return value;
			};
			view.getFloat64 = function() {
				var value;
				value = getFloat64.apply(this, [this.offset, false]);
				this.offset += 8;
				return value;
			};
			view.seek = function(offset) {
				return this.offset = offset;
			};
			return view.tell = function() {
				return this.offset;
			};
		};

		File.prototype.initFromBuffer = function(buffer) {
			var data, hdu, header, _results;
			this.length = buffer.byteLength;
			this.view = new DataView(buffer);
			this.hdus = [];
			this.eof = false;
			File.extendDataView(this.view);
			_results = [];
			while (true) {
				header = this.readHeader();
				data = this.readData(header);
				hdu = new HDU(header, data);
				this.hdus.push(hdu);
				if (this.eof) {
					break;
				} else {
					_results.push(void 0);
				}
			}
			return _results;
		};

		File.prototype.initFromObject = function(buffer) {
			this.length = buffer.length;
			this.view = null;
			this.hdus = buffer.hdus;
			return this.eof = true;
		};

		File.prototype.readHeader = function() {
			var beginOffset, block, done, end, endOffset, endPattern, header, i, line, match, start, whitespacePattern;
			whitespacePattern = /\s{80}/;
			endPattern = /^END\s/;
			beginOffset = this.view.tell();
			done = false;
			while (true) {
				if (done) {
					break;
				}
				block = this.view.getString(File.BLOCKLENGTH);
				i = 0;
				while (true) {
					start = File.BLOCKLENGTH - File.LINEWIDTH * (i + 1);
					end = File.BLOCKLENGTH - File.LINEWIDTH * i;
					line = block.slice(start, end);
					match = line.match(whitespacePattern);
					if (match) {
						i += 1;
						continue;
					}
					match = line.match(endPattern);
					if (match) {
						endOffset = this.view.tell();
						this.view.seek(beginOffset);
						block = this.view.getString(endOffset - beginOffset);
						header = new Header();
						header.init(block);
						done = true;
						this.checkEOF();
						return header;
					}
					break;
				}
			}
		};

		File.prototype.readData = function(header) {
			var data, excess;
			if (!header.hasDataUnit()) {
				return;
			}
			if (header.isPrimary()) {
				data = new Image(this.view, header);
			} else if (header.isExtension()) {
				if (header.extensionType === "BINTABLE") {
					if (header.contains("ZIMAGE")) {
						data = new CompressedImage(this.view, header);
					} else {
						data = new BinaryTable(this.view, header);
					}
				} else if (header.extensionType === "TABLE") {
					data = new Table(this.view, header);
				} else if (header.extensionType === "IMAGE") {
					data = new Image(this.view, header);
				}
			}
			excess = File.excessBytes(data.length);
			this.view.seek(this.view.tell() + data.length + excess);
			this.checkEOF();
			return data;
		};

		File.prototype.checkEOF = function() {
			if (this.view.offset >= this.length) {
				return this.eof = true;
			}
		};

		File.prototype.count = function() {
			return this.hdus.length;
		};

		File.prototype.getHDU = function(index) {
			var hdu, _i, _len, _ref;
			if (index == null) {
				index = void 0;
			}
			if ((index != null) && (this.hdus[index] != null)) {
				return this.hdus[index];
			}
			_ref = this.hdus;
			for (_i = 0, _len = _ref.length; _i < _len; _i++) {
				hdu = _ref[_i];
				if (hdu.hasData()) {
					return hdu;
				}
			}
		};

		File.prototype.getHeader = function(index) {
			if (index == null) {
				index = void 0;
			}
			return this.getHDU(index).header;
		};

		File.prototype.getDataUnit = function(index) {
			if (index == null) {
				index = void 0;
			}
			return this.getHDU(index).data;
		};

		File.prototype.getData = function(index) {
			if (index == null) {
				index = void 0;
			}
			return this.getHDU(index).data.getFrame();
		};

		return File;

	})();

	this.astro.ASTROFITS.File = File;

}).call(this);
/*******************************************************************************
 * Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 * 
 * This file is part of SITools2.
 * 
 * SITools2 is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * 
 * SITools2 is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

function FitsLoader() {

	/**
	 * Parse fits file
	 * 
	 * @param response
	 *            XHR response containing fits
	 * 
	 * @return Parsed data
	 */
	function parseFits(response) {
		var FITS = astro.ASTROFITS;
		// Initialize the FITS.File object using
		// the array buffer returned from the XHR
		var fits = new FITS.File(response);
		// Grab the first HDU with a data unit
		var hdu = fits.getHDU();
		var data = hdu.data;
		
		if (hdu.header.extensionType == "IMAGE" || !Ext.isEmpty(hdu.header.CRVAL1) && !Ext.isEmpty(hdu.header.CRPIX1)) {
		    var uintPixels;
		    var swapPixels = new Uint8Array(data.view.buffer, data.begin,
		            data.length); // with gl.UNSIGNED_byte
		    
		    var bpe = data.arrayType.BYTES_PER_ELEMENT;
		    for (var i = 0; i < swapPixels.length; i += bpe) {
		        var temp;
		        // Swap to little-endian
		        for (var j = 0; j < bpe / 2; j++) {
		            temp = swapPixels[i + j];
		            swapPixels[i + j] = swapPixels[i + bpe - 1 - j];
		            swapPixels[i + bpe - 1 - j] = temp;
		        }
		    }
		}


		return fits;
	};

	var loadFits = function(url, successCallback, failCallback,
			onprogressCallback) {
		var xhr = new XMLHttpRequest();
		xhr.onreadystatechange = function(e) {
			if (xhr.readyState == 4) {
				if (xhr.status == 200) {
					if (xhr.response) {
						var fits = parseFits(xhr.response);
						if (successCallback) {
							successCallback(fits);
						}
					}
				} else {
					console.log("Error while loading " + url);
					if (failCallback) {
						failCallback(xhr);
					}
				}
			}
		};

		xhr.onprogress = onprogressCallback;

		xhr.open("GET", url);
		xhr.responseType = 'arraybuffer';
		xhr.send();
		return xhr;
	};

	return {
		loadFits : loadFits,
		parseFits : parseFits
	};

};/*!
  * bean.js - copyright Jacob Thornton 2011
  * https://github.com/fat/bean
  * MIT License
  * special thanks to:
  * dean edwards: http://dean.edwards.name/
  * dperini: https://github.com/dperini/nwevents
  * the entire mootools team: github.com/mootools/mootools-core
  *//*global module:true, define:true*/
!function(a,b,c){typeof module!="undefined"?module.exports=c(a,b):typeof define=="function"&&typeof define.amd=="object"?define(c):b[a]=c(a,b)}("bean",this,function(a,b){var c=window,d=b[a],e=/over|out/,f=/[^\.]*(?=\..*)\.|.*/,g=/\..*/,h="addEventListener",i="attachEvent",j="removeEventListener",k="detachEvent",l=document||{},m=l.documentElement||{},n=m[h],o=n?h:i,p=Array.prototype.slice,q=/click|mouse|menu|drag|drop/i,r=/^touch|^gesture/i,s={one:1},t=function(a,b,c){for(c=0;c<b.length;c++)a[b[c]]=1;return a}({},("click dblclick mouseup mousedown contextmenu mousewheel DOMMouseScroll mouseover mouseout mousemove selectstart selectend keydown keypress keyup orientationchange focus blur change reset select submit load unload beforeunload resize move DOMContentLoaded readystatechange error abort scroll "+(n?"show input invalid touchstart touchmove touchend touchcancel gesturestart gesturechange gestureend message readystatechange pageshow pagehide popstate hashchange offline online afterprint beforeprint dragstart dragenter dragover dragleave drag drop dragend loadstart progress suspend emptied stalled loadmetadata loadeddata canplay canplaythrough playing waiting seeking seeked ended durationchange timeupdate play pause ratechange volumechange cuechange checking noupdate downloading cached updateready obsolete ":"")).split(" ")),u=function(){function a(a,b){while((b=b.parentNode)!==null)if(b===a)return!0;return!1}function b(b){var c=b.relatedTarget;return c?c!==this&&c.prefix!=="xul"&&!/document/.test(this.toString())&&!a(this,c):c===null}return{mouseenter:{base:"mouseover",condition:b},mouseleave:{base:"mouseout",condition:b},mousewheel:{base:/Firefox/.test(navigator.userAgent)?"DOMMouseScroll":"mousewheel"}}}(),v=function(){var a="altKey attrChange attrName bubbles cancelable ctrlKey currentTarget detail eventPhase getModifierState isTrusted metaKey relatedNode relatedTarget shiftKey srcElement target timeStamp type view which".split(" "),b=a.concat("button buttons clientX clientY dataTransfer fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" ")),c=a.concat("char charCode key keyCode".split(" ")),d=a.concat("touches targetTouches changedTouches scale rotation".split(" ")),f="preventDefault",g=function(a){return function(){a[f]?a[f]():a.returnValue=!1}},h="stopPropagation",i=function(a){return function(){a[h]?a[h]():a.cancelBubble=!0}},j=function(a){return function(){a[f](),a[h](),a.stopped=!0}},k=function(a,b,c){var d,e;for(d=c.length;d--;)e=c[d],!(e in b)&&e in a&&(b[e]=a[e])};return function(n,o){var p={originalEvent:n,isNative:o};if(!n)return p;var s,t=n.type,u=n.target||n.srcElement;p[f]=g(n),p[h]=i(n),p.stop=j(p),p.target=u&&u.nodeType===3?u.parentNode:u;if(o){if(t.indexOf("key")!==-1)s=c,p.keyCode=n.which||n.keyCode;else if(q.test(t)){s=b,p.rightClick=n.which===3||n.button===2,p.pos={x:0,y:0};if(n.pageX||n.pageY)p.clientX=n.pageX,p.clientY=n.pageY;else if(n.clientX||n.clientY)p.clientX=n.clientX+l.body.scrollLeft+m.scrollLeft,p.clientY=n.clientY+l.body.scrollTop+m.scrollTop;e.test(t)&&(p.relatedTarget=n.relatedTarget||n[(t==="mouseover"?"from":"to")+"Element"])}else r.test(t)&&(s=d);k(n,p,s||a)}return p}}(),w=function(a,b){return!n&&!b&&(a===l||a===c)?m:a},x=function(){function a(a,b,c,d,e){this.element=a,this.type=b,this.handler=c,this.original=d,this.namespaces=e,this.custom=u[b],this.isNative=t[b]&&a[o],this.eventType=n||this.isNative?b:"propertychange",this.customType=!n&&!this.isNative&&b,this.target=w(a,this.isNative),this.eventSupport=this.target[o]}return a.prototype={inNamespaces:function(a){var b,c;if(!a)return!0;if(!this.namespaces)return!1;for(b=a.length;b--;)for(c=this.namespaces.length;c--;)if(a[b]===this.namespaces[c])return!0;return!1},matches:function(a,b,c){return this.element===a&&(!b||this.original===b)&&(!c||this.handler===c)}},a}(),y=function(){var a={},b=function(c,d,e,f,g){if(!d||d==="*")for(var h in a)h.charAt(0)==="$"&&b(c,h.substr(1),e,f,g);else{var i=0,j,k=a["$"+d],l=c==="*";if(!k)return;for(j=k.length;i<j;i++)if(l||k[i].matches(c,e,f))if(!g(k[i],k,i,d))return}},c=function(b,c,d){var e,f=a["$"+c];if(f)for(e=f.length;e--;)if(f[e].matches(b,d,null))return!0;return!1},d=function(a,c,d){var e=[];return b(a,c,d,null,function(a){return e.push(a)}),e},e=function(b){return(a["$"+b.type]||(a["$"+b.type]=[])).push(b),b},f=function(c){b(c.element,c.type,null,c.handler,function(b,c,d){return c.splice(d,1),c.length===0&&delete a["$"+b.type],!1})},g=function(){var b,c=[];for(b in a)b.charAt(0)==="$"&&(c=c.concat(a[b]));return c};return{has:c,get:d,put:e,del:f,entries:g}}(),z=n?function(a,b,c,d){a[d?h:j](b,c,!1)}:function(a,b,c,d,e){e&&d&&a["_on"+e]===null&&(a["_on"+e]=0),a[d?i:k]("on"+b,c)},A=function(a,b,d){return function(e){return e=v(e||((this.ownerDocument||this.document||this).parentWindow||c).event,!0),b.apply(a,[e].concat(d))}},B=function(a,b,d,e,f,g){return function(h){if(e?e.apply(this,arguments):n?!0:h&&h.propertyName==="_on"+d||!h)h&&(h=v(h||((this.ownerDocument||this.document||this).parentWindow||c).event,g)),b.apply(a,h&&(!f||f.length===0)?arguments:p.call(arguments,h?0:1).concat(f))}},C=function(a,b,c,d,e){return function(){a(b,c,e),d.apply(this,arguments)}},D=function(a,b,c,d){var e,f,h,i=b&&b.replace(g,""),j=y.get(a,i,c);for(e=0,f=j.length;e<f;e++)j[e].inNamespaces(d)&&((h=j[e]).eventSupport&&z(h.target,h.eventType,h.handler,!1,h.type),y.del(h))},E=function(a,b,c,d,e){var h,i=b.replace(g,""),j=b.replace(f,"").split(".");if(y.has(a,i,c))return a;i==="unload"&&(c=C(D,a,i,c,d)),u[i]&&(u[i].condition&&(c=B(a,c,i,u[i].condition,!0)),i=u[i].base||i),h=y.put(new x(a,i,c,d,j[0]&&j)),h.handler=h.isNative?A(a,h.handler,e):B(a,h.handler,i,!1,e,!1),h.eventSupport&&z(h.target,h.eventType,h.handler,!0,h.customType)},F=function(a,b,c){return function(d){var e,f,g=typeof a=="string"?c(a,this):a;for(e=d.target;e&&e!==this;e=e.parentNode)for(f=g.length;f--;)if(g[f]===e)return b.apply(e,arguments)}},G=function(a,b,c){var d,e,h,i,j,k=D,l=b&&typeof b=="string";if(l&&b.indexOf(" ")>0){b=b.split(" ");for(j=b.length;j--;)G(a,b[j],c);return a}h=l&&b.replace(g,""),h&&u[h]&&(h=u[h].type);if(!b||l){if(i=l&&b.replace(f,""))i=i.split(".");k(a,h,c,i)}else if(typeof b=="function")k(a,null,b);else for(d in b)b.hasOwnProperty(d)&&G(a,d,b[d]);return a},H=function(a,b,c,d,e){var f,g,h,i,j=c,k=c&&typeof c=="string";if(b&&!c&&typeof b=="object")for(f in b)b.hasOwnProperty(f)&&H.apply(this,[a,f,b[f]]);else{i=arguments.length>3?p.call(arguments,3):[],g=(k?c:b).split(" "),k&&(c=F(b,j=d,e))&&(i=p.call(i,1)),this===s&&(c=C(G,a,b,c,j));for(h=g.length;h--;)E(a,g[h],c,j,i)}return a},I=function(){return H.apply(s,arguments)},J=n?function(a,b,d){var e=l.createEvent(a?"HTMLEvents":"UIEvents");e[a?"initEvent":"initUIEvent"](b,!0,!0,c,1),d.dispatchEvent(e)}:function(a,b,c){c=w(c,a),a?c.fireEvent("on"+b,l.createEventObject()):c["_on"+b]++},K=function(a,b,c){var d,e,h,i,j,k=b.split(" ");for(d=k.length;d--;){b=k[d].replace(g,"");if(i=k[d].replace(f,""))i=i.split(".");if(!i&&!c&&a[o])J(t[b],b,a);else{j=y.get(a,b),c=[!1].concat(c);for(e=0,h=j.length;e<h;e++)j[e].inNamespaces(i)&&j[e].handler.apply(a,c)}}return a},L=function(a,b,c){var d=0,e=y.get(b,c),f=e.length;for(;d<f;d++)e[d].original&&H(a,e[d].type,e[d].original);return a},M={add:H,one:I,remove:G,clone:L,fire:K,noConflict:function(){return b[a]=d,this}};if(c[i]){var N=function(){var a,b=y.entries();for(a in b)b[a].type&&b[a].type!=="unload"&&G(b[a].element,b[a].type);c[k]("onunload",N),c.CollectGarbage&&c.CollectGarbage()};c[i]("onunload",N)}return M});
//     Underscore.js 1.1.7
//     (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore is freely distributable under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function(){var a=this,b=a._,c={},d=Array.prototype,e=Object.prototype,f=Function.prototype,g=d.slice,h=d.unshift,i=e.toString,j=e.hasOwnProperty,k=d.forEach,l=d.map,m=d.reduce,n=d.reduceRight,o=d.filter,p=d.every,q=d.some,r=d.indexOf,s=d.lastIndexOf,t=Array.isArray,u=Object.keys,v=f.bind,w=function(a){return new B(a)};typeof module!="undefined"&&module.exports?(module.exports=w,w._=w):a._=w,w.VERSION="1.1.7";var x=w.each=w.forEach=function(a,b,d){if(a==null)return;if(k&&a.forEach===k)a.forEach(b,d);else if(a.length===+a.length){for(var e=0,f=a.length;e<f;e++)if(e in a&&b.call(d,a[e],e,a)===c)return}else for(var g in a)if(j.call(a,g)&&b.call(d,a[g],g,a)===c)return};w.map=function(a,b,c){var d=[];return a==null?d:l&&a.map===l?a.map(b,c):(x(a,function(a,e,f){d[d.length]=b.call(c,a,e,f)}),d)},w.reduce=w.foldl=w.inject=function(a,b,c,d){var e=c!==void 0;a==null&&(a=[]);if(m&&a.reduce===m)return d&&(b=w.bind(b,d)),e?a.reduce(b,c):a.reduce(b);x(a,function(a,f,g){e?c=b.call(d,c,a,f,g):(c=a,e=!0)});if(!e)throw new TypeError("Reduce of empty array with no initial value");return c},w.reduceRight=w.foldr=function(a,b,c,d){a==null&&(a=[]);if(n&&a.reduceRight===n)return d&&(b=w.bind(b,d)),c!==void 0?a.reduceRight(b,c):a.reduceRight(b);var e=(w.isArray(a)?a.slice():w.toArray(a)).reverse();return w.reduce(e,b,c,d)},w.find=w.detect=function(a,b,c){var d;return y(a,function(a,e,f){if(b.call(c,a,e,f))return d=a,!0}),d},w.filter=w.select=function(a,b,c){var d=[];return a==null?d:o&&a.filter===o?a.filter(b,c):(x(a,function(a,e,f){b.call(c,a,e,f)&&(d[d.length]=a)}),d)},w.reject=function(a,b,c){var d=[];return a==null?d:(x(a,function(a,e,f){b.call(c,a,e,f)||(d[d.length]=a)}),d)},w.every=w.all=function(a,b,d){var e=!0;return a==null?e:p&&a.every===p?a.every(b,d):(x(a,function(a,f,g){if(!(e=e&&b.call(d,a,f,g)))return c}),e)};var y=w.some=w.any=function(a,b,d){b=b||w.identity;var e=!1;return a==null?e:q&&a.some===q?a.some(b,d):(x(a,function(a,f,g){if(e|=b.call(d,a,f,g))return c}),!!e)};w.include=w.contains=function(a,b){var c=!1;return a==null?c:r&&a.indexOf===r?a.indexOf(b)!=-1:(y(a,function(a){if(c=a===b)return!0}),c)},w.invoke=function(a,b){var c=g.call(arguments,2);return w.map(a,function(a){return(b.call?b||a:a[b]).apply(a,c)})},w.pluck=function(a,b){return w.map(a,function(a){return a[b]})},w.max=function(a,b,c){if(!b&&w.isArray(a))return Math.max.apply(Math,a);var d={computed:-Infinity};return x(a,function(a,e,f){var g=b?b.call(c,a,e,f):a;g>=d.computed&&(d={value:a,computed:g})}),d.value},w.min=function(a,b,c){if(!b&&w.isArray(a))return Math.min.apply(Math,a);var d={computed:Infinity};return x(a,function(a,e,f){var g=b?b.call(c,a,e,f):a;g<d.computed&&(d={value:a,computed:g})}),d.value},w.sortBy=function(a,b,c){return w.pluck(w.map(a,function(a,d,e){return{value:a,criteria:b.call(c,a,d,e)}}).sort(function(a,b){var c=a.criteria,d=b.criteria;return c<d?-1:c>d?1:0}),"value")},w.groupBy=function(a,b){var c={};return x(a,function(a,d){var e=b(a,d);(c[e]||(c[e]=[])).push(a)}),c},w.sortedIndex=function(a,b,c){c||(c=w.identity);var d=0,e=a.length;while(d<e){var f=d+e>>1;c(a[f])<c(b)?d=f+1:e=f}return d},w.toArray=function(a){return a?a.toArray?a.toArray():w.isArray(a)?g.call(a):w.isArguments(a)?g.call(a):w.values(a):[]},w.size=function(a){return w.toArray(a).length},w.first=w.head=function(a,b,c){return b!=null&&!c?g.call(a,0,b):a[0]},w.rest=w.tail=function(a,b,c){return g.call(a,b==null||c?1:b)},w.last=function(a){return a[a.length-1]},w.compact=function(a){return w.filter(a,function(a){return!!a})},w.flatten=function(a){return w.reduce(a,function(a,b){return w.isArray(b)?a.concat(w.flatten(b)):(a[a.length]=b,a)},[])},w.without=function(a){return w.difference(a,g.call(arguments,1))},w.uniq=w.unique=function(a,b){return w.reduce(a,function(a,c,d){if(0==d||(b===!0?w.last(a)!=c:!w.include(a,c)))a[a.length]=c;return a},[])},w.union=function(){return w.uniq(w.flatten(arguments))},w.intersection=w.intersect=function(a){var b=g.call(arguments,1);return w.filter(w.uniq(a),function(a){return w.every(b,function(b){return w.indexOf(b,a)>=0})})},w.difference=function(a,b){return w.filter(a,function(a){return!w.include(b,a)})},w.zip=function(){var a=g.call(arguments),b=w.max(w.pluck(a,"length")),c=new Array(b);for(var d=0;d<b;d++)c[d]=w.pluck(a,""+d);return c},w.indexOf=function(a,b,c){if(a==null)return-1;var d,e;if(c)return d=w.sortedIndex(a,b),a[d]===b?d:-1;if(r&&a.indexOf===r)return a.indexOf(b);for(d=0,e=a.length;d<e;d++)if(a[d]===b)return d;return-1},w.lastIndexOf=function(a,b){if(a==null)return-1;if(s&&a.lastIndexOf===s)return a.lastIndexOf(b);var c=a.length;while(c--)if(a[c]===b)return c;return-1},w.range=function(a,b,c){arguments.length<=1&&(b=a||0,a=0),c=arguments[2]||1;var d=Math.max(Math.ceil((b-a)/c),0),e=0,f=new Array(d);while(e<d)f[e++]=a,a+=c;return f},w.bind=function(a,b){if(a.bind===v&&v)return v.apply(a,g.call(arguments,1));var c=g.call(arguments,2);return function(){return a.apply(b,c.concat(g.call(arguments)))}},w.bindAll=function(a){var b=g.call(arguments,1);return b.length==0&&(b=w.functions(a)),x(b,function(b){a[b]=w.bind(a[b],a)}),a},w.memoize=function(a,b){var c={};return b||(b=w.identity),function(){var d=b.apply(this,arguments);return j.call(c,d)?c[d]:c[d]=a.apply(this,arguments)}},w.delay=function(a,b){var c=g.call(arguments,2);return setTimeout(function(){return a.apply(a,c)},b)},w.defer=function(a){return w.delay.apply(w,[a,1].concat(g.call(arguments,1)))};var z=function(a,b,c){var d;return function(){var e=this,f=arguments,g=function(){d=null,a.apply(e,f)};c&&clearTimeout(d);if(c||!d)d=setTimeout(g,b)}};w.throttle=function(a,b){return z(a,b,!1)},w.debounce=function(a,b){return z(a,b,!0)},w.once=function(a){var b=!1,c;return function(){return b?c:(b=!0,c=a.apply(this,arguments))}},w.wrap=function(a,b){return function(){var c=[a].concat(g.call(arguments));return b.apply(this,c)}},w.compose=function(){var a=g.call(arguments);return function(){var b=g.call(arguments);for(var c=a.length-1;c>=0;c--)b=[a[c].apply(this,b)];return b[0]}},w.after=function(a,b){return function(){if(--a<1)return b.apply(this,arguments)}},w.keys=u||function(a){if(a!==Object(a))throw new TypeError("Invalid object");var b=[];for(var c in a)j.call(a,c)&&(b[b.length]=c);return b},w.values=function(a){return w.map(a,w.identity)},w.functions=w.methods=function(a){var b=[];for(var c in a)w.isFunction(a[c])&&b.push(c);return b.sort()},w.extend=function(a){return x(g.call(arguments,1),function(b){for(var c in b)b[c]!==void 0&&(a[c]=b[c])}),a},w.defaults=function(a){return x(g.call(arguments,1),function(b){for(var c in b)a[c]==null&&(a[c]=b[c])}),a},w.clone=function(a){return w.isArray(a)?a.slice():w.extend({},a)},w.tap=function(a,b){return b(a),a},w.isEqual=function(a,b){if(a===b)return!0;var c=typeof a,d=typeof b;if(c!=d)return!1;if(a==b)return!0;if(!a&&b||a&&!b)return!1;a._chain&&(a=a._wrapped),b._chain&&(b=b._wrapped);if(a.isEqual)return a.isEqual(b);if(b.isEqual)return b.isEqual(a);if(w.isDate(a)&&w.isDate(b))return a.getTime()===b.getTime();if(w.isNaN(a)&&w.isNaN(b))return!1;if(w.isRegExp(a)&&w.isRegExp(b))return a.source===b.source&&a.global===b.global&&a.ignoreCase===b.ignoreCase&&a.multiline===b.multiline;if(c!=="object")return!1;if(a.length&&a.length!==b.length)return!1;var e=w.keys(a),f=w.keys(b);if(e.length!=f.length)return!1;for(var g in a)if(!(g in b)||!w.isEqual(a[g],b[g]))return!1;return!0},w.isEmpty=function(a){if(w.isArray(a)||w.isString(a))return a.length===0;for(var b in a)if(j.call(a,b))return!1;return!0},w.isElement=function(a){return!!a&&a.nodeType==1},w.isArray=t||function(a){return i.call(a)==="[object Array]"},w.isObject=function(a){return a===Object(a)},w.isArguments=function(a){return!!a&&!!j.call(a,"callee")},w.isFunction=function(a){return!!(a&&a.constructor&&a.call&&a.apply)},w.isString=function(a){return!!(a===""||a&&a.charCodeAt&&a.substr)},w.isNumber=function(a){return!!(a===0||a&&a.toExponential&&a.toFixed)},w.isNaN=function(a){return a!==a},w.isBoolean=function(a){return a===!0||a===!1},w.isDate=function(a){return!!(a&&a.getTimezoneOffset&&a.setUTCFullYear)},w.isRegExp=function(a){return!(!(a&&a.test&&a.exec)||!a.ignoreCase&&a.ignoreCase!==!1)},w.isNull=function(a){return a===null},w.isUndefined=function(a){return a===void 0},w.noConflict=function(){return a._=b,this},w.identity=function(a){return a},w.times=function(a,b,c){for(var d=0;d<a;d++)b.call(c,d)},w.mixin=function(a){x(w.functions(a),function(b){D(b,w[b]=a[b])})};var A=0;w.uniqueId=function(a){var b=A++;return a?a+b:b},w.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g},w.template=function(a,b){var c=w.templateSettings,d="var __p=[],print=function(){__p.push.apply(__p,arguments);};with(obj||{}){__p.push('"+a.replace(/\\/g,"\\\\").replace(/'/g,"\\'").replace(c.interpolate,function(a,b){return"',"+b.replace(/\\'/g,"'")+",'"}).replace(c.evaluate||null,function(a,b){return"');"+b.replace(/\\'/g,"'").replace(/[\r\n\t]/g," ")+"__p.push('"}).replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t")+"');}return __p.join('');",e=new Function("obj",d);return b?e(b):e};var B=function(a){this._wrapped=a};w.prototype=B.prototype;var C=function(a,b){return b?w(a).chain():a},D=function(a,b){B.prototype[a]=function(){var a=g.call(arguments);return h.call(a,this._wrapped),C(b.apply(w,a),this._chain)}};w.mixin(w),x(["pop","push","reverse","shift","sort","splice","unshift"],function(a){var b=d[a];B.prototype[a]=function(){return b.apply(this._wrapped,arguments),C(this._wrapped,this._chain)}}),x(["concat","join","slice"],function(a){var b=d[a];B.prototype[a]=function(){return C(b.apply(this._wrapped,arguments),this._chain)}}),B.prototype.chain=function(){return this._chain=!0,this},B.prototype.value=function(){return this._wrapped}})();
/**
 * Flotr2 (c) 2012 Carl Sutherland
 * MIT License
 * Special thanks to:
 * Flotr: http://code.google.com/p/flotr/ (fork)
 * Flot: https://github.com/flot/flot (original fork)
 */
(function(){var a=this,b=this.Flotr,c;c={_:_,bean:bean,isIphone:/iphone/i.test(navigator.userAgent),isIE:navigator.appVersion.indexOf("MSIE")!=-1?parseFloat(navigator.appVersion.split("MSIE")[1]):!1,graphTypes:{},plugins:{},addType:function(a,b){c.graphTypes[a]=b,c.defaultOptions[a]=b.options||{},c.defaultOptions.defaultType=c.defaultOptions.defaultType||a},addPlugin:function(a,b){c.plugins[a]=b,c.defaultOptions[a]=b.options||{}},draw:function(a,b,d,e){return e=e||c.Graph,new e(a,b,d)},merge:function(a,b){var d,e,f=b||{};for(d in a)e=a[d],e&&typeof e=="object"?e.constructor===Array?f[d]=this._.clone(e):e.constructor!==RegExp&&!this._.isElement(e)&&!e.jquery?f[d]=c.merge(e,b?b[d]:undefined):f[d]=e:f[d]=e;return f},clone:function(a){return c.merge(a,{})},getTickSize:function(a,b,d,e){var f=(d-b)/a,g=c.getMagnitude(f),h=10,i=f/g;return i<1.5?h=1:i<2.25?h=2:i<3?h=e===0?2:2.5:i<7.5&&(h=5),h*g},defaultTickFormatter:function(a,b){return a+""},defaultTrackFormatter:function(a){return"("+a.x+", "+a.y+")"},engineeringNotation:function(a,b,c){var d=["Y","Z","E","P","T","G","M","k",""],e=["y","z","a","f","p","n","µ","m",""],f=d.length;c=c||1e3,b=Math.pow(10,b||2);if(a===0)return 0;if(a>1)while(f--&&a>=c)a/=c;else{d=e,f=d.length;while(f--&&a<1)a*=c}return Math.round(a*b)/b+d[f]},getMagnitude:function(a){return Math.pow(10,Math.floor(Math.log(a)/Math.LN10))},toPixel:function(a){return Math.floor(a)+.5},toRad:function(a){return-a*(Math.PI/180)},floorInBase:function(a,b){return b*Math.floor(a/b)},drawText:function(a,b,d,e,f){if(!a.fillText){a.drawText(b,d,e,f);return}f=this._.extend({size:c.defaultOptions.fontSize,color:"#000000",textAlign:"left",textBaseline:"bottom",weight:1,angle:0},f),a.save(),a.translate(d,e),a.rotate(f.angle),a.fillStyle=f.color,a.font=(f.weight>1?"bold ":"")+f.size*1.3+"px sans-serif",a.textAlign=f.textAlign,a.textBaseline=f.textBaseline,a.fillText(b,0,0),a.restore()},getBestTextAlign:function(a,b){return b=b||{textAlign:"center",textBaseline:"middle"},a+=c.getTextAngleFromAlign(b),Math.abs(Math.cos(a))>.01&&(b.textAlign=Math.cos(a)>0?"right":"left"),Math.abs(Math.sin(a))>.01&&(b.textBaseline=Math.sin(a)>0?"top":"bottom"),b},alignTable:{"right middle":0,"right top":Math.PI/4,"center top":Math.PI/2,"left top":3*(Math.PI/4),"left middle":Math.PI,"left bottom":-3*(Math.PI/4),"center bottom":-Math.PI/2,"right bottom":-Math.PI/4,"center middle":0},getTextAngleFromAlign:function(a){return c.alignTable[a.textAlign+" "+a.textBaseline]||0},noConflict:function(){return a.Flotr=b,this}},a.Flotr=c})(),Flotr.defaultOptions={colors:["#00A8F0","#C0D800","#CB4B4B","#4DA74D","#9440ED"],ieBackgroundColor:"#FFFFFF",title:null,subtitle:null,shadowSize:4,defaultType:null,HtmlText:!0,fontColor:"#545454",fontSize:7.5,resolution:1,parseFloat:!0,preventDefault:!0,xaxis:{ticks:null,minorTicks:null,showLabels:!0,showMinorLabels:!1,labelsAngle:0,title:null,titleAngle:0,noTicks:5,minorTickFreq:null,tickFormatter:Flotr.defaultTickFormatter,tickDecimals:null,min:null,max:null,autoscale:!1,autoscaleMargin:0,color:null,mode:"normal",timeFormat:null,timeMode:"UTC",timeUnit:"millisecond",scaling:"linear",base:Math.E,titleAlign:"center",margin:!0},x2axis:{},yaxis:{ticks:null,minorTicks:null,showLabels:!0,showMinorLabels:!1,labelsAngle:0,title:null,titleAngle:90,noTicks:5,minorTickFreq:null,tickFormatter:Flotr.defaultTickFormatter,tickDecimals:null,min:null,max:null,autoscale:!1,autoscaleMargin:0,color:null,scaling:"linear",base:Math.E,titleAlign:"center",margin:!0},y2axis:{titleAngle:270},grid:{color:"#545454",backgroundColor:null,backgroundImage:null,watermarkAlpha:.4,tickColor:"#DDDDDD",labelMargin:3,verticalLines:!0,minorVerticalLines:null,horizontalLines:!0,minorHorizontalLines:null,outlineWidth:1,outline:"nsew",circular:!1},mouse:{track:!1,trackAll:!1,position:"se",relative:!1,trackFormatter:Flotr.defaultTrackFormatter,margin:5,lineColor:"#FF3F19",trackDecimals:1,sensibility:2,trackY:!0,radius:3,fillColor:null,fillOpacity:.4}},function(){function b(a,b,c,d){this.rgba=["r","g","b","a"];var e=4;while(-1<--e)this[this.rgba[e]]=arguments[e]||(e==3?1:0);this.normalize()}var a=Flotr._,c={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]};b.prototype={scale:function(b,c,d,e){var f=4;while(-1<--f)a.isUndefined(arguments[f])||(this[this.rgba[f]]*=arguments[f]);return this.normalize()},alpha:function(b){return!a.isUndefined(b)&&!a.isNull(b)&&(this.a=b),this.normalize()},clone:function(){return new b(this.r,this.b,this.g,this.a)},limit:function(a,b,c){return Math.max(Math.min(a,c),b)},normalize:function(){var a=this.limit;return this.r=a(parseInt(this.r,10),0,255),this.g=a(parseInt(this.g,10),0,255),this.b=a(parseInt(this.b,10),0,255),this.a=a(this.a,0,1),this},distance:function(a){if(!a)return;a=new b.parse(a);var c=0,d=3;while(-1<--d)c+=Math.abs(this[this.rgba[d]]-a[this.rgba[d]]);return c},toString:function(){return this.a>=1?"rgb("+[this.r,this.g,this.b].join(",")+")":"rgba("+[this.r,this.g,this.b,this.a].join(",")+")"},contrast:function(){var a=1-(.299*this.r+.587*this.g+.114*this.b)/255;return a<.5?"#000000":"#ffffff"}},a.extend(b,{parse:function(a){if(a instanceof b)return a;var d;if(d=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(a))return new b(parseInt(d[1],16),parseInt(d[2],16),parseInt(d[3],16));if(d=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(a))return new b(parseInt(d[1],10),parseInt(d[2],10),parseInt(d[3],10));if(d=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(a))return new b(parseInt(d[1]+d[1],16),parseInt(d[2]+d[2],16),parseInt(d[3]+d[3],16));if(d=/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(a))return new b(parseInt(d[1],10),parseInt(d[2],10),parseInt(d[3],10),parseFloat(d[4]));if(d=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(a))return new b(parseFloat(d[1])*2.55,parseFloat(d[2])*2.55,parseFloat(d[3])*2.55);if(d=/rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(a))return new b(parseFloat(d[1])*2.55,parseFloat(d[2])*2.55,parseFloat(d[3])*2.55,parseFloat(d[4]));var e=(a+"").replace(/^\s*([\S\s]*?)\s*$/,"$1").toLowerCase();return e=="transparent"?new b(255,255,255,0):(d=c[e])?new b(d[0],d[1],d[2]):new b(0,0,0,0)},processColor:function(c,d){var e=d.opacity;if(!c)return"rgba(0, 0, 0, 0)";if(c instanceof b)return c.alpha(e).toString();if(a.isString(c))return b.parse(c).alpha(e).toString();var f=c.colors?c:{colors:c};if(!d.ctx)return a.isArray(f.colors)?b.parse(a.isArray(f.colors[0])?f.colors[0][1]:f.colors[0]).alpha(e).toString():"rgba(0, 0, 0, 0)";f=a.extend({start:"top",end:"bottom"},f),/top/i.test(f.start)&&(d.x1=0),/left/i.test(f.start)&&(d.y1=0),/bottom/i.test(f.end)&&(d.x2=0),/right/i.test(f.end)&&(d.y2=0);var g,h,i,j=d.ctx.createLinearGradient(d.x1,d.y1,d.x2,d.y2);for(g=0;g<f.colors.length;g++)h=f.colors[g],a.isArray(h)?(i=h[0],h=h[1]):i=g/(f.colors.length-1),j.addColorStop(i,b.parse(h).alpha(e));return j}}),Flotr.Color=b}(),Flotr.Date={set:function(a,b,c,d){c=c||"UTC",b="set"+(c==="UTC"?"UTC":"")+b,a[b](d)},get:function(a,b,c){return c=c||"UTC",b="get"+(c==="UTC"?"UTC":"")+b,a[b]()},format:function(a,b,c){function f(a){return a+="",a.length==1?"0"+a:a}if(!a)return;var d=this.get,e={h:d(a,"Hours",c).toString(),H:f(d(a,"Hours",c)),M:f(d(a,"Minutes",c)),S:f(d(a,"Seconds",c)),s:d(a,"Milliseconds",c),d:d(a,"Date",c).toString(),m:(d(a,"Month",c)+1).toString(),y:d(a,"FullYear",c).toString(),b:Flotr.Date.monthNames[d(a,"Month",c)]},g=[],h,i=!1;for(var j=0;j<b.length;++j)h=b.charAt(j),i?(g.push(e[h]||h),i=!1):h=="%"?i=!0:g.push(h);return g.join("")},getFormat:function(a,b){var c=Flotr.Date.timeUnits;return a<c.second?"%h:%M:%S.%s":a<c.minute?"%h:%M:%S":a<c.day?b<2*c.day?"%h:%M":"%b %d %h:%M":a<c.month?"%b %d":a<c.year?b<c.year?"%b":"%b %y":"%y"},formatter:function(a,b){var c=b.options,d=Flotr.Date.timeUnits[c.timeUnit],e=new Date(a*d);if(b.options.timeFormat)return Flotr.Date.format(e,c.timeFormat,c.timeMode);var f=(b.max-b.min)*d,g=b.tickSize*Flotr.Date.timeUnits[b.tickUnit];return Flotr.Date.format(e,Flotr.Date.getFormat(g,f),c.timeMode)},generator:function(a){function s(a){b(q,a,g,Flotr.floorInBase(c(q,a,g),m))}var b=this.set,c=this.get,d=this.timeUnits,e=this.spec,f=a.options,g=f.timeMode,h=d[f.timeUnit],i=a.min*h,j=a.max*h,k=(j-i)/f.noTicks,l=[],m=a.tickSize,n,o,p;o=f.tickFormatter===Flotr.defaultTickFormatter?this.formatter:f.tickFormatter;for(p=0;p<e.length-1;++p){var q=e[p][0]*d[e[p][1]];if(k<(q+e[p+1][0]*d[e[p+1][1]])/2&&q>=m)break}m=e[p][0],n=e[p][1],n=="year"&&(m=Flotr.getTickSize(f.noTicks*d.year,i,j,0),m==.5&&(n="month",m=6)),a.tickUnit=n,a.tickSize=m;var r=m*d[n];q=new Date(i);switch(n){case"millisecond":s("Milliseconds");break;case"second":s("Seconds");break;case"minute":s("Minutes");break;case"hour":s("Hours");break;case"month":s("Month");break;case"year":s("FullYear")}r>=d.second&&b(q,"Milliseconds",g,0),r>=d.minute&&b(q,"Seconds",g,0),r>=d.hour&&b(q,"Minutes",g,0),r>=d.day&&b(q,"Hours",g,0),r>=d.day*4&&b(q,"Date",g,1),r>=d.year&&b(q,"Month",g,0);var t=0,u=NaN,v;do{v=u,u=q.getTime(),l.push({v:u/h,label:o(u/h,a)});if(n=="month")if(m<1){b(q,"Date",g,1);var w=q.getTime();b(q,"Month",g,c(q,"Month",g)+1);var x=q.getTime();q.setTime(u+t*d.hour+(x-w)*m),t=c(q,"Hours",g),b(q,"Hours",g,0)}else b(q,"Month",g,c(q,"Month",g)+m);else n=="year"?b(q,"FullYear",g,c(q,"FullYear",g)+m):q.setTime(u+r)}while(u<j&&u!=v);return l},timeUnits:{millisecond:1,second:1e3,minute:6e4,hour:36e5,day:864e5,month:2592e6,year:31556952e3},spec:[[1,"millisecond"],[20,"millisecond"],[50,"millisecond"],[100,"millisecond"],[200,"millisecond"],[500,"millisecond"],[1,"second"],[2,"second"],[5,"second"],[10,"second"],[30,"second"],[1,"minute"],[2,"minute"],[5,"minute"],[10,"minute"],[30,"minute"],[1,"hour"],[2,"hour"],[4,"hour"],[8,"hour"],[12,"hour"],[1,"day"],[2,"day"],[3,"day"],[.25,"month"],[.5,"month"],[1,"month"],[2,"month"],[3,"month"],[6,"month"],[1,"year"]],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]},function(){function b(a){return a&&a.jquery?a[0]:a}var a=Flotr._;Flotr.DOM={addClass:function(c,d){c=b(c);var e=c.className?c.className:"";if(a.include(e.split(/\s+/g),d))return;c.className=(e?e+" ":"")+d},create:function(a){return document.createElement(a)},node:function(a){var b=Flotr.DOM.create("div"),c;return b.innerHTML=a,c=b.children[0],b.innerHTML="",c},empty:function(a){a=b(a),a.innerHTML=""},remove:function(a){a=b(a),a.parentNode.removeChild(a)},hide:function(a){a=b(a),Flotr.DOM.setStyles(a,{display:"none"})},insert:function(c,d){c=b(c),a.isString(d)?c.innerHTML+=d:a.isElement(d)&&c.appendChild(d)},opacity:function(a,c){a=b(a),a.style.opacity=c},position:function(a,c){return a=b(a),a.offsetParent?(c=this.position(a.offsetParent),c.left+=a.offsetLeft,c.top+=a.offsetTop,c):{left:a.offsetLeft||0,top:a.offsetTop||0}},removeClass:function(c,d){var e=c.className?c.className:"";c=b(c),c.className=a.filter(e.split(/\s+/g),function(a){if(a!=d)return!0}).join(" ")},setStyles:function(c,d){c=b(c),a.each(d,function(a,b){c.style[b]=a})},show:function(a){a=b(a),Flotr.DOM.setStyles(a,{display:""})},size:function(a){return a=b(a),{height:a.offsetHeight,width:a.offsetWidth}}}}(),function(){var a=Flotr,b=a.bean;a.EventAdapter={observe:function(a,c,d){return b.add(a,c,d),this},fire:function(a,c,d){return b.fire(a,c,d),typeof Prototype!="undefined"&&Event.fire(a,c,d),this},stopObserving:function(a,c,d){return b.remove(a,c,d),this},eventPointer:function(b){if(!a._.isUndefined(b.touches)&&b.touches.length>0)return{x:b.touches[0].pageX,y:b.touches[0].pageY};if(!a._.isUndefined(b.changedTouches)&&b.changedTouches.length>0)return{x:b.changedTouches[0].pageX,y:b.changedTouches[0].pageY};if(b.pageX||b.pageY)return{x:b.pageX,y:b.pageY};if(b.clientX||b.clientY){var c=document,d=c.body,e=c.documentElement;return{x:b.clientX+d.scrollLeft+e.scrollLeft,y:b.clientY+d.scrollTop+e.scrollTop}}}}}(),function(){var a=Flotr,b=a.DOM,c=a._,d=function(a){this.o=a};d.prototype={dimensions:function(a,b,c,d){return a?this.o.html?this.html(a,this.o.element,c,d):this.canvas(a,b):{width:0,height:0}},canvas:function(b,c){if(!this.o.textEnabled)return;c=c||{};var d=this.measureText(b,c),e=d.width,f=c.size||a.defaultOptions.fontSize,g=c.angle||0,h=Math.cos(g),i=Math.sin(g),j=2,k=6,l;return l={width:Math.abs(h*e)+Math.abs(i*f)+j,height:Math.abs(i*e)+Math.abs(h*f)+k},l},html:function(a,c,d,e){var f=b.create("div");return b.setStyles(f,{position:"absolute",top:"-10000px"}),b.insert(f,'<div style="'+d+'" class="'+e+' flotr-dummy-div">'+a+"</div>"),b.insert(this.o.element,f),b.size(f)},measureText:function(b,d){var e=this.o.ctx,f;return!e.fillText||a.isIphone&&e.measure?{width:e.measure(b,d)}:(d=c.extend({size:a.defaultOptions.fontSize,weight:1,angle:0},d),e.save(),e.font=(d.weight>1?"bold ":"")+d.size*1.3+"px sans-serif",f=e.measureText(b),e.restore(),f)}},Flotr.Text=d}(),function(){function e(a,c,d){return b.observe.apply(this,arguments),this._handles.push(arguments),this}var a=Flotr.DOM,b=Flotr.EventAdapter,c=Flotr._,d=Flotr;Graph=function(a,e,f){this._setEl(a),this._initMembers(),this._initPlugins(),b.fire(this.el,"flotr:beforeinit",[this]),this.data=e,this.series=d.Series.getSeries(e),this._initOptions(f),this._initGraphTypes(),this._initCanvas(),this._text=new d.Text({element:this.el,ctx:this.ctx,html:this.options.HtmlText,textEnabled:this.textEnabled}),b.fire(this.el,"flotr:afterconstruct",[this]),this._initEvents(),this.findDataRanges(),this.calculateSpacing(),this.draw(c.bind(function(){b.fire(this.el,"flotr:afterinit",[this])},this))},Graph.prototype={destroy:function(){b.fire(this.el,"flotr:destroy"),c.each(this._handles,function(a){b.stopObserving.apply(this,a)}),this._handles=[],this.el.graph=null},observe:e,_observe:e,processColor:function(a,b){var e={x1:0,y1:0,x2:this.plotWidth,y2:this.plotHeight,opacity:1,ctx:this.ctx};return c.extend(e,b),d.Color.processColor(a,e)},findDataRanges:function(){var a=this.axes,b,e,f;c.each(this.series,function(a){f=a.getRange(),f&&(b=a.xaxis,e=a.yaxis,b.datamin=Math.min(f.xmin,b.datamin),b.datamax=Math.max(f.xmax,b.datamax),e.datamin=Math.min(f.ymin,e.datamin),e.datamax=Math.max(f.ymax,e.datamax),b.used=b.used||f.xused,e.used=e.used||f.yused)},this),!a.x.used&&!a.x2.used&&(a.x.used=!0),!a.y.used&&!a.y2.used&&(a.y.used=!0),c.each(a,function(a){a.calculateRange()});var g=c.keys(d.graphTypes),h=!1;c.each(this.series,function(a){if(a.hide)return;c.each(g,function(b){a[b]&&a[b].show&&(this.extendRange(b,a),h=!0)},this),h||this.extendRange(this.options.defaultType,a)},this)},extendRange:function(a,b){this[a].extendRange&&this[a].extendRange(b,b.data,b[a],this[a]),this[a].extendYRange&&this[a].extendYRange(b.yaxis,b.data,b[a],this[a]),this[a].extendXRange&&this[a].extendXRange(b.xaxis,b.data,b[a],this[a])},calculateSpacing:function(){var a=this.axes,b=this.options,d=this.series,e=b.grid.labelMargin,f=this._text,g=a.x,h=a.x2,i=a.y,j=a.y2,k=b.grid.outlineWidth,l,m,n,o;c.each(a,function(a){a.calculateTicks(),a.calculateTextDimensions(f,b)}),o=f.dimensions(b.title,{size:b.fontSize*1.5},"font-size:1em;font-weight:bold;","flotr-title"),this.titleHeight=o.height,o=f.dimensions(b.subtitle,{size:b.fontSize},"font-size:smaller;","flotr-subtitle"),this.subtitleHeight=o.height;for(m=0;m<b.length;++m)d[m].points.show&&(k=Math.max(k,d[m].points.radius+d[m].points.lineWidth/2));var p=this.plotOffset;g.options.margin===!1?(p.bottom=0,p.top=0):g.options.margin===!0?(p.bottom+=(b.grid.circular?0:g.used&&g.options.showLabels?g.maxLabel.height+e:0)+(g.used&&g.options.title?g.titleSize.height+e:0)+k,p.top+=(b.grid.circular?0:h.used&&h.options.showLabels?h.maxLabel.height+e:0)+(h.used&&h.options.title?h.titleSize.height+e:0)+this.subtitleHeight+this.titleHeight+k):(p.bottom=g.options.margin,p.top=g.options.margin),i.options.margin===!1?(p.left=0,p.right=0):i.options.margin===!0?(p.left+=(b.grid.circular?0:i.used&&i.options.showLabels?i.maxLabel.width+e:0)+(i.used&&i.options.title?i.titleSize.width+e:0)+k,p.right+=(b.grid.circular?0:j.used&&j.options.showLabels?j.maxLabel.width+e:0)+(j.used&&j.options.title?j.titleSize.width+e:0)+k):(p.left=i.options.margin,p.right=i.options.margin),p.top=Math.floor(p.top),this.plotWidth=this.canvasWidth-p.left-p.right,this.plotHeight=this.canvasHeight-p.bottom-p.top,g.length=h.length=this.plotWidth,i.length=j.length=this.plotHeight,i.offset=j.offset=this.plotHeight,g.setScale(),h.setScale(),i.setScale(),j.setScale()},draw:function(a){var c=this.ctx,d;b.fire(this.el,"flotr:beforedraw",[this.series,this]);if(this.series.length){c.save(),c.translate(this.plotOffset.left,this.plotOffset.top);for(d=0;d<this.series.length;d++)this.series[d].hide||this.drawSeries(this.series[d]);c.restore(),this.clip()}b.fire(this.el,"flotr:afterdraw",[this.series,this]),a&&a()},drawSeries:function(a){function b(a,b){var c=this.getOptions(a,b);this[b].draw(c)}var e=!1;a=a||this.series,c.each(d.graphTypes,function(c,d){a[d]&&a[d].show&&this[d]&&(e=!0,b.call(this,a,d))},this),e||b.call(this,a,this.options.defaultType)},getOptions:function(a,b){var c=a[b],e=this[b],f=a.xaxis,g=a.yaxis,h={context:this.ctx,width:this.plotWidth,height:this.plotHeight,fontSize:this.options.fontSize,fontColor:this.options.fontColor,textEnabled:this.textEnabled,htmlText:this.options.HtmlText,text:this._text,element:this.el,data:a.data,color:a.color,shadowSize:a.shadowSize,xScale:f.d2p,yScale:g.d2p,xInverse:f.p2d,yInverse:g.p2d};return h=d.merge(c,h),h.fillStyle=this.processColor(c.fillColor||a.color,{opacity:c.fillOpacity}),h},getEventPosition:function(c){var d=document,e=d.body,f=d.documentElement,g=this.axes,h=this.plotOffset,i=this.lastMousePos,j=b.eventPointer(c),k=j.x-i.pageX,l=j.y-i.pageY,m,n,o;return"ontouchstart"in this.el?(m=a.position(this.overlay),n=j.x-m.left-h.left,o=j.y-m.top-h.top):(m=this.overlay.getBoundingClientRect(),n=c.clientX-m.left-h.left-e.scrollLeft-f.scrollLeft,o=c.clientY-m.top-h.top-e.scrollTop-f.scrollTop),{x:g.x.p2d(n),x2:g.x2.p2d(n),y:g.y.p2d(o),y2:g.y2.p2d(o),relX:n,relY:o,dX:k,dY:l,absX:j.x,absY:j.y,pageX:j.x,pageY:j.y}},clickHandler:function(a){if(this.ignoreClick)return this.ignoreClick=!1,this.ignoreClick;b.fire(this.el,"flotr:click",[this.getEventPosition(a),this])},mouseMoveHandler:function(a){if(this.mouseDownMoveHandler)return;var c=this.getEventPosition(a);b.fire(this.el,"flotr:mousemove",[a,c,this]),this.lastMousePos=c},mouseDownHandler:function(a){if(this.mouseUpHandler)return;this.mouseUpHandler=c.bind(function(a){b.stopObserving(document,"mouseup",this.mouseUpHandler),b.stopObserving(document,"mousemove",this.mouseDownMoveHandler),this.mouseDownMoveHandler=null,this.mouseUpHandler=null,b.fire(this.el,"flotr:mouseup",[a,this])},this),this.mouseDownMoveHandler=c.bind(function(c){var d=this.getEventPosition(c);b.fire(this.el,"flotr:mousemove",[a,d,this]),this.lastMousePos=d},this),b.observe(document,"mouseup",this.mouseUpHandler),b.observe(document,"mousemove",this.mouseDownMoveHandler),b.fire(this.el,"flotr:mousedown",[a,this]),this.ignoreClick=!1},drawTooltip:function(b,c,d,e){var f=this.getMouseTrack(),g="opacity:0.7;background-color:#000;color:#fff;display:none;position:absolute;padding:2px 8px;-moz-border-radius:4px;border-radius:4px;white-space:nowrap;",h=e.position,i=e.margin,j=this.plotOffset;c!==null&&d!==null?(e.relative?(h.charAt(0)=="n"?g+="bottom:"+(i-j.top-d+this.canvasHeight)+"px;top:auto;":h.charAt(0)=="s"&&(g+="top:"+(i+j.top+d)+"px;bottom:auto;"),h.charAt(1)=="e"?g+="left:"+(i+j.left+c)+"px;right:auto;":h.charAt(1)=="w"&&(g+="right:"+(i-j.left-c+this.canvasWidth)+"px;left:auto;")):(h.charAt(0)=="n"?g+="top:"+(i+j.top)+"px;bottom:auto;":h.charAt(0)=="s"&&(g+="bottom:"+(i+j.bottom)+"px;top:auto;"),h.charAt(1)=="e"?g+="right:"+(i+j.right)+"px;left:auto;":h.charAt(1)=="w"&&(g+="left:"+(i+j.left)+"px;right:auto;")),f.style.cssText=g,a.empty(f),a.insert(f,b),a.show(f)):a.hide(f)},clip:function(a){var b=this.plotOffset,c=this.canvasWidth,e=this.canvasHeight;a=a||this.ctx;if(d.isIE&&d.isIE<9&&!d.isFlashCanvas){if(a===this.octx)return;a.save(),a.fillStyle=this.processColor(this.options.ieBackgroundColor),a.fillRect(0,0,c,b.top),a.fillRect(0,0,b.left,e),a.fillRect(0,e-b.bottom,c,b.bottom),a.fillRect(c-b.right,0,b.right,e),a.restore()}else a.clearRect(0,0,c,b.top),a.clearRect(0,0,b.left,e),a.clearRect(0,e-b.bottom,c,b.bottom),a.clearRect(c-b.right,0,b.right,e)},_initMembers:function(){this._handles=[],this.lastMousePos={pageX:null,pageY:null},this.plotOffset={left:0,right:0,top:0,bottom:0},this.ignoreClick=!0,this.prevHit=null},_initGraphTypes:function(){c.each(d.graphTypes,function(a,b){this[b]=d.clone(a)},this)},_initEvents:function(){var a=this.el,d,e,f;"ontouchstart"in a?(d=c.bind(function(c){f=!0,b.stopObserving(document,"touchend",d),b.fire(a,"flotr:mouseup",[event,this]),this.multitouches=null,e||this.clickHandler(c)},this),this.observe(this.overlay,"touchstart",c.bind(function(c){e=!1,f=!1,this.ignoreClick=!1,c.touches&&c.touches.length>1&&(this.multitouches=c.touches),b.fire(a,"flotr:mousedown",[event,this]),this.observe(document,"touchend",d)},this)),this.observe(this.overlay,"touchmove",c.bind(function(c){var d=this.getEventPosition(c);this.options.preventDefault&&c.preventDefault(),e=!0,this.multitouches||c.touches&&c.touches.length>1?this.multitouches=c.touches:f||b.fire(a,"flotr:mousemove",[event,d,this]),this.lastMousePos=d},this))):this.observe(this.overlay,"mousedown",c.bind(this.mouseDownHandler,this)).observe(a,"mousemove",c.bind(this.mouseMoveHandler,this)).observe(this.overlay,"click",c.bind(this.clickHandler,this)).observe(a,"mouseout",function(c){b.fire(a,"flotr:mouseout",c)})},_initCanvas:function(){function k(e,f){return e||(e=a.create("canvas"),typeof FlashCanvas!="undefined"&&typeof e.getContext=="function"&&(FlashCanvas.initElement(e),this.isFlashCanvas=!0),e.className="flotr-"+f,e.style.cssText="position:absolute;left:0px;top:0px;",a.insert(b,e)),c.each(i,function(b,c){a.show(e);if(f=="canvas"&&e.getAttribute(c)===b)return;e.setAttribute(c,b*d.resolution),e.style[c]=b+"px"}),e.context_=null,e}function l(a){window.G_vmlCanvasManager&&window.G_vmlCanvasManager.initElement(a);var b=a.getContext("2d");return window.G_vmlCanvasManager||b.scale(d.resolution,d.resolution),b}var b=this.el,d=this.options,e=b.children,f=[],g,h,i,j;for(h=e.length;h--;)g=e[h],!this.canvas&&g.className==="flotr-canvas"?this.canvas=g:!this.overlay&&g.className==="flotr-overlay"?this.overlay=g:f.push(g);for(h=f.length;h--;)b.removeChild(f[h]);a.setStyles(b,{position:"relative"}),i={},i.width=b.clientWidth,i.height=b.clientHeight;if(i.width<=0||i.height<=0||d.resolution<=0)throw"Invalid dimensions for plot, width = "+i.width+", height = "+i.height+", resolution = "+d.resolution;this.canvas=k(this.canvas,"canvas"),this.overlay=k(this.overlay,"overlay"),this.ctx=l(this.canvas),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.octx=l(this.overlay),this.octx.clearRect(0,0,this.overlay.width,this.overlay.height),this.canvasHeight=i.height,this.canvasWidth=i.width,this.textEnabled=!!this.ctx.drawText||!!this.ctx.fillText},_initPlugins:function(){c.each(d.plugins,function(a,b){c.each(a.callbacks,function(a,b){this.observe(this.el,b,c.bind(a,this))},this),this[b]=d.clone(a),c.each(this[b],function(a,d){c.isFunction(a)&&(this[b][d]=c.bind(a,this))},this)},this)},_initOptions:function(a){var e=d.clone(d.defaultOptions);e.x2axis=c.extend(c.clone(e.xaxis),e.x2axis),e.y2axis=c.extend(c.clone(e.yaxis),e.y2axis),this.options=d.merge(a||{},e),this.options.grid.minorVerticalLines===null&&this.options.xaxis.scaling==="logarithmic"&&(this.options.grid.minorVerticalLines=!0),this.options.grid.minorHorizontalLines===null&&this.options.yaxis.scaling==="logarithmic"&&(this.options.grid.minorHorizontalLines=!0),b.fire(this.el,"flotr:afterinitoptions",[this]),this.axes=d.Axis.getAxes(this.options);var f=[],g=[],h=this.series.length,i=this.series.length,j=this.options.colors,k=[],l=0,m,n,o,p;for(n=i-1;n>-1;--n)m=this.series[n].color,m&&(--i,c.isNumber(m)?f.push(m):k.push(d.Color.parse(m)));for(n=f.length-1;n>-1;--n)i=Math.max(i,f[n]+1);for(n=0;g.length<i;){m=j.length==n?new d.Color(100,100,100):d.Color.parse(j[n]);var q=l%2==1?-1:1,r=1+q*Math.ceil(l/2)*.2;m.scale(r,r,r),g.push(m),++n>=j.length&&(n=0,++l)}for(n=0,o=0;n<h;++n){p=this.series[n],p.color?c.isNumber(p.color)&&(p.color=g[p.color].toString()):p.color=g[o++].toString(),p.xaxis||(p.xaxis=this.axes.x),p.xaxis==1?p.xaxis=this.axes.x:p.xaxis==2&&(p.xaxis=this.axes.x2),p.yaxis||(p.yaxis=this.axes.y),p.yaxis==1?p.yaxis=this.axes.y:p.yaxis==2&&(p.yaxis=this.axes.y2);for(var s in d.graphTypes)p[s]=c.extend(c.clone(this.options[s]),p[s]);p.mouse=c.extend(c.clone(this.options.mouse),p.mouse),c.isUndefined(p.shadowSize)&&(p.shadowSize=this.options.shadowSize)}},_setEl:function(a){if(!a)throw"The target container doesn't exist";if(a.graph instanceof Graph)a.graph.destroy();else if(!a.clientWidth)throw"The target container must be visible";a.graph=this,this.el=a}},Flotr.Graph=Graph}(),function(){function c(b){this.orientation=1,this.offset=0,this.datamin=Number.MAX_VALUE,this.datamax=-Number.MAX_VALUE,a.extend(this,b)}function d(a,b){return a=Math.log(Math.max(a,Number.MIN_VALUE)),b!==Math.E&&(a/=Math.log(b)),a}function e(a,b){return b===Math.E?Math.exp(a):Math.pow(b,a)}var a=Flotr._,b="logarithmic";c.prototype={setScale:function(){var a=this.length,c=this.max,f=this.min,g=this.offset,h=this.orientation,i=this.options,j=i.scaling===b,k;j?k=a/(d(c,i.base)-d(f,i.base)):k=a/(c-f),this.scale=k,j?(this.d2p=function(a){return g+h*(d(a,i.base)-d(f,i.base))*k},this.p2d=function(a){return e((g+h*a)/k+d(f,i.base),i.base)}):(this.d2p=function(a){return g+h*(a-f)*k},this.p2d=function(a){return(g+h*a)/k+f})},calculateTicks:function(){var b=this.options;this.ticks=[],this.minorTicks=[],b.ticks?(this._cleanUserTicks(b.ticks,this.ticks),this._cleanUserTicks(b.minorTicks||[],this.minorTicks)):b.mode=="time"?this._calculateTimeTicks():b.scaling==="logarithmic"?this._calculateLogTicks():this._calculateTicks(),a.each(this.ticks,function(a){a.label+=""}),a.each(this.minorTicks,function(a){a.label+=""})},calculateRange:function(){if(!this.used)return;var a=this,b=a.options,c=b.min!==null?b.min:a.datamin,d=b.max!==null?b.max:a.datamax,e=b.autoscaleMargin;b.scaling=="logarithmic"&&(c<=0&&(c=a.datamin),d<=0&&(d=c));if(d==c){var f=d?.01:1;b.min===null&&(c-=f),b.max===null&&(d+=f)}if(b.scaling==="logarithmic"){c<0&&(c=d/b.base);var g=Math.log(d);b.base!=Math.E&&(g/=Math.log(b.base)),g=Math.ceil(g);var h=Math.log(c);b.base!=Math.E&&(h/=Math.log(b.base)),h=Math.ceil(h),a.tickSize=Flotr.getTickSize(b.noTicks,h,g,b.tickDecimals===null?0:b.tickDecimals),b.minorTickFreq===null&&(g-h>10?b.minorTickFreq=0:g-h>5?b.minorTickFreq=2:b.minorTickFreq=5)}else a.tickSize=Flotr.getTickSize(b.noTicks,c,d,b.tickDecimals);a.min=c,a.max=d,b.min===null&&b.autoscale&&(a.min-=a.tickSize*e,a.min<0&&a.datamin>=0&&(a.min=0),a.min=a.tickSize*Math.floor(a.min/a.tickSize)),b.max===null&&b.autoscale&&(a.max+=a.tickSize*e,a.max>0&&a.datamax<=0&&a.datamax!=a.datamin&&(a.max=0),a.max=a.tickSize*Math.ceil(a.max/a.tickSize)),a.min==a.max&&(a.max=a.min+1)},calculateTextDimensions:function(a,b){var c="",d,e;if(this.options.showLabels)for(e=0;e<this.ticks.length;++e)d=this.ticks[e].label.length,d>c.length&&(c=this.ticks[e].label);this.maxLabel=a.dimensions(c,{size:b.fontSize,angle:Flotr.toRad(this.options.labelsAngle)},"font-size:smaller;","flotr-grid-label"),this.titleSize=a.dimensions(this.options.title,{size:b.fontSize*1.2,angle:Flotr.toRad(this.options.titleAngle)},"font-weight:bold;","flotr-axis-title")},_cleanUserTicks:function(b,c){var d=this,e=this.options,f,g,h,i;a.isFunction(b)&&(b=b({min:d.min,max:d.max}));for(g=0;g<b.length;++g)i=b[g],typeof i=="object"?(f=i[0],h=i.length>1?i[1]:e.tickFormatter(f,{min:d.min,max:d.max})):(f=i,h=e.tickFormatter(f,{min:this.min,max:this.max})),c[g]={v:f,label:h}},_calculateTimeTicks:function(){this.ticks=Flotr.Date.generator(this)},_calculateLogTicks:function(){var a=this,b=a.options,c,d,e=Math.log(a.max);b.base!=Math.E&&(e/=Math.log(b.base)),e=Math.ceil(e);var f=Math.log(a.min);b.base!=Math.E&&(f/=Math.log(b.base)),f=Math.ceil(f);for(i=f;i<e;i+=a.tickSize){d=b.base==Math.E?Math.exp(i):Math.pow(b.base,i);var g=d*(b.base==Math.E?Math.exp(a.tickSize):Math.pow(b.base,a.tickSize)),h=(g-d)/b.minorTickFreq;a.ticks.push({v:d,label:b.tickFormatter(d,{min:a.min,max:a.max})});for(c=d+h;c<g;c+=h)a.minorTicks.push({v:c,label:b.tickFormatter(c,{min:a.min,max:a.max})})}d=b.base==Math.E?Math.exp(i):Math.pow(b.base,i),a.ticks.push({v:d,label:b.tickFormatter(d,{min:a.min,max:a.max})})},_calculateTicks:function(){var a=this,b=a.options,c=a.tickSize,d=a.min,e=a.max,f=c*Math.ceil(d/c),g,h,i,j,k,l;b.minorTickFreq&&(h=c/b.minorTickFreq);for(k=0;(i=j=f+k*c)<=e;++k){g=b.tickDecimals,g===null&&(g=1-Math.floor(Math.log(c)/Math.LN10)),g<0&&(g=0),i=i.toFixed(g),a.ticks.push({v:i,label:b.tickFormatter(i,{min:a.min,max:a.max})});if(b.minorTickFreq)for(l=0;l<b.minorTickFreq&&k*c+l*h<e;++l)i=j+l*h,a.minorTicks.push({v:i,label:b.tickFormatter(i,{min:a.min,max:a.max})})}}},a.extend(c,{getAxes:function(a){return{x:new c({options:a.xaxis,n:1,length:this.plotWidth}),x2:new c({options:a.x2axis,n:2,length:this.plotWidth}),y:new c({options:a.yaxis,n:1,length:this.plotHeight,offset:this.plotHeight,orientation:-1}),y2:new c({options:a.y2axis,n:2,length:this.plotHeight,offset:this.plotHeight,orientation:-1})}}}),Flotr.Axis=c}(),function(){function b(b){a.extend(this,b)}var a=Flotr._;b.prototype={getRange:function(){var a=this.data,b=a.length,c=Number.MAX_VALUE,d=Number.MAX_VALUE,e=-Number.MAX_VALUE,f=-Number.MAX_VALUE,g=!1,h=!1,i,j,k;if(b<0||this.hide)return!1;for(k=0;k<b;k++)i=a[k][0],j=a[k][1],i!==null&&(i<c&&(c=i,g=!0),i>e&&(e=i,g=!0)),j!==null&&(j<d&&(d=j,h=!0),j>f&&(f=j,h=!0));return{xmin:c,xmax:e,ymin:d,ymax:f,xused:g,yused:h}}},a.extend(b,{getSeries:function(c){return a.map(c,function(c){var d;return c.data?(d=new b,a.extend(d,c)):d=new b({data:c}),d})}}),Flotr.Series=b}(),Flotr.addType("lines",{options:{show:!1,lineWidth:2,fill:!1,fillBorder:!1,fillColor:null,fillOpacity:.4,steps:!1,stacked:!1},stack:{values:[]},draw:function(a){var b=a.context,c=a.lineWidth,d=a.shadowSize,e;b.save(),b.lineJoin="round",d&&(b.lineWidth=d/2,e=c/2+b.lineWidth/2,b.strokeStyle="rgba(0,0,0,0.1)",this.plot(a,e+d/2,!1),b.strokeStyle="rgba(0,0,0,0.2)",this.plot(a,e,!1)),b.lineWidth=c,b.strokeStyle=a.color,this.plot(a,0,!0),b.restore()},plot:function(a,b,c){function w(){!b&&a.fill&&o&&(p=g(o[0]),d.fillStyle=a.fillStyle,d.lineTo(q,n),d.lineTo(p,n),d.lineTo(p,h(o[1])),d.fill(),a.fillBorder&&d.stroke())}var d=a.context,e=a.width,f=a.height,g=a.xScale,h=a.yScale,i=a.data,j=a.stacked?this.stack:!1,k=i.length-1,l=null,m=null,n=h(0),o=null,p,q,r,s,t,u,v;if(k<1)return;d.beginPath();for(v=0;v<k;++v){if(i[v][1]===null||i[v+1][1]===null){a.fill&&v>0&&i[v][1]!==null&&(d.stroke(),w(),o=null,d.closePath(),d.beginPath());continue}p=g(i[v][0]),q=g(i[v+1][0]),o===null&&(o=i[v]),j?(t=j.values[i[v][0]]||0,u=j.values[i[v+1][0]]||j.values[i[v][0]]||0,r=h(i[v][1]+t),s=h(i[v+1][1]+u),c&&(j.values[i[v][0]]=i[v][1]+t,v==k-1&&(j.values[i[v+1][0]]=i[v+1][1]+u))):(r=h(i[v][1]),s=h(i[v+1][1]));if(r>f&&s>f||r<0&&s<0||p<0&&q<0||p>e&&q>e)continue;(l!=p||m!=r+b)&&d.moveTo(p,r+b),l=q,m=s+b,a.steps?(d.lineTo(l+b/2,r+b),d.lineTo(l+b/2,m)):d.lineTo(l,m)}(!a.fill||a.fill&&!a.fillBorder)&&d.stroke(),w(),d.closePath()},extendYRange:function(a,b,c,d){var e=a.options;if(c.stacked&&(!e.max&&e.max!==0||!e.min&&e.min!==0)){var f=a.max,g=a.min,h=d.positiveSums||{},i=d.negativeSums||{},j,k;for(k=0;k<b.length;k++)j=b[k][0]+"",b[k][1]>0?(h[j]=(h[j]||0)+b[k][1],f=Math.max(f,h[j])):(i[j]=(i[j]||0)+b[k][1],g=Math.min(g,i[j]));d.negativeSums=i,d.positiveSums=h,a.max=f,a.min=g}c.steps&&(this.hit=function(a){var b=a.data,c=a.args,d=a.yScale,e=c[0],f=b.length,g=c[1],h=a.xInverse(e.relX),i=e.relY,j;for(j=0;j<f-1;j++)if(h>=b[j][0]&&h<=b[j+1][0]){Math.abs(d(b[j][1])-i)<8&&(g.x=b[j][0],g.y=b[j][1],g.index=j,g.seriesIndex=a.index);break}},this.drawHit=function(a){var b=a.context,c=a.args,d=a.data,e=a.xScale,f=c.index,g=e(c.x),h=a.yScale(c.y),i;d.length-1>f&&(i=a.xScale(d[f+1][0]),b.save(),b.strokeStyle=a.color,b.lineWidth=a.lineWidth,b.beginPath(),b.moveTo(g,h),b.lineTo(i,h),b.stroke(),b.closePath(),b.restore())},this.clearHit=function(a){var b=a.context,c=a.args,d=a.data,e=a.xScale,f=a.lineWidth,g=c.index,h=e(c.x),i=a.yScale(c.y),j;d.length-1>g&&(j=a.xScale(d[g+1][0]),b.clearRect(h-f,i-f,j-h+2*f,2*f))})}}),Flotr.addType("bars",{options:{show:!1,lineWidth:2,barWidth:1,fill:!0,fillColor:null,fillOpacity:.4,horizontal:!1,stacked:!1,centered:!0,topPadding:.1,grouped:!1},stack:{positive:[],negative:[],_positive:[],_negative:[]},draw:function(a){var b=a.context;this.current+=1,b.save(),b.lineJoin="miter",b.lineWidth=a.lineWidth,b.strokeStyle=a.color,a.fill&&(b.fillStyle=a.fillStyle),this.plot(a),b.restore()},plot:function(a){var b=a.data,c=a.context,d=a.shadowSize,e,f,g,h,i,j;if(b.length<1)return;this.translate(c,a.horizontal);for(e=0;e<b.length;e++){f=this.getBarGeometry(b[e][0],b[e][1],a);if(f===null)continue;g=f.left,h=f.top,i=f.width,j=f.height,a.fill&&c.fillRect(g,h,i,j),d&&(c.save(),c.fillStyle="rgba(0,0,0,0.05)",c.fillRect(g+d,h+d,i,j),c.restore()),a.lineWidth&&c.strokeRect(g,h,i,j)}},translate:function(a,b){b&&(a.rotate(-Math.PI/2),a.scale(-1,1))},getBarGeometry:function(a,b,c){var d=c.horizontal,e=c.barWidth,f=c.centered,g=c.stacked?this.stack:!1,h=c.lineWidth,i=f?e/2:0,j=d?c.yScale:c.xScale,k=d?c.xScale:c.yScale,l=d?b:a,m=d?a:b,n=0,o,p,q,r,s;return c.grouped&&(this.current/this.groups,l-=i,e/=this.groups,i=e/2,l=l+e*this.current-i),g&&(o=m>0?g.positive:g.negative,n=o[l]||n,o[l]=n+m),p=j(l-i),q=j(l+e-i),r=k(m+n),s=k(n),s<0&&(s=0),a===null||b===null?null:{x:l,y:m,xScale:j,yScale:k,top:r,left:Math.min(p,q)-h/2,width:Math.abs(q-p)-h,height:s-r}},hit:function(a){var b=a.data,c=a.args,d=c[0],e=c[1],f=a.xInverse(d.relX),g=a.yInverse(d.relY),h=this.getBarGeometry(f,g,a),i=h.width/2,j=h.left,k=h.y,l,m;for(m=b.length;m--;)l=this.getBarGeometry(b[m][0],b[m][1],a),(k>0&&k<l.y||k<0&&k>l.y)&&Math.abs(j-l.left)<i&&(e.x=b[m][0],e.y=b[m][1],e.index=m,e.seriesIndex=a.index)},drawHit:function(a){var b=a.context,c=a.args,d=this.getBarGeometry(c.x,c.y,a),e=d.left,f=d.top,g=d.width,h=d.height;b.save(),b.strokeStyle=a.color,b.lineWidth=a.lineWidth,this.translate(b,a.horizontal),b.beginPath(),b.moveTo(e,f+h),b.lineTo(e,f),b.lineTo(e+g,f),b.lineTo(e+g,f+h),a.fill&&(b.fillStyle=a.fillStyle,b.fill()),b.stroke(),b.closePath(),b.restore()},clearHit:function(a){var b=a.context,c=a.args,d=this.getBarGeometry(c.x,c.y,a),e=d.left,f=d.width,g=d.top,h=d.height,i=2*a.lineWidth;b.save(),this.translate(b,a.horizontal),b.clearRect(e-i,Math.min(g,g+h)-i,f+2*i,Math.abs(h)+2*i),b.restore()},extendXRange:function(a,b,c,d){this._extendRange(a,b,c,d),this.groups=this.groups+1||1,this.current=0},extendYRange:function(a,b,c,d){this._extendRange(a,b,c,d)},_extendRange:function(a,b,c,d){var e=a.options.max;if(_.isNumber(e)||_.isString(e))return;var f=a.min,g=a.max,h=c.horizontal,i=a.orientation,j=this.positiveSums||{},k=this.negativeSums||{},l,m,n,o;(i==1&&!h||i==-1&&h)&&c.centered&&(g=Math.max(a.datamax+c.barWidth,g),f=Math.min(a.datamin-c.barWidth,f));if(c.stacked&&(i==1&&h||i==-1&&!h))for(o=b.length;o--;)l=b[o][i==1?1:0]+"",m=b[o][i==1?0:1],m>0?(j[l]=(j[l]||0)+m,g=Math.max(g,j[l])):(k[l]=(k[l]||0)+m,f=Math.min(f,k[l]));(i==1&&h||i==-1&&!h)&&c.topPadding&&(a.max===a.datamax||c.stacked&&this.stackMax!==g)&&(g+=c.topPadding*(g-f)),this.stackMin=f,this.stackMax=g,this.negativeSums=k,this.positiveSums=j,a.max=g,a.min=f}}),Flotr.addType("bubbles",{options:{show:!1,lineWidth:2,fill:!0,fillOpacity:.4,baseRadius:2},draw:function(a){var b=a.context,c=a.shadowSize;b.save(),b.lineWidth=a.lineWidth,b.fillStyle="rgba(0,0,0,0.05)",b.strokeStyle="rgba(0,0,0,0.05)",this.plot(a,c/2),b.strokeStyle="rgba(0,0,0,0.1)",this.plot(a,c/4),b.strokeStyle=a.color,b.fillStyle=a.fillStyle,this.plot(a),b.restore()},plot:function(a,b){var c=a.data,d=a.context,e,f,g,h,i;b=b||0;for(f=0;f<c.length;++f)e=this.getGeometry(c[f],a),d.beginPath(),d.arc(e.x+b,e.y+b,e.z,0,2*Math.PI,!0),d.stroke(),a.fill&&d.fill(),d.closePath()},getGeometry:function(a,b){return{x:b.xScale(a[0]),y:b.yScale(a[1]),z:a[2]*b.baseRadius}},hit:function(a){var b=a.data,c=a.args,d=c[0],e=c[1],f=d.relX,g=d.relY,h,j,k,l;e.best=e.best||Number.MAX_VALUE;for(i=b.length;i--;)j=this.getGeometry(b[i],a),k=j.x-f,l=j.y-g,h=Math.sqrt(k*k+l*l),h<j.z&&j.z<e.best&&(e.x=b[i][0],e.y=b[i][1],e.index=i,e.seriesIndex=a.index,e.best=j.z)},drawHit:function(a){var b=a.context,c=this.getGeometry(a.data[a.args.index],a);b.save(),b.lineWidth=a.lineWidth,b.fillStyle=a.fillStyle,b.strokeStyle=a.color,b.beginPath(),b.arc(c.x,c.y,c.z,0,2*Math.PI,!0),b.fill(),b.stroke(),b.closePath(),b.restore()},clearHit:function(a){var b=a.context,c=this.getGeometry(a.data[a.args.index],a),d=c.z+a.lineWidth;b.save(),b.clearRect(c.x-d,c.y-d,2*d,2*d),b.restore()}}),Flotr.addType("candles",{options:{show:!1,lineWidth:1,wickLineWidth:1,candleWidth:.6,fill:!0,upFillColor:"#00A8F0",downFillColor:"#CB4B4B",fillOpacity:.5,barcharts:!1},draw:function(a){var b=a.context;b.save(),b.lineJoin="miter",b.lineCap="butt",b.lineWidth=a.wickLineWidth||a.lineWidth,this.plot(a),b.restore()},plot:function(a){var b=a.data,c=a.context,d=a.xScale,e=a.yScale,f=a.candleWidth/2,g=a.shadowSize,h=a.lineWidth,i=a.wickLineWidth,j=i%2/2,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y;if(b.length<1)return;for(y=0;y<b.length;y++){l=b[y],m=l[0],o=l[1],p=l[2],q=l[3],r=l[4],s=d(m-f),t=d(m+f),u=e(q),v=e(p),w=e(Math.min(o,r)),x=e(Math.max(o,r)),k=a[o>r?"downFillColor":"upFillColor"],a.fill&&!a.barcharts&&(c.fillStyle="rgba(0,0,0,0.05)",c.fillRect(s+g,x+g,t-s,w-x),c.save(),c.globalAlpha=a.fillOpacity,c.fillStyle=k,c.fillRect(s,x+h,t-s,w-x),c.restore());if(h||i)m=Math.floor((s+t)/2)+j,c.strokeStyle=k,c.beginPath(),a.barcharts?(c.moveTo(m,Math.floor(v+f)),c.lineTo(m,Math.floor(u+f)),n=Math.floor(o+f)+.5,c.moveTo(Math.floor(s)+j,n),c.lineTo(m,n),n=Math.floor(r+f)+.5,c.moveTo(Math.floor(t)+j,n),c.lineTo(m,n)):(c.strokeRect(s,x+h,t-s,w-x),c.moveTo(m,Math.floor(x+h)),c.lineTo(m,Math.floor(v+h)),c.moveTo(m,Math.floor(w+h)),c.lineTo(m,Math.floor(u+h))),c.closePath(),c.stroke()}},hit:function(a){var b=a.xScale,c=a.yScale,d=a.data,e=a.args,f=e[0],g=a.candleWidth/2,h=e[1],i=f.relX,j=f.relY,k=d.length,l,m,n,o,p,q,r,s;for(l=0;l<k;l++){m=d[l],n=m[2],o=m[3],p=b(m[0]-g),q=b(m[0]+g),s=c(o),r=c(n);if(i>p&&i<q&&j>r&&j<s){h.x=m[0],h.index=l,h.seriesIndex=a.index;return}}},drawHit:function(a){var b=a.context;b.save(),this.plot(_.defaults({fill:!!a.fillColor,upFillColor:a.color,downFillColor:a.color,data:[a.data[a.args.index]]},a)),b.restore()},clearHit:function(a){var b=a.args,c=a.context,d=a.xScale,e=a.yScale,f=a.lineWidth,g=a.candleWidth/2,h=a.data[b.index],i=d(h[0]-g)-f,j=d(h[0]+g)+f,k=e(h[2]),l=e(h[3])+f;c.clearRect(i,k,j-i,l-k)},extendXRange:function(a,b,c){a.options.max===null&&(a.max=Math.max(a.datamax+.5,a.max),a.min=Math.min(a.datamin-.5,a.min))}}),Flotr.addType("gantt",{options:{show:!1,lineWidth:2,barWidth:1,fill:!0,fillColor:null,fillOpacity:.4,centered:!0},draw:function(a){var b=this.ctx,c=a.gantt.barWidth,d=Math.min(a.gantt.lineWidth,c);b.save(),b.translate(this.plotOffset.left,this.plotOffset.top),b.lineJoin="miter",b.lineWidth=d,b.strokeStyle=a.color,b.save(),this.gantt.plotShadows(a,c,0,a.gantt.fill),b.restore();if(a.gantt.fill){var e=a.gantt.fillColor||a.color;b.fillStyle=this.processColor(e,{opacity:a.gantt.fillOpacity})}this.gantt.plot(a,c,0,a.gantt.fill),b.restore()},plot:function(a,b,c,d){var e=a.data;if(e.length<1)return;var f=a.xaxis,g=a.yaxis,h=this.ctx,i;for(i=0;i<e.length;i++){var j=e[i][0],k=e[i][1],l=e[i][2],m=!0,n=!0,o=!0;if(k===null||l===null)continue;var p=k,q=k+l,r=j-(a.gantt.centered?b/2:0),s=j+b-(a.gantt.centered?b/2:0);if(q<f.min||p>f.max||s<g.min||r>g.max)continue;p<f.min&&(p=f.min,m=!1),q>f.max&&(q=f.max,f.lastSerie!=a&&(n=!1)),r<g.min&&(r=g.min),s>g.max&&(s=g.max,g.lastSerie!=a&&(n=!1)),d&&(h.beginPath(),h.moveTo(f.d2p(p),g.d2p(r)+c),h.lineTo(f.d2p(p),g.d2p(s)+c),h.lineTo(f.d2p(q),g.d2p(s)+c),h.lineTo(f.d2p(q),g.d2p(r)+c),h.fill(),h.closePath()),a.gantt.lineWidth&&(m||o||n)&&(h.beginPath(),h.moveTo(f.d2p(p),g.d2p(r)+c),h[m?"lineTo":"moveTo"](f.d2p(p),g.d2p(s)+c),h[n?"lineTo":"moveTo"](f.d2p(q),g.d2p(s)+c),h[o?"lineTo":"moveTo"](f.d2p(q),g.d2p(r)+c),h.stroke(),h.closePath())}},plotShadows:function(a,b,c){var d=a.data;if(d.length<1)return;var e,f,g,h,i=a.xaxis,j=a.yaxis,k=this.ctx,l=this.options.shadowSize;for(e=0;e<d.length;e++){f=d[e][0],g=d[e][1],h=d[e][2];if(g===null||h===null)continue;var m=g,n=g+h,o=f-(a.gantt.centered?b/2:0),p=f+b-(a.gantt.centered?b/2:0);if(n<i.min||m>i.max||p<j.min||o>j.max)continue;m<i.min&&(m=i.min),n>i.max&&(n=i.max),o<j.min&&(o=j.min),p>j.max&&(p=j.max);var q=i.d2p(n)-i.d2p(m)-(i.d2p(n)+l<=this.plotWidth?0:l),r=j.d2p(o)-j.d2p(p)-(j.d2p(o)+l<=this.plotHeight?0:l);k.fillStyle="rgba(0,0,0,0.05)",k.fillRect(Math.min(i.d2p(m)+l,this.plotWidth),Math.min(j.d2p(p)+l,this.plotHeight),q,r)}},extendXRange:function(a){if(a.options.max===null){var b=a.min,c=a.max,d,e,f,g,h,i={},j={},k=null;for(d=0;d<this.series.length;++d){g=this.series[d],h=g.gantt;if(h.show&&g.xaxis==a){for(e=0;e<g.data.length;e++)h.show&&(y=g.data[e][0]+"",i[y]=Math.max(i[y]||0,g.data[e][1]+g.data[e][2]),k=g);for(e in i)c=Math.max(i[e],c)}}a.lastSerie=k,a.max=c,a.min=b}},extendYRange:function(a){if(a.options.max===null){var b=Number.MIN_VALUE,c=Number.MAX_VALUE,d,e,f,g,h={},i={},j=null;for(d=0;d<this.series.length;++d){f=this.series[d],g=f.gantt;if(g.show&&!f.hide&&f.yaxis==a){var k=Number.MIN_VALUE,l=Number.MAX_VALUE;for(e=0;e<f.data.length;e++)k=Math.max(k,f.data[e][0]),l=Math.min(l,f.data[e][0]);g.centered?(b=Math.max(k+.5,b),c=Math.min(l-.5,c)):(b=Math.max(k+1,b),c=Math.min(l,c)),g.barWidth+k>b&&(b=a.max+g.barWidth)}}a.lastSerie=j,a.max=b,a.min=c,a.tickSize=Flotr.getTickSize(a.options.noTicks,c,b,a.options.tickDecimals)}}}),function(){function a(a){return typeof a=="object"&&a.constructor&&(Image?!0:a.constructor===Image)}Flotr.defaultMarkerFormatter=function(a){return Math.round(a.y*100)/100+""},Flotr.addType("markers",{options:{show:!1,lineWidth:1,color:"#000000",fill:!1,fillColor:"#FFFFFF",fillOpacity:.4,stroke:!1,position:"ct",verticalMargin:0,labelFormatter:Flotr.defaultMarkerFormatter,fontSize:Flotr.defaultOptions.fontSize,stacked:!1,stackingType:"b",horizontal:!1},stack:{positive:[],negative:[],values:[]},draw:function(a){function m(a,b){return g=d.negative[a]||0,f=d.positive[a]||0,b>0?(d.positive[a]=g+b,g+b):(d.negative[a]=f+b,f+b)}var b=a.data,c=a.context,d=a.stacked?a.stack:!1,e=a.stackingType,f,g,h,i,j,k,l;c.save(),c.lineJoin="round",c.lineWidth=a.lineWidth,c.strokeStyle="rgba(0,0,0,0.5)",c.fillStyle=a.fillStyle;for(i=0;i<b.length;++i)j=b[i][0],k=b[i][1],d&&(e=="b"?a.horizontal?k=m(k,j):j=m(j,k):e=="a"&&(h=d.values[j]||0,d.values[j]=h+k,k=h+k)),l=a.labelFormatter({x:j,y:k,index:i,data:b}),this.plot(a.xScale(j),a.yScale(k),l,a);c.restore()},plot:function(b,c,d,e){var f=e.context;if(a(d)&&!d.complete)throw"Marker image not loaded.";this._plot(b,c,d,e)},_plot:function(b,c,d,e){var f=e.context,g=2,h=b,i=c,j;a(d)?j={height:d.height,width:d.width}:j=e.text.canvas(d),j.width=Math.floor(j.width+g*2),j.height=Math.floor(j.height+g*2),e.position.indexOf("c")!=-1?h-=j.width/2+g:e.position.indexOf("l")!=-1&&(h-=j.width),e.position.indexOf("m")!=-1?i-=j.height/2+g:e.position.indexOf("t")!=-1?i-=j.height+e.verticalMargin:i+=e.verticalMargin,h=Math.floor(h)+.5,i=Math.floor(i)+.5,e.fill&&f.fillRect(h,i,j.width,j.height),e.stroke&&f.strokeRect(h,i,j.width,j.height),a(d)?f.drawImage(d,parseInt(h+g,10),parseInt(i+g,10)):Flotr.drawText(f,d,h+g,i+g,{textBaseline:"top",textAlign:"left",size:e.fontSize,color:e.color})}})}(),function(){var a=Flotr._;Flotr.defaultPieLabelFormatter=function(a,b){return(100*b/a).toFixed(2)+"%"},Flotr.addType("pie",{options:{show:!1,lineWidth:1,fill:!0,fillColor:null,fillOpacity:.6,explode:6,sizeRatio:.6,startAngle:Math.PI/4,labelFormatter:Flotr.defaultPieLabelFormatter,pie3D:!1,pie3DviewAngle:Math.PI/2*.8,pie3DspliceThickness:20,epsilon:.1},draw:function(a){var b=a.data,c=a.context,d=a.lineWidth,e=a.shadowSize,f=a.sizeRatio,g=a.height,h=a.width,i=a.explode,j=a.color,k=a.fill,l=a.fillStyle,m=Math.min(h,g)*f/2,n=b[0][1],o=[],p=1,q=Math.PI*2*n/this.total,r=this.startAngle||2*Math.PI*a.startAngle,s=r+q,t=r+q/2,u=a.labelFormatter(this.total,n),v=i+m+4,w=Math.cos(t)*v,x=Math.sin(t)*v,y=w<0?"right":"left",z=x>0?"top":"bottom",A,B,C;c.save(),c.translate(h/2,g/2),c.scale(1,p),B=Math.cos(t)*i,C=Math.sin(t)*i,e>0&&(this.plotSlice(B+e,C+e,m,r,s,c),k&&(c.fillStyle="rgba(0,0,0,0.1)",c.fill())),this.plotSlice(B,C,m,r,s,c),k&&(c.fillStyle=l,c.fill()),c.lineWidth=d,c.strokeStyle=j,c.stroke(),A={size:a.fontSize*1.2,color:a.fontColor,weight:1.5},u&&(a.htmlText||!a.textEnabled?(divStyle="position:absolute;"+z+":"+(g/2+(z==="top"?x:-x))+"px;",divStyle+=y+":"+(h/2+(y==="right"?-w:w))+"px;",o.push('<div style="',divStyle,'" class="flotr-grid-label">',u,"</div>")):(A.textAlign=y,A.textBaseline=z,Flotr.drawText(c,u,w,x,A)));if(a.htmlText||!a.textEnabled){var D=Flotr.DOM.node('<div style="color:'+a.fontColor+'" class="flotr-labels"></div>');Flotr.DOM.insert(D,o.join("")),Flotr.DOM.insert(a.element,D)}c.restore(),this.startAngle=s,this.slices=this.slices||[],this.slices.push({radius:m,x:B,y:C,explode:i,start:r,end:s})},plotSlice:function(a,b,c,d,e,f){f.beginPath(),f.moveTo(a,b),f.arc(a,b,c,d,e,!1),f.lineTo(a,b),f.closePath()},hit:function(a){var b=a.data[0],c=a.args,d=a.index,e=c[0],f=c[1],g=this.slices[d],h=e.relX-a.width/2,i=e.relY-a.height/2,j=Math.sqrt(h*h+i*i),k=Math.atan(i/h),l=Math.PI*2,m=g.explode||a.explode,n=g.start%l,o=g.end%l,p=a.epsilon;h<0?k+=Math.PI:h>0&&i<0&&(k+=l),j<g.radius+m&&j>m&&(k>n&&k<o||n>o&&(k<o||k>n)||n===o&&(g.start===g.end&&Math.abs(k-n)<p||g.start!==g.end&&Math.abs(k-n)>p))&&(f.x=b[0],f.y=b[1],f.sAngle=n,f.eAngle=o,f.index=0,f.seriesIndex=d,f.fraction=b[1]/this.total)},drawHit:function(a){var b=a.context,c=this.slices[a.args.seriesIndex];b.save(),b.translate(a.width/2,a.height/2),this.plotSlice(c.x,c.y,c.radius,c.start,c.end,b),b.stroke(),b.restore()},clearHit:function(a){var b=a.context,c=this.slices[a.args.seriesIndex],d=2*a.lineWidth,e=c.radius+d;b.save(),b.translate(a.width/2,a.height/2),b.clearRect(c.x-e,c.y-e,2*e+d,2*e+d),b.restore()},extendYRange:function(a,b){this.total=(this.total||0)+b[0][1]}})}(),Flotr.addType("points",{options:{show:!1,radius:3,lineWidth:2,fill:!0,fillColor:"#FFFFFF",fillOpacity:1,hitRadius:null},draw:function(a){var b=a.context,c=a.lineWidth,d=a.shadowSize;b.save(),d>0&&(b.lineWidth=d/2,b.strokeStyle="rgba(0,0,0,0.1)",this.plot(a,d/2+b.lineWidth/2),b.strokeStyle="rgba(0,0,0,0.2)",this.plot(a,b.lineWidth/2)),b.lineWidth=a.lineWidth,b.strokeStyle=a.color,a.fill&&(b.fillStyle=a.fillStyle),this.plot(a),b.restore()},plot:function(a,b){var c=a.data,d=a.context,e=a.xScale,f=a.yScale,g,h,i;for(g=c.length-1;g>-1;--g){i=c[g][1];if(i===null)continue;h=e(c[g][0]),i=f(i);if(h<0||h>a.width||i<0||i>a.height)continue;d.beginPath(),b?d.arc(h,i+b,a.radius,0,Math.PI,!1):(d.arc(h,i,a.radius,0,2*Math.PI,!0),a.fill&&d.fill()),d.stroke(),d.closePath()}}}),Flotr.addType("radar",{options:{show:!1,lineWidth:2,fill:!0,fillOpacity:.4,radiusRatio:.9,sensibility:2},draw:function(a){var b=a.context,c=a.shadowSize;b.save(),b.translate(a.width/2,a.height/2),b.lineWidth=a.lineWidth,b.fillStyle="rgba(0,0,0,0.05)",b.strokeStyle="rgba(0,0,0,0.05)",this.plot(a,c/2),b.strokeStyle="rgba(0,0,0,0.1)",this.plot(a,c/4),b.strokeStyle=a.color,b.fillStyle=a.fillStyle,this.plot(a),b.restore()},plot:function(a,b){var c=a.data,d=a.context,e=Math.min(a.height,a.width)*a.radiusRatio/2,f=2*Math.PI/c.length,g=-Math.PI/2,h,i;b=b||0,d.beginPath();for(h=0;h<c.length;++h)i=c[h][1]/this.max,d[h===0?"moveTo":"lineTo"](Math.cos(h*f+g)*e*i+b,Math.sin(h*f+g)*e*i+b);d.closePath(),a.fill&&d.fill(),d.stroke()},getGeometry:function(a,b){var c=Math.min(b.height,b.width)*b.radiusRatio/2,d=2*Math.PI/b.data.length,e=-Math.PI/2,f=a[1]/this.max;return{x:Math.cos(a[0]*d+e)*c*f+b.width/2,y:Math.sin(a[0]*d+e)*c*f+b.height/2}},hit:function(a){var b=a.args,c=b[0],d=b[1],e=c.relX,f=c.relY,g,h,i,j;for(var k=0;k<d.series.length;k++){var l=d.series[k],m=l.data;for(var n=m.length;n--;){h=this.getGeometry(m[n],a),i=h.x-e,j=h.y-f,g=Math.sqrt(i*i+j*j);if(g<a.sensibility*2)return d.x=m[n][0],d.y=m[n][1],d.index=n,d.seriesIndex=k,d}}},drawHit:function(a){var b=2*Math.PI/a.data.length,c=-Math.PI/2,d=Math.min(a.height,a.width)*a.radiusRatio/2,e=a.args.series,f=e.points.hitRadius||e.points.radius||e.mouse.radius,g=a.context;g.translate(a.width/2,a.height/2);var h=a.args.index,i=a.data[h][1]/this.max,j=Math.cos(h*b+c)*d*i,k=Math.sin(h*b+c)*d*i;g.beginPath(),g.arc(j,k,f,0,2*Math.PI,!0),g.closePath(),g.stroke()},clearHit:function(a){var b=2*Math.PI/a.data.length,c=-Math.PI/2,d=Math.min(a.height,a.width)*a.radiusRatio/2,e=a.context,f=a.args.series,g=f.points?f.points.lineWidth:1;offset=(f.points.hitRadius||f.points.radius||f.mouse.radius)+g,e.translate(a.width/2,a.height/2);var h=a.args.index,i=a.data[h][1]/this.max,j=Math.cos(h*b+c)*d*i,k=Math.sin(h*b+c)*d*i;e.clearRect(j-offset,k-offset,offset*2,offset*2)},extendYRange:function(a,b){this.max=Math.max(a.max,this.max||-Number.MAX_VALUE)}}),Flotr.addType("timeline",{options:{show:!1,lineWidth:1,barWidth:.2,fill:!0,fillColor:null,fillOpacity:.4,centered:!0},draw:function(a){var b=a.context;b.save(),b.lineJoin="miter",b.lineWidth=a.lineWidth,b.strokeStyle=a.color,b.fillStyle=a.fillStyle,this.plot(a),b.restore()},plot:function(a){var b=a.data,c=a.context,d=a.xScale,e=a.yScale,f=a.barWidth,g=a.lineWidth,h;Flotr._.each(b,function(a){var b=a[0],h=a[1],i=a[2],j=f,k=Math.ceil(d(b)),l=Math.ceil(d(b+i))-k,m=Math.round(e(h)),n=Math.round(e(h-j))-m,o=k-g/2,p=Math.round(m-n/2)-g/2;c.strokeRect(o,p,l,n),c.fillRect(o,p,l,n)})},extendRange:function(a){var b=a.data,c=a.xaxis,d=a.yaxis,e=a.timeline.barWidth;c.options.min===null&&(c.min=c.datamin-e/2);if(c.options.max===null){var f=c.max;Flotr._.each(b,function(a){f=Math.max(f,a[0]+a[2])},this),c.max=f+e/2}d.options.min===null&&(d.min=d.datamin-e),d.options.min===null&&(d.max=d.datamax+e)}}),function(){var a=Flotr.DOM;Flotr.addPlugin("crosshair",{options:{mode:null,color:"#FF0000",hideCursor:!0},callbacks:{"flotr:mousemove":function(a,b){this.options.crosshair.mode&&(this.crosshair.clearCrosshair(),this.crosshair.drawCrosshair(b))}},drawCrosshair:function(b){var c=this.octx,d=this.options.crosshair,e=this.plotOffset,f=e.left+Math.round(b.relX)+.5,g=e.top+Math.round(b.relY)+.5;if(b.relX<0||b.relY<0||b.relX>this.plotWidth||b.relY>this.plotHeight){this.el.style.cursor=null,a.removeClass(this.el,"flotr-crosshair");return}d.hideCursor&&(this.el.style.cursor="none",a.addClass(this.el,"flotr-crosshair")),c.save(),c.strokeStyle=d.color,c.lineWidth=1,c.beginPath(),d.mode.indexOf("x")!=-1&&(c.moveTo(f,e.top),c.lineTo(f,e.top+this.plotHeight)),d.mode.indexOf("y")!=-1&&(c.moveTo(e.left,g),c.lineTo(e.left+this.plotWidth,g)),c.stroke(),c.restore()},clearCrosshair:function(){var a=this.plotOffset,b=this.lastMousePos,c=this.octx;b&&(c.clearRect(Math.round(b.relX)+a.left,a.top,1,this.plotHeight+1),c.clearRect(a.left,Math.round(b.relY)+a.top,this.plotWidth+1,1))}})}(),function(){function c(a,b,c,d,e,f){var g="image/"+a,h=c.getImageData(0,0,d,e),i=new Image;return c.save(),c.globalCompositeOperation="destination-over",c.fillStyle=f,c.fillRect(0,0,d,e),i.src=b.toDataURL(g),c.restore(),c.clearRect(0,0,d,e),c.putImageData(h,0,0),i}var a=Flotr.DOM,b=Flotr._;Flotr.addPlugin("download",{saveImage:function(d,e,f,g){var h=this.options.grid,i;if(Flotr.isIE&&Flotr.isIE<9)return i="<html><body>"+this.canvas.firstChild.innerHTML+"</body></html>",window.open().document.write(i);if(d!=="jpeg"&&d!=="png")return;i=c(d,this.canvas,this.ctx,this.canvasWidth,this.canvasHeight,h&&h.backgroundColor||"#ffffff");if(b.isElement(i)&&g)this.download.restoreCanvas(),a.hide(this.canvas),a.hide(this.overlay),a.setStyles({position:"absolute"}),a.insert(this.el,i),this.saveImageElement=i;else return window.open(i.src)},restoreCanvas:function(){a.show(this.canvas),a.show(this.overlay),this.saveImageElement&&this.el.removeChild(this.saveImageElement),this.saveImageElement=null}})}(),function(){var a=Flotr.EventAdapter,b=Flotr._;Flotr.addPlugin("graphGrid",{callbacks:{"flotr:beforedraw":function(){this.graphGrid.drawGrid()},"flotr:afterdraw":function(){this.graphGrid.drawOutline()}},drawGrid:function(){function p(a){for(n=0;n<a.length;++n){var b=a[n].v/l.max;for(o=0;o<=u;++o)c[o===0?"moveTo":"lineTo"](Math.cos(o*v+w)*t*b,Math.sin(o*v+w)*t*b)}}function q(a,d){b.each(b.pluck(a,"v"),function(a){if(a<=l.min||a>=l.max||(a==l.min||a==l.max)&&e.outlineWidth)return;d(Math.floor(l.d2p(a))+c.lineWidth/2)})}function r(a){c.moveTo(a,0),c.lineTo(a,j)}function s(a){c.moveTo(0,a),c.lineTo(k,a)}var c=this.ctx,d=this.options,e=d.grid,f=e.verticalLines,g=e.horizontalLines,h=e.minorVerticalLines,i=e.minorHorizontalLines,j=this.plotHeight,k=this.plotWidth,l,m,n,o;(f||h||g||i)&&a.fire(this.el,"flotr:beforegrid",[this.axes.x,this.axes.y,d,this]),c.save(),c.lineWidth=1,c.strokeStyle=e.tickColor;if(e.circular){c.translate(this.plotOffset.left+k/2,this.plotOffset.top+j/2);var t=Math.min(j,k)*d.radar.radiusRatio/2,u=this.axes.x.ticks.length,v=2*(Math.PI/u),w=-Math.PI/2;c.beginPath(),l=this.axes.y,g&&p(l.ticks),i&&p(l.minorTicks),f&&b.times(u,function(a){c.moveTo(0,0),c.lineTo(Math.cos(a*v+w)*t,Math.sin(a*v+w)*t)}),c.stroke()}else c.translate(this.plotOffset.left,this.plotOffset.top),e.backgroundColor&&(c.fillStyle=this.processColor(e.backgroundColor,{x1:0,y1:0,x2:k,y2:j}),c.fillRect(0,0,k,j)),c.beginPath(),l=this.axes.x,f&&q(l.ticks,r),h&&q(l.minorTicks,r),l=this.axes.y,g&&q(l.ticks,s),i&&q(l.minorTicks,s),c.stroke();c.restore(),(f||h||g||i)&&a.fire(this.el,"flotr:aftergrid",[this.axes.x,this.axes.y,d,this])},drawOutline:function(){var a=this,b=a.options,c=b.grid,d=c.outline,e=a.ctx,f=c.backgroundImage,g=a.plotOffset,h=g.left,j=g.top,k=a.plotWidth,l=a.plotHeight,m,n,o,p,q,r;if(!c.outlineWidth)return;e.save();if(c.circular){e.translate(h+k/2,j+l/2);var s=Math.min(l,k)*b.radar.radiusRatio/2,t=this.axes.x.ticks.length,u=2*(Math.PI/t),v=-Math.PI/2;e.beginPath(),e.lineWidth=c.outlineWidth,e.strokeStyle=c.color,e.lineJoin="round";for(i=0;i<=t;++i)e[i===0?"moveTo":"lineTo"](Math.cos(i*u+v)*s,Math.sin(i*u+v)*s);e.stroke()}else{e.translate(h,j);var w=c.outlineWidth,x=.5-w+(w+1)%2/2,y="lineTo",z="moveTo";e.lineWidth=w,e.strokeStyle=c.color,e.lineJoin="miter",e.beginPath(),e.moveTo(x,x),k-=w/2%1,l+=w/2,e[d.indexOf("n")!==-1?y:z](k,x),e[d.indexOf("e")!==-1?y:z](k,l),e[d.indexOf("s")!==-1?y:z](x,l),e[d.indexOf("w")!==-1?y:z](x,x),e.stroke(),e.closePath()}e.restore(),f&&(o=f.src||f,p=(parseInt(f.left,10)||0)+g.left,q=(parseInt(f.top,10)||0)+g.top,n=new Image,n.onload=function(){e.save(),f.alpha&&(e.globalAlpha=f.alpha),e.globalCompositeOperation="destination-over",e.drawImage(n,0,0,n.width,n.height,p,q,k,l),e.restore()},n.src=o)}})}(),function(){var a=Flotr.DOM,b=Flotr._,c=Flotr,d="opacity:0.7;background-color:#000;color:#fff;position:absolute;padding:2px 8px;-moz-border-radius:4px;border-radius:4px;white-space:nowrap;";Flotr.addPlugin("hit",{callbacks:{"flotr:mousemove":function(a,b){this.hit.track(b)},"flotr:click":function(a){var c=this.hit.track(a);c&&!b.isUndefined(c.index)&&(a.hit=c)},"flotr:mouseout":function(a){a.relatedTarget!==this.mouseTrack&&this.hit.clearHit()},"flotr:destroy":function(){this.options.mouse.container&&a.remove(this.mouseTrack),this.mouseTrack=null}},track:function(a){if(this.options.mouse.track||b.any(this.series,function(a){return a.mouse&&a.mouse.track}))return this.hit.hit(a)},executeOnType:function(a,d,e){function h(a,h){b.each(b.keys(c.graphTypes),function(b){a[b]&&a[b].show&&!a.hide&&this[b][d]&&(g=this.getOptions(a,b),g.fill=!!a.mouse.fillColor,g.fillStyle=this.processColor(a.mouse.fillColor||"#ffffff",{opacity:a.mouse.fillOpacity}),g.color=a.mouse.lineColor,g.context=this.octx,g.index=h,e&&(g.args=e),this[b][d].call(this[b],g),f=!0)},this)}var f=!1,g;return b.isArray(a)||(a=[a]),b.each(a,h,this),f},drawHit:function(a){var b=this.octx,c=a.series;if(c.mouse.lineColor){b.save(),b.lineWidth=c.points?c.points.lineWidth:1,b.strokeStyle=c.mouse.lineColor,b.fillStyle=this.processColor(c.mouse.fillColor||"#ffffff",{opacity:c.mouse.fillOpacity}),b.translate(this.plotOffset.left,this.plotOffset.top);if(!this.hit.executeOnType(c,"drawHit",a)){var d=a.xaxis,e=a.yaxis;b.beginPath(),b.arc(d.d2p(a.x),e.d2p(a.y),c.points.hitRadius||c.points.radius||c.mouse.radius,0,2*Math.PI,!0),b.fill(),b.stroke(),b.closePath()}b.restore(),this.clip(b)}this.prevHit=a},clearHit:function(){var b=this.prevHit,c=this.octx,d=this.plotOffset;c.save(),c.translate(d.left,d.top);if(b){if(!this.hit.executeOnType(b.series,"clearHit",this.prevHit)){var e=b.series,f=e.points?e.points.lineWidth:1;offset=(e.points.hitRadius||e.points.radius||e.mouse.radius)+f,c.clearRect(b.xaxis.d2p(b.x)-offset,b.yaxis.d2p(b.y)-offset,offset*2,offset*2)}a.hide(this.mouseTrack),this.prevHit=null}c.restore()},hit:function(a){var c=this.options,d=this.prevHit,e,f,g,h,i,j,k,l,m;if(this.series.length===0)return;m={relX:a.relX,relY:a.relY,absX:a.absX,absY:a.absY,series:this.series};if(c.mouse.trackY&&!c.mouse.trackAll&&this.hit.executeOnType(this.series,"hit",[a,m])&&!b.isUndefined(m.seriesIndex))i=this.series[m.seriesIndex],m.series=i,m.mouse=i.mouse,m.xaxis=i.xaxis,m.yaxis=i.yaxis;else{e=this.hit.closest(a);if(e){e=c.mouse.trackY?e.point:e.x,h=e.seriesIndex,i=this.series[h],k=i.xaxis,l=i.yaxis,f=2*i.mouse.sensibility;if(c.mouse.trackAll||e.distanceX<f/k.scale&&(!c.mouse.trackY||e.distanceY<f/l.scale))m.series=i,m.xaxis=i.xaxis,m.yaxis=i.yaxis,m.mouse=i.mouse,m.x=e.x,m.y=e.y,m.dist=e.distance,m.index=e.dataIndex,m.seriesIndex=h}}if(!d||d.index!==m.index||d.seriesIndex!==m.seriesIndex)this.hit.clearHit(),m.series&&m.mouse&&m.mouse.track&&(this.hit.drawMouseTrack(m),this.hit.drawHit(m),Flotr.EventAdapter.fire(this.el,"flotr:hit",[m,this]));return m},closest:function(a){function v(a){a.distance=m,a.distanceX=n,a.distanceY=o,a.seriesIndex=t,a.dataIndex=u,a.x=r,a.y=s,j=!0}var b=this.series,c=this.options,d=a.relX,e=a.relY,f=Number.MAX_VALUE,g=Number.MAX_VALUE,h={},i={},j=!1,k,l,m,n,o,p,q,r,s,t,u;for(t=0;t<b.length;t++){k=b[t],l=k.data,p=k.xaxis.p2d(d),q=k.yaxis.p2d(e);if(k.hide)continue;for(u=l.length;u--;){r=l[u][0],s=l[u][1];if(r===null||s===null)continue;if(r<k.xaxis.min||r>k.xaxis.max)continue;n=Math.abs(r-p),o=Math.abs(s-q),m=n*n+o*o,m<f&&(f=m,v(h)),n<g&&(g=n,v(i))}}return j?{point:h,x:i}:!1},drawMouseTrack:function(c){var e="",f=c.series,g=c.mouse.position,h=c.mouse.margin,i=c.x,j=c.y,k=d,l=this.mouseTrack,m=this.plotOffset,n=m.left,o=m.right,p=m.bottom,q=m.top,r=c.mouse.trackDecimals,s=this.options,t=s.mouse.container,u=0,v=0,w,x,y;l||(l=a.node('<div class="flotr-mouse-value" style="'+k+'"></div>'),this.mouseTrack=l,a.insert(t||this.el,l));if(!r||r<0)r=0;i&&i.toFixed&&(i=i.toFixed(r)),j&&j.toFixed&&(j=j.toFixed(r)),y=c.mouse.trackFormatter({x:i,y:j,series:c.series,index:c.index,nearest:c,fraction:c.fraction});if(b.isNull(y)||b.isUndefined(y)){a.hide(l);return}l.innerHTML=y,a.show(l);if(!g)return;x=a.size(l),t&&(w=a.position(this.el),u=w.top,v=w.left);if(!c.mouse.relative)e+="top:",g.charAt(0)=="n"?e+=u+h+q:g.charAt(0)=="s"&&(e+=u-h+q+this.plotHeight-x.height),e+="px;bottom:auto;left:",g.charAt(1)=="e"?e+=v-h+n+this.plotWidth-x.width:g.charAt(1)=="w"&&(e+=v+h+n),e+="px;right:auto;";else if(f.pie&&f.pie.show){var z={x:this.plotWidth/2,y:this.plotHeight/2},A=Math.min(this.canvasWidth,this.canvasHeight)*f.pie.sizeRatio/2,B=c.sAngle<c.eAngle?(c.sAngle+c.eAngle)/2:(c.sAngle+c.eAngle+2*Math.PI)/2;e+="bottom:"+(h-q-z.y-Math.sin(B)*A/2+this.canvasHeight)+"px;top:auto;",e+="left:"+(h+n+z.x+Math.cos(B)*A/2)+"px;right:auto;"}else e+="top:",/n/.test(g)?e+=u-h+q+c.yaxis.d2p(c.y)-x.height:e+=u+h+q+c.yaxis.d2p(c.y),e+="px;bottom:auto;left:",/w/.test(g)?e+=v-h+n+c.xaxis.d2p(c.x)-x.width:e+=v+h+n+c.xaxis.d2p(c.x),e+="px;right:auto;";l.style.cssText=k+e,c.mouse.relative&&(/[ew]/.test(g)?/[ns]/.test(g)||(l.style.top=u+q+c.yaxis.d2p(c.y)-a.size(l).height/2+"px"):l.style.left=v+n+c.xaxis.d2p(c.x)-a.size(l).width/2+"px")}})}(),function(){function a(a,b){return a.which?a.which===1:a.button===0||a.button===1}function b(a,b){return Math.min(Math.max(0,a),b.plotWidth-1)}function c(a,b){return Math.min(Math.max(0,a),b.plotHeight)}var d=Flotr.DOM,e=Flotr.EventAdapter,f=Flotr._;Flotr.addPlugin("selection",{options:{pinchOnly:null,mode:null,color:"#B6D9FF",fps:20},callbacks:{"flotr:mouseup":function(a){var b=this.options.selection,c=this.selection,d=this.getEventPosition(a);if(!b||!b.mode)return;c.interval&&clearInterval(c.interval),this.multitouches?c.updateSelection():b.pinchOnly||c.setSelectionPos(c.selection.second,d),c.clearSelection(),c.selecting&&c.selectionIsSane()&&(c.drawSelection(),c.fireSelectEvent(),this.ignoreClick=!0)},"flotr:mousedown":function(b){var c=this.options.selection,d=this.selection,e=this.getEventPosition(b);if(!c||!c.mode)return;if(!c.mode||!a(b)&&f.isUndefined(b.touches))return;c.pinchOnly||d.setSelectionPos(d.selection.first,e),d.interval&&clearInterval(d.interval),this.lastMousePos.pageX=null,d.selecting=!1,d.interval=setInterval(f.bind(d.updateSelection,this),1e3/c.fps)},"flotr:destroy":function(a){clearInterval(this.selection.interval)}},getArea:function(){var a=this.selection.selection,b=this.axes,c=a.first,d=a.second,e,f,g,h;return e=b.x.p2d(a.first.x),f=b.x.p2d(a.second.x),g=b.y.p2d(a.first.y),h=b.y.p2d(a.second.y),{x1:Math.min(e,f),y1:Math.min(g,h),x2:Math.max(e,f),y2:Math.max(g,h),xfirst:e,xsecond:f,yfirst:g,ysecond:h}},selection:{first:{x:-1,y:-1},second:{x:-1,y:-1}},prevSelection:null,interval:null,fireSelectEvent:function(a){var b=this.selection.getArea();a=a||"select",b.selection=this.selection.selection,e.fire(this.el,"flotr:"+a,[b,this])},setSelection:function(a,d){var e=this.options,f=this.axes.x,g=this.axes.y,h=g.scale,i=f.scale,j=e.selection.mode.indexOf("x")!=-1,k=e.selection.mode.indexOf("y")!=-1,l=this.selection.selection;this.selection.clearSelection(),l.first.y=c(j&&!k?0:(g.max-a.y1)*h,this),l.second.y=c(j&&!k?this.plotHeight-1:(g.max-a.y2)*h,this),l.first.x=b(k&&!j?0:(a.x1-f.min)*i,this),l.second.x=b(k&&!j?this.plotWidth:(a.x2-f.min)*i,this),this.selection.drawSelection(),d||this.selection.fireSelectEvent()},setSelectionPos:function(a,d){var e=this.options.selection.mode,f=this.selection.selection;e.indexOf("x")==-1?a.x=a==f.first?0:this.plotWidth:a.x=b(d.relX,this),e.indexOf("y")==-1?a.y=a==f.first?0:this.plotHeight-1:a.y=c(d.relY,this)},drawSelection:function(){this.selection.fireSelectEvent("selecting");var a=this.selection.selection,b=this.octx,c=this.options,d=this.plotOffset,e=this.selection.prevSelection;if(e&&a.first.x==e.first.x&&a.first.y==e.first.y&&a.second.x==e.second.x&&a.second.y==e.second.y)return;b.save(),b.strokeStyle=this.processColor(c.selection.color,{opacity:.8}),b.lineWidth=1,b.lineJoin="miter",b.fillStyle=this.processColor(c.selection.color,{opacity:.4}),this.selection.prevSelection={first:{x:a.first.x,y:a.first.y},second:{x:a.second.x,y:a.second.y}};var f=Math.min(a.first.x,a.second.x),g=Math.min(a.first.y,a.second.y),h=Math.abs(a.second.x-a.first.x),i=Math.abs(a.second.y-a.first.y);b.fillRect(f+d.left+.5,g+d.top+.5,h,i),b.strokeRect(f+d.left+.5,g+d.top+.5,h,i),b.restore()},updateSelection:function(){if(!this.lastMousePos.pageX)return;this.selection.selecting=!0;if(this.multitouches)this.selection.setSelectionPos(this.selection.selection.first,this.getEventPosition(this.multitouches[0])),this.selection.setSelectionPos(this.selection.selection.second,this.getEventPosition(this.multitouches[1]));else{if(this.options.selection.pinchOnly)return;this.selection.setSelectionPos(this.selection.selection.second,this.lastMousePos)}this.selection.clearSelection(),this.selection.selectionIsSane()&&this.selection.drawSelection()},clearSelection:function(){if(!this.selection.prevSelection)return;var a=this.selection.prevSelection,b=1,c=this.plotOffset,d=Math.min(a.first.x,a.second.x),e=Math.min(a.first.y,a.second.y),f=Math.abs(a.second.x-a.first.x),g=Math.abs(a.second.y-a.first.y);this.octx.clearRect(d+c.left-b+.5,e+c.top-b,f+2*b+.5,g+2*b+.5),this.selection.prevSelection=null},selectionIsSane:function(){var a=this.selection.selection;return Math.abs(a.second.x-a.first.x)>=5||Math.abs(a.second.y-a.first.y)>=5}})}(),function(){var a=Flotr.DOM;Flotr.addPlugin("labels",{callbacks:{"flotr:afterdraw":function(){this.labels.draw()}},draw:function(){function s(a,b,d){var e=d?b.minorTicks:b.ticks,f=b.orientation===1,h=b.n===1,k,m;k={color:b.options.color||o.grid.color,angle:Flotr.toRad(b.options.labelsAngle),textBaseline:"middle"};for(l=0;l<e.length&&(d?b.options.showMinorLabels:b.options.showLabels);++l){c=e[l],c.label+="";if(!c.label||!c.label.length)continue;x=Math.cos(l*i+j)*g,y=Math.sin(l*i+j)*g,k.textAlign=f?Math.abs(x)<.1?"center":x<0?"right":"left":"left",Flotr.drawText(p,c.label,f?x:3,f?y:-(b.ticks[l].v/b.max)*(g-o.fontSize),k)}}function t(a,b,d,e){function j(a){return a.options.showLabels&&a.used}function k(a,b,c,d){return a.plotOffset.left+(b?d:c?-o.grid.labelMargin:o.grid.labelMargin+a.plotWidth)}function m(a,b,c,d){return a.plotOffset.top+(b?o.grid.labelMargin:d)+(b&&c?a.plotHeight:0)}var f=b.orientation===1,g=b.n===1,h,i;h={color:b.options.color||o.grid.color,textAlign:d,textBaseline:e,angle:Flotr.toRad(b.options.labelsAngle)},h=Flotr.getBestTextAlign(h.angle,h);for(l=0;l<b.ticks.length&&j(b);++l){c=b.ticks[l];if(!c.label||!c.label.length)continue;i=b.d2p(c.v);if(i<0||i>(f?a.plotWidth:a.plotHeight))continue;Flotr.drawText(p,c.label,k(a,f,g,i),m(a,f,g,i),h),!f&&!g&&(p.save(),p.strokeStyle=h.color,p.beginPath(),p.moveTo(a.plotOffset.left+a.plotWidth-8,a.plotOffset.top+b.d2p(c.v)),p.lineTo(a.plotOffset.left+a.plotWidth,a.plotOffset.top+b.d2p(c.v)),p.stroke(),p.restore())}}function u(a,b){var d=b.orientation===1,e=b.n===1,g="",h,i,j,k=a.plotOffset;!d&&!e&&(p.save(),p.strokeStyle=b.options.color||o.grid.color,p.beginPath());if(b.options.showLabels&&(e?!0:b.used))for(l=0;l<b.ticks.length;++l){c=b.ticks[l];if(!c.label||!c.label.length||(d?k.left:k.top)+b.d2p(c.v)<0||(d?k.left:k.top)+b.d2p(c.v)>(d?a.canvasWidth:a.canvasHeight))continue;j=k.top+(d?(e?1:-1)*(a.plotHeight+o.grid.labelMargin):b.d2p(c.v)-b.maxLabel.height/2),h=d?k.left+b.d2p(c.v)-f/2:0,g="",l===0?g=" first":l===b.ticks.length-1&&(g=" last"),g+=d?" flotr-grid-label-x":" flotr-grid-label-y",m+=['<div style="position:absolute; text-align:'+(d?"center":"right")+"; ","top:"+j+"px; ",(!d&&!e?"right:":"left:")+h+"px; ","width:"+(d?f:(e?k.left:k.right)-o.grid.labelMargin)+"px; ",b.options.color?"color:"+b.options.color+"; ":" ",'" class="flotr-grid-label'+g+'">'+c.label+"</div>"].join(" "),!d&&!e&&(p.moveTo(k.left+a.plotWidth-8,k.top+b.d2p(c.v)),p.lineTo(k.left+a.plotWidth,k.top+b.d2p(c.v)))}}var b,c,d,e,f,g,h,i,j,k,l,m="",n=0,o=this.options,p=this.ctx,q=this.axes,r={size:o.fontSize};for(l=0;l<q.x.ticks.length;++l)q.x.ticks[l].label&&++n;f=this.plotWidth/n,o.grid.circular&&(p.save(),p.translate(this.plotOffset.left+this.plotWidth/2,this.plotOffset.top+this.plotHeight/2),g=this.plotHeight*o.radar.radiusRatio/2+o.fontSize,h=this.axes.x.ticks.length,i=2*(Math.PI/h),j=-Math.PI/2,s(this,q.x,!1),s(this,q.x,!0),s(this,q.y,!1),s(this,q.y,!0),p.restore()),!o.HtmlText&&this.textEnabled?(t(this,q.x,"center","top"),t(this,q.x2,"center","bottom"),t(this,q.y,"right","middle"),t(this,q.y2,"left","middle")):(q.x.options.showLabels||q.x2.options.showLabels||q.y.options.showLabels||q.y2.options.showLabels)&&!o.grid.circular&&(m="",u(this,q.x),u(this,q.x2),u(this,q.y),u(this,q.y2),p.stroke(),p.restore(),k=a.create("div"),a.setStyles(k,{fontSize:"smaller",color:o.grid.color}),k.className="flotr-labels",a.insert(this.el,k),a.insert(k,m))}})}(),function(){var a=Flotr.DOM,b=Flotr._;Flotr.addPlugin("legend",{options:{show:!0,noColumns:1,labelFormatter:function(a){return a},labelBoxBorderColor:"#CCCCCC",labelBoxWidth:14,labelBoxHeight:10,labelBoxMargin:5,container:null,position:"nw",margin:5,backgroundColor:"#F0F0F0",backgroundOpacity:.85},callbacks:{"flotr:afterinit":function(){this.legend.insertLegend()},"flotr:destroy":function(){var b=this.legend.markup;b&&(this.legend.markup=null,a.remove(b))}},insertLegend:function(){if(!this.options.legend.show)return;var c=this.series,d=this.plotOffset,e=this.options,f=e.legend,g=[],h=!1,i=this.ctx,j=b.filter(c,function(a){return a.label&&!a.hide}).length,k=f.position,l=f.margin,m=f.backgroundOpacity,n,o,p;if(j){var q=f.labelBoxWidth,r=f.labelBoxHeight,s=f.labelBoxMargin,t=d.left+l,u=d.top+l,v=0,w={size:e.fontSize*1.1,color:e.grid.color};for(n=c.length-1;n>-1;--n){if(!c[n].label||c[n].hide)continue;o=f.labelFormatter(c[n].label),v=Math.max(v,this._text.measureText(o,w).width)}var x=Math.round(q+s*3+v),y=Math.round(j*(s+r)+s);!m&&m!==0&&(m=.1);if(!e.HtmlText&&this.textEnabled&&!f.container){k.charAt(0)=="s"&&(u=d.top+this.plotHeight-(l+y)),k.charAt(0)=="c"&&(u=d.top+this.plotHeight/2-(l+y/2)),k.charAt(1)=="e"&&(t=d.left+this.plotWidth-(l+x)),p=this.processColor(f.backgroundColor,{opacity:m}),i.fillStyle=p,i.fillRect(t,u,x,y),i.strokeStyle=f.labelBoxBorderColor,i.strokeRect(Flotr.toPixel(t),Flotr.toPixel(u),x,y);var z=t+s,A=u+s;for(n=0;n<c.length;n++){if(!c[n].label||c[n].hide)continue;o=f.labelFormatter(c[n].label),i.fillStyle=c[n].color,i.fillRect(z,A,q-1,r-1),i.strokeStyle=f.labelBoxBorderColor,i.lineWidth=1,i.strokeRect(Math.ceil(z)-1.5,Math.ceil(A)-1.5,q+2,r+2),Flotr.drawText(i,o,z+q+s,A+r,w),A+=r+s}}else{for(n=0;n<c.length;++n){if(!c[n].label||c[n].hide)continue;n%f.noColumns===0&&(g.push(h?"</tr><tr>":"<tr>"),h=!0);var B=c[n],C=f.labelBoxWidth,E=f.labelBoxHeight;o=f.labelFormatter(B.label),p="background-color:"+(B.bars&&B.bars.show&&B.bars.fillColor&&B.bars.fill?B.bars.fillColor:B.color)+";",g.push('<td class="flotr-legend-color-box">','<div style="border:1px solid ',f.labelBoxBorderColor,';padding:1px">','<div style="width:',C-1,"px;height:",E-1,"px;border:1px solid ",c[n].color,'">','<div style="width:',C,"px;height:",E,"px;",p,'"></div>',"</div>","</div>","</td>",'<td class="flotr-legend-label">',o,"</td>")}h&&g.push("</tr>");if(g.length>0){var F='<table style="font-size:smaller;color:'+e.grid.color+'">'+g.join("")+"</table>";if(f.container)F=a.node(F),this.legend.markup=F,a.insert(f.container,F);else{var G={position:"absolute",zIndex:"2",border:"1px solid "+f.labelBoxBorderColor};k.charAt(0)=="n"?(G.top=l+d.top+"px",G.bottom="auto"):k.charAt(0)=="c"?(G.top=l+(this.plotHeight-y)/2+"px",G.bottom="auto"):k.charAt(0)=="s"&&(G.bottom=l+d.bottom+"px",G.top="auto"),k.charAt(1)=="e"?(G.right=l+d.right+"px",G.left="auto"):k.charAt(1)=="w"&&(G.left=l+d.left+"px",G.right="auto");var H=a.create("div"),I;H.className="flotr-legend",a.setStyles(H,G),a.insert(H,F),a.insert(this.el,H);if(!m)return;var J=f.backgroundColor||e.grid.backgroundColor||"#ffffff";b.extend(G,a.size(H),{backgroundColor:J,zIndex:"",border:""}),G.width+="px",G.height+="px",H=a.create("div"),H.className="flotr-legend-bg",a.setStyles(H,G),a.opacity(H,m),a.insert(H," "),a.insert(this.el,H)}}}}}})}(),function(){function a(a){if(this.options.spreadsheet.tickFormatter)return this.options.spreadsheet.tickFormatter(a);var b=c.find(this.axes.x.ticks,function(b){return b.v==a});return b?b.label:a}var b=Flotr.DOM,c=Flotr._;Flotr.addPlugin("spreadsheet",{options:{show:!1,tabGraphLabel:"Graph",tabDataLabel:"Data",toolbarDownload:"Download CSV",toolbarSelectAll:"Select all",csvFileSeparator:",",decimalSeparator:".",tickFormatter:null,initialTab:"graph"},callbacks:{"flotr:afterconstruct":function(){if(!this.options.spreadsheet.show)return;var a=this.spreadsheet,c=b.node('<div class="flotr-tabs-group" style="position:absolute;left:0px;width:'+this.canvasWidth+'px"></div>'),d=b.node('<div style="float:left" class="flotr-tab selected">'+this.options.spreadsheet.tabGraphLabel+"</div>"),e=b.node('<div style="float:left" class="flotr-tab">'+this.options.spreadsheet.tabDataLabel+"</div>"),f;a.tabsContainer=c,a.tabs={graph:d,data:e},b.insert(c,d),b.insert(c,e),b.insert(this.el,c),f=b.size(e).height+2,this.plotOffset.bottom+=f,b.setStyles(c,{top:this.canvasHeight-f+"px"}),this.observe(d,"click",function(){a.showTab("graph")}).observe(e,"click",function(){a.showTab("data")}),this.options.spreadsheet.initialTab!=="graph"&&a.showTab(this.options.spreadsheet.initialTab)}},loadDataGrid:function(){if(this.seriesData)return this.seriesData;var a=this.series,b={};return c.each(a,function(a,d){c.each(a.data,function(a){var c=a[0],e=a[1],f=b[c];if(f)f[d+1]=e;else{var g=[];g[0]=c,g[d+1]=e,b[c]=g}})}),this.seriesData=c.sortBy(b,function(a,b){return parseInt(b,10)}),this.seriesData},constructDataGrid:function(){if(this.spreadsheet.datagrid)return this.spreadsheet.datagrid;var d=this.series,e=this.spreadsheet.loadDataGrid(),f=["<colgroup><col />"],g,h,i,j=['<table class="flotr-datagrid"><tr class="first-row">'];j.push("<th>&nbsp;</th>"),c.each(d,function(a,b){j.push('<th scope="col">'+(a.label||String.fromCharCode(65+b))+"</th>"),f.push("<col />")}),j.push("</tr>"),c.each(e,function(b){j.push("<tr>"),c.times(d.length+1,function(d){var e="td",f=b[d],g=c.isUndefined(f)?"":Math.round(f*1e5)/1e5;if(d===0){e="th";var h=a.call(this,g);h&&(g=h)}j.push("<"+e+(e=="th"?' scope="row"':"")+">"+g+"</"+e+">")},this),j.push("</tr>")},this),f.push("</colgroup>"),i=b.node(j.join("")),g=b.node('<button type="button" class="flotr-datagrid-toolbar-button">'+this.options.spreadsheet.toolbarDownload+"</button>"),h=b.node('<button type="button" class="flotr-datagrid-toolbar-button">'+this.options.spreadsheet.toolbarSelectAll+"</button>"),this.observe(g,"click",c.bind(this.spreadsheet.downloadCSV,this)).observe(h,"click",c.bind(this.spreadsheet.selectAllData,this));var k=b.node('<div class="flotr-datagrid-toolbar"></div>');b.insert(k,g),b.insert(k,h);var l=this.canvasHeight-b.size(this.spreadsheet.tabsContainer).height-2,m=b.node('<div class="flotr-datagrid-container" style="position:absolute;left:0px;top:0px;width:'+this.canvasWidth+"px;height:"+l+'px;overflow:auto;z-index:10"></div>');return b.insert(m,k),b.insert(m,i),b.insert(this.el,m),this.spreadsheet.datagrid=i,this.spreadsheet.container=m,i},showTab:function(a){if(this.spreadsheet.activeTab===a)return;switch(a){case"graph":b.hide(this.spreadsheet.container),b.removeClass(this.spreadsheet.tabs.data,"selected"),b.addClass(this.spreadsheet.tabs.graph,"selected");break;case"data":this.spreadsheet.datagrid||this.spreadsheet.constructDataGrid(),b.show(this.spreadsheet.container),b.addClass(this.spreadsheet.tabs.data,"selected"),b.removeClass(this.spreadsheet.tabs.graph,"selected");break;default:throw"Illegal tab name: "+a}this.spreadsheet.activeTab=a},selectAllData:function(){if(this.spreadsheet.tabs){var a,b,c,d,e=this.spreadsheet.constructDataGrid();return this.spreadsheet.showTab("data"),setTimeout(function(){(c=e.ownerDocument)&&(d=c.defaultView)&&d.getSelection&&c.createRange&&(a=window.getSelection())&&a.removeAllRanges?(b=c.createRange(),b.selectNode(e),a.removeAllRanges(),a.addRange(b)):document.body&&document.body.createTextRange&&(b=document.body.createTextRange())&&(b.moveToElementText(e),b.select())},0),!0}return!1},downloadCSV:function(){var b="",d=this.series,e=this.options,f=this.spreadsheet.loadDataGrid(),g=encodeURIComponent(e.spreadsheet.csvFileSeparator);if(e.spreadsheet.decimalSeparator===e.spreadsheet.csvFileSeparator)throw"The decimal separator is the same as the column separator ("+e.spreadsheet.decimalSeparator+")";c.each(d,function(a,c){b+=g+'"'+(a.label||String.fromCharCode(65+c)).replace(/\"/g,'\\"')+'"'}),b+="%0D%0A",b+=c.reduce(f,function(b,c){var d=a.call(this,c[0])||"";d='"'+(d+"").replace(/\"/g,'\\"')+'"';var f=c.slice(1).join(g);return e.spreadsheet.decimalSeparator!=="."&&(f=f.replace(/\./g,e.spreadsheet.decimalSeparator)),b+d+g+f+"%0D%0A"},"",this),Flotr.isIE&&Flotr.isIE<9?(b=b.replace(new RegExp(g,"g"),decodeURIComponent(g)).replace(/%0A/g,"\n").replace(/%0D/g,"\r"),window.open().document.write(b)):window.open("data:text/csv,"+b)}})}(),function(){var a=Flotr.DOM;Flotr.addPlugin("titles",{callbacks:{"flotr:afterdraw":function(){this.titles.drawTitles()}},drawTitles:function(){var b,c=this.options,d=c.grid.labelMargin,e=this.ctx,f=this.axes;if(!c.HtmlText&&this.textEnabled){var g={size:c.fontSize,color:c.grid.color,textAlign:"center"};c.subtitle&&Flotr.drawText(e,c.subtitle,this.plotOffset.left+this.plotWidth/2,this.titleHeight+this.subtitleHeight-2,g),g.weight=1.5,g.size*=1.5,c.title&&Flotr.drawText(e,c.title,this.plotOffset.left+this.plotWidth/2,this.titleHeight-2,g),g.weight=1.8,g.size*=.8,f.x.options.title&&f.x.used&&(g.textAlign=f.x.options.titleAlign||"center",g.textBaseline="top",g.angle=Flotr.toRad(f.x.options.titleAngle),g=Flotr.getBestTextAlign(g.angle,g),Flotr.drawText(e,f.x.options.title,this.plotOffset.left+this.plotWidth/2,this.plotOffset.top+f.x.maxLabel.height+this.plotHeight+2*d,g)),f.x2.options.title&&f.x2.used&&(g.textAlign=f.x2.options.titleAlign||"center",g.textBaseline="bottom",g.angle=Flotr.toRad(f.x2.options.titleAngle),g=Flotr.getBestTextAlign(g.angle,g),Flotr.drawText(e,f.x2.options.title,this.plotOffset.left+this.plotWidth/2,this.plotOffset.top-f.x2.maxLabel.height-2*d,g)),f.y.options.title&&f.y.used&&(g.textAlign=f.y.options.titleAlign||"right",g.textBaseline="middle",g.angle=Flotr.toRad(f.y.options.titleAngle),g=Flotr.getBestTextAlign(g.angle,g),Flotr.drawText(e,f.y.options.title,this.plotOffset.left-f.y.maxLabel.width-2*d,this.plotOffset.top+this.plotHeight/2,g)),f.y2.options.title&&f.y2.used&&(g.textAlign=f.y2.options.titleAlign||"left",g.textBaseline="middle",g.angle=Flotr.toRad(f.y2.options.titleAngle),g=Flotr.getBestTextAlign(g.angle,g),Flotr.drawText(e,f.y2.options.title,this.plotOffset.left+this.plotWidth+f.y2.maxLabel.width+2*d,this.plotOffset.top+this.plotHeight/2,g))}else{b=[],c.title&&b.push('<div style="position:absolute;top:0;left:',this.plotOffset.left,"px;font-size:1em;font-weight:bold;text-align:center;width:",this.plotWidth,'px;" class="flotr-title">',c.title,"</div>"),c.subtitle&&b.push('<div style="position:absolute;top:',this.titleHeight,"px;left:",this.plotOffset.left,"px;font-size:smaller;text-align:center;width:",this.plotWidth,'px;" class="flotr-subtitle">',c.subtitle,"</div>"),b.push("</div>"),b.push('<div class="flotr-axis-title" style="font-weight:bold;">'),f.x.options.title&&f.x.used&&b.push('<div style="position:absolute;top:',this.plotOffset.top+this.plotHeight+c.grid.labelMargin+f.x.titleSize.height,"px;left:",this.plotOffset.left,"px;width:",this.plotWidth,"px;text-align:",f.x.options.titleAlign,';" class="flotr-axis-title flotr-axis-title-x1">',f.x.options.title,"</div>"),f.x2.options.title&&f.x2.used&&b.push('<div style="position:absolute;top:0;left:',this.plotOffset.left,"px;width:",this.plotWidth,"px;text-align:",f.x2.options.titleAlign,';" class="flotr-axis-title flotr-axis-title-x2">',f.x2.options.title,"</div>"),f.y.options.title&&f.y.used&&b.push('<div style="position:absolute;top:',this.plotOffset.top+this.plotHeight/2-f.y.titleSize.height/2,"px;left:0;text-align:",f.y.options.titleAlign,';" class="flotr-axis-title flotr-axis-title-y1">',f.y.options.title,"</div>"),f.y2.options.title&&f.y2.used&&b.push('<div style="position:absolute;top:',this.plotOffset.top+this.plotHeight/2-f.y.titleSize.height/2,"px;right:0;text-align:",f.y2.options.titleAlign,';" class="flotr-axis-title flotr-axis-title-y2">',f.y2.options.title,"</div>"),b=b.join("");var h=a.create("div");a.setStyles({color:c.grid.color}),h.className="flotr-titles",a.insert(this.el,h),a.insert(h,b)}}})}();
/******************************************************************************* 
* Copyright 2012, 2013 CNES - CENTRE NATIONAL d'ETUDES SPATIALES 
* 
* This file is part of SITools2. 
* 
* SITools2 is free software: you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by 
* the Free Software Foundation, either version 3 of the License, or 
* (at your option) any later version. 
* 
* SITools2 is distributed in the hope that it will be useful, 
* but WITHOUT ANY WARRANTY; without even the implied warranty of 
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
* GNU General Public License for more details. 
* 
* You should have received a copy of the GNU General Public License 
* along with SITools2. If not, see <http://www.gnu.org/licenses/>. 
******************************************************************************/ 

/**
 * Histogram module : create histogram to the given image
 */
Histogram = {
        init : function (options) {


         // Private variables
         var nbBins;

         var hist = [];
         var hmax; // histogram max to scale in image space

         // Origin histogram point
         var originX = 5.;
         var originY;
         var hwidth;
         var paddingBottom = 15.;

         /**
          *  Get mouse position on canvas
          */
         function _getMousePos(canvas, evt) {
         var rect = canvas.getBoundingClientRect();
             return {
                 x: evt.clientX - rect.left,
                 y: evt.clientY - rect.top
             };
         }

         /**
          *  Isoscele triangle object for thresholds manipulation
          *  
          *  @param a Pointer of threshold pointing on histogram
          *  @param b Isoscele point 1
          *  @param c Isoscele point 2
          */
         var Triangle = function(a,b,c)
         {
             this.initA = a.slice(0);
             this.initB = b.slice(0);
             this.initC = c.slice(0);

             this.a = a; // Pointer to histogram
             this.b = b; // Isoscele point 1
             this.c = c; // Isoscele point 2

             this.dragging = false;
             this.hover = false;
             this.halfWidth = Math.abs( (c[0] - b[0])/2 );
         }

         /**
          *  Reset to initial position
          */
         Triangle.prototype.reset = function()
         {
             this.a = this.initA.slice(0);
             this.b = this.initB.slice(0);
             this.c = this.initC.slice(0);
         }

         /**
          *  Test if triangle contains the given point
          */
         Triangle.prototype.contains = function(p)
         {
             return _pointInTriangle(p,this.a,this.b,this.c);
         }

         /**
          *  Draw the triangle
          */
         Triangle.prototype.draw = function(ctx)
         {
             if ( this.dragging )
             {
//                 ctx.fillStyle = "#FF0";
                 ctx.fillStyle = "#FF8F00";
             }
             else
             {
//                 ctx.fillStyle = "#F00"; 
                 ctx.fillStyle = "#FF8F00";
             }

             ctx.beginPath();
             ctx.moveTo(this.a[0],this.a[1]);
             ctx.lineTo(this.b[0],this.b[1]);
             ctx.lineTo(this.c[0],this.c[1]);
             ctx.closePath();
             ctx.fill();

             if ( !this.dragging && this.hover )
             {
//                 ctx.strokeStyle = "#FF0";
                 ctx.strokeStyle = "#FF9B2D";
                 ctx.stroke();
             }
         }

         /**
          *  Modify triangle's position by the given "pointer" point
          *  (could be modified only by X-axis)
          */
         Triangle.prototype.modifyPosition = function(point)
         {
             this.a[0] = point[0];
             this.b[0] = point[0]-this.halfWidth;
             this.c[0] = point[0]+this.halfWidth;
         }

         /**************************************************************************************************************/

         /**
          *  Test returning true if p1 and p2 are both lying on the same side of a-b, false otherwise
          */
         function _sameSide(p1,p2,a,b)
         {
             var temp1 = [];
             var temp2 = [];
             var temp3 = [];
             var cp1 = [];
             var cp2 = [];
             this.vec3().cross( this.vec3().subtract(b,a, temp1), this.vec3().subtract(p1,a,temp2), cp1 );
             this.vec3().cross( temp1, this.vec3().subtract(p2,a,temp3), cp2 );
             if ( this.vec3().dot( cp1,cp2 ) >= 0 )
             {
                 return true;
             }
             else
             {
                 return false;
             }
         }

         /**
          *  Private function to check if point is inside the given triangle
          *  If the point was on the same side of a-b as c and is also on the same side of b-c as a and on the same side of c-a as b, then it is in the triangle
          */
         function _pointInTriangle(p,a,b,c)
         {
             if ( _sameSide(p,a,b,c) && _sameSide(p,b,a,c) && _sameSide(p,c,a,b) )
             {
                 return true;
             }
             else
             {
                 return false;
             }
         }

         /**
          *  TODO: split on HistogramView and Histogram
          *  Histogram contructor
          *  @param options Histogram options
          *      <ul>
          *          <li>image: The image which is represented by current histogram(required)</li>
          *          <li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
          *          <li>onUpdate: On update callback
          *          <li>accuracy: The accuracy of histogram(numbers after floating point)
          *      </ul>
          */
//         var Histogram = function(options)
         
             this.jsFits = options.jsFits;
             this.viewer = options.viewer;
             this.vec3 = options.vec3;
             
             nbBins = options.nbBins || 256;
             this.image = options.image;
             this.onUpdate = options.onUpdate;
             this.accuracy = options.accuracy || 6;

             // Init canvas
             var canvas = document.getElementById(options.canvas);
             this.ctx = canvas.getContext('2d');

             // Init origins
             originY = canvas.height - paddingBottom;
             hwidth = nbBins + originX > canvas.width ? canvas.width : nbBins + originX; // clamp to canvas.width
             var triangleHalfWidth = 5;
             this.minThreshold = new Triangle(
                                         [originX,originY+1,0],
                                         [originX-triangleHalfWidth,originY+paddingBottom-1,0],
                                         [originX+triangleHalfWidth,originY+paddingBottom-1,0]
                                 );
             this.maxThreshold = new Triangle(
                                         [hwidth,originY+1, 0],
                                         [hwidth-triangleHalfWidth,originY+paddingBottom-1, 0],
                                         [hwidth+triangleHalfWidth,originY+paddingBottom-1, 0]
                                 );


             // Show bin pointed by mouse
             var self = this;
             canvas.addEventListener('mousemove', function(evt) {
                 var mousePos = _getMousePos(canvas, evt);

                 self.ctx.clearRect(0., originY, canvas.width, paddingBottom);           

                 if ( self.minThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
                 {
                     self.minThreshold.hover = true;
                 }
                 else
                 {
                     self.minThreshold.hover = false;
                 }

                 if ( self.maxThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
                 {
                     self.maxThreshold.hover = true;
                 }
                 else
                 {
                     self.maxThreshold.hover = false;
                 }

                 // Draw threshold controls
                 if ( self.minThreshold.dragging && mousePos.x >= self.minThreshold.initA[0] && mousePos.x < self.maxThreshold.a[0] )
                 {
                     self.minThreshold.modifyPosition([mousePos.x, self.minThreshold.a[1]]);
                 }

                 if ( self.maxThreshold.dragging && mousePos.x <= self.maxThreshold.initA[0] && mousePos.x > self.minThreshold.a[0] )
                 {
                     self.maxThreshold.modifyPosition([mousePos.x, self.maxThreshold.a[1]]);
                 }
                 self.drawThresholdControls();

                 // Don't draw histogram values if the mouse is out of histogram canvas
                 if ( mousePos.y > canvas.height || mousePos.y < 0. || mousePos.x > originX + nbBins || mousePos.x < originX )
                 {
                     return;
                 }

                 // Draw the text indicating the histogram value on mouse position
                 self.ctx.font = '10pt Calibri';
                 self.ctx.fillStyle = '#F0F0F0';
                 self.ctx.shadowColor = '#F3F3F3';
                 self.ctx.shadowBlur = 1;
                 self.ctx.shadowOffsetX = 1;
                 self.ctx.shadowOffsetY = 1;
                 
                 var thresholdValue = self.getHistValue( [mousePos.x, mousePos.y] );
                 self.ctx.fillText(thresholdValue, canvas.width/2-15., originY+paddingBottom);
                 // Draw a tiny line indicating the mouse position on X-axis
                 self.ctx.fillRect( mousePos.x, originY, 1, 2 );
             });
             
             // Handle threshold controller selection
             canvas.addEventListener('mousedown', function(evt) {
                 var mousePos = _getMousePos(canvas, evt);

                 if ( self.minThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
                 {
                     self.minThreshold.dragging = true;
                     self.minThreshold.draw(self.ctx);
                 }

                 if ( self.maxThreshold.contains( [mousePos.x, mousePos.y, 0] ) )
                 {
                     self.maxThreshold.dragging = true;
                     self.maxThreshold.draw(self.ctx);
                 }
             });
             
             // Update histogram on mouseup
             canvas.addEventListener('mouseup', function(evt) {
                 self.minThreshold.dragging = false;
                 self.maxThreshold.dragging = false;

                 if ( self.updateThreshold )
                 {

                     this.viewer.canvasPanel.getEl().mask(i18n.get('label.loadingFits'), "x-mask-loading");

                     Ext.defer(function () {
                         var min = self.getHistValue(self.minThreshold.a);
                         var max = self.getHistValue(self.maxThreshold.a);
                         
                         self.minThreshold.reset();
                         self.maxThreshold.reset();
                         
                         self.updateThreshold(min,max);
                     }, 5, this);
                 }


             }.bind(this));

         /**
          *  Get histogram value from the given X-position on canvas
          */
             this.getHistValue = function( position )
         {
             return Math.floor((((position[0]-originX)/256.)*(this.image.tmax-this.image.tmin) + this.image.tmin)*Math.pow(10,this.accuracy))/Math.pow(10, this.accuracy);
         }

         /**
          *  Draw threshold controls(two triangles which represents min/max of current histogram)
          */
         this.drawThresholdControls = function()
         {
             this.minThreshold.draw(this.ctx);
             this.maxThreshold.draw(this.ctx);
         }

         /**
          *  Draw histogram
          */
         this.drawHistogram = function() {
//             this.ctx.fillStyle = "blue";
             this.ctx.fillStyle = "#4151C5";
             for ( var i=0; i<hist.length; i++ )
             {
                 // Scale to y-axis height
                 var rectHeight = (hist[i]/hmax)*originY;
                 this.ctx.fillRect( originX + i, originY, 1, -rectHeight );
             }
         }

         /**
          *  Draw histogram axis
          */
         this.drawAxes = function() {

             var leftY, rightX;
             leftY = 0;
             rightX = originX + hwidth;
             // Draw y axis.
             this.ctx.beginPath();
             this.ctx.moveTo(originX, leftY);
             this.ctx.lineTo(originX, originY);

             // Draw x axis.
             this.ctx.moveTo(originX, originY);
             this.ctx.lineTo(rightX, originY);

             // Define style and stroke lines.
             this.ctx.closePath();
             this.ctx.strokeStyle = "#fff";
             this.ctx.lineWidth = 2;
             this.ctx.stroke();
         }

         /**
          *  Draw transfer function(linear, log, asin, sqrt, sqr)
          */
         this.drawTransferFunction = function()
         {
             // Draw transfer functions
             // "Grey" colormap for now(luminance curve only)
//             this.ctx.fillStyle = "red";
             this.ctx.fillStyle = "#F8AD0D";
             
             for ( var i=0; i<nbBins; i++ )
             {
                 var value = i;
                 var posX = originX + value;

                 var scaledValue;
                 switch (this.image.transferFn) {
                case "linear":
                    scaledValue = (value / nbBins) * originY;
                    break;
                case "log":
                    scaledValue = Math.log(value / 10. + 1) / Math.log(nbBins / 10. + 1) * originY;
                    break;
                case "sqrt":
                    scaledValue = Math.sqrt(value / 10.) / Math.sqrt(nbBins / 10.) * originY;
                    break;
                case "sqr":
                    scaledValue = Math.pow(value, 2) / Math.pow(nbBins, 2) * originY;
                    break;
                case "asin":
                    scaledValue = Math.log(value + Math.sqrt(Math.pow(value, 2) + 1.)) / Math.log(nbBins + Math.sqrt(Math.pow(nbBins, 2) + 1.)) * originY;
                    break;
                default:
                    break;
                }

                 if ( !this.image.inverse )
                 {
                     scaledValue = originY - scaledValue;
                 }

                 this.ctx.fillRect( posX, scaledValue, 1, 1);
             }
         }

         /**
          *  Draw the histogram in canvas
          */
         this.draw = function()
         {
             this.ctx.clearRect(0,0, this.ctx.canvas.width, this.ctx.canvas.height);
             this.drawHistogram();
             this.drawTransferFunction();
             this.drawAxes();
             this.drawThresholdControls();
         }

         /**
          *  TODO : create different module
          *  Compute histogram values
          */
         this.compute = function()
         {
             
             var image = this.image;
         //  var image = this.jsFits.image;
             
             // Initialize histogram
             hist = new Array(nbBins);
             for ( var i=0; i<hist.length; i++ )
             {
                 hist[i] = 0;
             }

             // Compute histogram
             hmax = Number.MIN_VALUE;
             for ( var i=0; i<image.pixels.length; i++ )
             {
                 var val = image.pixels[i];
                 
                 // Skip NaN
                 if ( isNaN(val) )
                     continue;
                 // Take only values which belongs to the interval [tmin,tmax]
                 if ( val < image.tmin )
                     continue;
                 if ( val >= image.tmax )
                     continue;

                 // Scale to [0,255]
                 var bin = Math.floor(nbBins * (val - image.tmin)/(image.tmax - image.tmin));
                 hist[bin]++;

                 // Compute histogram max value
                 if ( hist[bin] > hmax )
                 {
                     hmax = hist[bin];
                 }
             }

             // Logarithmic scale for better layout
             for ( var i=0; i<hist.length; i++ )
             {
                 hist[i] = Math.log(1 + hist[i]);
             }
             hmax = Math.log(1 + hmax);
         },
         
         this.updateThreshold = function (min, max)
         {
             this.image.tmin = min;
             this.image.tmax = max;

             this.compute();
             this.draw();
             
             this.jsFits.update({
                 max : max,
                 min : min
             });
             
             this.viewer.min = min;
             this.viewer.max = max;
             
             this.viewer.thresoldSlider.setValue(0, min, true);
             this.viewer.thresoldSlider.setValue(1, max, true);
             
             this.viewer.canvasPanel.getEl().unmask();
         },

         /**
          *  Set image
          */
         this.setImage = function(image)
         {
             this.image = image;
         }

         return this;

        }
};
function vec3() {
    
    return {
        create : function (vec) {
            var dest = new MatrixArray(3);

            if (vec) {
                dest[0] = vec[0];
                dest[1] = vec[1];
                dest[2] = vec[2];
            } else {
                dest[0] = dest[1] = dest[2] = 0;
            }

            return dest;
        },
        createFrom : function (x, y, z) {
            var dest = new MatrixArray(3);

            dest[0] = x;
            dest[1] = y;
            dest[2] = z;

            return dest;
        },
        set : function (vec, dest) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];

            return dest;
        },
        equal : function (a, b) {
            return a === b || (
                Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON
            );
        },
        add : function (vec, vec2, dest) {
            if (!dest || vec === dest) {
                vec[0] += vec2[0];
                vec[1] += vec2[1];
                vec[2] += vec2[2];
                return vec;
            }

            dest[0] = vec[0] + vec2[0];
            dest[1] = vec[1] + vec2[1];
            dest[2] = vec[2] + vec2[2];
            return dest;
        },
        subtract : function (vec, vec2, dest) {
            if (!dest || vec === dest) {
                vec[0] -= vec2[0];
                vec[1] -= vec2[1];
                vec[2] -= vec2[2];
                return vec;
            }

            dest[0] = vec[0] - vec2[0];
            dest[1] = vec[1] - vec2[1];
            dest[2] = vec[2] - vec2[2];
            return dest;
        },
        multiply : function (vec, vec2, dest) {
            if (!dest || vec === dest) {
                vec[0] *= vec2[0];
                vec[1] *= vec2[1];
                vec[2] *= vec2[2];
                return vec;
            }

            dest[0] = vec[0] * vec2[0];
            dest[1] = vec[1] * vec2[1];
            dest[2] = vec[2] * vec2[2];
            return dest;
        },
        negate : function (vec, dest) {
            if (!dest) { dest = vec; }

            dest[0] = -vec[0];
            dest[1] = -vec[1];
            dest[2] = -vec[2];
            return dest;
        },
        scale : function (vec, val, dest) {
            if (!dest || vec === dest) {
                vec[0] *= val;
                vec[1] *= val;
                vec[2] *= val;
                return vec;
            }

            dest[0] = vec[0] * val;
            dest[1] = vec[1] * val;
            dest[2] = vec[2] * val;
            return dest;
        },
        normalize : function (vec, dest) {
            if (!dest) { dest = vec; }

            var x = vec[0], y = vec[1], z = vec[2],
                len = Math.sqrt(x * x + y * y + z * z);

            if (!len) {
                dest[0] = 0;
                dest[1] = 0;
                dest[2] = 0;
                return dest;
            } else if (len === 1) {
                dest[0] = x;
                dest[1] = y;
                dest[2] = z;
                return dest;
            }

            len = 1 / len;
            dest[0] = x * len;
            dest[1] = y * len;
            dest[2] = z * len;
            return dest;
        },
        cross : function (vec, vec2, dest) {
            if (!dest) { dest = vec; }

            var x = vec[0], y = vec[1], z = vec[2],
                x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

            dest[0] = y * z2 - z * y2;
            dest[1] = z * x2 - x * z2;
            dest[2] = x * y2 - y * x2;
            return dest;
        },
        length : function (vec) {
            var x = vec[0], y = vec[1], z = vec[2];
            return Math.sqrt(x * x + y * y + z * z);
        },
        squaredLength : function (vec) {
            var x = vec[0], y = vec[1], z = vec[2];
            return x * x + y * y + z * z;
        },
        dot : function (vec, vec2) {
            return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
        },
        lerp : function (vec, vec2, lerp, dest) {
            if (!dest) { dest = vec; }

            dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
            dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
            dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

            return dest;
        },
        dist : function (vec, vec2) {
            var x = vec2[0] - vec[0],
                y = vec2[1] - vec[1],
                z = vec2[2] - vec[2];
                
            return Math.sqrt(x*x + y*y + z*z);
        },
        str : function (vec) {
            return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
        }
    };
};/***************************************
 * Copyright 2010, Aladin by the Centre de DonnÃ©es astronomiques de Strasbourg (CDS).
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

function ColorMap () {

/**************************************************************************************************************/
var transferFonctions = {
	"linear": [],
	"asin": [],
	"sqrt": [],
	"sqr": [],
	"log": []
};

var computeTransferFunctions = function() 
{

	for ( var x in transferFonctions)
	{
	    var min=Number.MAX_VALUE;
	    var max=Number.MIN_VALUE;
	    var v;
	    var val = [];
	    for( var i=0; i<256; i++ ) {
	      	v = i;
	      	switch( x ) {
	      		case "linear":
	      			val[i] = v;
	      			break;
	      		case "asin":
	      			val[i] = Math.log(v + Math.sqrt(Math.pow(v,2)+1.));
	      			break;
	      		case "log":
	      			val[i] = Math.log(v/10.+1);
	      			break;
	      		case "sqrt":
	      			val[i] = Math.sqrt(v/10.);
	      			break;
	      		case "sqr":
	      			val[i] = v*v;
	      			break;
	      		default:
	      			break;
	      	}
	      	 
	        if( val[i]<min ) min=val[i];
	        if( val[i]>max ) max=val[i];
	    }

	    // Normalize between [0..256]
	    for( i=0; i<256; i++ )
	    {
	    	v = 256 * ((val[i] - min)/(max-min));

	    	// Clamp
	        if( v>256. )
	        	v=256.;
	        else if( v<0. )
	        	v=0.;

	        transferFonctions[x][i] = Math.floor(v);
	    }
	}
}

computeTransferFunctions();

// Contstant colormaps
var colormaps = {
		// composantes de la table 'Fire' (ImageJ)
		"fire" : {
		    red: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4,7,
			   10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79,
			   82,85,88,91,94,98,101,104,107,110,113,116,119,122,125,128,131,134,137,
			   140,143,146,148,150,152,154,156,158,160,162,163,164,166,167,168,170,171,
			   173,174,175,177,178,179,181,182,184,185,186,188,189,190,192,193,195,196,
			   198,199,201,202,204,205,207,208,209,210,212,213,214,215,217,218,220,221,
			   223,224,226,227,229,230,231,233,234,235,237,238,240,241,243,244,246,247,
			   249,250,252,252,252,253,253,253,254,254,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255],

		    green: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,1,3,5,7,8,10,12,14,16,19,21,24,27,29,32,35,37,40,43,46,48,
			   51,54,57,59,62,65,68,70,73,76,79,81,84,87,90,92,95,98,101,103,105,107,
			   109,111,113,115,117,119,121,123,125,127,129,131,133,134,136,138,140,141,
			   143,145,147,148,150,152,154,155,157,159,161,162,164,166,168,169,171,173,
			   175,176,178,180,182,184,186,188,190,191,193,195,197,199,201,203,205,206,
			   208,210,212,213,215,217,219,220,222,224,226,228,230,232,234,235,237,239,
			   241,242,244,246,248,248,249,250,251,252,253,254,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255],

		    blue: [0,7,15,22,30,38,45,53,61,65,69,74,78,
			   82,87,91,96,100,104,108,113,117,121,125,130,134,138,143,147,151,156,160,
			   165,168,171,175,178,181,185,188,192,195,199,202,206,209,213,216,220,220,
			   221,222,223,224,225,226,227,224,222,220,218,216,214,212,210,206,202,199,
			   195,191,188,184,181,177,173,169,166,162,158,154,151,147,143,140,136,132,
			   129,125,122,118,114,111,107,103,100,96,93,89,85,82,78,74,71,67,64,60,56,
			   53,49,45,42,38,35,31,27,23,20,16,12,8,5,4,3,3,2,1,1,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   4,8,13,17,21,26,30,35,42,50,58,66,74,82,90,98,105,113,121,129,136,144,
			   152,160,167,175,183,191,199,207,215,223,227,231,235,239,243,247,251,255,
			   255,255,255,255,255,255,255]
		},

		// composantes de la table EOSB (IDL color table 27)
		"eosb" : {
			red: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,9,18,27,36,45,49,57,72,81,91,100,109,118,127,
			   136,131,139,163,173,182,191,200,209,218,227,213,221,255,255,255,255,255,
			   255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,255,255,
			   255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,229,255,
			   255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,
			   229,255,255,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,
			   255,229,229,255,255,255,255,255,255,255,255,229,229,255,253,251,249,247,
			   245,243,241,215,214,235,234,232,230,228,226,224,222,198,196,216,215,213,
			   211,209,207,205,203,181,179,197,196,194,192,190,188,186,184,164,162,178,
			   176,175,173,171,169,167,165,147,145,159,157,156,154,152,150,148,146,130,
			   128,140,138,137,135,133,131,129,127,113,111,121,119,117,117],

		   green: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,15,23,31,39,47,55,57,64,79,87,95,
			   103,111,119,127,135,129,136,159,167,175,183,191,199,207,215,200,207,239,
			   247,255,255,255,255,255,255,229,229,255,255,255,255,255,255,255,255,229,
			   229,255,255,255,255,255,255,255,255,229,229,255,250,246,242,238,233,229,
			   225,198,195,212,208,204,199,195,191,187,182,160,156,169,165,161,157,153,
			   148,144,140,122,118,127,125,123,121,119,116,114,112,99,97,106,104,102,
			   99,97,95,93,91,80,78,84,82,80,78,76,74,72,70,61,59,63,61,59,57,55,53,50,
			   48,42,40,42,40,38,36,33,31,29,27,22,21,21,19,16,14,12,13,8,6,3,1,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],

		   blue: [116,121,127,131,136,140,144,148,153,
			   157,145,149,170,174,178,182,187,191,195,199,183,187,212,216,221,225,229,
			   233,238,242,221,225,255,247,239,231,223,215,207,199,172,164,175,167,159,
			   151,143,135,127,119,100,93,95,87,79,71,63,55,47,39,28,21,15,7,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0]
		},

		// tableau des composantes pour Stern
		"stern" : {
	   	red: [0,18,36,54,72,90,108,127,145,163,199,217,235,
	         254,249,244,239,234,229,223,218,213,208,203,197,192,187,182,177,172,
	         161,156,151,146,140,135,130,125,120,115,109,104,99,94,89,83,78,73,68,
	         63,52,47,42,37,32,26,21,16,11,6,64,65,66,67,68,69,70,71,72,73,75,76,
	         77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,96,97,98,99,100,
	         101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,117,118,
	         119,120,121,122,123,124,125,126,128,129,130,131,132,133,134,135,136,
	         137,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,
	         155,156,157,158,160,161,162,163,164,165,166,167,168,169,170,171,172,
	         173,174,175,176,177,178,179,181,182,183,184,185,186,187,188,189,190,
	         192,193,194,195,196,197,198,199,200,201,203,204,205,206,207,208,209,
	         210,211,212,213,214,215,216,217,218,219,220,221,222,224,225,226,227,
	         228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,245,
	         246,247,248,249,250,251,252,253,254],

   		green: [0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,
	         19,20,21,22,23,24,25,26,27,28,29,30,32,33,34,35,36,37,38,39,40,41,42,
	         43,44,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,61,62,64,65,66,67,
	         68,69,70,71,72,73,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
	         92,93,94,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
	         112,113,114,115,117,118,119,120,121,122,123,124,125,126,128,129,130,
	         131,132,133,134,135,136,137,139,140,141,142,143,144,145,146,147,148,
	         149,150,151,152,153,154,155,156,157,158,160,161,162,163,164,165,166,
	         167,168,169,170,171,172,173,174,175,176,177,178,179,181,182,183,184,
	         185,186,187,188,189,190,192,193,194,195,196,197,198,199,200,201,203,
	         204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
	         221,222,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
	         239,240,241,242,243,245,246,247,248,249,250,251,252,253,254],

   		blue : [0,1,3,5,7,9,11,13,15,17,21,23,25,27,29,31,33,
	         35,37,39,41,43,45,47,49,51,53,55,57,59,63,65,67,69,71,73,75,77,79,81,
	         83,85,87,89,91,93,95,97,99,101,105,107,109,111,113,115,117,119,121,
	         123,127,129,131,133,135,137,139,141,143,145,149,151,153,155,157,159,
	         161,163,165,167,169,171,173,175,177,179,181,183,185,187,191,193,195,
	         197,199,201,203,205,207,209,211,213,215,217,219,221,223,225,227,229,
	         233,235,237,239,241,243,245,247,249,251,255,251,247,243,238,234,230,
	         226,221,217,209,204,200,196,192,187,183,179,175,170,166,162,158,153,
	         149,145,141,136,132,128,119,115,111,107,102,98,94,90,85,81,77,73,68,
	         64,60,56,51,47,43,39,30,26,22,17,13,9,5,0,3,7,15,19,22,26,30,34,38,41,
	         45,49,57,60,64,68,72,76,79,83,87,91,95,98,102,106,110,114,117,121,125,
	         129,137,140,144,148,152,156,159,163,167,171,175,178,182,186,190,194,
	         197,201,205,209,216,220,224,228,232,235,239,243,247,251]
		},

		// composantes de la table rainbow (IDL color table 13)
		"rainbow": {
			red : [0,4,9,13,18,22,27,31,36,40,45,50,54,
			   58,61,64,68,69,72,74,77,79,80,82,83,85,84,86,87,88,86,87,87,87,85,84,84,
			   84,83,79,78,77,76,71,70,68,66,60,58,55,53,46,43,40,36,33,25,21,16,12,4,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,21,25,29,33,42,
			   46,51,55,63,67,72,76,80,89,93,97,101,110,114,119,123,131,135,140,144,153,
			   157,161,165,169,178,182,187,191,199,203,208,212,221,225,229,233,242,246,
			   250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255],
   		green : [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,4,8,16,21,25,29,38,42,46,51,55,63,67,72,76,84,89,93,97,
			   106,110,114,119,127,131,135,140,144,152,157,161,165,174,178,182,187,195,
			   199,203,208,216,220,225,229,233,242,246,250,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,250,242,238,233,229,221,216,212,208,199,195,191,187,178,174,170,165,
			   161,153,148,144,140,131,127,123,119,110,106,102,97,89,85,80,76,72,63,59,
			   55,51,42,38,34,29,21,17,12,8,0],
   		blue : [0,3,7,10,14,19,23,28,32,38,43,48,53,
			   59,63,68,72,77,81,86,91,95,100,104,109,113,118,122,127,132,136,141,145,
			   150,154,159,163,168,173,177,182,186,191,195,200,204,209,214,218,223,227,
			   232,236,241,245,250,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
			   255,255,255,255,255,255,246,242,238,233,225,220,216,212,203,199,195,191,
			   187,178,174,170,165,157,152,148,144,135,131,127,123,114,110,106,102,97,
			   89,84,80,76,67,63,59,55,46,42,38,34,25,21,16,12,8,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
		},

		// Simple grey levels
		"grey": {
			red : [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		     19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,
		     43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,
		     68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
		     92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
		     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,
		     131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,
		     149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,
		     167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,
		     185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,
		     204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
		     221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
		     239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255],
     	green: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		     19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,
		     43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,
		     68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
		     92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
		     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,
		     131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,
		     149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,
		     167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,
		     185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,
		     204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
		     221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
		     239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255],
     	blue: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
		     19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,
		     43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,
		     68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,
		     92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,
		     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,
		     131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,
		     149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,
		     167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,
		     185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,
		     204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
		     221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
		     239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]
	}
}

/**
 *	Create texture from array
 *	TODO : maybe move this function to renderContext ?
 *
 *	@param gl Context
 *	@param dataArray Array creating the texture
 *	@param format Content format(gl.LUMINANCE, gl.RGB...)
 *	@param dataType Type of data(gl.UNSIGNED_BYTE or gl.FLOAT)
 *	@param width Width of texture
 *	@param height Height of texture
 *
 *	@return GLTexture, or null caused by not supported format
 */
function _textureFromPixelArray(gl, dataArray, format, dataType, width, height) {
	var dataTypedArray;
//	dataTypedArray = new Float32Array(dataArray, width, height);
	dataTypedArray = new Uint8Array(dataArray);
	
//	dataTypedArray = this.jsFits.ctx.createImageData(this.width, this.height);
	
//	dataTypedArray = new Float32Array(dataArray);
//	if ( dataType == gl.UNSIGNED_BYTE )
//    	dataTypedArray = new Uint8Array(dataArray);
//    else if ( dataType == gl.FLOAT )
//    else
//    	return null;

//    var texture = gl.createTexture();
//    gl.bindTexture(gl.TEXTURE_2D, texture);
//    gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, dataType, dataTypedArray);
//
//    // NPOT properties
//    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
//	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
//	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
//	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

	return dataTypedArray;
//    return texture;
}

return {

	/**
	 * Generate colormap
	 */
	generateColormap : function(gl, transferFonction, colormap, inverse)
	{
		// var pas1 = 128./(tr1-tr0);
	  	// var pas2 = 128./(tr2-tr1);
		
		// Get transfer function
		var fctGap = transferFonctions[transferFonction];

		var cm = [];

		var Sr, Sg, Sb;
		Sr = colormaps[colormap].red;
		Sg = colormaps[colormap].green;
		Sb = colormaps[colormap].blue;
		var max = Sr.length-1;
	  	for( var i=0; i<256; i++ ) {
	     	// int j= i<tr0 ? 0 :
	      //       i<tr1 ? (int)Math.round((i-tr0)*pas1) :
	      //       i<tr2 ? 128+(int)Math.round((i-tr1)*pas2) :
	      //               max;

	     	var j = fctGap[i];

	     	// Clamp
	     	if( j>max ) j=max;
	     		else if( j<0 ) j=0;
	     	if( inverse ) j=max-j;

	     	// Normalize between [0..1]
	     	cm[i*3] = Sr[j] / 256.;
	     	cm[i*3+1] = Sg[j] / 256.;
	     	cm[i*3+2] = Sb[j] / 256.;
	  }

	    // Create new texture
//	  	return _textureFromPixelArray(gl, cm, gl.RGB, gl.FLOAT, cm.length/3, 1);
		return _textureFromPixelArray(gl, cm, null, null, cm.length/3, 1);
	}

}

};